<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/11/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/11/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-IO/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C++ IO</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 16:00:09" itemprop="dateCreated datePublished" datetime="2019-11-05T16:00:09+08:00">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-25 21:58:30" itemprop="dateModified" datetime="2019-12-25T21:58:30+08:00">2019-12-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="i-o类">I/O类</h2>
<p>标准库提供了三类IO操作，它们分别是读写流的iostream，读写文件的fstream，读写内存中string的sstream。如下表所示：<br>
<img src="/2019/11/05/C-IO/io.png" alt="io"><br>
ifstream和istringstrem都继承自istream，ofstream和ostringstream都继承自ostream。像使用cin和cout那样使用它们就行。</p>
<h3 id="io对象的特性">IO对象的特性</h3>
<ol>
<li>不能拷贝或者对IO对象赋值。所以不能将形参和返回类型设置为流类型，必须将它们设置为流引用类型。</li>
<li>读写一个IO对象会改变它的状态，因此传递和返回的引用不能是const的。</li>
</ol>
<h3 id="io流的状态">IO流的状态</h3>
<p>IO操作很容易出错，一些错误是可恢复的，另一些是不可恢复的。下面是IO类中定义的函数和表示，可以帮助我们访问和操纵流的状态。<br>
<img src="/2019/11/05/C-IO/condition.png" alt="condition"><br>
<code>strm::iostate</code>中存放了当前IO流的状态，这个类型是一个位集合，IO类定义了四个iostate类型的常量表达式表达特定的位类型，可以使用位运算与设置或者检测多个标志位：</p>
<ul>
<li>strm::badbit，表示系统级的错误</li>
<li>strm::failbit，可恢复错误（到达文件结束也会置位strm::failbit，发生系统级错误时也会被置位）</li>
<li>strm::eofbit，到达文件结束</li>
<li>strm::goodbit，流处于未出错状态</li>
</ul>
<p>它们用来表示流的状态，可以用<code>good()</code>, <code>fail()</code>，<code>eof()</code>, <code>bad()</code>分别查询对应标志位的状态。我们将流当做条件使用的代码其实就是使用的是状态位的状态。<br>
可以使用<code>rdstate</code>函数获得当前流的状态，使用<code>setstate</code>对给定条件位置位，使用<code>clear</code>可以清除所错误标志位，也可以清除指定错误标志位。</p>
<h3 id="管理缓冲区">管理缓冲区</h3>
<p>关于缓冲区的内容，简单来说，缓冲区的作用就是减少系统级IO，提高读写效率。具体介绍可以查看<a href></a>。<br>
这里介绍一下导致C++中缓冲区刷新的原因：</p>
<ol>
<li>程序结束，作为main函数return的一部分，冲洗缓冲区</li>
<li>缓冲区满时，冲洗缓冲区</li>
<li>使用操作符endl，会在输出内容的末尾加一个<code>'\n'</code>，然后刷新缓冲区；使用flush刷新缓冲区，不附加任何字符；使用ends在输出内容的末尾加一个空字节，并不会刷新缓冲区（C++ Primer第五版上写错了）。</li>
<li>使用<code>cout &lt;&lt; unitbuf</code>设置为每次输出操作后都刷新缓冲区（即使不适用endl等操作符），即无缓冲，使用<code>cout &lt;&lt; nounitbuf</code>恢复。</li>
<li>一个输出流可能关联到另一个流，当读写关联的流时，关联到的流的缓冲区都会被刷新。</li>
</ol>
<h2 id="iostream"><code>iostream</code></h2>
<p>C++标准IO库<code>iostream</code>提供了输入流<code>istream</code>和输出流<code>ostream</code>，一个流就是一个字符序列，从IO设备中读出或者写入IO设备。</p>
<h3 id="标准输入输出对象">标准输入输出对象</h3>
<ul>
<li><code>cin</code>，标准输入</li>
<li><code>cout</code>，标准输出</li>
<li><code>cerr</code>，标准错误</li>
<li><code>clog</code>，用来输出一些普通信息。</li>
</ul>
<p>通常系统会将程序所运行的窗口和标准IO对象关联起来，读取<code>cin</code>，从当前程序关联的窗口进行读取，向<code>cout</code>,<code>cerr</code>和<code>clog</code>写入数据时，会写到同一个窗口中，可对它们进行重定向。</p>
<h3 id="输入输出运算符">输入输出运算符</h3>
<ul>
<li><code>&lt;&lt;</code>输出运算符，接收两个运算符，左侧需要是<code>ostream</code>对象，右侧需要是要打印的对象。返回左侧运算对象，即写入给定值的<code>ostream</code>对象。</li>
<li><code>&gt;&gt;</code>输入运算符，接收两个运算符，左侧需要是<code>istream</code>对象，右侧从istream中读入的数据要写入的对象。返回左侧运算对象，即给定的<code>istream</code>对象。</li>
</ul>
<p>一直有个问题就是为什么<code>&lt;&lt;</code>是输出，<code>&gt;&gt;</code>是输入，可以简单的把箭头方向当做数据流向，输出的数据流向<code>ostream</code>中的标准输出<code>cin</code>，输入时，数据从<code>istream</code>的标准输入<code>cin</code>流向变量。</p>
<h3 id="操纵符">操纵符</h3>
<p><code>endl</code>是一种操纵符。当把它写入到<code>ostream</code>的时候，有两个作用：</p>
<ol>
<li>结束当前行</li>
<li>将与当前输出设备相关的缓冲区中的内容刷新到输出设备中。这个刷新操作可以保证目前为止程序的所有输出都真正写入输出流而不是在内存中的等待写入输出流。</li>
</ol>
<h3 id="命名空间">命名空间</h3>
<p>命名空间可以解决名自定义冲突问题。比如有两个不同的库中实现了一个同名的函数，可以通过加上命名空间进行区分。<code>cin</code>,<code>cout</code>和<code>endl</code>都定义在<code>std</code>命名空间中。在访问时需要使用以下方式：<code>std::cin</code>，<code>std::cout</code>，<code>std::endl</code>。<br>
C++标准库定义的名字在都在<code>std</code>中。</p>
<h3 id="读取任意的输入数据">读取任意的输入数据</h3>
<p>下面的示例代码对任意的输入数据进行求和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using std::cin;</span><br><span class="line">using std::endl;</span><br><span class="line">using std::cout;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0, value = 0;</span><br><span class="line">    while(std::cin &gt;&gt; value)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fstream"><code>fstream</code></h2>
<p>头文件<code>fstream</code>定义了三个类型支持文件IO：</p>
<ul>
<li><code>ifstream</code>从一个给定的文件读取数据；</li>
<li><code>ofstream</code>向一个给定的文件写入数据；</li>
<li><code>fstream</code>读写给定文件。</li>
</ul>
<p>这些类型和我们之前使用的<code>cin</code>和<code>cout</code>一样，可以使用<code>getline</code>从一个<code>ifstream</code>中读取数据。<code>fstream</code>具有以下的一些特殊操作：<br>
<img src="/2019/11/05/C-IO/fstream.png" alt="fstream"><br>
这些操作只有<code>fstream</code>,<code>ofstream</code>和<code>ifstream</code>对象能调用，其他类型不行。</p>
<h3 id="使用fstream-ifstream和ofstream">使用<code>fstream</code>,<code>ifstream</code>和<code>ofstream</code></h3>
<p>我们想要读文件的时候，可以定义一个<code>fstream</code>对象，然后将这个对象和文件关联起来，每个<code>fstream</code>类都定义了一个名字为<code>open</code>的成员函数，它完成了一些系统相关的操作，定位给定的文件，打开为读或写模式。<br>
在创建<code>fstream</code>对象时，我们可以提供一个文件名，此时<code>open</code>函数会被自动调用。如果定义了一个空<code>fstream</code>对象，可以手动调用<code>open</code>将它和一个文件关联起来。调用<code>open</code>可能失败，进行<code>open</code>是否成功的检测通常是一个好习惯。<br>
<code>close</code>函数可以关闭<code>fstream</code>当前关联的文件，当一个<code>fstream</code>对象被销毁时，会自动调用<code>close</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造一个ifstream并打开给定文件，文件名可以是string，也可以是C风格字符串</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.输出文件流并未关联到任何文件。</span></span><br><span class="line">ofstream out;</span><br><span class="line">out.open(ifile+<span class="string">".out"</span>);</span><br></pre></td></tr></table></figure>
<p>可以使用<code>fstream</code>代替<code>iostream</code>，因为<code>fstream</code>是<code>iostream</code>的子类。</p>
<h3 id="file-mode">file mode</h3>
<p>C++ 中的file mode如下所示：<br>
<img src="/2019/11/05/C-IO/file_mode.png" alt="file_mode"><br>
具体的使用可以等用到的时候查资料。</p>
<h2 id="sstream"><code>sstream</code></h2>
<p>头文件<code>sstream</code>定义了三个类型支持内存IO：</p>
<ul>
<li><code>istringstream</code>从<code>string</code>读取数据；</li>
<li><code>ostringfstream</code>向<code>string</code>写入数据；</li>
<li><code>stringstream</code>读写<code>string</code>。</li>
</ul>
<p><code>stringstream</code>特有的操作如下：<br>
<img src="/2019/11/05/C-IO/stringstream.png" alt="stringstream"></p>
<h3 id="使用istringstream和使用ostringstream">使用<code>istringstream</code>和使用<code>ostringstream</code></h3>
<p>最好的就是写一个例子。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-char-char-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-char-char-string/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C char*, char [], char** and C++ string</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 12:21:22" itemprop="dateCreated datePublished" datetime="2019-11-05T12:21:22+08:00">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:14:29" itemprop="dateModified" datetime="2019-12-17T15:14:29+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="char-arr-字符数组-c类型字符串"><code>char arr[]</code>（字符数组，C类型字符串）</h2>
<ol>
<li>C语言中的<strong>字符串</strong>的概念：以NULL字节结尾的零个或者多个字符。而字符数组可以不以<code>'\0'</code>结束，而且不能为空。</li>
<li>字符串通常存在字符数组中，这也是C语言中没有显式的字符串类型的原因。</li>
<li>因为字符串以NULL结束，所以字符串内部不能有NULL字节。</li>
<li>为什么选择NULL作为字符串的终止符，因为它不是一个可打印的字符。</li>
</ol>
<p>如下所示，是<code>char str[]</code>，即字符数组的定义。<code>str</code>是自动变量，存放在栈里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> str3[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="char-字符指针"><code>char*</code>（字符指针）</h2>
<ol>
<li><code>char*</code>是一个指针，指向一个<code>char</code>，理论上来说，它并不是一个数组。</li>
<li><code>char *ptr;</code>并不为它指向的内容分配内存，而是只分配一个<code>char *</code>大小的内存存放指针变量<code>ptr</code>。</li>
<li><code>char arr[10];</code>是一个数组，不是一个指针，<code>char *</code>和<code>char[10]</code>不是一个类型。</li>
</ol>
<h2 id="char-指向字符指针的指针"><code>char**</code>（指向字符指针的指针）</h2>
<p><code>char**</code>是一个指针，指向一个指向<code>char</code>的指针。这个东西我刚开没有理解它有什么有，后来想明白了，它可以指向一个指针数组。如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *arr[] =  &#123;</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">    <span class="string">"world"</span>,</span><br><span class="line">    <span class="string">"hi"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> **p = arr;</span><br></pre></td></tr></table></figure></p>
<p>p是字符指针的指针，指向数组中的第一个字符串，(*p)就是一个字符指针，指向第一个字符串的第一个字符，**p就是第一个字符串的第一个字符。<br>
而<code>p+1</code>指向数组中的第二个字符串。<br>
<code>p+2</code>指向数组中的第三个字符串。<br>
事实上，这个p和arr的作用是一样的。<code>char**</code>经常在<code>main</code>函数中用到。</p>
<h2 id="std-string"><code>std::string</code></h2>
<p>字符串字面值和<code>string</code>是不同的类型，字符串字面值是为了和C语言兼容，它不是标准库中<code>string</code>对象的内容。</p>
<h2 id="字符和字符串字面值常量">字符和字符串字面值常量</h2>
<p><strong>字符串字面值常量</strong>是用一对双引号包围一串字符。如<code>&quot;hello&quot;</code>, <code>&quot;hi\n&quot;</code>, <code>&quot;&quot;</code>等，<code>'a'</code>是字面值字符常量。<br>
程序在使用字符串常量时，编译器会将字符串常量存放在数据区的常量区。当一个字符串常量出现在在一个表达式中，表达式使用的值是字符串常量在内存中的地址，而不是这些字符串常量本身。可以把字符串赋值给“指向字符的指针”，即让指针指向字符串常量在内存中的地址。但是不能把字符串常量赋值给一个字符数组，即不能把字符串常量的地址赋值给字符数组。比如<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *message1 = <span class="string">"Hello world!"</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个代码是将字符串常量中第一个字符的地址传递给message。</p>
<h2 id="字符数组和字面值常量的区别">字符数组和字面值常量的区别</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> message1[] = <span class="string">"Hello world!;</span></span><br><span class="line"><span class="string">char *message2 = "</span>Hello world!<span class="string">";</span></span><br></pre></td></tr></table></figure>
<p>第一种方式，其实是一种约定，它等于<code>char message1[] = {'H', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd', '\0'};</code>。<br>
而第二种方式中，&quot;Hello world&quot;是一个字面值常量，它在内存中只能以数组的形式存在，是一个不可修改的左值表达式。而message2实际上指向了这个字符串数组的首字符。</p>
<h2 id="常见的指针数组">常见的指针数组</h2>
<ol>
<li><code>main</code>函数的形参<code>char *argv[]</code>就是一个指针数组</li>
<li><code>getline</code>的第一个参数是<code>char **lineptr</code>。</li>
</ol>
<p>怎么理解？如下图所示：<br>
<img src="/2019/11/05/C-char-char-string/pointer_array.jpg" alt="pointer_array"></p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.<a href="https://www.zhihu.com/question/307261590/answer/563448215" target="_blank" rel="noopener">https://www.zhihu.com/question/307261590/answer/563448215</a><br>
3.<a href="https://www.zhihu.com/question/307261590/answer/563630017" target="_blank" rel="noopener">https://www.zhihu.com/question/307261590/answer/563630017</a><br>
4.<a href="https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-sizeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-sizeof/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C sizeof</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 12:19:54" itemprop="dateCreated datePublished" datetime="2019-11-05T12:19:54+08:00">2019-11-05</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-malloc-free-new-and-delete/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-malloc-free-new-and-delete/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C/C++ malloc(alloc) free new and delete</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 10:37:48" itemprop="dateCreated datePublished" datetime="2019-11-05T10:37:48+08:00">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-25 17:46:02" itemprop="dateModified" datetime="2020-01-25T17:46:02+08:00">2020-01-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="malloc"><code>malloc</code></h2>
<h3 id="c标准malloc定义">C标准<code>malloc</code>定义</h3>
<p><code>malloc</code>定义在头文件<code>&lt;stdlib.h&gt;</code>中</p>
<blockquote>
<p>Allocates size bytes of uninitialized storage.<br>
If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type with fundamental alignment.<br>
If size is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to free).</p>
</blockquote>
<blockquote>
<p>malloc is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.<br>
A previous call to free or realloc that deallocates a region of memory synchronizes-with a call to malloc that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by malloc. There is a single total order of all allocation and deallocation functions operating on each particular region of memory. (since C11)</p>
</blockquote>
<h3 id="malloc-calloc和realloc原型"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reallocarray</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-calloc和realloc性质"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>性质</h3>
<ol start="0">
<li><code>malloc</code>函数的实现中（C标准没有规定），在分配空间的时候，通常分配的空间要比申请的要大一些，这些额外的空间用来记录<code>malloc</code>这片空间的大小，在使用<code>free</code>的时候会用到。</li>
<li><code>malloc</code>，分配指定字节的内存空间，初始值不定。</li>
<li><code>calloc</code>，为指定长度的固定数量的对象分配空间，每一个bit都被初始化为0。</li>
<li><code>realloc</code>，增加或者减少已经分配的内存空间的大小。当这个大小增加时，可能需要将之前分配的空间中的数据移到另一个足够大的区域以便于增加大小，新增加的区域内的值是不确定的。</li>
<li>这三个函数返回的指针一定是对齐的，保证它可以用于任何对象。比如<code>double</code>的要求最严格，需要从8的倍数的地址单元开始，这三个函数返回的地址一定满足这个要求。</li>
<li>它们的返回类型都是<code>void*</code>，需要使用强制类型转换。</li>
<li><code>realloc</code>函数可以增加或者减少之前分配的内存空间的大小。比如分配了一个固定大小的数组，后来发小它不够用了，可以使用<code>realloc</code>对它进行扩充，如果原有的存储后有足够的大小进行扩充，则可以在原存储区的位置上向高地址进行扩充，无需移动原有数组，返回和传入相同的指针。如果原来的内存空间后没有足够的空间，就重新分配一个足够大的内存空间，再将原有数据的内容复制过去，然后释放原来的内存空间，返回新的指针。</li>
<li><code>realloc</code>传入的参数是存储区的新长度。如果传入的<code>ptr</code>参数是<code>NULL</code>指针，那就退化成了<code>malloc</code>。</li>
</ol>
<h3 id="自己实现一个malloc">自己实现一个<code>malloc</code></h3>
<p>???</p>
<h2 id="free"><code>free</code></h2>
<h3 id="c标准free定义">C标准<code>free</code>定义</h3>
<p><code>free</code>定义在头文件<code>&lt;stdlib.h&gt;</code>中</p>
<blockquote>
<p>Deallocates the space previously allocated by malloc(), calloc(), aligned_alloc, (since C11) or realloc().<br>
If ptr is a null pointer, the function does nothing.<br>
The behavior is undefined if the value of ptr does not equal a value returned earlier by malloc(), calloc(), realloc(), or aligned_alloc() (since C11).<br>
The behavior is undefined if the memory area referred to by ptr has already been deallocated, that is, free() or realloc() has already been called with ptr as the argument and no calls to malloc(), calloc() or realloc() resulted in a pointer equal to ptr afterwards.<br>
The behavior is undefined if after free() returns, an access is made through the pointer ptr (unless another allocation function happened to result in a pointer value equal to ptr)<br>
free is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p>
</blockquote>
<blockquote>
<p>A call to free that deallocates a region of memory synchronizes-with a call to any subsequent allocation function that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by the allocation function. There is a single total order of all allocation and deallocation functions operating on each particular region of memory. (since C11)</p>
</blockquote>
<h3 id="free原型"><code>free</code>原型</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void free(void *ptr);</span><br></pre></td></tr></table></figure>
<h3 id="free属性"><code>free</code>属性</h3>
<p>从标准的定义可以看出来，以下都是未定义的行为：</p>
<ol>
<li>
<p><code>free</code>的对象不是<code>alloc</code>函数族的返回值；比如<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">pi++;</span><br><span class="line"><span class="comment">//下面就是错误的，因为这个`pi`不是`alloc`函数族的返回值。</span></span><br><span class="line"><span class="built_in">free</span>(pi);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p><code>free</code>一个已经被释放过了的块；</p>
</li>
<li>
<p>访问一个<code>free</code>已经释放了的块。<br>
等等。为什么？？？因为标准并没有定义<code>malloc</code>应该怎么实现，有的内存分配器，<code>malloc</code>实际申请的内存要比传入的参数大，里面存放了额外的数据记录这块内存有多大，一般就是存在指针左边。<code>free</code>的时候，就会读取那个内存块中存放的信息，进行<code>free</code>，所以上面的那些都是未定义的行为。</p>
</li>
</ol>
<p>其他属性</p>
<ol>
<li><code>free</code>可以释放<code>ptr</code>指向的内存空间，释放的空间通常送入可用内存池，之后可以通过这三个函数重新分配。</li>
<li><code>malloc</code>和<code>free</code>底层通常使用<code>sbrk</code>系统调用实现，这个系统调用扩充或者减小进程的堆，虽然<code>sbrk</code>可以扩充或者缩小进程的堆，但是一般<code>malloc</code>和<code>free</code>的实现不会减少进程的内存空间，释放的内存空间保存在<code>malloc</code>池中，而不是交给内核。</li>
<li>大多数实现分配的空间要比请求的空间大一些，因为需要存储一些管理信息，如block的大小，指向下一个block的指针等等。因此，如果对超过一个分配区域的内存进行读写的话，会造成很严重的错误。</li>
<li><code>free</code>一个已经释放了的块，<code>free</code>的不是<code>alloc</code>函数的返回值，没有进行<code>free</code>等等，都是未定义的结果。为什么？？？</li>
</ol>
<h2 id="new"><code>new</code></h2>
<p>对于自定义类型而言，<code>new</code>操作符首先调用operator new()函数申请内存，其内部调用的是malloc函数，返回一个<code>void*</code>类型的指针；<code>new</code>还会负责把它转换成自定义对象的指针；然后调用类的构造函数初始化对象；最后返回自定义对象的指针。<code>malloc</code>只负责内存的分配而不会调用类的构造函数数。举个例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Complex *pc = <span class="keyword">new</span> Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">// 1.内部调用malloc</span></span><br><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex));</span><br><span class="line"><span class="comment">// 2.将void *类型指针转换为Complex*类型的</span></span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt; (mem);</span><br><span class="line"><span class="comment">// 3.调用Complex的构造函数</span></span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>默认初始化。<code>new</code>后面加类型，没有小括号，也没有花括号。<br>
默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。这意味着内置类型或组合类型的对象的值是无定义的，而类类型对象将用默认构造函数进行初始化。</li>
<li>值初始化。类型名字后加()即可，对于内置类型的变量，初始化为0，对于类类型的变量，调用默认构造函数。</li>
<li>直接初始化。使用初始化列表加对象值，或者小括号加对象值。</li>
</ol>
<p>对于自定义类型而言，只要一调用new，无论后面有没有加()，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化。</p>
<h2 id="delete"><code>delete</code></h2>
<ol>
<li><code>delete</code>是和<code>new</code>配对的操作。调用<code>delete</code>操作，编译器实际上会将它转换为两步操作，第一步是调用析构函数；第二部调用<code>opereator delete()</code>，其内部调用了<code>free</code>。</li>
<li>数组的<code>new</code>一定要和数组的<code>delete</code>配对，否则就会出现内存泄露。第一条中说了<code>delete</code>分为两步，第一步其实不会造成内存泄露；而是第二步中，析构函数被调用的次数，<code>delete p</code>只会调用一次析构函数，而<code>delete[] p</code>会调用多次析构函数，调用次数和<code>new</code>时申请的数组大小一样。</li>
</ol>
<h2 id="malloc-vs-new"><code>malloc</code> vs <code>new</code></h2>
<ol>
<li><code>malloc</code>是C语言中的函数，而<code>new</code>是C++的操作符；</li>
<li><code>malloc</code>返回的是<code>void*</code>类型的指针，需要我们手动进行强制类型转换转换成我们需要的类型，而<code>new</code>返回的是对象类型的指针，类型和对象严格匹配，<code>new</code>是类型安全型操作符。</li>
<li>在分配内存失败时，<code>malloc</code>会返回NULL，而<code>new</code>会throw on failure。</li>
<li><code>malloc</code>需要指定申请的内存占多少个字节，而<code>new</code>不需要指定申请内存块的大小，编译器会根据类型计算需要的内存大小；</li>
<li><code>malloc</code>和<code>new</code>都是申请heap上的内存；</li>
<li><code>new</code>操作符调用的operator new()函数可以重载（操作符<code>new</code>不能重载），而<code>malloc</code>不能重载。</li>
<li><code>malloc</code>和<code>free</code>，<code>new</code>和<code>delete</code>必须配套使用。</li>
</ol>
<p>几个问题：</p>
<ol>
<li>什么时候<code>malloc</code>和<code>new</code>会申请内存失败。</li>
<li><code>new</code>操作符的两个步骤，一个是申请内存，一个是调用构造函数，<code>new</code>的申请内存和<code>malloc</code>的申请内存有什么区别。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.<a href="https://stackoverflow.com/questions/184537/in-what-cases-do-i-use-malloc-and-or-new" target="_blank" rel="noopener">https://stackoverflow.com/questions/184537/in-what-cases-do-i-use-malloc-and-or-new</a><br>
3.<a href="https://zhuanlan.zhihu.com/p/47089696?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=687606928481730560" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47089696?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=687606928481730560</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/03/data-structure-map-vs-hash-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/03/data-structure-map-vs-hash-map/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">data structure map vs hash_map</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-03 21:28:13" itemprop="dateCreated datePublished" datetime="2019-11-03T21:28:13+08:00">2019-11-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:49:58" itemprop="dateModified" datetime="2019-12-17T15:49:58+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>map vs hash_map(unordered_map)</p>
<ul>
<li>数据结构，<br>
map使用平衡二叉树，通常是红黑树；hash_map使用哈希函表。</li>
<li>查找时间<br>
map是$O(\log n)$；hash_map是$O(1)$（没有冲突的情况下），最坏情况下是$O(n)$。</li>
</ul>
<p>C++中的hash_map叫做unordered_map。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/2189189/map-vs-hash-map-in-c/2189206" target="_blank" rel="noopener">https://stackoverflow.com/questions/2189189/map-vs-hash-map-in-c/2189206</a><br>
2.<a href="https://stackoverflow.com/questions/5139859/what-the-difference-between-map-and-hashmap-in-stl/5139888" target="_blank" rel="noopener">https://stackoverflow.com/questions/5139859/what-the-difference-between-map-and-hashmap-in-stl/5139888</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/01/linear-algebra-Gram-Schmidt-正交化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/01/linear-algebra-Gram-Schmidt-正交化/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">linear algebra Gram-Schmidt 正交化</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-01 09:39:44" itemprop="dateCreated datePublished" datetime="2019-11-01T09:39:44+08:00">2019-11-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:48:07" itemprop="dateModified" datetime="2019-12-17T15:48:07+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/线性代数/" itemprop="url" rel="index"><span itemprop="name">线性代数</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="gram-schmidi正交化">Gram-Schmidi正交化</h2>
<p>这一章属于<a href>正交</a>的内容，但是因为很重要，就单独拎出来再说一遍。<br>
Gram-Schmidt正交化过程就相当于是在不断的进行投影，这个方法的想法是从$n$个独立的column vector出发，构建$n$个正交向量，然后再单位化。拿$3$个过程举个例子。用$a,b,c$表示初始的$3$个独立向量，$A,B,C$表示三个正交向量，$q_1, q_2,q_3$表示三个正交单位向量。<br>
第一个正交向量，直接对第一个向量单位化<br>
$$A=a, q_1 = \frac{A}{\vert A\vert}$$<br>
第二个正交向量，将第二个向量投影到第一个向量上，计算出一个和第二个向量正交的向量。<br>
$$B=b-\frac{A^T B}{A^T A}A , q_2 = \frac{B}{\vert B\vert}$$<br>
第三个正交向量，将第三个向量分别投影到第一个和第二个正交向量上，计算处第三个正交向量。<br>
$$C=c - \frac{A^T C}{A^T A}A - \frac{B^T C}{B^T B}B , q_2 = \frac{C}{\vert C\vert}$$<br>
<img src="/2019/11/01/linear-algebra-Gram-Schmidt-正交化/gram_schmidi.jpg" alt="gram_schmidi"></p>
<h2 id="参考文献">参考文献</h2>
<p>1.MIT线性代数公开课</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/01/linear-algebra-matrix-decomposition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/01/linear-algebra-matrix-decomposition/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">linear algebra matrix decomposition</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-01 09:35:12" itemprop="dateCreated datePublished" datetime="2019-11-01T09:35:12+08:00">2019-11-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:47:45" itemprop="dateModified" datetime="2019-12-17T15:47:45+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/线性代数/" itemprop="url" rel="index"><span itemprop="name">线性代数</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="矩阵分解">矩阵分解</h2>
<h2 id="lu分解">LU分解</h2>
<h2 id="plu分解">PLU分解</h2>
<h2 id="qr分解">QR分解</h2>
<h2 id="代码">代码</h2>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="http://www.math.iit.edu/~fass/477577_Chapter_7.pdf" target="_blank" rel="noopener">http://www.math.iit.edu/~fass/477577_Chapter_7.pdf</a><br>
2.<a href="https://www.sciencedirect.com/science/article/pii/S0377042706001403" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/pii/S0377042706001403</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/10/28/logistic-regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/28/logistic-regression/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">logistic regression</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-28 19:40:06" itemprop="dateCreated datePublished" datetime="2019-10-28T19:40:06+08:00">2019-10-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:21:12" itemprop="dateModified" datetime="2019-12-17T15:21:12+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="logistic-regression">logistic regression</h2>
<p>逻辑回归是使用线性模型进行分类的模型，它是一个对数线性模型。<br>
在使用线性模型进行回归时，产生的预测值是实数值。而对于分类任务，函数的输出需要是离散值。对于二分类任务，类别分别记为$0$和$1$，如果将回归模型的值限制在$[0, 1]$之间，那么接下来我们要做的就是将$[0,1]$之间的值转换为$0$和$1$。比如单位跃阶函数：<br>
$$y=\begin{cases}0, x \lt 0;\\0.5, x=0;\\1, x\gt 0\end{cases} \tag{1}$$<br>
但是它是离散的，需要找一个连续的函数。这就是接下来介绍的logistic function。</p>
<h2 id="logistic-distribution">logistic distribution</h2>
<p>连续随机变量$X$服从logistic distribution指的是$X$具有以下分布函数和密度函数：<br>
$$F(x) = P(X\le x) = \frac{1}{1 + e^{-(x-\mu)/\gamma} } \tag{2}$$<br>
$$f(x) = F’(x) = \frac{e^{-(x-\mu)/\gamma} }{\gamma(1 + e^{-(x-\mu)/\gamma} )^2 } \tag{3}$$<br>
其中$\mu$为位置参数，$\gamma \gt 0$是形状参数。分布函数属于logistic function，相应的图如下所示，它的取值在$[0,1]$之间，是一条sigmod曲线，以点$(\mu, \frac{1}{2})$为中心对称，即满足：<br>
$$F(-x+\mu) - \frac{1}{2} = -F(x-\mu) +\frac{1}{2} \tag{4}$$<br>
<img src="/2019/10/28/logistic-regression/logistic_function.png" alt="logistic_func"><br>
曲线在中心附近增长的速度很快，在两端增加的速度很慢。$\gamma$越小，曲线在中心附近增长的越快。当$\mu=0, \gamma=1$时，得到一个特殊的函数：<br>
$$ f(x) = \frac{1}{1+e^{-x} } \tag{5}$$<br>
用$w^T x+b$代替$f(x)$中的$x$，就得到了：<br>
$$h(x) = \frac{1}{1+ e^{-(w^T x +b)} } \tag{6}$$<br>
其中$x$是输入，$\theta$是要求的参数。</p>
<h2 id="二项logistic-regression">二项logistic regression</h2>
<p>上面给出的$y=h(x)$其实是一个二项的logistic regression分类函数。式子$(6)$可以进行变形，得到<br>
$$ \log\frac{y}{1-y} = \log\frac{\frac{1}{1+ e^{-(w^T x +b)} } }{1-\frac{1}{1+ e^{-(w^T x +b)} } }= \log\frac{\frac{1}{1+ e^{-(w^T x +b)} } }{\frac{e^{-(w^T x +b)} }{1+ e^{-(w^T x +b)} } } = \log\frac{1}{e^{-(w^T x +b) } } = w^T x +b  \tag{7}$$<br>
这里的$y$是一个函数值，给定一个$x$就会有一个$y$。将$y$看做给定$x$，事件发生的概率，$1-y$是该事件不发生的概率，两者的比值$\frac{y}{1-y}$被称为几率，反映了$x$发生的相对可能性。对几率取对数得到对数几率logit：<br>
$$\log \frac{y}{1-y}$$<br>
可以看出，公式$6$实际上是在近似真实标记的对数几率。所以这个模型叫作对数几率回归。如果将式子$(6)$中的$y$看成类后验概率估计$p(y=1|x)$，公式$(7)$可以写成：<br>
$$\log \frac{p(y=1|x)}{p(y=0|x)} = w^T x+b \tag{8}$$<br>
则有：<br>
$$ p(y=1|x) = \frac{e^{w^T x+ b} }{1+e^{w^T x+ b} } \tag{9} $$<br>
$$ p(y=0|x) = \frac{1}{1+e^{w^T x+ b} } \tag{10} $$<br>
其实就是分子分母同时乘了$e^{w^T x+ b}$。线性模型$w^T x+b$的值域是实数域，然而logistic模型将线性函数$w^T x+b$转换成了如公式$(8),(9)$的概率。当$w^T x+b$的值越接近于$1$，$p(y=1|x)$的概率越接近于$1$。</p>
<h2 id="最大似然估计进行参数估计">最大似然估计进行参数估计</h2>
<p>给定训练集样本$(x_1, y_1), \cdots, (x_N,y_N)$，可以使用最大似然估计求解给定的$w$和$b$：<br>
$$l(w,b) =\prod_{i=1}^m p(y_i|x_i; w,b) \tag{11}$$<br>
即让所有样本属于其真实标记的概率越大越好。设$p(y=1|x) = \pi(x), p(y=0|x) = 1-\pi(x)$，这两个式子可以用一个式子表示$\pi(x)^y (1-\pi(x))^{1-y} $，重写式子$(11)$，得到的似然函数为：<br>
$$l(w,b) =\prod_{i=1}^m p(y_i|x_i; w,b) = \prod_{i=1}^m \left[\pi(x)\right]^{y_i} \left[1-pi(x)\right]^{1-y_i} \tag{12}$$</p>
<p>取对数得到对数似然：<br>
\begin{align*}<br>
L &amp;= \log l(w,b) \\<br>
&amp; = \log \prod_{i=1}^m \left[\pi(x)\right]^{y_i} \left[1-pi(x)\right]^{1-y_i}\\<br>
&amp; = \sum_{i=1}^m \left[y_i\log\pi(x)+(1-y_i)\log(1-\pi(x_i)) \right] \tag{13}\\<br>
&amp; = \sum_{i=1}^m \left[y_i\log\frac{\pi(x)}{1-\pi(x_i)} + \log(1-\pi(x_i)) \right] \tag{14}\\<br>
&amp; = \sum_{i=1}^m \left[y_i (w^T x+b) - \log(1+e^{w^T x+b} ) \right]\\ \tag{15}<br>
\end{align*}<br>
然后求得$w$和$b$即可。</p>
<h2 id="多项logistic-regression">多项logistic regression</h2>
<p>假设离散型随机变量的取值集合是${1, 2,\cdots, K}$，多项logistic regression的公式是：<br>
$$P(Y=k|x) = \frac{e^{w^T x+b} }{ 1+ \sum_{k=1}^{K-1} e^{w^T x+b} }, k = 1, 2, \cdots, K-1 \tag{16}$$<br>
$$P(Y=K|x) = \frac{1}{1+ \sum_{k=1}^{K-1} e^{w^T x+b} } \tag{17}$$</p>
<h2 id="参考文献">参考文献</h2>
<p>1.周志华《西瓜书》<br>
2.李航《统计机器学习》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/10/27/ml-bayesian-classifier-naive-baye-classifier/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/27/ml-bayesian-classifier-naive-baye-classifier/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">beyesian classifier naive baye classifier</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-27 21:57:09" itemprop="dateCreated datePublished" datetime="2019-10-27T21:57:09+08:00">2019-10-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:48:36" itemprop="dateModified" datetime="2019-12-17T15:48:36+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="朴素贝叶斯分类器">朴素贝叶斯分类器</h2>
<h3 id="简介">简介</h3>
<p>朴素贝叶斯法是基于贝叶斯定理和特征条件独立假设的分类方法。对于给定的训练数据，根据特征条件独立假设学习，输入和输出的联合概率分布；然后基于此模型，对于新给定的输入$x$，利用贝叶斯定理求出后验概率最大的输出$y$。<br>
朴素贝叶斯的一个假设：条件独立假设，拿公式举个例子就是<br>
$$P(X|Y=y_k)=\prod_{i=1}^m P(x_i|Y=y_k) \tag{1}$$<br>
其中$X=[x_1, x_2,\cdots, x_m]$即$m$个属性。朴素贝叶斯实际上学习到生成数据的机制，属于生成模型。条件独立假设是说用于分类的特征在类别确定的情况下都是条件独立的，这一假设让朴素贝叶斯变得好计算，但是可能会牺牲一定的精度。</p>
<h3 id="训练过程">训练过程</h3>
<p>贝叶斯分类器的流程如下所示：</p>
<ol>
<li>给出训练样本集，属性集合$X=[x_1, x_2,\cdots, x_m]$，标签集合$Y=[y_1, y_2,\cdots, y_n]$，计算每个类别$y_j$中出现属性$x_i$的条件概率，即<br>
$$P(x_i|y_j), 1 \le i \le m, 1 \le j \le n \tag{2}$$</li>
<li>给出一个新的样本$X$，根据贝叶斯定理以及条件独立假设，计算：<br>
$$P(y_k|X) = \frac{P(y_k)P(X|y_k)}{P(X)} = \frac{P(y_k) \prod_{i=1}^m P(x_i|y_k) }{P(X)} \tag{3}$$</li>
<li>从$P(y_k|X)$中选出最大的$P$对应的$y_k$当做label。</li>
</ol>
<p>可以看出，朴素贝叶斯分类器的关键就是计算条件概率：</p>
<ul>
<li>当属性$X$是离散值时，可以统计样本中各个$P(x_i|y_j)$的频率近似计算概率</li>
<li>当属性$X$是连续值时，可以假设变量服从某种分布，使用训练数据估计分布的参数。 如高斯分布的均值和方差。</li>
</ul>
<h2 id="后验最大化的含义">后验最大化的含义</h2>
<p>朴素贝叶斯法将实例分到后验概率最大的类中，相当于期望风险最小化。</p>
<h2 id="参数估计方法">参数估计方法</h2>
<p>在朴素贝叶斯的训练过程中，我们需要学习先验概率以及条件概率。可以使用<a href="https://mxxhcm.github.io/2019/07/31/probability_basic/">贝叶斯估计</a>，<a href="https://mxxhcm.github.io/2019/01/20/maximum-likelyhood-estimation/">最大似然估计</a>和<a href="https://mxxhcm.github.io/2019/07/31/probability_basic/">最大后验估计</a>求朴素贝叶斯的先验概率和条件概率。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://www.cnblogs.com/phoenixzq/p/3539619.html" target="_blank" rel="noopener">https://www.cnblogs.com/phoenixzq/p/3539619.html</a><br>
2.<a href="http://funhacks.net/2015/05/18/Bayesian-classifier/" target="_blank" rel="noopener">http://funhacks.net/2015/05/18/Bayesian-classifier/</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/10/27/C-input-output/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/27/C-input-output/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C/C++ input and output</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-27 10:00:47" itemprop="dateCreated datePublished" datetime="2019-10-27T10:00:47+08:00">2019-10-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-19 22:19:16" itemprop="dateModified" datetime="2019-12-19T22:19:16+08:00">2019-12-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="特殊符号的ascii">特殊符号的ASCII</h2>
<p>'\n’是10。<br>
EOF是-1。</p>
<h2 id="输入输出">输入输出</h2>
<p>C/C++语言中输入输出主要分为两种，一种是文件的输入输出，另一种是标准输入输出即<code>stdin</code>和<code>stdout</code>，从控制台进行输入输出。其实标准输入输出是一种特殊的文件流，这样子文件的输入输出也可以用在标准输入输出。</p>
<h3 id="文件输入和输出常用函数">文件输入和输出常用函数</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//字符</span><br><span class="line">fgetc() and fputc()</span><br><span class="line">getc() and putc()</span><br><span class="line">// getc()和fgetc()功能功能一样，只不过getc()是宏实现，进行了优化，getc()可以被当做宏调用。而fgetc()只能当做函数被调用，getc()也能读取&apos;\n&apos;字符。</span><br><span class="line"></span><br><span class="line">//n个项</span><br><span class="line">fread() and fwrite()</span><br><span class="line"></span><br><span class="line">//字符串</span><br><span class="line">getline() </span><br><span class="line">fgets() and fputs()</span><br><span class="line">fscanf() and fprintf()</span><br></pre></td></tr></table></figure>
<h3 id="标准输入和输出常用函数">标准输入和输出常用函数</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//字符</span><br><span class="line">getchar() and putchar()</span><br><span class="line">scanf() and printf()</span><br><span class="line">getche()和getch() //不经过缓冲区</span><br><span class="line"></span><br><span class="line">//字符串</span><br><span class="line">scanf() and printf()</span><br><span class="line">gets() and puts()</span><br></pre></td></tr></table></figure>
<h3 id="注意事项">注意事项</h3>
<ol>
<li>getline()，fgets()都能用于标准输入输出中的读入。</li>
<li>当用于标准输入输出时：<br>
getline()，fgets()，scanf()，gets()之间的区别和联系：<br>
getline()推荐使用，fgets()不推荐，scanf()不推荐，gets()别用。<br>
因为fgets()和scanf()都有缓冲区溢出的危险，而gets()最容易发生缓冲区溢出。</li>
<li>fgetc()和getc()都是用于文件中字符操作的。而fgets()是用于文件中字符串操作的，gets()是用于标准输入输出中字符串操作的。</li>
<li>getc()和fgetc()功能功能一样，只不过getc()是宏实现，进行了优化，getc()可以被当做宏调用。而fgetc()只能当做函数被调用，getc()也能读取’\n’字符。</li>
</ol>
<h2 id="缓冲区">缓冲区</h2>
<p>我们在使用输入输出函数的时候，不管是从文件还是控制台中读取数据，数据都会先存放在缓冲区里面，在需要使用的时候会在缓冲区里面提取，缓冲区是一个队列，遵循先进先出的规则。</p>
<p>例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a, b);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在控制台输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 23 34 45 56 67 78 89</span><br></pre></td></tr></table></figure>
<p>控制台输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">12 23</span><br><span class="line">34 45</span><br><span class="line">56 67</span><br></pre></td></tr></table></figure>
<p>由于输入在控制台的数据已经到了缓冲区，所以除了第一次调用scanf()的时候控制台会弹出（缓冲区为空），另两次则不会弹出（缓冲区不为空），直接从缓冲区里面拿取数据。<br>
如果不想这样做可以选择清空缓冲区，可以使用fclose()函数清空缓冲区并关闭流，但是这样我们就无法继续使用流了。我们还可以选择使用fflush()函数，在不关闭流的情况下清空缓冲区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fflush</span> <span class="params">( FILE * stream )</span></span>;</span><br></pre></td></tr></table></figure>
<p>如果给出的文件流是一个输出流,那么fflush()把输出到缓冲区的内容写入文件；如果给出的文件流是输入类型的,结果未定义；<br>
fflush(NULL)刷新所有的输出流；<br>
fflush(stdin)刷新标准输入缓冲区，把输入缓冲区里的东西丢弃；但是fflush<a href="https://stackoverflow.com/questions/17318886/fflush-is-not-working-in-linux" target="_blank" rel="noopener">在linux上并不work</a>。<br>
fflush(stdout)刷新标准输出缓冲区，把输出缓冲区里的东西打印到标准输出设备上。<br>
例如</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a, b);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a, b);</span><br><span class="line">    fflush(<span class="built_in">stdin</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;a, &amp;b);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d %d\n"</span>, a, b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在控制台输入：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 23 34 45 56 67 78 89</span><br></pre></td></tr></table></figure>
<p>控制台输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">12 23</span><br></pre></td></tr></table></figure>
<p>然后会等待控制台输入。（我在linux上并没有实验成功。）</p>
<h2 id="文件输入-输出">文件输入/输出</h2>
<h3 id="打开文件fopen和关闭文件close">打开文件<code>fopen</code>和关闭文件<code>close</code></h3>
<h4 id="函数原型">函数原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * 打开文件，打开成功返回一个FILE指针，打开失败返回NULL</span></span><br><span class="line"><span class="comment"> * type：是文件操作方法，包括'w', 'a', 'rb', 'wb', 'ab', 'r+', 'w+', 'a+', 'rb+', 'wb+', 'ab+'</span></span><br><span class="line"><span class="comment">FILE* fopen(char*filename, char* type);</span></span><br><span class="line"><span class="comment">int fclose(FILE* stream);</span></span><br></pre></td></tr></table></figure>
<h4 id="示例">示例</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">20</span>] = <span class="string">"data.txt"</span>;</span><br><span class="line">    FILE *fp = fopen(filename, <span class="string">"r"</span>); </span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Cannot open file.\n"</span>); </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Open file %s success.\n"</span>, filename);</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(fp);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="从文件流中读写字符">从文件流中读写字符</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从文件流中读取单个字符，会读取'\n'字符，</span></span><br><span class="line"><span class="comment"> * File* 读入文件流和输出文件流</span></span><br><span class="line"><span class="comment"> * int ch: 待写入字符</span></span><br><span class="line"><span class="comment"> * fgetc()和getc()返回读取的字符，</span></span><br><span class="line"><span class="comment"> * fputc()和putc()返回输出字符的ascii，否则 返回 EOF .</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> */</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE* stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE* stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> ch, FILE* stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> ch, FILE* stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="从文件流中读取和写入多个数据项">从文件流中读取和写入多个数据项</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从流指针指定的文件中读取nobj个数据项，每个数据项有size个字节，存入ptr指向的缓冲区。读取的数据项不一定等于nobj，可能读完了或者出错了。</span></span><br><span class="line"><span class="comment"> * ptr:缓冲区指针</span></span><br><span class="line"><span class="comment"> * size_t size: 每个数据项字节</span></span><br><span class="line"><span class="comment"> * size_t nobj: 读取多少个数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE* stream);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nobj, FILE* stream);</span><br></pre></td></tr></table></figure>
<h3 id="从文件流中读写字符串">从文件流中读写字符串</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 从文件中读取一行，getline会读入换行符。</span></span><br><span class="line"><span class="comment"> * *lineptr指向一个动态分配的内存区域。*n是所分配内存的长度。如果*lineptr是NULL的话，getline函数会自动进行动态内存的分配（忽略*n的大小），所以使用这个函数非常注意的就使用要注意自己进行内存的释放。</span></span><br><span class="line"><span class="comment"> * 如果*lineptr分配了内存，但在使用过程中发现所分配的内存不足的话，getline函数会调用realloc函数来重新进行内存的分配，同时更新*lineptr和*n。</span></span><br><span class="line"><span class="comment"> * 注意*lineptr指向的是一个动态分配的内存，由malloc，calloc或realloc分配的，不能是静态分配的数组。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">ssize_t</span> getline(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * fgets从流文件中n个字符到指定数组中，遇到 "\n"就停止。</span></span><br><span class="line"><span class="comment"> * char* str: 字符数组或者字符串指针，字符串指针一定要配内存空间，否则会出问题</span></span><br><span class="line"><span class="comment"> * int n: 从流指针开始读取n个字符。</span></span><br><span class="line"><span class="comment"> * fgets()返回值：</span></span><br><span class="line"><span class="comment"> *      n &lt;= 0或者读入错误，或者遇到EOF，返回NULL</span></span><br><span class="line"><span class="comment"> *      n = 1返回空串 </span></span><br><span class="line"><span class="comment"> *      读入成功返回缓冲区地址</span></span><br><span class="line"><span class="comment"> * fputs()返回值：</span></span><br><span class="line"><span class="comment"> *      输出成功返回大于$0$的值，否则返回EOF</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">fgets</span><span class="params">(<span class="keyword">char</span>* str, <span class="keyword">int</span> n, FILE* stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">char</span>* str, FILE* stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE* stream, <span class="keyword">char</span>* format, variable-<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE* stream, <span class="keyword">char</span>* format, variable-<span class="built_in">list</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="标准输入-输出">标准输入/输出</h2>
<h3 id="读写字符">读写字符</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * scanf函数的格式说明符有几个就要取几次数据，</span></span><br><span class="line"><span class="comment"> * 只要碰到格式说明符就必须把数据取走，没取完</span></span><br><span class="line"><span class="comment"> * 的数据继续留在缓冲区中。</span></span><br><span class="line"><span class="comment"> * scanf()加%c</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">scanf</span>();</span><br><span class="line"><span class="built_in">printf</span>(); </span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将用户输入的字符输出到标准输出设备，也是按下回车后从缓冲区读取。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getchar();</span><br><span class="line"><span class="built_in">putchar</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 不读取缓冲区的字符，只要用户输入字符，getche()函数会立刻读取，而不需等待按回车键，并在屏幕上显示读入的字符。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">getche();</span><br><span class="line"><span class="comment">//它与getche()的区别是，getch()不需将所输入的字符显示到屏幕上</span></span><br><span class="line">getch();</span><br></pre></td></tr></table></figure>
<h3 id="读写字符串">读写字符串</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * gets</span></span><br><span class="line"><span class="comment"> * /Never use gets(). 别用gets()，因为get()没有指定可以使用的缓冲区大小，它会在遇到换行符或者EOF才能停止，把所有的字符都存在缓冲区中，然而因为不知道要读多少个字符，所以可能会发生溢出。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="comment">//* 以"\0"作为字符串的结束。</span></span><br><span class="line"><span class="built_in">puts</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * scanf()加%s，但是%s会在遇到空白符（空格，tab）时自动结束，而gets和fgets()都是以换行或者EOF为结束。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="built_in">scanf</span>();</span><br><span class="line"><span class="built_in">printf</span>();</span><br></pre></td></tr></table></figure>
<h3 id="其他">其他</h3>
<p>可以定义文件指针，指向<code>stdin</code>和<code>stdout</code>，文件的读写函数就也可以使用到标准输入输出了。<br>
如下示例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ch;</span><br><span class="line"></span><br><span class="line">    FILE *pfin = <span class="built_in">stdin</span>; <span class="comment">//定义一个文件指针，并指向标准输入设备(键盘)</span></span><br><span class="line">    FILE *pfout = <span class="built_in">stdout</span>; <span class="comment">//定义一个文件指针，并指向标准输出设备(屏幕)</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Enter a string: "</span>);</span><br><span class="line">    </span><br><span class="line">    ch = getc(pfin); <span class="comment">//使用getc()函数获取缓冲区中的第一个字符</span></span><br><span class="line"></span><br><span class="line">    putc(ch, pfout); <span class="comment">//使用putc()函数输出该字符</span></span><br><span class="line">    putc(<span class="string">'\n'</span>, pfout); <span class="comment">//使用putc()函数输出换行字符</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="文件输入示例">文件输入示例</h2>
<h3 id="从文件中一行一行的读取数字">从文件中一行一行的读取数字</h3>
<p>有data.txt如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">13</span><br><span class="line">38</span><br><span class="line">28</span><br></pre></td></tr></table></figure>
<p>读取程序如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">#define N 510</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123; </span><br><span class="line">    char filename[20] = &quot;data.txt&quot;;</span><br><span class="line">    FILE *fp = fopen(filename, &quot;r&quot;); </span><br><span class="line">    if (fp == NULL) </span><br><span class="line">    &#123; </span><br><span class="line">        printf(&quot;Cannot open file \n&quot;); </span><br><span class="line">        exit(0); </span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    char chunk[128];</span><br><span class="line">    int array[N] = &#123;0&#125;;</span><br><span class="line">    int count = 0;</span><br><span class="line">    while (fgets(chunk, sizeof(chunk), fp)!=NULL) </span><br><span class="line">    &#123; </span><br><span class="line">        array[count] = atoi(chunk);</span><br><span class="line">        count += 1;</span><br><span class="line">    &#125; </span><br><span class="line">    fclose(fp); </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://blog.csdn.net/strongwangjiawei/article/details/7786085" target="_blank" rel="noopener">https://blog.csdn.net/strongwangjiawei/article/details/7786085</a><br>
2.<a href="https://solarianprogrammer.com/2019/04/03/c-programming-read-file-lines-fgets-getline-implement-portable-getline/" target="_blank" rel="noopener">https://solarianprogrammer.com/2019/04/03/c-programming-read-file-lines-fgets-getline-implement-portable-getline/</a><br>
3.<a href="https://stackoverflow.com/questions/20378430/reading-numbers-from-a-text-file-into-an-array-in-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/20378430/reading-numbers-from-a-text-file-into-an-array-in-c</a><br>
4.<a href="http://manpages.ubuntu.com/manpages/bionic/man3/fgetc.3.html" target="_blank" rel="noopener">http://manpages.ubuntu.com/manpages/bionic/man3/fgetc.3.html</a><br>
5.<a href="https://www.cnblogs.com/JCSU/articles/1306308.html" target="_blank" rel="noopener">https://www.cnblogs.com/JCSU/articles/1306308.html</a><br>
6.<a href="https://www.cnblogs.com/JCSU/articles/1306308.html" target="_blank" rel="noopener">https://www.cnblogs.com/JCSU/articles/1306308.html</a><br>
7.<a href="https://blog.csdn.net/baidu_27435045/article/details/53313699" target="_blank" rel="noopener">https://blog.csdn.net/baidu_27435045/article/details/53313699</a><br>
8.<a href="https://stackoverflow.com/questions/17318886/fflush-is-not-working-in-linux" target="_blank" rel="noopener">https://stackoverflow.com/questions/17318886/fflush-is-not-working-in-linux</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">324</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">74</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  

  

</body>
</html>
