<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/11/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/11/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-fundamental-types-and-variables/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-fundamental-types-and-variables/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C++ fundamental types</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 17:11:26" itemprop="dateCreated datePublished" datetime="2019-11-05T17:11:26+08:00">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-13 21:28:11" itemprop="dateModified" datetime="2019-11-13T21:28:11+08:00">2019-11-13</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>C++中基本类型包括算术类型和空类型。这一节主要介绍算术类型，然后介绍了字面值常量的相关内容。</p>
<h2 id="算术类型">算术类型</h2>
<p>算术类型有两类：整形和浮点型。算术类型的大小在不同的机器上实现也可能不同。<br>
整形包括字符，布尔型，整形，长整形。<br>
浮点类型有单精度，双精度和扩展精度浮点数，具体怎么表示可以查看<a href="https://mxxhcm.github.io/2019/10/24/IEEE-754-Floating-Point-Standard/">IEEE 754标准</a>。<br>
一般情况下，<code>char</code>占用$1$字节，<code>int</code>占用$4$字节，<code>long</code>占用$8$字节，<code>long long</code>占用$8$个字节。<code>float</code>占用$4$字节，<code>double</code>占用$8$字节。<br>
除了布尔型和扩展的字符型（wchar_t, char16_t, char32_t)之外，其他整形可以划分为无符号和带符号的两种，无符号类型中所有的比特位都用来存储值，而有符号类型需要使用其中的某些位存储符号。<code>int</code>,<code>long</code>, <code>long long</code>默认是带符号的。<code>char</code>可以分为三种，<code>char</code>, <code>signed char</code>, <code>unsigned char</code>，<code>char</code>不一定是有符号的，由不同的编译器来决定。</p>
<p>其他注意事项：</p>
<ol>
<li>算术表达式中不要使用<code>char</code>，因为不同的编译器对<code>char</code>的处理方式可能不同，一些把<code>char</code>当做有符号的，一些把<code>char</code>当做无符号的，在不同机器之间进行迁移时可能会出现问题。</li>
<li>浮点数运算用<code>double</code>，<code>float</code>精度不够，而且计算代价和<code>double</code>差不多。</li>
</ol>
<h3 id="类型转换">类型转换</h3>
<p>在程序的某处使用一种类型而其实对象应该使用另外一种类型时，程序会自动进行类型转换。关于类型转换的更多内容可以查看<a href="https://mxxhcm.github.io/2019/11/09/C-type-conversion/">C++ type conversions</a>。</p>
<ol>
<li>在将有符号数转化为无符号数的时候，如果这个有符号数是负数，那么会做一个模运算，将它转换为正值。</li>
<li>无符号数永远不可能为负。</li>
<li>如果一个运算同时有有符号数和无符号数参与运算，那么会将有符号数转换为无符号数进行运算。如下示例：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line">b--;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output: 4294967295</span></span><br><span class="line">b = a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//output: 4294967293</span></span><br></pre></td></tr></table></figure>
<h2 id="字面值常量">字面值常量</h2>
<p>字面值(literal)是字面值常量的缩写，它的值是一看就知道的量，并且不允许改变。每一个字面值常量都对应一种数据类型，可以是整形，浮点型，字符，字符串，转义序列，布尔和指针等，数据类型由它的形式和值决定。可以通过前缀或者后缀显式的指定字面值的类型，字符和字符串的字面值类型通过前缀指定，整形和浮点型的字面值类型通过后缀指定。<br>
前缀</p>
<ul>
<li><code>u</code>，表示<code>unicode 16</code>字符</li>
<li><code>U</code>，表示<code>unicode 32</code>字符</li>
<li><code>L</code>，表示宽字符</li>
<li><code>u8</code>，<code>utf-8</code>，只用于字符串字面值常量</li>
</ul>
<p>后缀，这里给出的最小匹配类型，如果不够的话，会自动选择更大的。</p>
<ul>
<li><code>u,U</code>，<code>unsigned</code></li>
<li><code>l, L</code>, <code>long</code></li>
<li><code>ll, LL</code>, <code>long long</code></li>
<li><code>f, F</code>, <code>float</code></li>
<li><code>l, L</code>, <code>long double</code></li>
</ul>
<h3 id="整形字面值常量">整形字面值常量</h3>
<p>如<code>12</code>,<code>1345</code>等。<br>
十进制的字面值常量是带符号数，比如<code>12</code>是<code>int</code>, <code>long</code>, <code>long long</code>中能容纳下的占用最小字节的类型；八进制和十六进制的字面值常量是能容纳其数值的<code>int</code>, <code>long</code>, <code>long long</code>, <code>unsigned int</code>, <code>unsigned long</code>, <code>unsigned long</code>中的最小类型。</p>
<h3 id="浮点型字面值常量">浮点型字面值常量</h3>
<p>浮点型的字面值常量是<code>double</code>。</p>
<h3 id="字符和字符串字面值常量">字符和字符串字面值常量</h3>
<p><code>'a'</code>是字面值字符常量，<code>&quot;hello world&quot;</code>是字符串字面值常量。</p>
<h3 id="转义序列">转义序列</h3>
<p>包含不可打印和可打印的字符。<code>\n</code>,<code>\r</code>,<code>\t</code>,<code>\b</code>,<code>\a</code>等。</p>
<h3 id="布尔字面值">布尔字面值</h3>
<p><code>true</code>, <code>false</code>是<code>bool</code>变量的字面值。</p>
<h3 id="指针字面值">指针字面值</h3>
<p><code>nullptr</code>是指针字面值。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.<a href="https://www.cnblogs.com/yc_sunniwell/archive/2010/06/18/1760034.html" target="_blank" rel="noopener">https://www.cnblogs.com/yc_sunniwell/archive/2010/06/18/1760034.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-concepts/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-concepts/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C++ concepts</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 17:03:42" itemprop="dateCreated datePublished" datetime="2019-11-05T17:03:42+08:00">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-18 22:59:28" itemprop="dateModified" datetime="2019-12-18T22:59:28+08:00">2019-12-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="第一章">第一章</h2>
<ul>
<li>变量，具有名字的对象</li>
<li>缓冲区，一个存储区域，用于保存数据。IO设施通常将输入输出数据保存在一个缓冲区中。</li>
<li>文件结束符(end of file, EOF)，文件结束标志，通常是-1。</li>
<li>初始化，对象创建的时候给它一个初始值。</li>
<li>未初始化的变量，没有给定初始值的变量，类类型的变量如果没有指定初值，按类定义指定的方式进行初始化。函数内部的内置类型变量默认是不初始化的，需要进行显式的初始化。</li>
</ul>
<h2 id="第二章">第二章</h2>
<ul>
<li>
<p>无法预知的行为，编译器无须或者不能检测的错误。即使代码编译通过了，如果程序执行了一条未定义的表达式，仍有可能产生错误，而且这是很有可能的。</p>
</li>
<li>
<p>字面值常量：<code>12</code>, <code>024</code>, <code>0x3</code>,<code>true</code>, <code>3.141</code>, <code>nullptr</code>,<code>A</code>都是字面值常量，他们分别属于<code>int</code>,<code>int</code>,<code>int</code>, <code>bool</code>, <code>double</code>, 指针，<code>char</code>等类型。可以通过前缀或者后缀显式的指定字面值的类型，字符和字符串的字面值类型通过前缀指定，整形和浮点型的字面值类型通过后缀指定。</p>
</li>
<li>
<p>字面值类型：算术类型，引用和指针都属于字面值类型，<code>string</code>，IO库和类不属于字面值类型。算术类型包含整形和浮点型，整形中又包含字符和<code>int</code>,<code>long</code>等。<code>constexpr</code>只能用于字面值类型。</p>
</li>
<li>
<p>在将有符号数转化为无符号数的时候，如果这个有符号数是负数，那么会做一个模运算，将它转换为正值。</p>
</li>
<li>
<p>有符号数永远不可能为负。</p>
</li>
<li>
<p>不要混用无符号类型和有符号类型，因为有符号数会被转化成有符号数进行运算。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">-3</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">b --;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">b = a;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">b = <span class="number">3</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; a* b &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>不要用<code>char</code>进行算术运算，因为不同的平台实现可能不同，有的是无符号的，有的是有符号的。</p>
</li>
<li>
<p>常见的未定义行为：</p>
</li>
</ul>
<ol>
<li>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">i = i++;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>给带符号数一个超出它表示范围的值。</p>
</li>
</ol>
<ul>
<li>
<p>默认初始化，变量没有指定初值，被赋予默认值。默认值由变量类型和变量位置决定。<br>
对于内置类型的变量，如果没有显式初始化，它的位置由定义的位置决定。函数内部的内置类型不会被初始化，定义于任何函数外部的内置类型被初始化为$0$。未初始化的变量的值是未定义的。<br>
对于自定义的类型来说，每个类决定初始化对象的方式，而且是否允许不经过初始化就定义对象也由自己决定。如果类允许这种行为，由类决定对象的初始值是什么；如果类要求每个对象显示初始化，在创建类对象没有进行明确的初始化操作时，会引发错误。</p>
</li>
<li>
<p>未初始化变量。</p>
</li>
<li>
<p>声明和定义的区别和联系。</p>
</li>
<li>
<p>在函数体内部不能初始化由<code>extern</code>关键字标记的变量。</p>
</li>
<li>
<p>静态类型，在编译阶段检查类型。</p>
</li>
<li>
<p>类型修饰符：<code>*</code>和<code>&amp;</code>，它是声明符的一部分，const也是类型修饰符。</p>
</li>
<li>
<p>声明符：变量名或者变量名前面加上类型修饰符，即<code>*d</code>和<code>&amp;d</code>，其中<code>d</code>是变量名。</p>
</li>
<li>
<p>复合类型：基于其他类型定义的类型，引用和指针都是复合类型。</p>
</li>
<li>
<p>引用就是别名，不能更改，必须初始化。</p>
</li>
<li>
<p>指针存放的是某个对象的地址，要想获取变量的地址，使用<code>&amp;</code>符号获取变量的地址。</p>
</li>
<li>
<p>建议初始化所有指针。如果指针未经初始化，该指针变量中存放的值被当做一个地址，访问该指针，相当于访问一个本不存在的变量，如果这个地址中的内容被我们拿到了，我们可能就不知道这个值是合法还是非法的。建议初始化所有的指针，不知道指针应该指向什么的话，就让指针指向<code>nullptr</code>或者<code>0</code>。</p>
</li>
<li>
<p>复杂的指针或者引用的声明语句，从右往左读。</p>
</li>
<li>
<p>常量引用是对<code>const</code>的引用的简称。严格来说，并不存在常量引用，因为引用不是一个对象，我们没办法让引用本身恒定不变。但是因为C++中，引用绑定的对象是不能更改的，所以从这层意义上理解，所有的引用又都称得上常量。引用的对象是常量还是非常量决定了引用能进行的操作，但是影响不到引用和对象的绑定关系。</p>
</li>
<li>
<p>指向常量的指针和对常量的引用（常量引用），可以使用非常量对象初始化指向常量的指针和常量引用，不论指向或者引用的是不是常量对象，都不能通过指针或者引用修改他们引用或者指向的对象的值。因为他们认为自己指向或者引用了常量，而常量是不能修改的，所以就不能修改了。</p>
</li>
<li>
<p>常量指针即指针本身是一个常量。它的指向不能改变，但是它指向变量的值是可以改变的。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val =<span class="number">3</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;cr = val; <span class="comment">// 对常量的引用，引用的变量不能通过cr引用改变。</span></span><br><span class="line">cont <span class="keyword">int</span> *ptr = &amp;val;   <span class="comment">// 指向常量的指针，指针指向的变量不能通过ptr指针改变。</span></span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> p = &amp;val;    <span class="comment">//常量指针，指针的指向不能变，指针指向变量的值可以改变。</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>顶层<code>const</code>，变量本身是一个常量。</p>
</li>
<li>
<p>底层<code>cosnt</code>，针对于复合类型如指针和引用来说的，引用的对象是一个常量（常量引用）或者指针指向的是一个常量。</p>
</li>
<li>
<p>顶层<code>const</code>和底层<code>const</code><br>
对常量的引用（常量引用）可以和常量对量绑定；<br>
对常量的引用（常量引用）可以和非常量对量绑定；<br>
非常量引用不可以和常量对象绑定；<br>
非常量引用可以和非常量对象绑定；<br>
指向常量的指针可以指向常量对象；<br>
指向常量的指针可以指向非常量对象；<br>
常量指针可以指向非常量对象；<br>
常量指针不可以指向常量对象；<br>
普通指针不可以指向常量对象；<br>
普通指针可以指向非常量对象；<br>
常量指针（顶层const）可以用来初始化非常量对象。<br>
对常量的引用和指向常量的指针（底层const）不可以用来初始化非常量对象。</p>
</li>
<li>
<p>常量表达式，值不会改变并且在编译时值就已经确定的表达式。</p>
</li>
<li>
<p>constexpr`用于声明常量表达式，常量表达式一定是常量，但是常量不一定是常量表达式。比如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const int sz = get_size() //sz是常量，但是不是常量表达式</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p><code>auto</code>会忽略顶层<code>const</code>，保留底层<code>const</code>。</p>
</li>
<li>
<p><code>auto</code>也会忽略引用。</p>
</li>
<li>
<p>设置类型为<code>auto</code>的引用，可以保留顶层<code>const</code></p>
</li>
<li>
<p><code>decltype</code>的结果可以是引用，引用从来都是作为它所指对象的同义词出现，只有在<code>decltype</code>处是例外。</p>
</li>
<li>
<p>如果表达式的内容是解引用操作，使用<code>decltype</code>将会得到引用类型。</p>
</li>
<li>
<p><code>decltype((variable))</code>的结果永远是引用，而<code>decltype(variable)</code>的结果只有在真的是引用的时候才会返回引用。</p>
</li>
</ul>
<h2 id="第三章">第三章</h2>
<ol>
<li><code>cin</code>和<code>getline</code>的区别，对于空白符的处理</li>
<li><code>string</code>的初始化方式，默认初始化，拷贝初始化，直接初始化</li>
<li>range for语句逐字符操作。</li>
<li></li>
</ol>
<h2 id="第七章">第七章</h2>
<ul>
<li><strong>构造函数</strong>。每个类都会定义它的对象被初始化的方式，类通过一个或者几个特殊的成员函数控制每个类的初始化过程,这些函数叫做构造函数。</li>
<li><strong>前向声明</strong>。仅仅声明类而暂时不定义它，这种声明有时候也叫前向声明。</li>
<li><strong>不完全类型</strong>。在类声明之后定义之前，这个类属于不完全类型。我们知道它是一个类，但是不清楚它到底包含哪些类型。</li>
</ul>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Prime第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-IO/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C++ IO</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 16:00:09" itemprop="dateCreated datePublished" datetime="2019-11-05T16:00:09+08:00">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-25 21:58:30" itemprop="dateModified" datetime="2019-12-25T21:58:30+08:00">2019-12-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="i-o类">I/O类</h2>
<p>标准库提供了三类IO操作，它们分别是读写流的iostream，读写文件的fstream，读写内存中string的sstream。如下表所示：<br>
<img src="/2019/11/05/C-IO/io.png" alt="io"><br>
ifstream和istringstrem都继承自istream，ofstream和ostringstream都继承自ostream。像使用cin和cout那样使用它们就行。</p>
<h3 id="io对象的特性">IO对象的特性</h3>
<ol>
<li>不能拷贝或者对IO对象赋值。所以不能将形参和返回类型设置为流类型，必须将它们设置为流引用类型。</li>
<li>读写一个IO对象会改变它的状态，因此传递和返回的引用不能是const的。</li>
</ol>
<h3 id="io流的状态">IO流的状态</h3>
<p>IO操作很容易出错，一些错误是可恢复的，另一些是不可恢复的。下面是IO类中定义的函数和表示，可以帮助我们访问和操纵流的状态。<br>
<img src="/2019/11/05/C-IO/condition.png" alt="condition"><br>
<code>strm::iostate</code>中存放了当前IO流的状态，这个类型是一个位集合，IO类定义了四个iostate类型的常量表达式表达特定的位类型，可以使用位运算与设置或者检测多个标志位：</p>
<ul>
<li>strm::badbit，表示系统级的错误</li>
<li>strm::failbit，可恢复错误（到达文件结束也会置位strm::failbit，发生系统级错误时也会被置位）</li>
<li>strm::eofbit，到达文件结束</li>
<li>strm::goodbit，流处于未出错状态</li>
</ul>
<p>它们用来表示流的状态，可以用<code>good()</code>, <code>fail()</code>，<code>eof()</code>, <code>bad()</code>分别查询对应标志位的状态。我们将流当做条件使用的代码其实就是使用的是状态位的状态。<br>
可以使用<code>rdstate</code>函数获得当前流的状态，使用<code>setstate</code>对给定条件位置位，使用<code>clear</code>可以清除所错误标志位，也可以清除指定错误标志位。</p>
<h3 id="管理缓冲区">管理缓冲区</h3>
<p>关于缓冲区的内容，简单来说，缓冲区的作用就是减少系统级IO，提高读写效率。具体介绍可以查看<a href></a>。<br>
这里介绍一下导致C++中缓冲区刷新的原因：</p>
<ol>
<li>程序结束，作为main函数return的一部分，冲洗缓冲区</li>
<li>缓冲区满时，冲洗缓冲区</li>
<li>使用操作符endl，会在输出内容的末尾加一个<code>'\n'</code>，然后刷新缓冲区；使用flush刷新缓冲区，不附加任何字符；使用ends在输出内容的末尾加一个空字节，并不会刷新缓冲区（C++ Primer第五版上写错了）。</li>
<li>使用<code>cout &lt;&lt; unitbuf</code>设置为每次输出操作后都刷新缓冲区（即使不适用endl等操作符），即无缓冲，使用<code>cout &lt;&lt; nounitbuf</code>恢复。</li>
<li>一个输出流可能关联到另一个流，当读写关联的流时，关联到的流的缓冲区都会被刷新。</li>
</ol>
<h2 id="iostream"><code>iostream</code></h2>
<p>C++标准IO库<code>iostream</code>提供了输入流<code>istream</code>和输出流<code>ostream</code>，一个流就是一个字符序列，从IO设备中读出或者写入IO设备。</p>
<h3 id="标准输入输出对象">标准输入输出对象</h3>
<ul>
<li><code>cin</code>，标准输入</li>
<li><code>cout</code>，标准输出</li>
<li><code>cerr</code>，标准错误</li>
<li><code>clog</code>，用来输出一些普通信息。</li>
</ul>
<p>通常系统会将程序所运行的窗口和标准IO对象关联起来，读取<code>cin</code>，从当前程序关联的窗口进行读取，向<code>cout</code>,<code>cerr</code>和<code>clog</code>写入数据时，会写到同一个窗口中，可对它们进行重定向。</p>
<h3 id="输入输出运算符">输入输出运算符</h3>
<ul>
<li><code>&lt;&lt;</code>输出运算符，接收两个运算符，左侧需要是<code>ostream</code>对象，右侧需要是要打印的对象。返回左侧运算对象，即写入给定值的<code>ostream</code>对象。</li>
<li><code>&gt;&gt;</code>输入运算符，接收两个运算符，左侧需要是<code>istream</code>对象，右侧从istream中读入的数据要写入的对象。返回左侧运算对象，即给定的<code>istream</code>对象。</li>
</ul>
<p>一直有个问题就是为什么<code>&lt;&lt;</code>是输出，<code>&gt;&gt;</code>是输入，可以简单的把箭头方向当做数据流向，输出的数据流向<code>ostream</code>中的标准输出<code>cin</code>，输入时，数据从<code>istream</code>的标准输入<code>cin</code>流向变量。</p>
<h3 id="操纵符">操纵符</h3>
<p><code>endl</code>是一种操纵符。当把它写入到<code>ostream</code>的时候，有两个作用：</p>
<ol>
<li>结束当前行</li>
<li>将与当前输出设备相关的缓冲区中的内容刷新到输出设备中。这个刷新操作可以保证目前为止程序的所有输出都真正写入输出流而不是在内存中的等待写入输出流。</li>
</ol>
<h3 id="命名空间">命名空间</h3>
<p>命名空间可以解决名自定义冲突问题。比如有两个不同的库中实现了一个同名的函数，可以通过加上命名空间进行区分。<code>cin</code>,<code>cout</code>和<code>endl</code>都定义在<code>std</code>命名空间中。在访问时需要使用以下方式：<code>std::cin</code>，<code>std::cout</code>，<code>std::endl</code>。<br>
C++标准库定义的名字在都在<code>std</code>中。</p>
<h3 id="读取任意的输入数据">读取任意的输入数据</h3>
<p>下面的示例代码对任意的输入数据进行求和。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">using std::cin;</span><br><span class="line">using std::endl;</span><br><span class="line">using std::cout;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int sum = 0, value = 0;</span><br><span class="line">    while(std::cin &gt;&gt; value)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; &quot;Sum is: &quot; &lt;&lt; sum &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="fstream"><code>fstream</code></h2>
<p>头文件<code>fstream</code>定义了三个类型支持文件IO：</p>
<ul>
<li><code>ifstream</code>从一个给定的文件读取数据；</li>
<li><code>ofstream</code>向一个给定的文件写入数据；</li>
<li><code>fstream</code>读写给定文件。</li>
</ul>
<p>这些类型和我们之前使用的<code>cin</code>和<code>cout</code>一样，可以使用<code>getline</code>从一个<code>ifstream</code>中读取数据。<code>fstream</code>具有以下的一些特殊操作：<br>
<img src="/2019/11/05/C-IO/fstream.png" alt="fstream"><br>
这些操作只有<code>fstream</code>,<code>ofstream</code>和<code>ifstream</code>对象能调用，其他类型不行。</p>
<h3 id="使用fstream-ifstream和ofstream">使用<code>fstream</code>,<code>ifstream</code>和<code>ofstream</code></h3>
<p>我们想要读文件的时候，可以定义一个<code>fstream</code>对象，然后将这个对象和文件关联起来，每个<code>fstream</code>类都定义了一个名字为<code>open</code>的成员函数，它完成了一些系统相关的操作，定位给定的文件，打开为读或写模式。<br>
在创建<code>fstream</code>对象时，我们可以提供一个文件名，此时<code>open</code>函数会被自动调用。如果定义了一个空<code>fstream</code>对象，可以手动调用<code>open</code>将它和一个文件关联起来。调用<code>open</code>可能失败，进行<code>open</code>是否成功的检测通常是一个好习惯。<br>
<code>close</code>函数可以关闭<code>fstream</code>当前关联的文件，当一个<code>fstream</code>对象被销毁时，会自动调用<code>close</code>函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.构造一个ifstream并打开给定文件，文件名可以是string，也可以是C风格字符串</span></span><br><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(ifile)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.输出文件流并未关联到任何文件。</span></span><br><span class="line">ofstream out;</span><br><span class="line">out.open(ifile+<span class="string">".out"</span>);</span><br></pre></td></tr></table></figure>
<p>可以使用<code>fstream</code>代替<code>iostream</code>，因为<code>fstream</code>是<code>iostream</code>的子类。</p>
<h3 id="file-mode">file mode</h3>
<p>C++ 中的file mode如下所示：<br>
<img src="/2019/11/05/C-IO/file_mode.png" alt="file_mode"><br>
具体的使用可以等用到的时候查资料。</p>
<h2 id="sstream"><code>sstream</code></h2>
<p>头文件<code>sstream</code>定义了三个类型支持内存IO：</p>
<ul>
<li><code>istringstream</code>从<code>string</code>读取数据；</li>
<li><code>ostringfstream</code>向<code>string</code>写入数据；</li>
<li><code>stringstream</code>读写<code>string</code>。</li>
</ul>
<p><code>stringstream</code>特有的操作如下：<br>
<img src="/2019/11/05/C-IO/stringstream.png" alt="stringstream"></p>
<h3 id="使用istringstream和使用ostringstream">使用<code>istringstream</code>和使用<code>ostringstream</code></h3>
<p>最好的就是写一个例子。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-char-char-string/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-char-char-string/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C char*, char [], char** and C++ string</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 12:21:22" itemprop="dateCreated datePublished" datetime="2019-11-05T12:21:22+08:00">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:14:29" itemprop="dateModified" datetime="2019-12-17T15:14:29+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="char-arr-字符数组-c类型字符串"><code>char arr[]</code>（字符数组，C类型字符串）</h2>
<ol>
<li>C语言中的<strong>字符串</strong>的概念：以NULL字节结尾的零个或者多个字符。而字符数组可以不以<code>'\0'</code>结束，而且不能为空。</li>
<li>字符串通常存在字符数组中，这也是C语言中没有显式的字符串类型的原因。</li>
<li>因为字符串以NULL结束，所以字符串内部不能有NULL字节。</li>
<li>为什么选择NULL作为字符串的终止符，因为它不是一个可打印的字符。</li>
</ol>
<p>如下所示，是<code>char str[]</code>，即字符数组的定义。<code>str</code>是自动变量，存放在栈里面。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"hello"</span>;</span><br><span class="line"><span class="keyword">char</span> str2[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> str3[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="char-字符指针"><code>char*</code>（字符指针）</h2>
<ol>
<li><code>char*</code>是一个指针，指向一个<code>char</code>，理论上来说，它并不是一个数组。</li>
<li><code>char *ptr;</code>并不为它指向的内容分配内存，而是只分配一个<code>char *</code>大小的内存存放指针变量<code>ptr</code>。</li>
<li><code>char arr[10];</code>是一个数组，不是一个指针，<code>char *</code>和<code>char[10]</code>不是一个类型。</li>
</ol>
<h2 id="char-指向字符指针的指针"><code>char**</code>（指向字符指针的指针）</h2>
<p><code>char**</code>是一个指针，指向一个指向<code>char</code>的指针。这个东西我刚开没有理解它有什么有，后来想明白了，它可以指向一个指针数组。如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *arr[] =  &#123;</span><br><span class="line">    <span class="string">"hello"</span>,</span><br><span class="line">    <span class="string">"world"</span>,</span><br><span class="line">    <span class="string">"hi"</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">char</span> **p = arr;</span><br></pre></td></tr></table></figure></p>
<p>p是字符指针的指针，指向数组中的第一个字符串，(*p)就是一个字符指针，指向第一个字符串的第一个字符，**p就是第一个字符串的第一个字符。<br>
而<code>p+1</code>指向数组中的第二个字符串。<br>
<code>p+2</code>指向数组中的第三个字符串。<br>
事实上，这个p和arr的作用是一样的。<code>char**</code>经常在<code>main</code>函数中用到。</p>
<h2 id="std-string"><code>std::string</code></h2>
<p>字符串字面值和<code>string</code>是不同的类型，字符串字面值是为了和C语言兼容，它不是标准库中<code>string</code>对象的内容。</p>
<h2 id="字符和字符串字面值常量">字符和字符串字面值常量</h2>
<p><strong>字符串字面值常量</strong>是用一对双引号包围一串字符。如<code>&quot;hello&quot;</code>, <code>&quot;hi\n&quot;</code>, <code>&quot;&quot;</code>等，<code>'a'</code>是字面值字符常量。<br>
程序在使用字符串常量时，编译器会将字符串常量存放在数据区的常量区。当一个字符串常量出现在在一个表达式中，表达式使用的值是字符串常量在内存中的地址，而不是这些字符串常量本身。可以把字符串赋值给“指向字符的指针”，即让指针指向字符串常量在内存中的地址。但是不能把字符串常量赋值给一个字符数组，即不能把字符串常量的地址赋值给字符数组。比如<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *message1 = <span class="string">"Hello world!"</span>;</span><br></pre></td></tr></table></figure></p>
<p>这个代码是将字符串常量中第一个字符的地址传递给message。</p>
<h2 id="字符数组和字面值常量的区别">字符数组和字面值常量的区别</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> message1[] = <span class="string">"Hello world!;</span></span><br><span class="line"><span class="string">char *message2 = "</span>Hello world!<span class="string">";</span></span><br></pre></td></tr></table></figure>
<p>第一种方式，其实是一种约定，它等于<code>char message1[] = {'H', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd', '\0'};</code>。<br>
而第二种方式中，&quot;Hello world&quot;是一个字面值常量，它在内存中只能以数组的形式存在，是一个不可修改的左值表达式。而message2实际上指向了这个字符串数组的首字符。</p>
<h2 id="常见的指针数组">常见的指针数组</h2>
<ol>
<li><code>main</code>函数的形参<code>char *argv[]</code>就是一个指针数组</li>
<li><code>getline</code>的第一个参数是<code>char **lineptr</code>。</li>
</ol>
<p>怎么理解？如下图所示：<br>
<img src="/2019/11/05/C-char-char-string/pointer_array.jpg" alt="pointer_array"></p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.<a href="https://www.zhihu.com/question/307261590/answer/563448215" target="_blank" rel="noopener">https://www.zhihu.com/question/307261590/answer/563448215</a><br>
3.<a href="https://www.zhihu.com/question/307261590/answer/563630017" target="_blank" rel="noopener">https://www.zhihu.com/question/307261590/answer/563630017</a><br>
4.<a href="https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-sizeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-sizeof/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C sizeof</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 12:19:54" itemprop="dateCreated datePublished" datetime="2019-11-05T12:19:54+08:00">2019-11-05</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/05/C-malloc-free-new-and-delete/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/05/C-malloc-free-new-and-delete/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">C/C++ malloc(alloc) free new and delete</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-05 10:37:48" itemprop="dateCreated datePublished" datetime="2019-11-05T10:37:48+08:00">2019-11-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-25 17:46:02" itemprop="dateModified" datetime="2020-01-25T17:46:02+08:00">2020-01-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="malloc"><code>malloc</code></h2>
<h3 id="c标准malloc定义">C标准<code>malloc</code>定义</h3>
<p><code>malloc</code>定义在头文件<code>&lt;stdlib.h&gt;</code>中</p>
<blockquote>
<p>Allocates size bytes of uninitialized storage.<br>
If allocation succeeds, returns a pointer to the lowest (first) byte in the allocated memory block that is suitably aligned for any object type with fundamental alignment.<br>
If size is zero, the behavior is implementation defined (null pointer may be returned, or some non-null pointer may be returned that may not be used to access storage, but has to be passed to free).</p>
</blockquote>
<blockquote>
<p>malloc is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.<br>
A previous call to free or realloc that deallocates a region of memory synchronizes-with a call to malloc that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by malloc. There is a single total order of all allocation and deallocation functions operating on each particular region of memory. (since C11)</p>
</blockquote>
<h3 id="malloc-calloc和realloc原型"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reallocarray</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-calloc和realloc性质"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>性质</h3>
<ol start="0">
<li><code>malloc</code>函数的实现中（C标准没有规定），在分配空间的时候，通常分配的空间要比申请的要大一些，这些额外的空间用来记录<code>malloc</code>这片空间的大小，在使用<code>free</code>的时候会用到。</li>
<li><code>malloc</code>，分配指定字节的内存空间，初始值不定。</li>
<li><code>calloc</code>，为指定长度的固定数量的对象分配空间，每一个bit都被初始化为0。</li>
<li><code>realloc</code>，增加或者减少已经分配的内存空间的大小。当这个大小增加时，可能需要将之前分配的空间中的数据移到另一个足够大的区域以便于增加大小，新增加的区域内的值是不确定的。</li>
<li>这三个函数返回的指针一定是对齐的，保证它可以用于任何对象。比如<code>double</code>的要求最严格，需要从8的倍数的地址单元开始，这三个函数返回的地址一定满足这个要求。</li>
<li>它们的返回类型都是<code>void*</code>，需要使用强制类型转换。</li>
<li><code>realloc</code>函数可以增加或者减少之前分配的内存空间的大小。比如分配了一个固定大小的数组，后来发小它不够用了，可以使用<code>realloc</code>对它进行扩充，如果原有的存储后有足够的大小进行扩充，则可以在原存储区的位置上向高地址进行扩充，无需移动原有数组，返回和传入相同的指针。如果原来的内存空间后没有足够的空间，就重新分配一个足够大的内存空间，再将原有数据的内容复制过去，然后释放原来的内存空间，返回新的指针。</li>
<li><code>realloc</code>传入的参数是存储区的新长度。如果传入的<code>ptr</code>参数是<code>NULL</code>指针，那就退化成了<code>malloc</code>。</li>
</ol>
<h3 id="自己实现一个malloc">自己实现一个<code>malloc</code></h3>
<p>???</p>
<h2 id="free"><code>free</code></h2>
<h3 id="c标准free定义">C标准<code>free</code>定义</h3>
<p><code>free</code>定义在头文件<code>&lt;stdlib.h&gt;</code>中</p>
<blockquote>
<p>Deallocates the space previously allocated by malloc(), calloc(), aligned_alloc, (since C11) or realloc().<br>
If ptr is a null pointer, the function does nothing.<br>
The behavior is undefined if the value of ptr does not equal a value returned earlier by malloc(), calloc(), realloc(), or aligned_alloc() (since C11).<br>
The behavior is undefined if the memory area referred to by ptr has already been deallocated, that is, free() or realloc() has already been called with ptr as the argument and no calls to malloc(), calloc() or realloc() resulted in a pointer equal to ptr afterwards.<br>
The behavior is undefined if after free() returns, an access is made through the pointer ptr (unless another allocation function happened to result in a pointer value equal to ptr)<br>
free is thread-safe: it behaves as though only accessing the memory locations visible through its argument, and not any static storage.</p>
</blockquote>
<blockquote>
<p>A call to free that deallocates a region of memory synchronizes-with a call to any subsequent allocation function that allocates the same or a part of the same region of memory. This synchronization occurs after any access to the memory by the deallocating function and before any access to the memory by the allocation function. There is a single total order of all allocation and deallocation functions operating on each particular region of memory. (since C11)</p>
</blockquote>
<h3 id="free原型"><code>free</code>原型</h3>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">void free(void *ptr);</span><br></pre></td></tr></table></figure>
<h3 id="free属性"><code>free</code>属性</h3>
<p>从标准的定义可以看出来，以下都是未定义的行为：</p>
<ol>
<li>
<p><code>free</code>的对象不是<code>alloc</code>函数族的返回值；比如<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *pi = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="number">10</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">pi++;</span><br><span class="line"><span class="comment">//下面就是错误的，因为这个`pi`不是`alloc`函数族的返回值。</span></span><br><span class="line"><span class="built_in">free</span>(pi);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p><code>free</code>一个已经被释放过了的块；</p>
</li>
<li>
<p>访问一个<code>free</code>已经释放了的块。<br>
等等。为什么？？？因为标准并没有定义<code>malloc</code>应该怎么实现，有的内存分配器，<code>malloc</code>实际申请的内存要比传入的参数大，里面存放了额外的数据记录这块内存有多大，一般就是存在指针左边。<code>free</code>的时候，就会读取那个内存块中存放的信息，进行<code>free</code>，所以上面的那些都是未定义的行为。</p>
</li>
</ol>
<p>其他属性</p>
<ol>
<li><code>free</code>可以释放<code>ptr</code>指向的内存空间，释放的空间通常送入可用内存池，之后可以通过这三个函数重新分配。</li>
<li><code>malloc</code>和<code>free</code>底层通常使用<code>sbrk</code>系统调用实现，这个系统调用扩充或者减小进程的堆，虽然<code>sbrk</code>可以扩充或者缩小进程的堆，但是一般<code>malloc</code>和<code>free</code>的实现不会减少进程的内存空间，释放的内存空间保存在<code>malloc</code>池中，而不是交给内核。</li>
<li>大多数实现分配的空间要比请求的空间大一些，因为需要存储一些管理信息，如block的大小，指向下一个block的指针等等。因此，如果对超过一个分配区域的内存进行读写的话，会造成很严重的错误。</li>
<li><code>free</code>一个已经释放了的块，<code>free</code>的不是<code>alloc</code>函数的返回值，没有进行<code>free</code>等等，都是未定义的结果。为什么？？？</li>
</ol>
<h2 id="new"><code>new</code></h2>
<p>对于自定义类型而言，<code>new</code>操作符首先调用operator new()函数申请内存，其内部调用的是malloc函数，返回一个<code>void*</code>类型的指针；<code>new</code>还会负责把它转换成自定义对象的指针；然后调用类的构造函数初始化对象；最后返回自定义对象的指针。<code>malloc</code>只负责内存的分配而不会调用类的构造函数数。举个例子：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Complex *pc = <span class="keyword">new</span> Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="comment">// 1.内部调用malloc</span></span><br><span class="line"><span class="keyword">void</span> *mem = <span class="keyword">operator</span> <span class="keyword">new</span>(<span class="keyword">sizeof</span>(Complex));</span><br><span class="line"><span class="comment">// 2.将void *类型指针转换为Complex*类型的</span></span><br><span class="line">pc = <span class="keyword">static_cast</span>&lt;Complex*&gt; (mem);</span><br><span class="line"><span class="comment">// 3.调用Complex的构造函数</span></span><br><span class="line">pc-&gt;Complex::Complex(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure></p>
<ol>
<li>默认初始化。<code>new</code>后面加类型，没有小括号，也没有花括号。<br>
默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。这意味着内置类型或组合类型的对象的值是无定义的，而类类型对象将用默认构造函数进行初始化。</li>
<li>值初始化。类型名字后加()即可，对于内置类型的变量，初始化为0，对于类类型的变量，调用默认构造函数。</li>
<li>直接初始化。使用初始化列表加对象值，或者小括号加对象值。</li>
</ol>
<p>对于自定义类型而言，只要一调用new，无论后面有没有加()，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化。</p>
<h2 id="delete"><code>delete</code></h2>
<ol>
<li><code>delete</code>是和<code>new</code>配对的操作。调用<code>delete</code>操作，编译器实际上会将它转换为两步操作，第一步是调用析构函数；第二部调用<code>opereator delete()</code>，其内部调用了<code>free</code>。</li>
<li>数组的<code>new</code>一定要和数组的<code>delete</code>配对，否则就会出现内存泄露。第一条中说了<code>delete</code>分为两步，第一步其实不会造成内存泄露；而是第二步中，析构函数被调用的次数，<code>delete p</code>只会调用一次析构函数，而<code>delete[] p</code>会调用多次析构函数，调用次数和<code>new</code>时申请的数组大小一样。</li>
</ol>
<h2 id="malloc-vs-new"><code>malloc</code> vs <code>new</code></h2>
<ol>
<li><code>malloc</code>是C语言中的函数，而<code>new</code>是C++的操作符；</li>
<li><code>malloc</code>返回的是<code>void*</code>类型的指针，需要我们手动进行强制类型转换转换成我们需要的类型，而<code>new</code>返回的是对象类型的指针，类型和对象严格匹配，<code>new</code>是类型安全型操作符。</li>
<li>在分配内存失败时，<code>malloc</code>会返回NULL，而<code>new</code>会throw on failure。</li>
<li><code>malloc</code>需要指定申请的内存占多少个字节，而<code>new</code>不需要指定申请内存块的大小，编译器会根据类型计算需要的内存大小；</li>
<li><code>malloc</code>和<code>new</code>都是申请heap上的内存；</li>
<li><code>new</code>操作符调用的operator new()函数可以重载（操作符<code>new</code>不能重载），而<code>malloc</code>不能重载。</li>
<li><code>malloc</code>和<code>free</code>，<code>new</code>和<code>delete</code>必须配套使用。</li>
</ol>
<p>几个问题：</p>
<ol>
<li>什么时候<code>malloc</code>和<code>new</code>会申请内存失败。</li>
<li><code>new</code>操作符的两个步骤，一个是申请内存，一个是调用构造函数，<code>new</code>的申请内存和<code>malloc</code>的申请内存有什么区别。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.<a href="https://stackoverflow.com/questions/184537/in-what-cases-do-i-use-malloc-and-or-new" target="_blank" rel="noopener">https://stackoverflow.com/questions/184537/in-what-cases-do-i-use-malloc-and-or-new</a><br>
3.<a href="https://zhuanlan.zhihu.com/p/47089696?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=687606928481730560" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/47089696?utm_source=wechat_session&amp;utm_medium=social&amp;utm_oi=687606928481730560</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/03/data-structure-map-vs-hash-map/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/03/data-structure-map-vs-hash-map/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">data structure map vs hash_map</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-03 21:28:13" itemprop="dateCreated datePublished" datetime="2019-11-03T21:28:13+08:00">2019-11-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:49:58" itemprop="dateModified" datetime="2019-12-17T15:49:58+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>map vs hash_map(unordered_map)</p>
<ul>
<li>数据结构，<br>
map使用平衡二叉树，通常是红黑树；hash_map使用哈希函表。</li>
<li>查找时间<br>
map是$O(\log n)$；hash_map是$O(1)$（没有冲突的情况下），最坏情况下是$O(n)$。</li>
</ul>
<p>C++中的hash_map叫做unordered_map。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/2189189/map-vs-hash-map-in-c/2189206" target="_blank" rel="noopener">https://stackoverflow.com/questions/2189189/map-vs-hash-map-in-c/2189206</a><br>
2.<a href="https://stackoverflow.com/questions/5139859/what-the-difference-between-map-and-hashmap-in-stl/5139888" target="_blank" rel="noopener">https://stackoverflow.com/questions/5139859/what-the-difference-between-map-and-hashmap-in-stl/5139888</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/01/linear-algebra-Gram-Schmidt-正交化/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/01/linear-algebra-Gram-Schmidt-正交化/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">linear algebra Gram-Schmidt 正交化</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-01 09:39:44" itemprop="dateCreated datePublished" datetime="2019-11-01T09:39:44+08:00">2019-11-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:48:07" itemprop="dateModified" datetime="2019-12-17T15:48:07+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/线性代数/" itemprop="url" rel="index"><span itemprop="name">线性代数</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="gram-schmidi正交化">Gram-Schmidi正交化</h2>
<p>这一章属于<a href>正交</a>的内容，但是因为很重要，就单独拎出来再说一遍。<br>
Gram-Schmidt正交化过程就相当于是在不断的进行投影，这个方法的想法是从$n$个独立的column vector出发，构建$n$个正交向量，然后再单位化。拿$3$个过程举个例子。用$a,b,c$表示初始的$3$个独立向量，$A,B,C$表示三个正交向量，$q_1, q_2,q_3$表示三个正交单位向量。<br>
第一个正交向量，直接对第一个向量单位化<br>
$$A=a, q_1 = \frac{A}{\vert A\vert}$$<br>
第二个正交向量，将第二个向量投影到第一个向量上，计算出一个和第二个向量正交的向量。<br>
$$B=b-\frac{A^T B}{A^T A}A , q_2 = \frac{B}{\vert B\vert}$$<br>
第三个正交向量，将第三个向量分别投影到第一个和第二个正交向量上，计算处第三个正交向量。<br>
$$C=c - \frac{A^T C}{A^T A}A - \frac{B^T C}{B^T B}B , q_2 = \frac{C}{\vert C\vert}$$<br>
<img src="/2019/11/01/linear-algebra-Gram-Schmidt-正交化/gram_schmidi.jpg" alt="gram_schmidi"></p>
<h2 id="参考文献">参考文献</h2>
<p>1.MIT线性代数公开课</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/01/linear-algebra-matrix-decomposition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/01/linear-algebra-matrix-decomposition/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">linear algebra matrix decomposition</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-01 09:35:12" itemprop="dateCreated datePublished" datetime="2019-11-01T09:35:12+08:00">2019-11-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:47:45" itemprop="dateModified" datetime="2019-12-17T15:47:45+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/线性代数/" itemprop="url" rel="index"><span itemprop="name">线性代数</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="矩阵分解">矩阵分解</h2>
<h2 id="lu分解">LU分解</h2>
<h2 id="plu分解">PLU分解</h2>
<h2 id="qr分解">QR分解</h2>
<h2 id="代码">代码</h2>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="http://www.math.iit.edu/~fass/477577_Chapter_7.pdf" target="_blank" rel="noopener">http://www.math.iit.edu/~fass/477577_Chapter_7.pdf</a><br>
2.<a href="https://www.sciencedirect.com/science/article/pii/S0377042706001403" target="_blank" rel="noopener">https://www.sciencedirect.com/science/article/pii/S0377042706001403</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/10/28/logistic-regression/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/10/28/logistic-regression/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/11/index.html">logistic regression</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-10-28 19:40:06" itemprop="dateCreated datePublished" datetime="2019-10-28T19:40:06+08:00">2019-10-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:21:12" itemprop="dateModified" datetime="2019-12-17T15:21:12+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="logistic-regression">logistic regression</h2>
<p>逻辑回归是使用线性模型进行分类的模型，它是一个对数线性模型。<br>
在使用线性模型进行回归时，产生的预测值是实数值。而对于分类任务，函数的输出需要是离散值。对于二分类任务，类别分别记为$0$和$1$，如果将回归模型的值限制在$[0, 1]$之间，那么接下来我们要做的就是将$[0,1]$之间的值转换为$0$和$1$。比如单位跃阶函数：<br>
$$y=\begin{cases}0, x \lt 0;\\0.5, x=0;\\1, x\gt 0\end{cases} \tag{1}$$<br>
但是它是离散的，需要找一个连续的函数。这就是接下来介绍的logistic function。</p>
<h2 id="logistic-distribution">logistic distribution</h2>
<p>连续随机变量$X$服从logistic distribution指的是$X$具有以下分布函数和密度函数：<br>
$$F(x) = P(X\le x) = \frac{1}{1 + e^{-(x-\mu)/\gamma} } \tag{2}$$<br>
$$f(x) = F’(x) = \frac{e^{-(x-\mu)/\gamma} }{\gamma(1 + e^{-(x-\mu)/\gamma} )^2 } \tag{3}$$<br>
其中$\mu$为位置参数，$\gamma \gt 0$是形状参数。分布函数属于logistic function，相应的图如下所示，它的取值在$[0,1]$之间，是一条sigmod曲线，以点$(\mu, \frac{1}{2})$为中心对称，即满足：<br>
$$F(-x+\mu) - \frac{1}{2} = -F(x-\mu) +\frac{1}{2} \tag{4}$$<br>
<img src="/2019/10/28/logistic-regression/logistic_function.png" alt="logistic_func"><br>
曲线在中心附近增长的速度很快，在两端增加的速度很慢。$\gamma$越小，曲线在中心附近增长的越快。当$\mu=0, \gamma=1$时，得到一个特殊的函数：<br>
$$ f(x) = \frac{1}{1+e^{-x} } \tag{5}$$<br>
用$w^T x+b$代替$f(x)$中的$x$，就得到了：<br>
$$h(x) = \frac{1}{1+ e^{-(w^T x +b)} } \tag{6}$$<br>
其中$x$是输入，$\theta$是要求的参数。</p>
<h2 id="二项logistic-regression">二项logistic regression</h2>
<p>上面给出的$y=h(x)$其实是一个二项的logistic regression分类函数。式子$(6)$可以进行变形，得到<br>
$$ \log\frac{y}{1-y} = \log\frac{\frac{1}{1+ e^{-(w^T x +b)} } }{1-\frac{1}{1+ e^{-(w^T x +b)} } }= \log\frac{\frac{1}{1+ e^{-(w^T x +b)} } }{\frac{e^{-(w^T x +b)} }{1+ e^{-(w^T x +b)} } } = \log\frac{1}{e^{-(w^T x +b) } } = w^T x +b  \tag{7}$$<br>
这里的$y$是一个函数值，给定一个$x$就会有一个$y$。将$y$看做给定$x$，事件发生的概率，$1-y$是该事件不发生的概率，两者的比值$\frac{y}{1-y}$被称为几率，反映了$x$发生的相对可能性。对几率取对数得到对数几率logit：<br>
$$\log \frac{y}{1-y}$$<br>
可以看出，公式$6$实际上是在近似真实标记的对数几率。所以这个模型叫作对数几率回归。如果将式子$(6)$中的$y$看成类后验概率估计$p(y=1|x)$，公式$(7)$可以写成：<br>
$$\log \frac{p(y=1|x)}{p(y=0|x)} = w^T x+b \tag{8}$$<br>
则有：<br>
$$ p(y=1|x) = \frac{e^{w^T x+ b} }{1+e^{w^T x+ b} } \tag{9} $$<br>
$$ p(y=0|x) = \frac{1}{1+e^{w^T x+ b} } \tag{10} $$<br>
其实就是分子分母同时乘了$e^{w^T x+ b}$。线性模型$w^T x+b$的值域是实数域，然而logistic模型将线性函数$w^T x+b$转换成了如公式$(8),(9)$的概率。当$w^T x+b$的值越接近于$1$，$p(y=1|x)$的概率越接近于$1$。</p>
<h2 id="最大似然估计进行参数估计">最大似然估计进行参数估计</h2>
<p>给定训练集样本$(x_1, y_1), \cdots, (x_N,y_N)$，可以使用最大似然估计求解给定的$w$和$b$：<br>
$$l(w,b) =\prod_{i=1}^m p(y_i|x_i; w,b) \tag{11}$$<br>
即让所有样本属于其真实标记的概率越大越好。设$p(y=1|x) = \pi(x), p(y=0|x) = 1-\pi(x)$，这两个式子可以用一个式子表示$\pi(x)^y (1-\pi(x))^{1-y} $，重写式子$(11)$，得到的似然函数为：<br>
$$l(w,b) =\prod_{i=1}^m p(y_i|x_i; w,b) = \prod_{i=1}^m \left[\pi(x)\right]^{y_i} \left[1-pi(x)\right]^{1-y_i} \tag{12}$$</p>
<p>取对数得到对数似然：<br>
\begin{align*}<br>
L &amp;= \log l(w,b) \\<br>
&amp; = \log \prod_{i=1}^m \left[\pi(x)\right]^{y_i} \left[1-pi(x)\right]^{1-y_i}\\<br>
&amp; = \sum_{i=1}^m \left[y_i\log\pi(x)+(1-y_i)\log(1-\pi(x_i)) \right] \tag{13}\\<br>
&amp; = \sum_{i=1}^m \left[y_i\log\frac{\pi(x)}{1-\pi(x_i)} + \log(1-\pi(x_i)) \right] \tag{14}\\<br>
&amp; = \sum_{i=1}^m \left[y_i (w^T x+b) - \log(1+e^{w^T x+b} ) \right]\\ \tag{15}<br>
\end{align*}<br>
然后求得$w$和$b$即可。</p>
<h2 id="多项logistic-regression">多项logistic regression</h2>
<p>假设离散型随机变量的取值集合是${1, 2,\cdots, K}$，多项logistic regression的公式是：<br>
$$P(Y=k|x) = \frac{e^{w^T x+b} }{ 1+ \sum_{k=1}^{K-1} e^{w^T x+b} }, k = 1, 2, \cdots, K-1 \tag{16}$$<br>
$$P(Y=K|x) = \frac{1}{1+ \sum_{k=1}^{K-1} e^{w^T x+b} } \tag{17}$$</p>
<h2 id="参考文献">参考文献</h2>
<p>1.周志华《西瓜书》<br>
2.李航《统计机器学习》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/10/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/10/">10</a><span class="page-number current">11</span><a class="page-number" href="/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/12/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">326</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  

  

</body>
</html>
