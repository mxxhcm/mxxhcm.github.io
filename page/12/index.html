<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/12/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/12/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/01/05/ESL-chapter-1-Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/05/ESL-chapter-1-Introduction/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">ESL chapter 1 Introduction</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-05 09:46:39" itemprop="dateCreated datePublished" datetime="2019-01-05T09:46:39+08:00">2019-01-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这本书主要介绍的是统计学习。一些典型的学习问题如下：</p>
<ul>
<li>基于一个心脏病患者的饮食，临床检测等等，去预测一个这个因为心脏病住院的人会不会第二次患心脏病。</li>
<li>基于一个公司的运行状况或一些经济数据，去预测未来六个月股票的价格。</li>
<li>从一个手写字母图像中识别出来其中的字母。</li>
<li>从一个糖尿病(diabetic)患者血液的红外吸收频谱去预测他的血糖(glucose)含量。</li>
<li>基于人口统计(demographic)和临床检测，分析前列腺癌的致病因素。 </li>
</ul>
<p>在一个典型的学习场景下，我们通常有一些定量的结果(outcome measurement)，如上面例子中的股票价格或者分类问题中问题的类别，我们希望基于一系列的特征进行预测。<br>接下来给了几个真实的学习问题的示例。下面就简要介绍一下这几个例子。</p>
<h3 id="邮件分类"><a href="#邮件分类" class="headerlink" title="邮件分类"></a>邮件分类</h3><p>给定一封邮件，邮件分类的目标就是根据邮件的特征去判断这封邮件是正常邮件还是垃圾邮件。这是监督学习中的二分类问题，因为该问题有ouputs，且只有两个类别。</p>
<h3 id="前列腺癌-prostate-cancer"><a href="#前列腺癌-prostate-cancer" class="headerlink" title="前列腺癌(prostate cancer)"></a>前列腺癌(prostate cancer)</h3><p>该问题的目标是给定一系列临床检测，如记录癌症量(log cancer volume)，去预测前列腺特异性抗原(prstate specific antigen)的数量。该问题是监督学习中的回归问题，因为结果(outcome measurement)是定量的(quatitative)。</p>
<h3 id="手写数字识别"><a href="#手写数字识别" class="headerlink" title="手写数字识别"></a>手写数字识别</h3><p>给定一个手写数字的图片，该问题的目标是识别出图片中的数字。</p>
<h3 id="DNA-Expression-Microarrays"><a href="#DNA-Expression-Microarrays" class="headerlink" title="DNA Expression Microarrays"></a>DNA Expression Microarrays</h3><p>这个问题是通过基因数组去学习基因和不同基因样本之间的关系，一些典型的问题是：</p>
<ol>
<li>哪些样本之间是相似的？在不同的基因之间都相似。</li>
<li>哪些基因是相似的？在不同的样本之间都相似。</li>
<li>一些特定的基因对于特定的癌症患者表达是达不是很明显？</li>
</ol>
<p>这个问题可以看成回归问题，或者更有可能是无监督问题。</p>
<h2 id="本书结构"><a href="#本书结构" class="headerlink" title="本书结构"></a>本书结构</h2><p>第一章就是本章。第二章讲监督学习的介绍。第三章和第四章介绍线性回归和分类。第五章介绍仿样(splines)，小波(wavelets)，正则化(regularization)和惩罚(penalization)。第六章介绍核方法(kernel methods)和局部回归(local regression)。第七章将模型估计和选择(model assessment and selection)，涉及到偏置(bias)和方差(variance)，过拟合(overfitting)以及交叉验证(cross-validation)等等。第八章讲模型推理。第十章讲boosting。<br>第九到十三章讲监督学习的一系列结构化方法。十四章介绍非监督学习。十五和十六章分别介绍随机森林(random forests)和集成学习(ensemble learning)。第十七章介绍无向图(undirected graphical models)。第十八章介绍高维问题。<br>第一到四章是基础最好按顺序阅读，第七章也是。其他的可以不按顺序。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/01/05/ESL-chapter-2-Overview-of-supervides-learning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/05/ESL-chapter-2-Overview-of-supervides-learning/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">ESL chapter 2 Overview of supervised learning</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-05 09:30:55" itemprop="dateCreated datePublished" datetime="2019-01-05T09:30:55+08:00">2019-01-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>在机器学习领域，监督学习(supervised learning)的每一个样本都由输入(inputs)和输出(outputs)组成。监督学习的目标就是根据inputs的值去预测outpus的值。<br>在统计学(statistical)中，inputs通常被称为预测器？？(predictors)，或者叫自变量(independent variables)。<br>在模式识别(pattern recognition)领域，inputs通常称为特征(features)，或者叫因变量(dependent variables)</p>
<h2 id="变量类型和一些术语-terminology"><a href="#变量类型和一些术语-terminology" class="headerlink" title="变量类型和一些术语(terminology)"></a>变量类型和一些术语(terminology)</h2><p>不同的问题中，输出也不一样。血糖预测问题中，输出是一个定量的(quantitative)测量。手写数字识别问题中，输出是十个不同的类，是定性的(qualitative)，定性的输出也通常被称为类别(catrgorical)，这里的类别是无序的。通常，预测定量的输出被称为回归问题(regression)，预测定性的输出被称为分类问题。这两个问题很相像，多可以看成函数拟合。第三种输出是有序类别，像小，中，大，没有合适的度量表示，因为中和小之间的差别和中和大之间的差别是不同的。<br>定性分析在代码实现中进行二值化数值表示。即如果只有两类的话，用一个二进制位$0$或者$1$表示，或者$1$和$-1$。当超过两类的时候，通常用虚拟变量(dummy variables)来表示，一个$K$级变量是一个长度为$K$的二进制位，每一个时刻只有一位被置一。<br>一些常用的表示，$X$表示inputs，$Y$表示定量outputs，$G$表示定性outputs。大写字母表示通用的表示，观测值用小写字母表示，inputs $X$的第$i$个观测值用$x_i$表示，其中$x_i$是一个标量或者向量。矩阵用粗体的大写字母表示，如具有$N$个$p$维向量$x_i, j= 1,\cdots,N$的$N\times p$矩阵$\mathbf{X}$。所有的向量都用的是列向量表示，$\mathbf{A}$的第$i$行是$x_i^T$，第$i$列的转置。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/01/03/奇异值分解-singular-value-decomposition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/03/奇异值分解-singular-value-decomposition/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">奇异值分解 singular value decomposition</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-03 15:19:54" itemprop="dateCreated datePublished" datetime="2019-01-03T15:19:54+08:00">2019-01-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/线性代数/" itemprop="url" rel="index"><span itemprop="name">线性代数</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="特征值分解-eigen-value-decomposition"><a href="#特征值分解-eigen-value-decomposition" class="headerlink" title="特征值分解(eigen value decomposition)"></a>特征值分解(eigen value decomposition)</h2><p>要谈奇异值分解，首先要从特征值分解(eigen value decomposition, EVD)谈起。<br>矩阵的作用有三个：一个是旋转，一个是拉伸，一个是平移，都是线性操作。如果一个$n\times n$方阵$A$对某个向量$x$只产生拉伸变换，而不产生旋转和平移变换，那么这个向量就称为方阵$A$的特征向量(eigenvector)，对应的伸缩比例叫做特征值(eigenvalue)，即满足等式$Ax = \lambda x$。其中$A$是方阵，$x$是方阵$A$的一个特征向量，$\lambda$是方阵$A$对应特征向量$x$的特征值。<br>假设$S$是由方阵$A$的$n$个线性无关的特征向量构成的方阵，$\Lambda$是方阵$A$的$n$个特征值构成的对角矩阵，则$A=S\Lambda S^{-1}$，这个过程叫做对角化过程。<br>证明：<br>因为$Ax_1 = \lambda_1 x_1,\cdots,Ax_n = \lambda_n x_n$,<br>所以<br>\begin{align*}AS &amp;= A\begin{bmatrix}x_1&amp; \cdots&amp;x_n\end{bmatrix}\\<br>&amp;=\begin{bmatrix} \lambda_1x_1&amp;\cdots&amp;\lambda x_n\end{bmatrix}\\<br>&amp;= \begin{bmatrix}x_1&amp; \cdots&amp;x_n\end{bmatrix} \begin{bmatrix}\lambda_1&amp;&amp;&amp;\\&amp;\lambda_2&amp;&amp;\\&amp;&amp;\cdots&amp;\\&amp;&amp;&amp;\lambda_n\end{bmatrix}\\<br>&amp;= S\Lambda<br>\end{align*}<br>所以$AS=S\Lambda, A=S\Lambda S^{-1}, S^{-1}AS=\Lambda$。<br>若方阵$A$为对称矩阵，矩阵$A$的特征向量是正交的，将其单位化为$Q$，则$A=Q\Lambda Q^T$，这个过程就叫做特征值分解。</p>
<h2 id="奇异值分解-singular-value-decomposition"><a href="#奇异值分解-singular-value-decomposition" class="headerlink" title="奇异值分解(singular value decomposition)"></a>奇异值分解(singular value decomposition)</h2><p>特征值分解是一个非常好的分解，因为它能把一个方阵分解称两个非常好的矩阵，一个是正交阵，一个是对角阵，这些矩阵都便于进行各种计算，但是它对于原始矩阵的要求太严格了，必须要求矩阵是对称正定矩阵，这是一个很苛刻的条件。所以就产生了奇异值分解，奇异值分解可以看作特征值分解在$m\times n$维矩阵上的推广。对于对称正定矩阵来说，有特征值，对于其他一般矩阵，有奇异值。</p>
<p>奇异值分解可以看作将一组正交基映射到另一组正交基的变换。普通矩阵$A$不是对称正定矩阵，但是$AA^T$和$A^TA$一定是对称矩阵，且至少是半正定的。从对$A^TA$进行特征值分解开始，$A^TA=V\Sigma_1V^T$，$V$是一组正交的单位化特征向量$\{v_1,\cdots,v_n\}$，则$Av_1,\cdots,Av_n$也是正交的。<br>证明：<br>\begin{align*}Av_1\cdot Av_2 &amp;=(Av_1)^TAv_2\\<br>&amp;=v_1^TA^TAv_2\\<br>&amp;=v_1^T \lambda v_2\\<br>&amp;=\lambda v_1^T v_2\\<br>&amp;=0<br>\end{align*}<br>所以$Av_1,Av_2$是正交的，同理可得$Av_1,\cdots,Av_n$都是正交的。<br>而：<br>\begin{align*}<br>Av_i\cdot Av_i &amp;= v_i^TA^TAv_i\\<br>&amp;=v_i \lambda v_i\\<br>&amp;=\lambda v_i^2\\<br>&amp;=\lambda<br>\end{align*}<br>将$Av_i$单位化为$u_i$，得$u_i = \frac{Av_i}{|Av_i|} = \frac{Av_i}{\sqrt{\lambda_i}}$，所以$Av_i = \sqrt{\lambda_i}u_i$。<br>将向量组$\{v_1,\cdots,v_r\}$扩充到$R^n$中的标准正交基$\{v_1,\cdots,v_n\}$，将向量组$\{u_1,\cdots,u_r\}$扩充到$R^n$中的标准正交基$\{u_1,\cdots,u_n\}$，则$AV = U\Sigma$，$A=U\sigma V^T$。</p>
<p>事实上，奇异值分解可以看作将行空间的一组正交基加上零空间的一组基映射到列空间的一组正交基加上左零空间的一组基的变换。对一矩阵$A,A\in R^{m\times n}$，若$r(A)=r$，取行空间的一组特殊正交基$\{v_1,\cdots,v_r\}$，当矩阵$A$作用到这组基上，会得到另一组正交基$\{u_1,\cdots,u_r\}$，即$Av_i = \sigma_iu_i$。<br>矩阵表示是：<br>\begin{align*}<br>AV &amp;= A\begin{bmatrix}v_1&amp;\cdots&amp;v_r\end{bmatrix}\\<br>&amp;= \begin{bmatrix}\sigma_1u_1 &amp; \cdots &amp; \sigma_ru_r\end{bmatrix}\\<br>&amp;= \begin{bmatrix}u_1&amp;u_2&amp;\cdots&amp;u_r\end{bmatrix}\begin{bmatrix}\sigma_1&amp;&amp;&amp;\\&amp;\sigma_2&amp;&amp;\\&amp;&amp;\cdots&amp;\\&amp;&amp;&amp;\sigma_n\end{bmatrix}\\<br>&amp;=U\Sigma<br>\end{align*}<br>其中$A\in R^{m\times n}, V\in R^{n\times r},U\in R^{m\times r}, \Sigma \in R^{r\times n}$。<br>当有零空间的时候，行空间的一组基是$r$维，加上零空间的$n-r$维，构成$R^n$空间中的一组标准正交基。列空间的一组基也是$r$维的，加上左零空间的$m-r$维，构成$R^m$空间的一组标准正交基。零空间中的向量在对角矩阵$\Sigma$中体现为$0$，<br>则$A=U\Sigma V^{-1}$，$V$是正交的，所以$A=U\Sigma V^T$，其中$V\in R^{n\times n}, U\in R^{m\times m}, \Sigma \in R^{m\times n}$。</p>
<p>$A=U\Sigma V^T$<br>$A^T = V\Sigma^TU^T$<br>$AA^T = U\Sigma V^TV\Sigma^TU^T$<br>$A^TA = V\Sigma^TU^TU\Sigma V^T$<br>对$AA^T$和$A^TA$作特征值分解，则$AA^T = U\Sigma_1U^T$,$A^TA=V\Sigma_2V^T$，所以对$AA^T$作特征值分解求出来的$U$和对$A^TA$作特征值分解求出来的$V$就是对$A$作奇异值分解求出来的$U$和$V$，$AA^T$和$A^TA$作特征值分解求出来的$\Sigma$的非零值是相等的，都是对$A$作奇异值分解的$\Sigma$的平方。</p>
<h3 id="A-TA-和-AA-T-的非零特征值是相等的"><a href="#A-TA-和-AA-T-的非零特征值是相等的" class="headerlink" title="$A^TA$和$AA^T$的非零特征值是相等的"></a>$A^TA$和$AA^T$的非零特征值是相等的</h3><p>证明：对于任意的$m\times n$矩阵$A$，$A^TA$和$AA^T$的非零特征值相同的。 设$A^TA$的特征值为$\lambda_i$，对应的特征向量为$v_i$，即$A^TAv_i = \lambda_i v_i$。<br>则$AA^T Av_i = A\lambda_iv_i = \lambda_i Av_i$。<br>所以$AA^T$的特征值为$\lambda_i$，对应的特征向量为$Av_i$。<br>因此$A^TA$和$AA^T$的非零特征值相等。</p>
<h3 id="几何意义"><a href="#几何意义" class="headerlink" title="几何意义"></a>几何意义</h3><p>对于任意一个矩阵，找到其行空间(加上零空间)的一组正交向量，使得该矩阵作用在该向量序列上得到的新的向量序列保持两两正交。奇异值的几何意义就是这组变化后的新的向量序列的长度。</p>
<h3 id="物理意义"><a href="#物理意义" class="headerlink" title="物理意义"></a>物理意义</h3><p>奇异值往往对应着矩阵隐含的重要信息，且重要性和奇异值大小正相关。每个矩阵都可以表示为一系列秩为$1$的“小矩阵”的和，而奇异值则衡量了这些秩一矩阵对$A$的权重。<br>奇异值分解的物理意义可以通过图像压缩表现出来。给定一张$m\times n$像素的照片$A$，用奇异值分解将矩阵分解为若干个秩一矩阵之和，即：<br>\begin{align*}<br>A&amp;=\sigma_1 u_1v_1^T +\sigma_2 u_2v_2^T +\cdots+\sigma_r u_rv_r^T\\<br>&amp;= \begin{bmatrix}u_1&amp;u_2&amp;\cdots&amp;u_r\end{bmatrix}\begin{bmatrix}\sigma_1&amp;&amp;&amp;\\&amp;\sigma_2&amp;&amp;\\&amp;&amp;\cdots&amp;\\&amp;&amp;&amp;\sigma_n\end{bmatrix}\begin{bmatrix}v_1^T\\v_2^T\\ \vdots\\v_r^T\end{bmatrix}\\<br>&amp;=U\Sigma V^T<br>\end{align*}</p>
<p>这个也叫部分奇异值分解。其中$V\in R^{r\times n}, U\in R^{m\times r}, \Sigma \in R^{r\times r}$。因为不含有零空间和左零空间的基，如果加上零空间的$n-r$维和左零空间的$m-r$维，就是奇异值分解。<br>较大的奇异值保存了图片的主要信息，特别小的奇异值有时可能是噪声，或者对于图片的整体信息不是特别重要。做图像压缩的时候，可以只取一部分较大的奇异值，比如取前八个奇异值作为压缩后的图片：<br>$A = \sigma_1 u_1v_1^T +\sigma_2 u_2v_2^T + \cdots + \sigma_8 u_8v_8^T$。<br>现实中常用的做法有两个：</p>
<ol>
<li>保留矩阵中$90%$的信息：将奇异值平方和累加到总值的%90%为止。</li>
<li>当矩阵有上万个奇异值的时候，取前面的$2000$或者$3000$个奇异值。。</li>
</ol>
<h2 id="参考文献-references"><a href="#参考文献-references" class="headerlink" title="参考文献(references)"></a>参考文献(references)</h2><p>1.Gilbert Strang, MIT Open course：Linear Algebra<br>2.<a href="https://www.cnblogs.com/pinard/p/6251584.html" target="_blank" rel="noopener">https://www.cnblogs.com/pinard/p/6251584.html</a><br>3.<a href="http://www.ams.org/publicoutreach/feature-column/fcarc-svd" target="_blank" rel="noopener">http://www.ams.org/publicoutreach/feature-column/fcarc-svd</a><br>4.<a href="https://www.zhihu.com/question/22237507/answer/53804902" target="_blank" rel="noopener">https://www.zhihu.com/question/22237507/answer/53804902</a><br>5.<a href="http://charleshm.github.io/2016/03/Singularly-Valuable-Decomposition/" target="_blank" rel="noopener">http://charleshm.github.io/2016/03/Singularly-Valuable-Decomposition/</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/01/02/主成分分析-Principal-Component-Analysis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/01/02/主成分分析-Principal-Component-Analysis/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">主成分分析(Principal Component Analysis)</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-01-02 20:51:19" itemprop="dateCreated datePublished" datetime="2019-01-02T20:51:19+08:00">2019-01-02</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="降维"><a href="#降维" class="headerlink" title="降维"></a>降维</h2><h3 id="降维的目标"><a href="#降维的目标" class="headerlink" title="降维的目标"></a>降维的目标</h3><p>降维可以看做将$p$维的数据映射到$m$维，其中$p\gt m$。</p>
<h3 id="降维的目的"><a href="#降维的目的" class="headerlink" title="降维的目的"></a>降维的目的</h3><ol>
<li>维度灾难(curse of dimensionity)</li>
<li>随着维度增加，精确度和效率的退化。</li>
<li>可视化数据</li>
<li>数据压缩</li>
<li>去噪声<br>…</li>
</ol>
<h3 id="降维的方法"><a href="#降维的方法" class="headerlink" title="降维的方法"></a>降维的方法</h3><h4 id="无监督的降维"><a href="#无监督的降维" class="headerlink" title="无监督的降维"></a>无监督的降维</h4><ol>
<li>线性的:PCA</li>
<li>非线性的: GPCA, Kernel PCA, ISOMAP, LLE</li>
</ol>
<h4 id="有监督的降维"><a href="#有监督的降维" class="headerlink" title="有监督的降维"></a>有监督的降维</h4><ol>
<li>线性的: LDA</li>
<li>非线性的: Kernel LDA</li>
</ol>
<h2 id="主成分分析-PCA"><a href="#主成分分析-PCA" class="headerlink" title="主成分分析(PCA)"></a>主成分分析(PCA)</h2><p>主成分分析(principal component analysis,PCA)是一个降维工具。PCA使用正交变换(orthogonal transformation)将可能相关的变量的一系列观测值(observation)转换成一系列不相关的变量，这些转换后不相关的变量叫做主成分(principal component)。第一个主成分有着最大的方差，后来的主成分必须和前面的主成分正交，然后最大化方差。或者PCA也可以看成根据数据拟合一个$m$维的椭球体(ellipsoid)，椭球体的每一个轴代表着一个主成分。<br>上课的时候，老师给出了五种角度来看待PCA，分别是信息保存，投影，拟合，嵌入(embedding)，mainfold learning。本文首先从保存信息的角度来给出PCA的推理过程，其他的几种方法就随缘了吧。。。</p>
<h3 id="信息保存-preserve-information"><a href="#信息保存-preserve-information" class="headerlink" title="信息保存(preserve information)"></a>信息保存(preserve information)</h3><h4 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h4><p>从信息保存的角度来看PCA的目标是用尽可能小的空间去存储尽可能多的信息。一般情况下，信息用信息熵$-\int p lnp$来表示，如果这里使用信息熵的话，不知道信息的概率表示，一般不知道概率分布的情况下就采用高斯分布，带入高斯分布之后得到$\frac{1}{2}log(2\pi e\sigma^2)$，其中$2\pi e$都是常量，只剩下方差。给出一堆数据，直接计算信息熵是行不通的，但是计算方差是可行的，而方差和信息熵是有联系的，所以可以考虑用方差来表示信息。考虑一下降维前的$p$维数据$x$和降维后的$m$维数据$z$方差之间的关系，$var(z)?var(x)$，这里$z$和$x$的方差维度是不同的，所以不能相等，这里我们的目标就是最大化$z$的方差。方差能解释变化，方差越大，数据的变化就越大，越能包含信息。PCA的目标就是让降维后的数据方差最大。</p>
<h4 id="线性PCA过程"><a href="#线性PCA过程" class="headerlink" title="线性PCA过程"></a>线性PCA过程</h4><h5 id="目标函数"><a href="#目标函数" class="headerlink" title="目标函数"></a>目标函数</h5><p>给定$n$个观测数据$x_1,x_2,\cdots,x_n \in R^p$，形成一个观测矩阵$X,X\in R^{p\times n}$，我们的目标是将这样一组$p$维的数据转换成$m$维的数据。线性PCA是通过线性变换(matrix)来实现的，也就是我们要求一个$p\times m$的矩阵$V$，将原始的$X$矩阵转换成$Z$矩阵，使得</p>
<script type="math/tex; mode=display">Z_{m\times n}= V_{p\times m}^{T}X_{p\times n},</script><p>其中$V\in R^{p\times m}$, $v_i=\begin{bmatrix}v_{1i}\\v_{2i}\\ \vdots\\v_{pi}\end{bmatrix}$, $V = \begin{bmatrix}v_{11}&amp;v_{12}&amp;\cdots&amp;v_{1m}\\v_{21}&amp;v_{22}&amp;\cdots&amp;v_{2m}\\ \vdots&amp;\vdots&amp;\cdots&amp;\vdots\\v_{p1}&amp;v_{p2}&amp;\cdots&amp;v_{pm}\end{bmatrix}=\begin{bmatrix}v_1&amp;v_2&amp;\cdots&amp;v_m\end{bmatrix}$, $V^T = \begin{bmatrix}v_{11}&amp;v_{21}&amp;\cdots&amp;v_{p1}\\v_{12}&amp;v_{22}&amp;\cdots&amp;v_{p2}\\ \vdots&amp;\vdots&amp;\cdots&amp;\vdots\\v_{1m}&amp;v_{2m}&amp;\cdots&amp;v_{pm}\end{bmatrix}=\begin{bmatrix}v_1^T\\v_2^T\\ \vdots\\v_m^T\end{bmatrix}$。<br>所以就有：<br>\begin{align*}<br>z_1 &amp;= v_1^Tx_j\\<br>&amp;\cdots\\<br>z_k &amp;= v_k^Tx_j\\<br>&amp;\cdots\\<br>z_m &amp;= v_m^Tx_j<br>\end{align*}<br>其中，$z_1,\cdots,z_m$是标量，$v_1^T,\cdots, v_m^T$是$1\times p$的向量，$x_j$是一个$p\times 1$维的观测向量，而我们有$n$个观测向量，所以随机变量$z_k$共有$n$个可能取值：</p>
<script type="math/tex; mode=display">z_{k} = v_k^Tx_i= \sum_{i=1}^{p}v_{ik}x_{ij}, j = 1,2,\cdots,n</script><p>其中$x_i$是观测矩阵$X$的第$i$列，$X\in R^{p\times n}$。</p>
<h5 id="协方差矩阵"><a href="#协方差矩阵" class="headerlink" title="协方差矩阵"></a>协方差矩阵</h5><p>离散型随机变量$X$($X$的取值等可能性)方差的计算公式是：</p>
<script type="math/tex; mode=display">var(X) = E[(X-\mu)^2] = \frac{1}{n}\sum_{i=1}^n(x_i-\mu)^2,</script><p>其中$\mu$是X的平均数，即$\mu = \frac{1}{n}\sum_{i=1}^nx_i$。</p>
<p>让$z_k$的方差最大即最大化：<br>\begin{align*}<br>var(z_1) &amp;=E(z_1,\bar{z_1})^2\\<br>&amp;=\frac{1}{n}\sum_{i=1}^n(v_1^Tx_i - v_1^T\bar{x_i})^2\\<br>&amp;=\frac{1}{n}\sum_{i=1}^n(v_1^Tx_i - v_1^T\bar{x_i})(v_1^Tx_i - v_1^T\bar{x_i})^T\\<br>&amp;=\frac{1}{n}\sum_{i=1}^nv_1^T(x_i - \bar{x_i})(x_i - \bar{x_i})^Tv_1\\<br>\end{align*}<br>其中$x_i=\begin{bmatrix}x_{1i}\\x_{2i}\\ \vdots\\x_{pi}\end{bmatrix}$,$\bar{x_i}=\begin{bmatrix}\bar{x_{1i}}\\\bar{x_{2i}}\\ \vdots\\\bar{x_{pi}}\end{bmatrix}$,$x_i$是$p$维的，$x_i^p$也是$p$维的，$(x_i-\bar{x_i})$是$p\times 1$维的，$(x_i -\bar{x_i})^T$是$1\times p$维的。<br>令$S=\frac{1}{n}\sum_{i=1}^n(x_i -\bar{x_i})(x_i-\bar{x_i})^T$，$S$是一个$p\times p$的对称矩阵，其实$S$是一个协方差矩阵。这个协方差矩阵可以使用矩阵$X$直接求出来，也可以通过对$X$进行奇异值分解求出来。<br>如果使用奇异值分解的话，首先对矩阵$X$进行去中心化，即$\bar{x_i}=0$，则：<br>\begin{align*}<br>S &amp;= \frac{1}{n}\sum_{i=1}^Tx_ix_i^T\\<br>&amp;=\frac{1}{n}X_{p\times n}X_{n\times p}^T<br>\end{align*}<br>$X=U\Sigma V^T$<br>$XX^T=U\Sigma V^TV\Sigma U^T = U\Sigma_1^2U^T$<br>$X^TX =V\Sigma U^TU\Sigma V^T = V\Sigma_2^2V^T$<br>$S=\frac{1}{n}XX^T=\frac{1}{n}U\Sigma^2U^T$</p>
<h5 id="拉格朗日乘子法"><a href="#拉格朗日乘子法" class="headerlink" title="拉格朗日乘子法"></a>拉格朗日乘子法</h5><p>将$S$代入得：</p>
<script type="math/tex; mode=display">var(z_1) = v_1^TSv_1,</script><p>接下来的目标是最大化$var(z_1)$，这里要给出一个限制条件，就是$v_1^Tv_1 = 1$，否则的话$v_1$无限大，$var(z_1)$就没有最大值了。<br>使用拉格朗日乘子法，得到目标函数：</p>
<script type="math/tex; mode=display">L=v_1^TSv_1 - \lambda (v_1^Tv_1 -1)</script><p>求偏导，令偏导数等于零得：<br>\begin{align*}<br>\frac{\partial{L}}{\partial{v_1}}&amp;=2Sv_1 - 2\lambda v_1\\<br>&amp;=2(S-\lambda) v_1\\<br>&amp;=0<br>\end{align*}<br>即$Sv_1 = \lambda v_1$，所以$v_1$是矩阵$S$的一个特征向量(eigenvector)。所以：</p>
<script type="math/tex; mode=display">var(z_1) = v_1^TSv_1 = v_1^T\lambda v_1 = \lambda v_1^Tv_1 = \lambda,</script><p>第一个主成分$v_1$对应矩阵$S$的最大特征值。</p>
<h5 id="其他主成分"><a href="#其他主成分" class="headerlink" title="其他主成分"></a>其他主成分</h5><p>对于$z_2$,同理可得：<br>$var(z_2) = v_2^TSv_2$，<br>但是这里要加一些限制条件$v_2^Tv_2=1$，除此以外，第2个主成分还有和之前的主成分不相关，即$cov[z_1,z_2]=0$,或者说是$v_1^Tv_2=0$，证明如下。<br>\begin{align*}<br>cov[z_1,z_2] &amp;=E[(z_1-\bar{z_1})(z_2-\bar{z_2})]\\<br>&amp;=\frac{1}{n}(v_1^Tx_i - v_1^T\bar{x_i})(v_2^Tx_i-v_2^T\bar{x_i})\\<br>&amp;=\frac{1}{n}v_1^T(x_i-\bar{x_i})(x_i-\bar{x_i})v_2\\<br>&amp;=\frac{1}{n}v_1^TSV_2\\<br>&amp;=\frac{1}{n}\lambda v_1^Tv_2\\<br>&amp;=0<br>\end{align*}<br>维基百科上是通过将数据减去第一个主成分之后再最大化方差，这两种理解方法都行。<br>所以拉格朗日目标函数就成了：</p>
<script type="math/tex; mode=display">L=v_1^TSv_1 - \lambda (v_1^Tv_1 -1) -\beta v_2^Tv_1</script><p>求导，令导数等于零得：</p>
<script type="math/tex; mode=display">\frac{\partial{L}}{\partial{v_1}}=2Sv_2 - 2\lambda v_2 - \beta v_1 = 0</script><p>而$v_1$和$v_2$不相关，所以$\beta=0$，所以$Sv_2 = \lambda v_2$，即$v_2$也是矩阵$S$的特征向量，但是最大的特征值对应的特征向量已经被$v_1$用了，所以$v_2$是第二大的特征值对应的特征向量。<br>同理可得第$k$个主成分是$S$的第$k$大特征值对应的特征向量。</p>
<p>但是这种理解方法没有办法推广到非线性PCA。接下来的集中理解方式可以由线性PCA开始，并且可以推广到非线性PCA。</p>
<h3 id="函数拟合"><a href="#函数拟合" class="headerlink" title="函数拟合"></a>函数拟合</h3><h4 id="线性PCA过程-1"><a href="#线性PCA过程-1" class="headerlink" title="线性PCA过程"></a>线性PCA过程</h4><h4 id="非线性PCA过程"><a href="#非线性PCA过程" class="headerlink" title="非线性PCA过程"></a>非线性PCA过程</h4><h5 id="广义主成分分析-Generalized-PCA-GPCA"><a href="#广义主成分分析-Generalized-PCA-GPCA" class="headerlink" title="广义主成分分析(Generalized PCA,GPCA)"></a>广义主成分分析(Generalized PCA,GPCA)</h5><p>刚才讲的PCA是线性PCA，是拟合一个超平面(hyperplane)的过程，但是如果数据不是线性的，比如说是一个曲面$x^2+y^2+z=0$，这样子线性PCA就不适用了，可以稍加变化让其依然是可以用的。比如$x+y+1=0$可以看成$\begin{bmatrix}a&amp;b&amp;c\end{bmatrix}\begin{bmatrix}x\\y\\1\end{bmatrix}$，而$x^2+y^2+z=0$可以看成$\begin{bmatrix}a&amp;b&amp;c\end{bmatrix}\begin{bmatrix}x^2\\y^2\\z\end{bmatrix}$。</p>
<p>如果原始数据是非线性的，我们可以通过多个特征映射函数$\Phi$从原始数据提取非线性特征（也可看成升维，变成高维空间中数据，在高维中可以看成是线性的），然后利用线性PCA对非线性特征进行降维。例如：<br>假设$x=[x_1,x_2,x_3]^T \in R^3$，按照转换函数$v(x) = [x_1^2,x_1x_2,x_1x_3,x_2^2,x_2x_3,x_3^2$将其转换成$R^6$中的特征，接下来使用线性PCA对这些非线性特征进行降维。</p>
<p>给定一个函数$\Phi$将$p$维数据映射到特征空间$F$中，即$\Phi:R^p\rightarrow F,\mathbf{x}\rightarrow X$。我们可以通过计算协方差矩阵$C_F = \frac{\Phi\Phi^T}{n}$,即$C_F = \frac{1}{n}\sum_{i=1}^{n}\phi(x_i)\phi(x_i)^T$，然后对协方差矩阵$C_F$进行特征值分解$C_Fx=\lambda x$就可以求解，这里我们假设空间$F$中的数据均值为$0$，即$E[\Phi(x)] = 0$。</p>
<h3 id="嵌入-embedding-，保距离"><a href="#嵌入-embedding-，保距离" class="headerlink" title="嵌入(embedding)，保距离"></a>嵌入(embedding)，保距离</h3><h4 id="核函数技巧-Kernel-trick"><a href="#核函数技巧-Kernel-trick" class="headerlink" title="核函数技巧(Kernel trick)"></a>核函数技巧(Kernel trick)</h4><p>在GPCA中，如果不知道$\Phi$的话，或者$\Phi$将数据映射到了无限维空间中，就没有办法求解了。这里就给出了一个假设，假设低维空间中$x_i,x_j$的点积(dot product)可以通过一个函数计算，将$x_i,x_j$的点积记为$K_{ij}$，则：</p>
<script type="math/tex; mode=display">K_{ij} = \lt \phi(x_i),\phi(x_j) \gt = k(x_i,x_j)</script><p>其中$k()$是一个函数，比如可以取高斯函数，$k(x,y) = e^{\frac{(\Vert x-y\Vert)^2}{2\sigma^2}}$，我们叫它核函数(kernel function)。<br>这样即使我们不知道$\Phi$，也可以计算点积，直接使用核函数计算。</p>
<h4 id="dot-PCA"><a href="#dot-PCA" class="headerlink" title="dot PCA"></a>dot PCA</h4><p>给定原始数据$X_D = [x_1,\cdots,x_n],x_i\in R^p$，假定$\hat{x}=0$，那么$X_D$的协方差矩阵：<br>\begin{align*}<br>S&amp;= \frac{\sum_{i=1}^n(x_i-\bar{x})(x_i-\bar{x})^T}{n}\\<br>&amp;= \frac{\sum_{i=1}^n(x_i-0)(x_i-0)^T}{n}\\<br>&amp;= \frac{\sum_{i=1}^n(x_i)(x_i)^T}{n}\\<br>&amp;= \frac{\begin{bmatrix}x_1&amp;\cdots&amp;x_n\end{bmatrix}\begin{bmatrix}x_1\\\vdots\\x_n\end{bmatrix}}{n}\\<br>&amp;= \frac{X_DX_D^T}{n}\\<br>&amp;= Cov(X_D, X_D)<br>\end{align*}<br>即$S=\frac{X_DX_D^T}{n}$，而对$X_D$做奇异值分解，有$X_D = V\Sigma U^T$，所以$S = \frac{V\Sigma^2 V^T}{n}$，其中$U$是$S$的特征值矩阵，则：$Z’ = V^T X’$，其中$V\in R^{p\times m}$，$X’$是新的样本数据。</p>
<p>这里我们推导一下点积和PCA的关系，即假设我们有$K = Dot(X_D,X_D) = X_D^TX_D$，则$K=U^T\sigma^2U$，而我们根据奇异值分解$X_D = V\Sigma U^T$可以得到$U$和$V$的关系，即$V=X_DU\Sigma^{-1}$，对$K$进行特征值分解，可以求得$U$和$\Sigma$，所以来了一个新的样本$X’$，</p>
<script type="math/tex; mode=display">Z' = V^TX' = D^{-1}U^TX_D^TX' = D^{-1}U^T\lt X_D,X' \gt.</script><p>事实上，这里$X’$是已知的，可以直接计算协方差，但是这里是为了给Kernel PCA做引子，所以，推导的过程中是没有用到$X$的，只用到了$X$的点积，在测试的时候会用到$X’$。</p>
<h5 id="Kernel-PCA"><a href="#Kernel-PCA" class="headerlink" title="Kernel PCA"></a>Kernel PCA</h5><p>Kernel PCA就是将Kernel trick应用到了dot PCA中，由Kernel trick得$K = \Phi^T\Phi$，$K=U\Sigma^2U^T$，则</p>
<script type="math/tex; mode=display">V = \Phi U\Sigma^{-1} = \Phi U diag(1/sqrt(\lambda_1),1/sqrt(\lambda_2),\cdots)</script><p>但是我们求不出来$V$，因为$\Phi$不知道，但是可以让$V$中的$\Phi$和样本$X’$中的$\Phi$在一起，就可以计算了，即</p>
<script type="math/tex; mode=display">Z' = V^T\phi(X') = \Sigma^{-1}U\Phi\phi(X') = \Sigma^{-1}UK(X,X')</script><h3 id="流形学习-manifold"><a href="#流形学习-manifold" class="headerlink" title="流形学习(manifold)"></a>流形学习(manifold)</h3><h4 id="线性"><a href="#线性" class="headerlink" title="线性"></a>线性</h4><h5 id="PCA"><a href="#PCA" class="headerlink" title="PCA"></a>PCA</h5><h5 id="MDS"><a href="#MDS" class="headerlink" title="MDS"></a>MDS</h5><h4 id="非线性"><a href="#非线性" class="headerlink" title="非线性"></a>非线性</h4><h5 id="LLE"><a href="#LLE" class="headerlink" title="LLE"></a>LLE</h5><h5 id="ISOMAP"><a href="#ISOMAP" class="headerlink" title="ISOMAP"></a>ISOMAP</h5><h2 id="线性判断分析-Fisher-linear-discrimiant-analysis-LDA"><a href="#线性判断分析-Fisher-linear-discrimiant-analysis-LDA" class="headerlink" title="线性判断分析(Fisher linear discrimiant analysis,LDA)"></a>线性判断分析(Fisher linear discrimiant analysis,LDA)</h2><h3 id="线性LDA"><a href="#线性LDA" class="headerlink" title="线性LDA"></a>线性LDA</h3><h4 id="两类"><a href="#两类" class="headerlink" title="两类"></a>两类</h4><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h4 id="C类-C-gt-2"><a href="#C类-C-gt-2" class="headerlink" title="C类(C$\gt 2$)"></a>C类(C$\gt 2$)</h4><p>两维的问题是通过将原始数据投影到一维空间进行分类，而$C$维的问题则是将原始数据投影到$C-1$空间进行分类，通过一个投影矩阵$W=\begin{bmatrix}w_1&amp;\cdots&amp;w_{C-1}\end{bmatrix}$将$C$维的$x$投影到$C-1$维，得到$y=\begin{bmatrix}y_1&amp;\cdots&amp;y_{C-1}\end{bmatrix}$，即$y_i = w_i^Tx\Rightarrow y = W^Tx$。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><h3 id="不足"><a href="#不足" class="headerlink" title="不足"></a>不足</h3><ul>
<li>最多投影到$C-1$维特征空间。</li>
<li>LDA是参数化的方法，它假设数据服从单高斯分布，并且所有类的协方差都是等价的。对于多个高斯分布，线性的LDA是无法分开的。</li>
<li>当数据之间的差异主要通过方差而不是均值体现的话，LDA就会失败(fail)。如下图<br><img src="/2019/01/02/主成分分析-Principal-Component-Analysis/" alt="figure"></li>
</ul>
<h3 id="Kernel-LDA"><a href="#Kernel-LDA" class="headerlink" title="Kernel LDA"></a>Kernel LDA</h3><h2 id="PCA和LDA区别和联系"><a href="#PCA和LDA区别和联系" class="headerlink" title="PCA和LDA区别和联系"></a>PCA和LDA区别和联系</h2><p>PCA是一个无监督的降维方法，通过最大化降维后数据的方差实现；LDA是一个有监督的降维方法，通过最大化类可分性实现(class discrimnatory)。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="https://en.wikipedia.org/wiki/Principal_component_analysis" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Principal_component_analysis</a><br>2.<a href="https://en.wikipedia.org/wiki/Variance" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Variance</a><br>3.<a href="https://sebastianraschka.com/faq/docs/lda-vs-pca.html" target="_blank" rel="noopener">https://sebastianraschka.com/faq/docs/lda-vs-pca.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2018/12/28/内积空间、赋范空间和希尔伯特空间/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/28/内积空间、赋范空间和希尔伯特空间/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">内积空间、赋范空间和希尔伯特空间</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-28 15:15:37" itemprop="dateCreated datePublished" datetime="2018-12-28T15:15:37+08:00">2018-12-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/线性代数/" itemprop="url" rel="index"><span itemprop="name">线性代数</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>数学的空间是研究工作的对象和遵循的规则。<br>线性空间：加法和数乘<br>拓扑空间：距离，范数和内积。</p>
<h2 id="距离"><a href="#距离" class="headerlink" title="距离"></a>距离</h2><p>距离是用来衡量两个点有多“近”的。</p>
<h3 id="距离定义"><a href="#距离定义" class="headerlink" title="距离定义"></a>距离定义</h3><p>$X$是一非空集合，任给一对这一集合中的元素$x,y$，都会给定一个实数$d(x,y)$与它们对应，并且这个实数满足以下条件：</p>
<ol>
<li>$d(x,y)\ge 0, d(x,y) = 0 \Leftrightarrow x=y$；</li>
<li>$d(x,y) = d(y,x)$；</li>
<li>$d(x,y) \le d(x,z) + d(z,y)$。</li>
</ol>
<p>则$d(x,y)$为这两点$x$和$y$之间的距离。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="向量的距离"><a href="#向量的距离" class="headerlink" title="向量的距离"></a>向量的距离</h4><p>$d_1(x,y) = \sqrt{(x_1-y_1)^2+\cdots,(x_n-y_n)^n}$<br>$d_2(x,y) = max\{|x_1-y_1|,\cdots,|x_n,y_n|\}$<br>$d_3(x,y) = |x_1-y_1|+\cdots+|x_n,y_n|$</p>
<h4 id="曲线的距离"><a href="#曲线的距离" class="headerlink" title="曲线的距离"></a>曲线的距离</h4><p>$d_1(f,g) = \int_a^b(f(x)-g(x))^2 dx$<br>$d_2(f,g) = max_{a\le x\le b}|f(x)-f(y)|$<br>$d_3(f,g) = \int_a^b(f(x)-g(x))^k dx$</p>
<h3 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h3><p>向量的加法和数乘</p>
<h3 id="线性空间的八个性质"><a href="#线性空间的八个性质" class="headerlink" title="线性空间的八个性质"></a>线性空间的八个性质</h3><p>加法的交换律和结合律，零元，负元，数乘的交换律，单位一，数乘与加法的结合律。</p>
<h2 id="范数（向量到零点的距离）定义"><a href="#范数（向量到零点的距离）定义" class="headerlink" title="范数（向量到零点的距离）定义"></a>范数（向量到零点的距离）定义</h2><p>如果$\Vert x\Vert $是$R^n$上的范数（$x$是向量），那么它需要满足以下条件：</p>
<ol>
<li>$\Vert x\Vert \ge 0, \forall x\in R, \Vert x\Vert  = 0  \Leftrightarrow x = 0$；</li>
<li>$\Vert \alpha x\Vert  = |\alpha|\Vert x\Vert, \forall \alpha \in R, x\in R^n$</li>
<li>$\Vert x+y\Vert  \le \Vert x\Vert  + \Vert y\Vert , \forall x,y\in R$</li>
</ol>
<p>可以看成是点到零点距离多了条件2。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>$\Vert x\Vert_2  = \sqrt{x_1^2+\cdots,x_n^n}$<br>$\Vert x\Vert_{\infty}  = max\{|x_1|,\cdots,|x_n|\}$<br>$\Vert x\Vert_1  = |x_1|+\cdots+|x_n|$</p>
<h3 id="距离和范数的关系"><a href="#距离和范数的关系" class="headerlink" title="距离和范数的关系"></a>距离和范数的关系</h3><p>由范数可以定义距离。$d(x,y) = \Vert  x-y\Vert$。<br>但是由距离不一定可以定义范数。如$\Vert x\Vert  = d(0,x)$,但是$\Vert \alpha x\Vert  = d(0, \alpha x) \ne |\alpha|\Vert x\Vert $。</p>
<h3 id="赋范空间和度量空间"><a href="#赋范空间和度量空间" class="headerlink" title="赋范空间和度量空间"></a>赋范空间和度量空间</h3><p>赋予范数的集合称为赋范空间。<br>距离的集合称为度量空间。</p>
<h3 id="线性赋范空间和线性度量空间"><a href="#线性赋范空间和线性度量空间" class="headerlink" title="线性赋范空间和线性度量空间"></a>线性赋范空间和线性度量空间</h3><p>赋予范数加上线性空间称为线性赋范空间。<br>距离加上线性空间称为线性度量空间。</p>
<h2 id="内积"><a href="#内积" class="headerlink" title="内积"></a>内积</h2><h3 id="引言-1"><a href="#引言-1" class="headerlink" title="引言"></a>引言</h3><p>赋范空间有向量的模长，即范数。但是范数只有大小，没有夹角，所以就引入了内积。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>给定$(x,y)\in R$,如果它满足：</p>
<ol>
<li>对称性；</li>
<li>对第一变元的线性性；</li>
<li>正定性。</li>
</ol>
<p>那么就称$(x,y)$为内积。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><ol>
<li>$(x,y) = \sum_{n=1}^nx_ny_n$。</li>
<li>$(f,g) = \int_{-\infty}^{\infty}f(x)g(x)dx$。</li>
</ol>
<h3 id="内积和范数的关系"><a href="#内积和范数的关系" class="headerlink" title="内积和范数的关系"></a>内积和范数的关系</h3><ul>
<li>内积可以导出范数 </li>
<li>范数不能导出距离 </li>
</ul>
<h3 id="内积空间"><a href="#内积空间" class="headerlink" title="内积空间"></a>内积空间</h3><p>在线性空间上定义内积，这个空间称为内积空间。<br>常见的欧几里得空间就是一个内积空间，内积空间是一个抽象的空间，而欧几里得空间是一个具象化了的内积空间。<br>希尔伯特引入了无穷维空间并定义了内积，其空间称为内积空间，再加上完备性，称为希尔伯特空间。完备性是取极限之后还在这个空间内。<br>完备的赋范空间称为巴拿赫空间。</p>
<h2 id="拓扑空间"><a href="#拓扑空间" class="headerlink" title="拓扑空间"></a>拓扑空间</h2><p>欧几里得几何学需要定义内积，连续的概念不需要内积，甚至不需要距离。</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>给定一个集合$X$,$\tau$是$X$的一系列子集，如果$\tau$满足以下条件：</p>
<ol>
<li>空集(empty set)和全集X都是$\tau$的元素;</li>
<li>$\tau$中任意元素的并集(union)仍然是$\tau$的元素;</li>
<li>$\tau$中任意有限多个元素的交集(intersection)仍然是$\tau$中的元素。<br>则称$\tau$是$X$上的一个拓扑。</li>
</ol>
<h2 id="距离，范数和内积之间的关系"><a href="#距离，范数和内积之间的关系" class="headerlink" title="距离，范数和内积之间的关系"></a>距离，范数和内积之间的关系</h2><p>距离$\gt$范数$\gt$内积</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2018/12/24/convex-optimization-chapter-2-Convex-sets/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/24/convex-optimization-chapter-2-Convex-sets/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">convex optimization chapter 2 Convex sets</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-24 16:28:45" itemprop="dateCreated datePublished" datetime="2018-12-24T16:28:45+08:00">2018-12-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/凸优化笔记/" itemprop="url" rel="index"><span itemprop="name">凸优化笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="仿射集-affine-sets-和凸集-convex-sets"><a href="#仿射集-affine-sets-和凸集-convex-sets" class="headerlink" title="仿射集(affine sets)和凸集(convex sets)"></a>仿射集(affine sets)和凸集(convex sets)</h2><h3 id="直线-line-和线段-line-segmens"><a href="#直线-line-和线段-line-segmens" class="headerlink" title="直线(line)和线段(line segmens)"></a>直线(line)和线段(line segmens)</h3><p>假设$x_1,x_2 \in R^n$是n维空间中不重合$(x_1 \ne x_2)$的两点，给定：</p>
<script type="math/tex; mode=display">y = \theta x_1 + (1 - \theta)x_2,</script><p>当$\theta\in R$时，$y$是经过点$x_1$和点$x_2$的直线。当$\theta=1$时，$y=x_1$,当$\theta=0$时，$y=x_2$。当$\theta\in[0,1]$时，$y$是$x_1$和$x_2$之间的线段(line segment)。 把$y$改写成如下形式： <script type="math/tex">y = x_2 + \theta(x_1 - x_2)</script>，可以给出另一种解释，$y$是点$x_2$和方向$x_1 - x_2$(从$x_2$到$x_1$的方向)乘上一个缩放因子$\theta$的和。<br>如下图所示，可以将y看成$\theta$的函数。<br><img src="https://ws1.sinaimg.cn/large/006wtfMEly1fyhy7m4llij30mz0alwep.jpg" alt="line_line-segment"></p>
<h3 id="仿射集-affine-sets"><a href="#仿射集-affine-sets" class="headerlink" title="仿射集(affine sets)"></a>仿射集(affine sets)</h3><h4 id="仿射集的定义"><a href="#仿射集的定义" class="headerlink" title="仿射集的定义"></a>仿射集的定义</h4><p>给定一个集合$C\subset R^n$,如果经过$C$中任意两个不同点的直线仍然在$C$中，那么$C$就是一个仿射集。即，对于任意$x_1,x_2\in C$和$\theta\in R$，都有$\theta x_1 + (1 - \theta)x_2 \in C$。换句话说，给定线性组合的系数和为$1$，$C$中任意两点的线性组合仍然在$C$中，我们就称这样的集合是仿射的(affine)。</p>
<h4 id="仿射组合-affine-combination"><a href="#仿射组合-affine-combination" class="headerlink" title="仿射组合(affine combination)"></a>仿射组合(affine combination)</h4><p>我们可以把两个点的线性组合推广到多个点的线性组合，这里称它为仿射组合。<br>仿射组合的定义：给定$\theta_1+\cdots+\theta_k = 1$,则$\theta_1 x_1 + \cdots + \theta_k x_k$是点$x_1,\cdots,x_k$的仿射组合(affine combination)。<br>根据仿射集的定义，一个仿射集(affine set)包含集合中任意两个点的仿射（线性）组合，那么可以推导出仿射集包含集合中任意点（大于等于两个）的仿射组合，即：如果$C$是一个仿射集，$x_1,\cdots,x_k\in C$,且$\theta_1 x_1 + \cdots + \theta_k x_k = 1$,那么点$\theta_1 x_1 + \cdots + \theta_k x_k$仍然属于$C$。</p>
<h4 id="仿射集的子空间-subspce"><a href="#仿射集的子空间-subspce" class="headerlink" title="仿射集的子空间(subspce)"></a>仿射集的子空间(subspce)</h4><p>如果$C$是一个仿射集，$x_0 \in C$,那么集合</p>
<script type="math/tex; mode=display">V = C - x_0 = \{x - x_0\big|x \in C\}</script><p>是一个子空间(subspace),因为$V$是加法封闭和数乘封闭的。<br>证明：<br>假设$v_1, v_2 \in V$，并且$\alpha,\beta \in R$。<br>要证明V是一个子空间，那么只需要证明$\alpha v_1 + \beta v_2 \in V$即可。<br>因为$v_1, v_2 \in V$，则$v_1+x_0, v_2+x_0 \in C$。<br>而$x_0 \in C$，所以有</p>
<script type="math/tex; mode=display">\alpha(v_1+x_0) + \beta(v_2+x_0) + (1 - \alpha - \beta)x_0 \in C</script><p>即：<br>\begin{align*}<br>\alpha v_1 + \beta v_2 + (\alpha + \beta + 1 - \alpha - \beta)x_0 &amp;\in C\\<br>\alpha v_1 + \beta v_2 + x_0 &amp;\in C<br>\end{align*}<br>所以$\alpha v_1 + \beta v_2 \in V$。<br>所以，仿射集$C$可以写成：</p>
<script type="math/tex; mode=display">C = V + x_0 = \{ v + x_0\big| v \in V\},</script><p>即，一个子空间加上一个偏移(offset)。而与仿射集$C$相关的子空间$V$与$x_0$的选择无关，即$x_0$可以为$C$中任意一点。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>线性方程组的解。一个线性方程组的解可以表示为一个仿射集:$C=\{x\big|Ax = b\}$,其中 $A\in R^{m \times n}, b \in R^m$。<br>证明：<br>设$x_1, x_2 \in C$,即$Ax_1 = b, Ax_2 = b$。对于任意$\theta \in R$,有:<br>\begin{align*}<br>A(\theta x_1 + (1-\theta x_2) &amp;= \theta Ax_1 + (1-\theta)Ax_2\\<br>&amp;= \theta b + (1 - \theta) b\\<br>&amp;= b \end{align*}<br>所以线性方程组的解是一个仿射组合：$\theta x_1 + (1 - \theta) x_2$，这个仿射组合在集合$C$中，所以线性方程组的解集$C$是一个仿射集。<br>和该仿射集$C$相关的子空间$V$是$A$的零空间(nullspace)。因为仿射集$C$中的任意点都是方程$Ax = b$的解，而$V = C - x_0 = \{x - x_0\big|x \in C\}$，有$Ax = b, Ax_0 = b$，则$Ax - Ax_0 = A(x - x_0) = b - b = 0$，所以$V$是$A$的零空间。</p>
<h4 id="仿射包-affine-hull"><a href="#仿射包-affine-hull" class="headerlink" title="仿射包(affine hull)"></a>仿射包(affine hull)</h4><p>给定集合$C\subset R^n$，集合中点的仿射组合称为集合$C$的仿射包(affine hull),表示为$aff C$:<br>$aff C = \{\theta_1 x_1 + \cdots + \theta_k x_k\big| x_1,\cdots,x_k \in C, \theta_1 + \cdots + \theta_k = 1\}$<br>集合$C$可以是任意集合。仿射包是包含集合$C$的最小仿射集（一个集合的仿射包只有一个，是不变的）。即如果$S$是任意仿射集，满足$C\subset S$，那么有$aff C \subset S$。或者说仿射包是所有包含集合$C$的仿射集的交集。</p>
<h3 id="仿射纬度-affine-dimension-和相对内部-relative-interior"><a href="#仿射纬度-affine-dimension-和相对内部-relative-interior" class="headerlink" title="仿射纬度(affine dimension)和相对内部(relative interior)"></a>仿射纬度(affine dimension)和相对内部(relative interior)</h3><h4 id="拓扑-topology"><a href="#拓扑-topology" class="headerlink" title="拓扑(topology)"></a>拓扑(topology)</h4><p>拓扑(topology)，开集(open sets),闭集(close sets),内部(interior),边界(boundary),闭包(closure),邻域(neighbood),相对内部(relative interior)<br>同一个集合可以有很多个不同的拓扑。</p>
<h5 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h5><p>给定一个集合$X$,$\tau$是$X$的一系列子集，如果$\tau$满足以下条件：</p>
<ol>
<li>空集(empty set)和全集X都是$\tau$的元素;</li>
<li>$\tau$中任意元素的并集(union)仍然是$\tau$的元素;</li>
<li>$\tau$中任意有限多个元素的交集(intersection)仍然是$\tau$中的元素。</li>
</ol>
<p>则称$\tau$是集合$X$上的一个拓扑。<br>如果$\tau$是$X$上的一个拓扑，那么$(X,\tau)$对称为一个拓扑空间(topological space)。<br>如果$X$的一个子集在$\tau$中，这个子集被称为开集(open set)。<br>如果$X$的一个子集的补集是在$\tau$中，那么这个子集是闭集(closed set)。<br>$X$的子集可能是开集，闭集，或者都是，都不是。<br>空集和全集是开集，也是闭集（定义）。</p>
<h5 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h5><ol>
<li>给定集合$X=\{1,2,3,4\}$, 集合$\tau = \{ \{\},\{1,2,3,4\} \}$就是$X$上的一个拓扑。</li>
<li>给定集合$X=\{1,2,3,4\}$, 集合$\tau = \{ \{\},\{1\}, \{3,4\},\{1,3,4\},\{1,2,3,4\} \}$就是$X$上的另一个拓扑。</li>
<li>给定集合$X=\{1,2,3,4\}$, $X$的幂集(power set)也是$X$上的另一个拓扑。</li>
</ol>
<p><strong>通常如果不说的话，默认是在欧式空间(1维，2维,…,n维欧式空间)的拓扑，即欧式拓扑。以下讲的一些概念是在欧式空间的拓扑（通常拓扑）上的定义和一般拓扑直观上可能不太一样，但实际上意义是相同的。</strong></p>
<h4 id="epsilon-disc-或-epsilon-邻域"><a href="#epsilon-disc-或-epsilon-邻域" class="headerlink" title="$\epsilon-disc$或$\epsilon$邻域"></a>$\epsilon-disc$或$\epsilon$邻域</h4><h5 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h5><p>给定$x\in R^n$以及$\epsilon\gt 0$，集合</p>
<script type="math/tex; mode=display">D(x,\epsilon) = \{y\in R^n\big|d(x,y) \lt \epsilon\}</script><p>称为关于$x$的$\epsilon-disc$或者$\epsilon$邻域(neighbood)或者$\epsilon$球(ball)。即所有离点$x$距离小于$\epsilon$的点$y$的集合。</p>
<h4 id="开集-open-sets"><a href="#开集-open-sets" class="headerlink" title="开集(open sets)"></a>开集(open sets)</h4><h5 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h5><p><strong>给定集合$A\subset R^n$，对于$A$中的所有元素，即$\forall x\in A$，都存在$\epsilon \gt 0$使得$D(x,\epsilon)\subset A$，那么就称该集合是开的。</strong><br>即集合$A$中所有元素的$spsilon$邻域都还在集合$A$中（定理$1$）。<br><strong>注意：必须满足$\epsilon \gt 0$</strong></p>
<h5 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h5><h6 id="定理-1-epsilon-邻域是开集"><a href="#定理-1-epsilon-邻域是开集" class="headerlink" title="定理$1$ $epsilon$邻域是开集"></a>定理$1$ $epsilon$邻域是开集</h6><ul>
<li>在$R^n$中，对于一个$\epsilon \gt 0, x\in R^n$,那么集合$x$的$\epsilon$邻域$D(x,\epsilon)$是开的，给定一个$\epsilon$，能找到一个更小的$epsilon$邻域。</li>
</ul>
<h6 id="定理-2"><a href="#定理-2" class="headerlink" title="定理$2$"></a>定理$2$</h6><ul>
<li>$R^n$中有限个开子集的交集是$R^n$的开子集。</li>
<li>$R^n$中任意个开子集的并集是$R^n$的开子集。</li>
</ul>
<p><strong>注意：任意开集的交可能不是开集，一个点不是开集，但是它是所有包含它的开集的交。</strong></p>
<h5 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h5><p><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/unit_circle.png" alt="unit_circle"></p>
<ol>
<li>$R^2$中的不包含边界的球是开的，如图。</li>
<li>考虑一个$R^1$中的开区间，如$(0,1)$，它是一个开集，但是如果把它放在二维欧式空间中(是x轴上的一个线段)，它不是开的，不满足定义，所以开集是必须针对于某一个给定的集合$X$。 </li>
<li>$R^2$上的包含边界的单位圆$X = \{x\in R^2 \big||x|\le 1\}$不是开的。因为边界上的点$x$不满足$\epsilon \gt 0, D(x,\epsilon) \subset X$。</li>
<li>集合$S=\{(x,y) \in R^2\big|0 \lt x \lt 1\}$是开集。对于每个点$(x,y)\in S$,我们可以画出半径$r = min\{x,1-x\}$的邻域并且其全部含于$S$，所以$S$是开集。</li>
<li>集合$S=\{(x,y) \in R^2\big|0 \lt x \le 1\}$不是开集。因为点$(1,0) \in S$的邻域包含点$(x,0)$,其中$x\gt 1$。</li>
</ol>
<h4 id="内部-interior"><a href="#内部-interior" class="headerlink" title="内部(interior)"></a>内部(interior)</h4><h5 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h5><p><strong>给定集合$A\subset R^n$,点$x \in A$，如果有一个开集$U$使得$x \in U\subset A$,那么该点就称为$A$的一个内点。或者说对于$x\in A$，有一个$\epsilon \gt 0$使得$D(x,\epsilon)\subset A$。$A$的所有内点组成的集合叫做$A$的内部(interior)，记做$int(A)$。</strong><br>集合内部可能是空的，单点的内部就是空的。单位圆的内部是不包含边界的单位圆。事实上$A$的内部是$A$所有开子集的并，由开集的定理得$A$的内部是开的，且$A$的内部是$A$的最大的开集。<br>简单来说，就是集合内所有开集还在这个集合内的点 的并。</p>
<h5 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h5><ol>
<li>给定集合$S=\{(x,y)\in R^2\big| 0 \lt x \le 1\}$，$int(S) = \{(x,y)\big|0 \lt x \lt 1\}$。因为区间$(0,1)$中的点都满足它们的$\epsilon$邻域在$S$中。</li>
<li>$int(A) \cup int(B) \ne int(A\cup B)$。在实数轴上，$A=[0,1],B=[1,2]$，那么$int(A) = (0,1),int(B) = (1,2)$，所以$int(A) \cup int(B) = (0,1)\cup (1,2) = (0,2)\backslash \{1\}$，而$int(A\cup B) = int[0,2] = (0,2)$。</li>
</ol>
<h4 id="闭集-closed-set"><a href="#闭集-closed-set" class="headerlink" title="闭集(closed set)"></a>闭集(closed set)</h4><h5 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h5><p><strong>对于$R^n$中的集合$B$，如果它在$R^n$的补（即集合$R^n \backslash B$）是开集，那么它是闭集。</strong><br>单点是闭集。含有边界的单位圆组成的集合是闭集，因为它的补集不包含边界。一个集合可能既不是开集也不是闭集。例如，在一维欧几里得空间，半开半闭区间（如$(0,1]$）既不是开集也不是闭集。</p>
<h5 id="定理-1"><a href="#定理-1" class="headerlink" title="定理"></a>定理</h5><ol>
<li>$R^n$中有限个闭子集的并是闭集。</li>
<li>$R^n$中任意个闭子集的交是闭集。</li>
</ol>
<p>这个定理是从开集的定理中得出的，在对开集取补变成闭集时候，并与交相互变换即可。</p>
<h5 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h5><ol>
<li>给定集合$S=\{(x,y) \in R^2\big| 0 \lt x \le 1, 0 \lt y \lt 1\}$，$S$不是闭集。因为目标区域的下边界不在S中。</li>
<li>给定集合$S=\{(x,y) \in R^2\big| x^2+y^2\le 1\}$，$S$是闭集，因为它的闭集是$R^2$中的开集。 </li>
<li>$R^n$中任何有限集是闭集。因为单点是闭集，有限集可以看成很多个单点的并，由定理$1$可以得出。 </li>
</ol>
<h4 id="聚点-accumulation-point"><a href="#聚点-accumulation-point" class="headerlink" title="聚点(accumulation point)"></a>聚点(accumulation point)</h4><h5 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h5><p>对于点$x\in R^n$，如果包含$x$的每个开集$U$包含不同于$x$但依然属于集合$A$中的点，那么就称$x$是$A$的一个聚点(accumulation points)，也叫聚类点(cluster points)。<strong>注意这里是包含集合$A$中的点，而不是全部是集合$A$中的点，所以集合的聚点不一定必须在集合中。</strong>如，在一维欧式空间中，单点集合没有聚点，开区间$(0,1)$的聚点是$[0,1]$，$\{0,1\}$不在区间内，但是是聚点。<br>此外，$x$是聚类点等价于：对于每个$\epsilon \gt 0$，$D(x,\epsilon)$包含$A$中的某点$y$且$y\ne x$。</p>
<h5 id="定理-2"><a href="#定理-2" class="headerlink" title="定理"></a>定理</h5><p>当且仅当集合$S$的所有聚点属于$S$时，$S\subset R^n$是闭集。</p>
<h5 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h5><ol>
<li>给定集合$S=\{x\in R\big|x\in [0,1]且x是有理数\}$，$S$的聚点为$[0,1]$中所有点。任何不属于$[0,1]$的点都不是聚点，因为这类点有一个包含它的$\epsilon$邻域与$[0,1]$不相交。</li>
<li>给定集合$S=\{(x,y)\in R^2\big| 0 \le x\le or\ x = 2\}$, 它的聚点是它本身，因为它是闭集。</li>
<li>给定集合$S=\{(x,y)\in R^2\big|y \lt x^2 + 1\}$，S的聚点为集合$\{(x,y)\in R^2\big|y \le x^2 + 1\}$，</li>
</ol>
<h4 id="闭包-closure"><a href="#闭包-closure" class="headerlink" title="闭包(closure)"></a>闭包(closure)</h4><h5 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h5><p>给定集合$A\subset R^n$,集合$A$的闭包$cl(A)$定义成所有包含$A$的闭集的交，所以$cl(A)$是一个闭集。定价的定义是给定集合$A$，包含$A$的最小闭集叫做这个集合$X$的闭包(closure)，用$cl(A)$或者$\{\overline{A}\}$表示。</p>
<h5 id="定理-3"><a href="#定理-3" class="headerlink" title="定理"></a>定理</h5><p>给定$A\subset R^n$，那么$cl(A)$由$A$和$A$的所有聚点组成。</p>
<h5 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h5><ol>
<li>$R$中$S=[0,1)\cup \{2\}$的闭包是$[0,1]$和$\{2\}$,S聚点是$[0,1]$,所以S的闭包是$[0,1]\cup\{2\}$。</li>
<li>对于任意$S\subset R^n$，$R^n \backslash cl(S)$是开集。因为$cl(S)$是闭集，所以它的补集是开集。 </li>
<li>$cl(A\cap B) \ne cl(A)\cap cl(B)$。比如$A=(0,1),B(1,2),cl(A)=[0,1],cl(B)=[1,2]$,$A\cap B = \varnothing$,$cl(A\cap B) = \varnothing$,而$cl(A)\cap cl(B) = \{1\}$。</li>
</ol>
<h4 id="边界-boundary"><a href="#边界-boundary" class="headerlink" title="边界(boundary)"></a>边界(boundary)</h4><h5 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a>定义</h5><p>对于$R^n$中的集合$A$，边界定义为集合：<br>$bd(A) = cl(A)\cap cl(R^n \backslash A)$<br>即集合$A$的补集的闭包和$A$的闭包的交集，所以$bd(A)$是闭集。$bd(A)$是$A$与$R^n \backslash A$之间的边界。</p>
<h5 id="定理-4"><a href="#定理-4" class="headerlink" title="定理"></a>定理</h5><p>给定$A\subset R^n$，当且仅当对于每个$\epsilon \gt 0$，$D(x,\epsilon)$包含$A$与$R^n\backslash A$的点，$x\in bd(A)$。</p>
<h5 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h5><ol>
<li>给定集合$S=\{x\in R\big|x\in [0,1],x是有理数\}$，$bd(S) = [0,1]$。因为对于任意$\epsilon \gt 0, x\in [0,1],D(x,\epsilon) = (x-\epsilon, x+\epsilon)$包含有理数和无理数，即x是有理数和无理数之间的边界。</li>
<li>给定$x\in bd(S)$，$x$不一定是聚点。给定集合$S = \{0\} \subset R$，$bd(S) = \{0\}$，但是单点没有聚点。</li>
<li>给定集合$S=\{(x,y)\in R^2\big| x^2-y^2 \gt 1 \}$，$bd(S)=\{(x,y)\big|x^2 - y^2 = 1\}$。 </li>
</ol>
<h4 id="仿射维度-affine-dimension"><a href="#仿射维度-affine-dimension" class="headerlink" title="仿射维度(affine dimension)"></a>仿射维度(affine dimension)</h4><h5 id="定义-8"><a href="#定义-8" class="headerlink" title="定义"></a>定义</h5><p>给定一个仿射集$C$，仿射维度是它的仿射包的维度。<br>仿射维度和其他维度的定义不总是相同的，具体可以看以下的示例。</p>
<h5 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h5><p>给定一个二维欧几里得空间的单位圆，$\{x\in C\big|x_1^2+x_2^2=1\}$。它的仿射包是整个$R^2$，所以二维平面的单位圆仿射维度是$2$。但是在很多定义中，二维平面的单位圆的维度是$1$。</p>
<h4 id="相对内部-relative-interior"><a href="#相对内部-relative-interior" class="headerlink" title="相对内部(relative interior)"></a>相对内部(relative interior)</h4><p>给定一个集合$C\subset R^n$，它的仿射维度可能小于$n$，这个时候仿射集$aff\ C \ne R^n$。</p>
<h5 id="定义-9"><a href="#定义-9" class="headerlink" title="定义"></a>定义</h5><p>给定集合$C$，相对内部的定义如下：<br>$relint\ C = \{x\in C\big|(B(x,r)\cup aff\ C) \subset C\, \exists \ r \gt 0\}.$<br>就是集合$C$内所有$\epsilon$球在$C$的仿射集内的点的集合。<br>其中$B(x,r)=\{y \big|\Vert y- x\Vert \le r\}$，是以$x$为中心，以$r$为半径的圆。这里的范数可以是任何范数，它们定义的相对内部是相同的。</p>
<h5 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h5><p>给定一个$R^3$空间中$(x_1,x_2)$平面上的正方形，$C=\{x\in R^3\big|-1 \le x_1 \le 1, -1\le x_2 \le 1, x_3 = 0\}$。它的仿射包是$(x_1,x_2)$平面，$aff\ C = \{x\in R^3\big|x_3=0\}$。$C$的内部是空的，但是相对内部是：<br>$relint\ C = \{x \in R^3\big|-1 \le x_1 \le 1, -1\le x_2 \le 1,x_3=0\}$。 </p>
<h4 id="相对边界-relative-boundary"><a href="#相对边界-relative-boundary" class="headerlink" title="相对边界(relative boundary)"></a>相对边界(relative boundary)</h4><h5 id="定义-10"><a href="#定义-10" class="headerlink" title="定义"></a>定义</h5><p>给定集合$C$，相对边界(relative boundary)定义为$cl\ C \backslash relint\ C$，其中$cl\ C$是集合$C$的闭包(closure)。</p>
<h5 id="示例-10"><a href="#示例-10" class="headerlink" title="示例"></a>示例</h5><p>对于上例（相对内部的示例）来说，它的边界(boundary)是它本身。它的相对内部是边框，$\{x\in R^3\big|max\{|x_1|,|x_2|\}=1,x_3=0\}$。</p>
<h3 id="凸集-convex-sets"><a href="#凸集-convex-sets" class="headerlink" title="凸集(convex sets)"></a>凸集(convex sets)</h3><h4 id="凸集定义"><a href="#凸集定义" class="headerlink" title="凸集定义"></a>凸集定义</h4><p>给定一个集合$C$，如果集合$C$中经过任意两点的线段仍然在$C$中，这个集合就是一个凸集。<br>给定$\forall x_1,x_2 \in C, 0 \le \theta \le 1$，那么我们有$\theta x_1 + (1-\theta)x_2 \in C$。<br>每一个仿射集都是凸的，因为它包含经过任意两个不同点的直线，所以肯定就包含过那两个点的线段。</p>
<h4 id="凸组合-convex-combination"><a href="#凸组合-convex-combination" class="headerlink" title="凸组合(convex combination)"></a>凸组合(convex combination)</h4><p>给定$k$个点$x_1,x_2,\cdots,x_k$，如果具有$\theta_1 x_1 + \cdots, \theta_k x_k$形式且满足$\theta_1 + \cdots + \theta_k=1, \theta_i \ge 0,i=1,\cdots,k$,那么就称这是$x_1,\cdots,x_k$的一个凸组合。<br>当且仅当一个集合包含其中所有点的凸组合，这个集合是一个凸集。点的一个凸组合可以看成点的混合或者加权，$\theta_i$是第$i$个点$x_i$的权重。<br>凸组合可以推广到无限维求和，积分，概率分布等等。假设$\theta_1,\theta_2,\cdots$满足：</p>
<script type="math/tex; mode=display">\theta_i \le 0, i = 1,2,\cdots, \sum_{i=1}^{\infty}\theta_i = 1</script><p>并且$x_1,x_2,\cdots \in C$，$C\subset R^n$是凸的，如果(series)$\sum_{i=1}^{\infty}\theta_i x_i$收敛，那么$\sum_{i=1}^{\infty}\theta_i x_i \in C$。<br>更一般的，假设概率分布$p$，$R^n \rightarrow R$满足$p(x)\le 0 for\ all\ x\in C, \int_{C}p(x)dx = 1$,其中$C\subset R^n$是凸的，如果$\int_{C}p(x)xdx$存在的话，那么$\int_{C}p(x)xdx\in C$。</p>
<h4 id="凸包-convex-hull"><a href="#凸包-convex-hull" class="headerlink" title="凸包(convex hull)"></a>凸包(convex hull)</h4><p>给定一个集合$C$，凸包的定义为包含集合$C$中所有点的凸组合的结合，记为$conv\ C$，公式如下：<br>$conv\ C = \{\theta_1 x_1 + \cdots + \theta_k x_k\big|x_i \in C, \theta_i \ge 0, i = 1,\cdots,k,\theta_1 +\cdots + \theta_k = 1\}$<br>任意集合都是有凸包的。一个集合的凸包总是凸的。集合$C$的凸包是包含集合$C$的最小凸集。如果集合$B$是任意包含$C$的凸集，那么$conv\ C \subset B$。</p>
<h4 id="示例-11"><a href="#示例-11" class="headerlink" title="示例"></a>示例</h4><p><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/figure2_2.png" alt="figure 2.2"><br><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/figure2_3.png" alt="figure 2.3"></p>
<h3 id="锥-cones"><a href="#锥-cones" class="headerlink" title="锥(cones)"></a>锥(cones)</h3><h4 id="锥-cones-和凸锥-convex-cones-的定义"><a href="#锥-cones-和凸锥-convex-cones-的定义" class="headerlink" title="锥(cones)和凸锥(convex cones)的定义"></a>锥(cones)和凸锥(convex cones)的定义</h4><p>给定集合$C$，如果$\forall x \in C, \theta \ge 0$，都有$\theta x\in C$，这样的集合就称为一个锥(cone)，或者非负同质(nonnegative homogeneour)。<br>一个集合$C$如果既是锥又是凸的，那这个集合是一个凸锥(convex cone)，即：$\forall x_1,x_2 \in C, \theta_1,\theta_2 \ge 0$,那么有$\theta_1 x_1+\theta_2 x_2 \in C$。几何上可以看成经过顶点为原点，两条边分别经过点$x_1$和$x_2$的$2$维扇形。</p>
<h4 id="锥组合-conic-combination"><a href="#锥组合-conic-combination" class="headerlink" title="锥组合(conic combination)"></a>锥组合(conic combination)</h4><p>给定$k$个点$x_1,x_2,\cdots,x_k$，如果具有$\theta_1 x_1 + \cdots, \theta_k x_k$形式且满足$\theta_i \ge 0,i=1,\cdots,k$,那么就称这是$x_1,\cdots,x_k$的一个锥组合(conic combination)或者非负线性组合(nonnegative combination)。<br>给定集合$C$是凸锥，那么集合$C$中任意点$x_i$的锥组合仍然在集合$C$中。反过来，当且仅当集合$C$包含它的任意元素的凸组合时，这个集合是一个凸锥(convex cone)。</p>
<h4 id="锥包-conic-hull"><a href="#锥包-conic-hull" class="headerlink" title="锥包(conic hull)"></a>锥包(conic hull)</h4><p>给定集合$C$，它的锥包(conic hull)是集合$C$中所有点的锥组合。即：<br>$conic\ C = \{\theta_1 x_1 + \cdots + \theta_k x_k\big|x_i \in C, \theta_i \ge 0, i = 1,\cdots,k\}$<br>集合$C$的锥包是包含集合$C$的最小凸锥。</p>
<h4 id="示例-12"><a href="#示例-12" class="headerlink" title="示例"></a>示例</h4><p><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/figure2_4.png" alt="figure 2.4"><br><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/figure2_5.png" alt="figure 2.5"></p>
<h3 id="一些想法"><a href="#一些想法" class="headerlink" title="一些想法"></a>一些想法</h3><p>在我自己看来，在几何上<br>仿射集可以看成是集合中任意两个点的直线的集合。<br>凸集可以看成是集合中任意两个点的线段的集合，因为直线一定包含线段，所以仿射集一定是凸集。<br>锥集可以看成是集合中任意一个点和原点构成的射线的集合，锥集不一定是连续的（两条射线也是锥集），所以锥集不一定是凸集。<br>而凸锥既是凸集又是锥集。<br>我在stackexchange看到这样一句话觉得说的挺好的。</p>
<blockquote>
<p>What basically distinguishes the definitions of convex, affine and cone, is the domain of the coefficients and the constraints that relate them.</p>
</blockquote>
<p>区别凸集，仿射和锥的是系数的取值范围和一些其他限制。仿射集要求$\theta_1+\cdots+\theta_k = 1$，凸集要求$\theta_1 +\cdots +\theta_k = 1, 0\le \theta \le 1$，锥的要求是$\theta \ge 0$，凸锥的要求是$\theta_i \ge 0,i=1,\cdots,k$。<br>仿射集不是凸集的子集，凸集也不是仿射集的子集。所有仿射集的集合是所有凸集的集合的子集，一个仿射集是一个凸集。</p>
<h2 id="示例-13"><a href="#示例-13" class="headerlink" title="示例"></a>示例</h2><ul>
<li>$\emptyset$，单点(single point)$\{x_0\}$，整个$R^n$空间都是$R^n$中的仿射子集，所以也是凸集，点不一定是凸锥（在原点熵是凸锥），空集是凸锥，$R^n$维空间也是凸锥。<strong>根据定义证明。</strong></li>
<li>任意一条直线都是仿射的，所以是凸集。如果经过原点，它是一个子空间，也就是一个凸锥，否则不是。 </li>
<li>任意一条线段都是凸集，不是仿射集，当它退化成一点的时候，它是仿射的，线段不是凸锥。 </li>
<li>一条射线$\{x_0 + \theta v\big| \theta \ge 0\}$是凸的，但是不是仿射的，当$x_0=0$时，它是凸锥。</li>
<li>任意子空间都是仿射的，也是凸锥，所以是凸的。 </li>
</ul>
<p>补充最后一条，任意子空间都是仿射的，也是凸锥。<br>如果$V$是一个子空间，那么$V$中任意两个向量的线性组合还在$V$中。即如果$x_1,x_2\in V$，对于$\theta_1,\theta_2 \in R$，都有$\theta_1 x_1 + \theta_2 x_2 \in V$。正如前面说的，子空间是加法和数乘封闭的。<br>而根据仿射集的定义，如果$x_1,x_2$在一个仿射集$C$中，那么对于$\theta_1+\theta_2 = 1$，都有$\theta_1 x_1 + \theta_2 x_2 \in C$。我们可以看出来，如果取子空间中线性组合的系数和为$1$，那么就成了仿射集。如果取子空间中的系数$\theta_1,\theta_2 \in R_+$,那么就成了锥，如果同时满足$\theta_1+\theta_2 = 1$，那么就成凸锥。那么如果加上这些限制条件，即取子空间中线性组合的系数和为$1$，或者取子空间中的系数$\theta_1,\theta_2 \in R_+$,同时满足$\theta_1+\theta_2 = 1$。<br>事实上，子空间要求的条件比仿射集和凸锥的条件要更严格。仿射集和凸锥只要求在系数$\theta_i$满足相应的条件时,有$\theta_1 x_1 + \theta_2 x_2 \in R^n$；而子空间要求的是在系数$\theta_i$取任意值的时候，都有$\theta_1 x_1 + \theta_2 x_2 \in R^n$，所以子空间一定是仿射集，也一定是凸锥。（拿二维的举个例子，给定$x_1$和$x_2$，仿射集可以看成是$\theta_1$的函数，因为$\theta_2=1-\theta_1$，而子空间可以看成$\theta_1$和$\theta_2$的函数，一个是一元函数，一个是二元函数）</p>
<h3 id="超平面-hyperplane-和半空间-halfspace"><a href="#超平面-hyperplane-和半空间-halfspace" class="headerlink" title="超平面(hyperplane)和半空间(halfspace)"></a>超平面(hyperplane)和半空间(halfspace)</h3><p>超平面是一个仿射集，也是凸集，但不一定是锥集(过原点才是锥集，也是一个子空间)。<br>闭的半空间是一个凸集，不是仿射集。</p>
<h4 id="超平面-hyperplane"><a href="#超平面-hyperplane" class="headerlink" title="超平面(hyperplane)"></a>超平面(hyperplane)</h4><p>超平面通常具有以下形式：</p>
<script type="math/tex; mode=display">\{x\big|a^Tx=b\},</script><p>其中$a\in R^n,a\ne 0,b\in R$，它其实是一个平凡(nontrivial)线性方程组的解，因此也是一个仿射集。几何上，超平面可以解释为和一个给定向量$a$具有相同内积(inner product)的点集，或者说是法向量为$a$的一个超平面。常数$b$是超平面和原点之间的距离(offset)。<br>几何意义可以被表示成如下形式：</p>
<script type="math/tex; mode=display">\{x\big|a^T(x-x_0) = 0\},</script><p>其中$x_0$是超平面上的一点，即满足$a^Tx_0=0$。可以被表示成如下形式：</p>
<script type="math/tex; mode=display">\{x\big|a^T(x-x_0)=0\} = x_0+a^{\perp},</script><p>其中$a^{\perp}$是$a$的正交补，即所有与$a$正交的向量的集合，满足$a^{\perp}=\{v\big|a^Tv=0\}$。所以，超平面的几何解释可以看做一个偏移(原点到这个超平面的距离)加上所有垂直于一个特定向量$a$(正交向量)的向量，即这些垂直于$a$的向量构成了一个过原点的超平面，再加上这个偏移量就是我们要的超平面。几何表示如下图所示。<br><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/figure2_6.png" alt="figure 2.6"></p>
<h4 id="半空间-halfspace"><a href="#半空间-halfspace" class="headerlink" title="半空间(halfspace)"></a>半空间(halfspace)</h4><p>一个超平面将$R^n$划分为两个半空间(halfspaces)，一个是闭(closed)半空间，一个是开半空间。闭的半空间可以表示成$\{x\big|a^Tx\le b\}$，其中$a\ne 0$，半空间是凸的，但不是仿射的。下图便是一个闭的半空间。<br><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/figure2_7.png" alt="figure 2.7"><br>这个半空间也可以写成：</p>
<script type="math/tex; mode=display">\{x\big|a^T(x-x_0)\le 0\},</script><p>其中$x_0$是划分两个半空间的超平面上的一点，即满足$a^Tx_0=b$。一个几何解释是：半空间由一个偏移$x_0$加上所有和一个特定向量$a$(超平面的外(outward)法向量)成钝角(obtuse)或者直角(right)的所有向量组成。<br>这个半空间的边界是超平面$\{x\big|a^Tx=b\}$。这个半空间$\{x\big|a^Tx\le b\}$的内部是$\{x\big|a^Tx\lt b\}$，也被称为一个开半平面。</p>
<h3 id="欧几里得球-Euclidean-ball-和椭球-ellipsoid"><a href="#欧几里得球-Euclidean-ball-和椭球-ellipsoid" class="headerlink" title="欧几里得球(Euclidean ball)和椭球(ellipsoid)"></a>欧几里得球(Euclidean ball)和椭球(ellipsoid)</h3><h4 id="欧几里得球"><a href="#欧几里得球" class="headerlink" title="欧几里得球"></a>欧几里得球</h4><p>$R^n$空间中的欧几里得球或者叫球，有如下的形式：</p>
<script type="math/tex; mode=display">B(x_r,r = \{x\big|\Vert x-x_c\Vert_2\le r\}=\{x \big|(x-x_c)^T(x-x_c)\le r^2\},</script><p>其中$r\gt 0$,$\Vert \cdot\Vert_2$是欧几里得范数(第二范数)，即$\Vert u\Vert_2=(u^Tu)^{\frac{1}{2}}$。向量$x_c$是球心，标量$r$是半径。$B(x_c,r)$包含所有和圆心$x_c$距离小于$r$的球。<br>欧几里得球的另一种表示形式是：</p>
<script type="math/tex; mode=display">B(x_c,r)=\{x_c + ru\big| \Vert u \Vert_2 \le 1\},</script><p>一个欧几里得球是凸集，如果$\Vert x_1-x_c\Vert_2 \le r,\Vert x_2-x_c\Vert_2\le r, 0\le\theta\le1$，那么：<br>\begin{align*}<br>\Vert\theta x_1 + (1-\theta)x_2 - x_c\Vert_2 &amp;= \Vert\theta(x_1-x_c)+(1-\theta)(x_2-x_c)\Vert_2\\<br>&amp;\le\theta\Vert x_1-x_c\Vert_2 + (1-\theta)\Vert x_2 - x_c \Vert_2\\<br>&amp;\le r<br>\end{align*}<br>用其次性和三角不等式可证明</p>
<h4 id="椭球"><a href="#椭球" class="headerlink" title="椭球"></a>椭球</h4><p>另一类凸集是椭球，它们有如下的形式：</p>
<script type="math/tex; mode=display">\varepsilon =\{x\big|(x-x_c)^TP^{-1}(x-x_c) \le 1\},</script><p>其中$P=P^T \succ 0$即$P$是对称和正定的。向量$x_c\in R^n$是椭球的中心。矩阵$P$决定了椭球从$x_c$向各个方向扩展的距离。椭球$\varepsilon$的半轴由矩阵$P$的特征值$\lambda_i$算出，$\sqrt{\lambda_i}$，球是$P=r^2I$的椭球。<br><strong>这里这种表示形式为什么要用$P^{-1}$？</strong><br>椭球的另一种表示是：</p>
<script type="math/tex; mode=display">\varepsilon = \{x_c + Au\big| \Vert u \Vert_2 \le 1\},</script><p>其中$A$是一个非奇异方阵。假设$A$是对称正定的，取$A=P^{\frac{1}{2}}$，这种表示就和上面的表示是一样的。第一次看到这种表示的时候，我在想，椭球的边界上有无数个点，一个方阵$A$是怎么实现对这无数个操作的，后来和球做了对比，发现自己一直都想错了，这无数个点是通过范数实现的而不是通过矩阵$A$实现的，到球心距离为$\Vert u\Vert_2\le 1$的点有无数个，$A$对这无数个点的坐标都做了仿射变换，将一个球变换成了椭球，特殊情况下就是球。当矩阵$A$是对称半正定但是是奇异的时候，这个情况下称为退化椭球(degenerate ellipsoid)，它的仿射维度和矩阵$A$的秩(rank)是相同的。退化椭球也是凸的。</p>
<h3 id="范数球-norm-ball-和范数锥-norm-cone"><a href="#范数球-norm-ball-和范数锥-norm-cone" class="headerlink" title="范数球(norm ball)和范数锥(norm cone)"></a>范数球(norm ball)和范数锥(norm cone)</h3><h4 id="范数球-norm-ball"><a href="#范数球-norm-ball" class="headerlink" title="范数球(norm ball)"></a>范数球(norm ball)</h4><h5 id="定义-11"><a href="#定义-11" class="headerlink" title="定义"></a>定义</h5><p>$\Vert \cdot\Vert$是$R^n$上的范数。一个范数球(norm ball)可以看成一个以$x_c$为中心，以$r$为半径的集合，但是这个$r$可以是任何范数，即$\{x\big|\Vert x-x_c \Vert \le r\}$，它是凸的。</p>
<h5 id="示例-14"><a href="#示例-14" class="headerlink" title="示例"></a>示例</h5><p>我们常见的球是二范数（欧几里得范数）对应的范数球。</p>
<h4 id="范数锥"><a href="#范数锥" class="headerlink" title="范数锥"></a>范数锥</h4><h5 id="定义-12"><a href="#定义-12" class="headerlink" title="定义"></a>定义</h5><p>和范数相关的范数锥是集合：$C = \{(x,t)\big|\Vert x\Vert \le t\} \subset R^{n+1}$，它也是凸锥。</p>
<h5 id="示例-15"><a href="#示例-15" class="headerlink" title="示例"></a>示例</h5><p><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/figure2_10.png" alt="figure 2.10"><br>二阶锥(second-order cone)是欧几里得范数对应的范数锥，如图所示，其表达式为：<br>\begin{align*}<br>C &amp;=\{(x,t)\in R^{n+1} \big| \Vert x\Vert_2 \le t\}\\<br>&amp;= \left\{ \begin{bmatrix}x\\t\end{bmatrix}\big| \begin{bmatrix}x\\t\end{bmatrix}^T\begin{bmatrix}I&amp;0\\0&amp;-1\end{bmatrix}\begin{bmatrix}x\\t\end{bmatrix}\le 0, t \gt 0 \right\}<br>\end{align*}<br>这个二阶锥也被称为二次锥(quadratic cone)，因为它是通过一个二次不等式定义的，也被叫做Lorentz cone或者冰激凌锥(ice-cream cone)。</p>
<h4 id="范数锥和范数球的区别"><a href="#范数锥和范数球的区别" class="headerlink" title="范数锥和范数球的区别"></a>范数锥和范数球的区别</h4><p>范数球是所有点到圆心$x_c$的范数小于一个距离$r$。<br>范数锥是很多直线组成的锥。</p>
<h3 id="多面体-polyhedra"><a href="#多面体-polyhedra" class="headerlink" title="多面体(polyhedra)"></a>多面体(polyhedra)</h3><h4 id="定义-13"><a href="#定义-13" class="headerlink" title="定义"></a>定义</h4><p>多面体(polyhedron)是有限个线性不等式或者线性方程组的解集的集合：<br>$P = \{x\big|a_j^Tx\le b_j, j=1,\cdots,m,c_j^Tx=d_j,j=1,\cdots,p\}$<br>多面体因此也是有限个半空间或者超平面的交集。仿射集(如，子空间，超平面，直线)，射线，线段，半空间等等都是多面体，多面体也是凸集。有界的polyhedron有时也被称为polytope，一些作者会把它们两个反过来叫。<br>上式的紧凑(compact)表示是：</p>
<script type="math/tex; mode=display">P=\{x\big|Ax\preceq b, Cx=d\}</script><p>其中$A=\begin{bmatrix}a_1^T\\ \vdots\\ a_m^T\end{bmatrix},C=\begin{bmatrix}c_1^T\\ \vdots\\c_p^T\end{bmatrix}$，$\preceq$表示$R^m$空间中的向量不等式(vector ineuqalitied)或者分量大小的不等式，$u\preceq v$代表着$u_i\le v_i, i=1,\cdots,m$。</p>
<h5 id="simplexes"><a href="#simplexes" class="headerlink" title="simplexes"></a>simplexes</h5><p>simplexes是另一类很重要的多面体。假设$R^n$空间中的$k+1$个点是仿射独立(affinely independent)，意味着$v_1-v_0, \cdots,v_k-v_0$是线性独立的。由$k+1$个仿射独立的点确定的simplex是：</p>
<script type="math/tex; mode=display">C = conv\{v_0,\cdots,v_k\} = \{\theta_0v_0+\cdots+\theta_kv_k\big| \theta \succeq 0, \mathcal{1}\theta=1 \},</script><p>其中$\mathcal{1}$是全为$1$的列向量。这个simplex的仿射维度是$k$，所以它也叫$R^n$空间中的$k$维simplex。为什么仿射维度是$k$，我的理解是simplex是凸集，而凸集不是子空间，凸集去掉其中任意一个元素才是子空间，所以就是$k$维而不是$k+1$维。<br>为了将simplex表达成一个紧凑形式的多面体。定义$y=(\theta_1,\cdots,\theta_k)$和$B=[v_1-v_0\ \cdots\ v_k-v_0]\in R^{n\times k}$，当且仅当存在$y\succeq 0, \mathcal{1}^Ty\le 1$，$x=v_0+By$有$x\in C$，<strong>疑问，这里为什么变成了$\mathcal{1}^Ty\le 1$，难道是因为少了个$v_0$吗</strong>。点$v_0,\cdots,v_k$表明矩阵$B$的秩为$k$。因此存在一个非奇异矩阵$A=(A_1,A_2)\in R^{n\times n}$使得：</p>
<script type="math/tex; mode=display">AB = \begin{bmatrix}A_1\\A_2\end{bmatrix}B= \begin{bmatrix}I\\0\end{bmatrix}.</script><p>对$x = v_0+By$同时左乘$A$，得到：</p>
<script type="math/tex; mode=display">A_1x = A_1v_0+y, A_2x=A_xv_0.</script><p>从中我们可以看出如果$A_2x=A_2v_0$，且向量$y=A_1x-A_1v_0$满足$y\succeq 0, \mathcal{1}^Ty\le1$时，$x\in C$。换句话说，当且仅当$x$满足以下等式和不等式时：</p>
<script type="math/tex; mode=display">A_2x = A_2v_0,A_1x\succeq A_1v_0, \mathcal{1}A_1x\le1+\mathcal{1}^TA_1v_0,</script><p>有$x\in C$。</p>
<h5 id="多面体的凸包描述"><a href="#多面体的凸包描述" class="headerlink" title="多面体的凸包描述"></a>多面体的凸包描述</h5><p>一个有限集合$\{v_1,\cdots,v_k\}$的凸包是：</p>
<script type="math/tex; mode=display">conv\{v_1,\cdots,v_k\} = \{\theta_1 v_1 +\cdots +\theta_k v_k\big| \theta \succeq 0, \mathcal{1}^T\theta = 1\}.</script><p>这个集合是一个多面体，并且有界。但是它（除了simplex）不容易化成多面体的紧凑表示，即不等式和等式的集合。<br>一个一般化的凸包描述是：</p>
<script type="math/tex; mode=display">\{\theta_1 v_1 +\cdots +\theta_k v_k\big| \theta_1+\cdots + \theta_m = 1,\theta_i \ge 0,i=1,\cdots,k\}.</script><p>其中$m\le k$，它可以看做是点$v_1,\cdots,v_m$的凸包加上点$v_{m+1},\cdots,v_{k}$的锥包。这个集合定义了一个多面体，反过来，任意一个多面体可以看做凸包加上锥包。<br>一个多面体如何表示是很有技巧的。比如一个$R^n$空间上的无穷范数单位球$C$：</p>
<script type="math/tex; mode=display">C=\{x\big|\ |x_i|\le 1,i = 1,\cdots,n\}.</script><p>集合$C$可以被表示成$2n$个线性不等式$\pm e_i^Tx\le 1$，其中$e_i$是第$i$个单位向量。然而用凸包形式描述这个集合需要用至少$2^n$个点：</p>
<script type="math/tex; mode=display">C = conv\{v_{1},\cdots,v_{2^n}\},</script><p>其中$v_{1},\cdots,v_{2n}$是$2^n$个向量，每个向量的元素都是$1$或$-1$。因此凸包描述和不等式描述有很大差异，尤其是$n$很大的时候。<br>这里为什么是$2^n$个点呢？因为是无穷范数构成的单位圆，在数轴上是区间$[-1,1]$，在$R^2$是正方形$\{(x,)\big|-1 \le x\le 1,-1\le y\le 1\}$，对应的四个点是$\{(1,1),(1,-1),(-1,1),(-1,-1)\}$，而在$R^3$是立方体$\{(x,y,z)\big|-1 \le x\le 1,-1\le y\le 1\, -1\le z\le 1\}$，对应的是立方体的八个顶点$\{(1,1,1),(1,1,-1),(1,-1,1),(1,-1,-1),(-1,1,1),(-1,1,-1),(-1,-1,1),(-1,-1,-1)\}$。</p>
<h4 id="示例-16"><a href="#示例-16" class="headerlink" title="示例"></a>示例</h4><ol>
<li>如图所示，是五个半平面的交集定义的多面体。<br><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/figure2_11.png" alt="figure 2.11"></li>
<li>非负象限(nonnegative orthant)是非负点的集合，即：<script type="math/tex; mode=display">R_{+}^n = \{x\in R^n\big| x_i\ge 0, i = 1,\cdots,n\} = \{x\in R^n\big| x\succeq 0\}.</script>非负象限是一个多面体，也是一个锥，所以也叫多面体锥(polyhedral cone)，也叫非负象限锥。</li>
<li>一个1维的simplex是一条线段。一个二维的simplex是一个三角形（包含它的内部）。一个三维的simple是一个四面体(tetrahedron)。</li>
<li>由$R^n$中的零向量和单位向量确定的simplex是$n$维unit simplex。它是向量集合：<script type="math/tex; mode=display">x\succeq 0, \mathcal{1}^T x \le 1.</script></li>
<li>由$R^n$中的单位向量确定的simplex是$n-1$维probability simplex。它是向量集合：<script type="math/tex; mode=display">x\succeq 0, \mathcal{1}^T x = 1.</script>Probability simplex是中的向量可以看成具有$n$个元素的集合的概率分布，$x_i$解释为第$i$个元素的概率。</li>
</ol>
<h3 id="半正定锥-positive-sefidefinite-cone"><a href="#半正定锥-positive-sefidefinite-cone" class="headerlink" title="半正定锥(positive sefidefinite cone)"></a>半正定锥(positive sefidefinite cone)</h3><h4 id="定义-14"><a href="#定义-14" class="headerlink" title="定义"></a>定义</h4><p>用$S^n$表示$n\times n$的对称矩阵：$S^n=\{X\in R^{n\times n} \big| X = X^T\}$，$S^n$是一个$n(n+1)/2$维基的向量空间。比如，三维空间中对称矩阵的一组基是：</p>
<script type="math/tex; mode=display">\begin{bmatrix}1&0&0\\0&0&0\\0&0&0\end{bmatrix}\begin{bmatrix}0&0&0\\1&0&0\\0&0&0\end{bmatrix}\begin{bmatrix}0&0&0\\0&1&0\\0&0&0\end{bmatrix}\begin{bmatrix}0&0&0\\0&0&0\\1&0&0\end{bmatrix}\begin{bmatrix}0&0&0\\0&0&0\\0&1&0\end{bmatrix}\begin{bmatrix}0&0&0\\0&0&0\\0&0&1\end{bmatrix}.</script><p>用$S_{+}^n$表示半正定的对称矩阵集合：</p>
<script type="math/tex; mode=display">S_{+}^n = \{X\in S^n\big| X\succeq 0\},</script><p>用$S_{++}^n$表示正定的对称矩阵集合：</p>
<script type="math/tex; mode=display">S_{+}^n = \{X\in S^n\big| X\succ 0\},</script><p>集合$S_{+}^n$是凸锥：如果$\theta_1,\theta_2 \ge 0$且$A,B\in S_{+}^n$，那么$\theta_1 A+\theta_{2} B\in S_{+}^n$。这个可以直接从依靠半正定的定义来证明，如果$A,B\in S_{+}^n ,\theta_1,\theta_2\ge 0$，(<strong>这里原书中用的是$A,B\succeq 0$,我觉得应该是写错了吧</strong>)，对任意$\forall x \in R^n$，都有：</p>
<script type="math/tex; mode=display">x^T(\theta_1A+\theta_2B)x = \theta_1x^TAx + \theta_2x^TBx.</script><h4 id="示例-17"><a href="#示例-17" class="headerlink" title="示例"></a>示例</h4><p>对于$S^2$空间中的半正定锥，有</p>
<script type="math/tex; mode=display">X=\begin{bmatrix}x&y\\y&z\end{bmatrix}\in S\_{+}^2 \Leftrightarrow x\ge 0,z\ge 0, xz\ge y^2</script><p>这个锥的边界如下图所示。<br><img src="/2018/12/24/convex-optimization-chapter-2-Convex-sets/figure2_12.png" alt="figure 2.12"></p>
<h3 id="常见的几种锥"><a href="#常见的几种锥" class="headerlink" title="常见的几种锥"></a>常见的几种锥</h3><p>范数锥，非负象限锥，半正定锥，它们都过原点。<br>想想对应的图像是什么样的。<br>范数锥和非负象限锥图像还好理解一些，非负象限锥是$R^n$空间所有非负半轴围成的锥，范数锥的边界像一个沙漏，但是是无限延伸的。半正定锥怎么理解，还没有太好的类比。</p>
<h2 id="保凸运算-operations-that-preserve-convexity"><a href="#保凸运算-operations-that-preserve-convexity" class="headerlink" title="保凸运算(operations that preserve convexity)"></a>保凸运算(operations that preserve convexity)</h2><p>这一小节介绍的是一些保留集合凸性，或者从一些集合中构造凸集的运算。这些运算和simplex形成了凸集的积分去确定或者建立集合的凸性。</p>
<h3 id="集合交-intersection"><a href="#集合交-intersection" class="headerlink" title="集合交(intersection)"></a>集合交(intersection)</h3><p>凸集求交集可以保留凸性：如果$S_1$和$S_2$是凸集，那么$S_1\cup S_2$是凸集。扩展到无限个集合就是：如果$\forall \alpha \in A,S_{\alpha}$都是凸的，那么$\cup_{\alpha\in A S_{\alpha}$是凸的</p>
<h3 id="仿射函数-affine-functions"><a href="#仿射函数-affine-functions" class="headerlink" title="仿射函数(affine functions)"></a>仿射函数(affine functions)</h3><h3 id="线性分式-linear-fractional-和视角函数-perspective-functions"><a href="#线性分式-linear-fractional-和视角函数-perspective-functions" class="headerlink" title="线性分式(linear-fractional)和视角函数(perspective functions)"></a>线性分式(linear-fractional)和视角函数(perspective functions)</h3><h4 id="线性分式-linear-fractional"><a href="#线性分式-linear-fractional" class="headerlink" title="线性分式(linear-fractional)"></a>线性分式(linear-fractional)</h4><h4 id><a href="#" class="headerlink" title=" "></a> </h4><h2 id="-1"><a href="#-1" class="headerlink" title=" "></a> </h2><h2 id="-2"><a href="#-2" class="headerlink" title=" "></a> </h2><h2 id="-3"><a href="#-3" class="headerlink" title=" "></a> </h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.stephen boyd. Convex optimization<br>2.<a href="https://en.wikipedia.org/wiki/Topology" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Topology</a><br>3.<a href="https://en.wikipedia.org/wiki/Topological_space" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Topological_space</a><br>4.<a href="https://en.wikipedia.org/wiki/Power_set" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Power_set</a><br>5.<a href="https://en.wikipedia.org/wiki/Open_set" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Open_set</a><br>6.<a href="https://en.wikipedia.org/wiki/Closed_set" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Closed_set</a><br>7.<a href="https://en.wikipedia.org/wiki/Clopen_set" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Clopen_set</a><br>8.<a href="https://en.wikipedia.org/wiki/Interior_(topology" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Interior_(topology</a>)<br>9.<a href="https://en.wikipedia.org/wiki/Closure_(topology" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Closure_(topology</a>)<br>10.<a href="https://en.wikipedia.org/wiki/Boundary_(topology" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Boundary_(topology</a>)<br>11.<a href="https://en.wikipedia.org/wiki/Ball_(mathematics" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Ball_(mathematics</a>)<br>12.<a href="https://blog.csdn.net/u010182633/article/details/53792588" target="_blank" rel="noopener">https://blog.csdn.net/u010182633/article/details/53792588</a><br>13.<a href="https://blog.csdn.net/u010182633/article/details/53819910" target="_blank" rel="noopener">https://blog.csdn.net/u010182633/article/details/53819910</a><br>14.<a href="https://blog.csdn.net/u010182633/article/details/53983642" target="_blank" rel="noopener">https://blog.csdn.net/u010182633/article/details/53983642</a><br>15.<a href="https://blog.csdn.net/u010182633/article/details/53997843" target="_blank" rel="noopener">https://blog.csdn.net/u010182633/article/details/53997843</a><br>16.<a href="https://blog.csdn.net/u010182633/article/details/54093987" target="_blank" rel="noopener">https://blog.csdn.net/u010182633/article/details/54093987</a><br>17.<a href="https://blog.csdn.net/u010182633/article/details/54139896" target="_blank" rel="noopener">https://blog.csdn.net/u010182633/article/details/54139896</a><br>18.<a href="https://math.stackexchange.com/questions/1168898/why-is-any-subspace-a-convex-cone" target="_blank" rel="noopener">https://math.stackexchange.com/questions/1168898/why-is-any-subspace-a-convex-cone</a><br>19.<a href="https://www.zhihu.com/question/22799760/answer/139753685" target="_blank" rel="noopener">https://www.zhihu.com/question/22799760/answer/139753685</a><br>20.<a href="https://www.zhihu.com/question/22799760/answer/34282205" target="_blank" rel="noopener">https://www.zhihu.com/question/22799760/answer/34282205</a><br>21.<a href="https://www.zhihu.com/question/22799760/answer/137768096" target="_blank" rel="noopener">https://www.zhihu.com/question/22799760/answer/137768096</a><br>22.<a href="https://en.wikipedia.org/wiki/Positive-definite_matrix" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Positive-definite_matrix</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2018/12/23/熵、交叉熵和K-L散度/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/23/熵、交叉熵和K-L散度/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">熵，交叉熵，相对熵（KL散度），条件熵，互信息</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-23 10:54:31" itemprop="dateCreated datePublished" datetime="2018-12-23T10:54:31+08:00">2018-12-23</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/机器学习/" itemprop="url" rel="index"><span itemprop="name">机器学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="乡农熵-Shannon-entropy"><a href="#乡农熵-Shannon-entropy" class="headerlink" title="乡农熵(Shannon entropy)"></a>乡农熵(Shannon entropy)</h2><p>乡农定义了一个事件的信息量是其发生概率的负对数($-log(p)$)，即乡农信息量，乡农熵是信息量的期望。</p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>这里的熵都是指的信息论中的熵，也叫乡农熵(shannon entropy)。通常，熵是无序或不确定性的度量。<br>与每个变量可能的取值相关的信息熵是每个可能取值的概率质量函数的负对数：</p>
<script type="math/tex; mode=display">S = - \sum_i P_i lnP_i</script><p>当事件发生的概率较低时，该事件比高概率事件携带更多“信息”。这种方式定义的每个事件所携带的信息量是一个随机变量，事实上乡农熵定义的一个事件的信息量就是这个事件发生的概率的负对数，这个随机变量（信息量）的期望值是信息熵。信息熵通常以比特(或者称为shannons),自然单位(nats)或十进制数字(dits，bans或hartleys)来测量。具体的单位取决于用于定义熵的对数的基。<br>采用概率分布的对数形式作为信息的度量的原因是因为它的可加性。例如，投掷公平硬币的熵是$1$比特，投掷$m$个硬币的熵是$m$比特。以比特为单位的时候，如果$n$是$2$的指数次方，则需要$log_2n$位来表示一个具有$n$个取值的变量。如果该变量的$n$个取值发生的可能性是相等的，则熵等于$log_2n$。<br>如果一个事件发生的可能性比其他事件发生的可能性更高，观察到该事件发生的信息量少于观测到一些罕见事件，即观测到更罕见的事件时能提供更多的信息。由于小概率事件发生的可能性更低，因此最终的结果是从非均匀分布的数据接收的熵总是小于或等于$log_2n$。当一个结果一定发生时，熵为零。<br>但是熵仅仅量化考虑事件发生的概率，它封装的信息是有关概率分布的信息，事件本身的意义在这种度量方式的定义中无关紧要。<br>熵的另一种解释是最短平均编码长度。</p>
<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>乡农定义了entropy, 定义离散型随机变量$X$，其可能取值为${x_1,\cdots,x_n}$，它对应的概率质量函数(probability mass function) P(X)，则熵$H$为：</p>
<script type="math/tex; mode=display">H(X) = E[I(X)] = E[-log(P(X))]</script><p>其中$E$是求期望，$I$是随机变量$X$的信息量, $I(X)$本身是一个随机变量。<br>它可以显示写成：</p>
<script type="math/tex; mode=display">H(X) = \sum_{i=1}^nP(x_i)I(x_i) = -\sum_{i=1}^nP(x_i)log_bP(x_i)</script><p>其中b是自然对数的底，$b$常取的值为$2,e,10$，对应的熵的单位是bits, nats，bans。<br>当$P(x_i)=0$的时候，对应的$PlogP$的值为$0log_b(0)$, 和极限(limit)是一致的：</p>
<script type="math/tex; mode=display">lim_{p\rightarrow 0_+}plog(p) = 0.</script><h4 id="连续型随机变量的熵"><a href="#连续型随机变量的熵" class="headerlink" title="连续型随机变量的熵"></a>连续型随机变量的熵</h4><p>将概率质量函数替换为概率密度函数，即可得到连续性随机变量的熵：</p>
<script type="math/tex; mode=display">h[f] = E[-ln(f(x))] = - \int_X f(x)ln(f(x))dx.</script><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>抛一枚硬币，已知其正反两面出现的概率是不相等的，求其正面朝上的概率，该问题可以看做一个伯努利分布问题。<br>如果硬币是公平的，此时得到结果的熵是最大的。这是因为此时抛一次抛硬币的结果具有最大的不确定性。每一个抛硬币的结果会占满一整个bit位。因为<br>\begin{align*}<br>H(X) &amp;= - \sum_{i=1}^n P(x_i)log_bP(x_i)\\<br>&amp;= - \sum_{i=1}^2\frac{1}{2}log_2\frac{1}{2}\\<br>&amp;= - \sum_{i=1}^2\frac{1}{2}\cdot(-1)\\<br>&amp;= 1<br>\end{align*}<br>如果硬币是不公平的，正面向上的概率是$p$，反面向上的概率是$q$，$p \ne q$, 则结果的不确定性更小。因为每次抛硬币，出现其中一面的可能性要比另一面要大，减小的不确定性就得到了更小的熵：每一次抛硬币得到的信息都会小于$1$bit，比如，$p=0.7$时：<br>\begin{align*}<br>H(X) &amp;= -plog_2p - qlog_2q\\<br>&amp;= -0.7log_20.7 - 0.3log_20.3\\<br>&amp;= -0.7\cdot(-0.515) - 0.3\cdot(-1.737)\\<br>&amp;= 0.8816\\<br>&amp;\le 1<br>\end{align*}<br>上面的例子证明不确定性跟变量取值的概率有关。<br>不确定性也跟变量的取值个数有关，上面例子的极端情况是正反面一样（即只有一种取值），那么熵就是0，没有不确定性。</p>
<h3 id="解释-rationale"><a href="#解释-rationale" class="headerlink" title="解释(rationale)"></a>解释(rationale)</h3><p>为什么乡农定义了信息量为$-log(p)$？$-\sum p_i log(p_i)$的意义是什么？<br>首先我们需要想一想信息量需要满足什么条件，然后定义一个信息函数I表示发生概率为$p_i$的事件$i$的信息量，那么这个信息函数需要满足以下条件。</p>
<ul>
<li>$I(p)$是单调下降的；</li>
<li>$I(p) \ge 0$, 即信息是非负的；</li>
<li>$I(1) = 0$, 一定发生的事件不包含信息；</li>
<li>$I(p_1p_2) = I(p_1) + I(p_2)$, 独立事件包含的信息是可加的。<br>最后一个条件很关键，它指出了两个独立事件的联合分布和两个分开的独立事件所包含的信息是一样多的。例如，$A$事件有$m$个等可能性的结果，$B$事件有$n$个等可能性的结果，$AB$有$mn$个等可能性的结果。$A$事件需要$log_2(m)$bits去编码，$B$事件需要用$log_2(n)$bits去编码，$AB$需要$log_2(mn) = log_2(m) + log_2(n)$bits编码。乡农发现了$log$函数能够保留可加性，即：<script type="math/tex; mode=display">I(p) = log(\frac{1}{p}) = - log(p)</script>事实上，这个函数$I$是唯一的(可以证明),选择$I$当做信息函数。如果一个分布中事件$i$发生的概率是$p_i$,那么采样$N$次，事件$i$发生的次数为$n_i = N p_i$, 所有$n_i$次的信息为<script type="math/tex">\sum_in_iI(p_i) = - \sum_iNp_ilog(p_i).</script><br>每个事件的平均信息就是：<script type="math/tex; mode=display">-\sum_ip_ilog(p_i)</script>所以$-\sum_ip_ilog(p_i)$就是信息量的期望，即信息熵。<br>在信息论中，熵的另一种解释是最短平均编码长度。</li>
</ul>
<h2 id="交叉熵-cross-entropy"><a href="#交叉熵-cross-entropy" class="headerlink" title="交叉熵(cross entropy)"></a>交叉熵(cross entropy)</h2><h3 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h3><p>交叉熵用于衡量估计的概率分布与真实概率分布之间的差异。<br>交叉熵是信息熵的推广。假设有两个分布$p$和$q$，$p$是真实分布，$q$是非真实分布。信息熵是用真实分布$p$来衡量识别一个事件所需要的编码长度的期望。而交叉熵是用非真实分布$q$来估计真实分布$p$的编码长度的期望，用$q$来编码的事件来自分布$p$，所以期望中使用的概率是$p(i)$。$H(p,q)$称为交叉熵。</p>
<h3 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h3><p>分布p和q在给定集合X的交叉熵定义为：</p>
<script type="math/tex; mode=display">H(p,q) = E_p[-logq] = H(p) + D_{KL}(p||q)</script><p>其中$H(p)$是$p$的信息熵，$D_{KL}(p||q)$是从$q$到$p$的$K-L$散度，或者说$p$相对于$q$的相对熵。</p>
<h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>如含有4个字母$(A,B,C,D)$的数据集中，$p=(\frac{1}{2}, \frac{1}{2}, 0, 0)$，即$A$和$B$出现的概率均为$\frac{1}{2}$，$C$和$D$出现的概率都为$0$。$H(p)$为$1$，即只需要$1$位编码即可识别$A$和$B$。如果使用分布$q=(\frac{1}{4},\frac{1}{4},\frac{1}{4},\frac{1}{4})$来编码则得到$H(p,q)=2$，即需要$2$位编码来识别$A$和$B$。</p>
<h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>在机器学习中，交叉熵用于衡量估计的概率分布与真实概率分布之间的差异。<br>在信息论中，Kraft-McMillan定理建立了任何可直接解码的编码方案，为了识别一个$X$的可能值$x_i$f可以看做服从一个在$X$上的隐式概率分布$q(x_i)=2^{-l_i}$,其中$l_i$是$x_i$的编码长度，单位是bits。因此，交叉熵可以被解释为当数据服从真实分布$p$时，在假设分布$q$下得到的每个信息编码长度的期望。</p>
<h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><ul>
<li>$H(p,q) \ge H(p)$,由吉布森不等式可以知道，该式子恒成立，当$q$等于$p$时等号成立。</li>
</ul>
<h3 id="to-do-交叉熵损失函数和logistic-regression之间的关系。"><a href="#to-do-交叉熵损失函数和logistic-regression之间的关系。" class="headerlink" title="to do ?交叉熵损失函数和logistic regression之间的关系。"></a>to do ?交叉熵损失函数和logistic regression之间的关系。</h3><h2 id="K-L-散度-Kullback-Leibler-divergence"><a href="#K-L-散度-Kullback-Leibler-divergence" class="headerlink" title="$K-L$散度(Kullback-Leibler divergence)"></a>$K-L$散度(Kullback-Leibler divergence)</h2><h3 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h3><p>$K-L$散度也叫相对熵(relative entropy)，是用来衡量估计分布和真实分布之间的差异性。<br>$K-L$散度也叫相对熵(relative entropy)，信息熵是用来度量信息量的，信息熵给出了最小熵是多少，但是信息熵并没有给出如何得到最小熵，$K-L$散度也没有给出来如何得到最小熵。但是$K-L$散度可以用来衡量用一个带参数的估计分布来近似真实数据分布时损失了多少信息，可以理解为根据非真实分布$q$得到的平均编码长度比由真实分布$p$得到的平均编码长度多出的长度叫做相对熵。</p>
<h3 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h3><h4 id="离散型随机变量"><a href="#离散型随机变量" class="headerlink" title="离散型随机变量"></a>离散型随机变量</h4><p>给定概率分布$P$和$Q$在相同的空间中，它们的$K-L$散度定义为：<br>\begin{align*}<br>D_{KL}(P||Q) &amp;= -\sum_iP(i)(logQ(i)) - (-\sum_iP(i)logP(i))\\<br>D_{KL}(P||Q) &amp;= \sum_iP(i)(logP(i) - logQ(i))\\<br>D_{KL}(P||Q) &amp;= -\sum_iP(i)log(\frac{Q(i)}{Q(i)})\\<br>D_{KL}(P||Q) &amp;= \sum_iP(i)log(\frac{P(i)}{Q(i)})<br>\end{align*}<br>可以看出，$K-L$散度是概率分布$P$和$Q$对数差相对于概率分布$P$的期望。需要注意的是$D_{KL}(P||Q) \ne D_{KL}(Q||P),$因为$P$和$Q$的地位是不同的。相对熵的前半部分就是交叉熵，后半部分是相对熵。</p>
<h4 id="连续型随机变量"><a href="#连续型随机变量" class="headerlink" title="连续型随机变量"></a>连续型随机变量</h4><p>对于连续性随机变量的分布$P$和$Q$，$K-L$散度被定义为积分：</p>
<script type="math/tex; mode=display">D_{KL}(P||Q) = \int_{-\infty}^{infty}p(x)log(\frac{p(x)}{q(x)})dx,</script><p>其中$p$和$q$代表分布$P$和分布$Q$的概率密度函数。<br>更一般的，$P$和$Q$表示是同一个集合$X$的概率分布，$P$相对于$Q$是绝对连续的，从$Q$到$P$的$K-L$散度定义为：</p>
<script type="math/tex; mode=display">D_{KL}(P||Q) = \int_X log(\frac{dP}{dQ})dP</script><p>上式可以被写成：</p>
<script type="math/tex; mode=display">D_{KL}(P||Q) = \int_X log(\frac{dP}{dQ})\frac{dP}{dQ}dP</script><p>可以看成$\frac{P}{Q}$的熵。</p>
<h3 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h3><p>$P$是一个二项分布，$P~(2,0.4)$，$Q$是一个离散型均匀分布，$x = 0,1,2$, 每一个取值的概率都是$p=\frac{1}{3}$。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>0</th>
<th>1</th>
<th>2</th>
</tr>
</thead>
<tbody>
<tr>
<td>$P$分布</td>
<td>0.36</td>
<td>0.48</td>
<td>0.16</td>
</tr>
<tr>
<td>$Q$分布</td>
<td>0.333</td>
<td>0.333</td>
<td>0.333</td>
</tr>
</tbody>
</table>
</div>
<p>$K-L$散度的计算公式如下（使用自然对数）：<br>\begin{align*}<br>D_{KL}(Q||P) &amp;= \sum_iQ(i)ln(\frac{Q(i)}{P(i)})\\<br>&amp; = 0.333ln(\frac{0.333}{0.36}) + 0.333ln(\frac{0.333}{0.48}) + 0.333ln(\frac{0.333}{0.16})\\<br>&amp; = -0.02596 + (-0.12176) + 0.24408\\<br>&amp; = 0.09637(nats)<br>\end{align*}<br>上面计算出来的是从$P$到$Q$的K-L散度，或者$Q$相对于$P$的相对熵。</p>
<h3 id="解释-1"><a href="#解释-1" class="headerlink" title="解释"></a>解释</h3><p>从$Q$到$P$的$K-L$散度表示为$D_{KL}(P||Q)$。在机器学习中，$D_{KL}(P||Q)$被称为信息增益。<br>在信息论中，$K-L$散度也被称为$P$相对于$Q$的相对熵。从信息编码角度来看，$D_{KL}(P||Q)$可以看做用估计分布$q$得到的平均编码长度比用真实分布p得到的平均编码长度多出的长度。</p>
<h3 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h3><ul>
<li>非负性，$D_{KL}(P||Q)\ge 0$,当且仅当$P=Q$时等号成立。</li>
<li>可加性，如果$P_1,P_2$的分布是独立的，即$P(x,y) = P_1(x)P_2(y)$, $Q,Q_1,Q_2$类似，那么：<script type="math/tex; mode=display">D_{KL}(P||Q) = D_{KL}(P_1||Q_1) + D_{KL}(P_2||Q_2)</script></li>
<li>不对称性，所以K-L散度不是距离，距离需要满足对称性。</li>
</ul>
<h2 id="条件熵"><a href="#条件熵" class="headerlink" title="条件熵"></a>条件熵</h2><h3 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h3><p>给定$X$，$Y$的条件熵定义如下：<br>给定离散变量${\displaystyle X}$和${\displaystyle Y}$,给定${\displaystyle X}$以后，${\displaystyle Y}$的条件熵定义为每一个${\displaystyle x}$使用权值${\displaystyle p(x)}$ 的加权和${\displaystyle \mathrm {H} (Y|X=x)}$。</p>
<script type="math/tex; mode=display">H(Y|X) &\equiv \sum_{x\in\bold{X}}p(x)H(Y|X=x)</script><p>可以证明它等价于下式：</p>
<script type="math/tex; mode=display">H(Y|X) = -\sum_{X\in \bold{X},Y\in \bold{Y}}p(X,Y)log{\frac{p(X,Y)}{p(X)}}</script><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>\begin{align*}<br>H(Y|X) &amp;\equiv \sum_{x\in\bold{X}}p(x)H(Y|X=x)\\<br>&amp;=-\sum_{x\in\bold{X}}p(x)\sum_{y\in \bold{Y}}p(y|x)logp(y|x)\\<br>&amp;=-\sum_{x\in\bold{X}}\sum_{y\in \bold{Y}}p(x)p(y|x)logp(y|x)\\<br>&amp;=-\sum_{x\in\bold{X},y\in \bold{Y}}p(x,y)logp(y|x)\\<br>&amp;=-\sum_{x\in\bold{X},y\in \bold{Y}}p(x,y)\frac{logp(x,y)}{logp(x)}\\<br>&amp;=\sum_{x\in\bold{X},y\in \bold{Y}}p(x,y)\frac{logp(x)}{logp(x,y)}\\<br>\end{align*}</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>当且仅当$Y$完全由$X$的值确定时，条件熵为$0$。</li>
<li>当且仅当$X$和$Y$是独立随机变量的时候，$H(Y|X) = H(Y)$。</li>
<li>链式法则。假设一个系统由随机变量$X,Y$确定，他们有联合熵$H(X,Y)$，我们需要$H(X,Y)$个比特去表述这个系统，如果我们已经知道了$X$的值，相当于我们已经有了$H(X)$位的信息。一旦$X$已知了，我们只需要$H(X,Y)-H(X)$位去描述整个系统。所以就有了链式法则：$H(Y|X) = H(X,Y) - H(X)$。<br>\begin{align*}<br>H(Y|X) &amp;= \sum_{X\in \bold{X}, Y\in \bold{Y}}p(X,Y)log{\frac{p(X)}{p(X,Y)}}\\<br>&amp;= - \sum_{X\in \bold{X}, Y\in \bold{Y}}p(X,Y)log{p(X,Y)}+\sum_{X\in \bold{X}, Y\in \bold{Y}}p(X,Y)log{p(X)}\\<br>&amp;=H(X,Y) +\sum_{X\in \bold{X}}p(X)log{p(X)}\\<br>&amp;=H(X,Y) - H(X)<br>\end{align*}</li>
<li>贝叶斯公式。$H(Y|X) = H(X|Y) - H(X) + H(Y)$。<br>证明：$H(Y|X)=H(X,Y) - H(X),H(X|Y) = H(X,Y) - H(Y)$。两个式子相减就可以得到。</li>
</ul>
<h2 id="互信息"><a href="#互信息" class="headerlink" title="互信息"></a>互信息</h2><p>决策树中的信息增益指的是互信息不是KL散度。</p>
<h3 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h3><p>用$(X,Y)$表示空间$\bold{X}\times\bold{Y}$上的一对随机变量，他们的联合分布是$P_{(X,Y)}$，边缘分布是$P_X,P_Y)$，信息熵被定义为：<br>$I(X;Y) = D_{KL}(P_{(X,Y)}||P_XP_Y)$<br>对于离散变量：<br>$I(X;Y)=\sum_{X\in \bold{X},Y\in \bold{Y}}p(X,Y)log(\frac{p(X,Y)}{p(X)p(Y)})$<br>对于随机变量：<br>$I(X;Y)=\int_X\int_Y p(X,Y)log(\frac{p(X,Y)}{p(X)p(Y)})dxdy$</p>
<h2 id="信息熵，相对熵，交叉熵，条件熵，互信息之间的关系"><a href="#信息熵，相对熵，交叉熵，条件熵，互信息之间的关系" class="headerlink" title="信息熵，相对熵，交叉熵，条件熵，互信息之间的关系"></a>信息熵，相对熵，交叉熵，条件熵，互信息之间的关系</h2><h3 id="信息论"><a href="#信息论" class="headerlink" title="信息论"></a>信息论</h3><p>信息熵是对随机事件用真实的概率分布$p$进行编码的长度的期望，是最短平均编码长度。<br>交叉熵是对随机事件用估计的概率分布$q$按照其真实概率分布$p$进行编码的长度的期望（随机事件是从真实概率分布$p$中取的，但是用分布$q$进行编码），大于等于最短平均编码长度，只有$q$等于真实分布$q$时，才是最短编码长度。<br>而相对熵对随机事件用估计的概率分布$q$比用真实的概率分布$p$进行编码多用的编码长度，如果$p$和$q$相等的话，相对熵为$0$。</p>
<h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>在机器学习中，交叉熵通常作为一个loss函数，用来衡量真实分布$p$和估计分布$q$之间的差异。而$K-L$散度也是用来衡量两个概率分布的差异，但是多了一个信息熵项。$K-L$散度的前半部分是交叉熵，后半部分是真实分布$p$的信息熵。(一个我自己认为的不严谨的说法是相对熵算的是相对值，而交叉熵算的是绝对值)。交叉熵正比于负的对数似然估计，最小化交叉熵等价于最大化对数似然估计。<br>如果$p$是固定的，那么随着$q$的增加相对熵也在增加，但是如果$p$是不固定的，很难说相对熵是差异的绝对量度，因为它随着$p$的增长而改变。而在机器学习领域，真实分布$p$是固定的，随着$q$的改变，$H(p)$是不变的,也就是信息熵是固定的。所以，从优化的角度来说，最小化交叉熵也就是最小化了相对熵。但是在其他领域，$p$可能是变化的，最小化交叉熵和最小化相对熵就不是等价的了。</p>
<h3 id="互信息和条件熵，相对熵的关系"><a href="#互信息和条件熵，相对熵的关系" class="headerlink" title="互信息和条件熵，相对熵的关系"></a>互信息和条件熵，相对熵的关系</h3><p>互信息可以被等价定义为：<br>\begin{align*}<br>I(X;Y)&amp; \equiv H(X)-H(X|Y)\\<br>&amp;\equiv H(Y) - H(Y|X)\\<br>&amp;\equiv H(X)+H(Y)-H(X,Y)\\<br>&amp;\equiv H(X,Y)-H(X|Y)-H(Y|X)\\<br>\end{align*}</p>
<p>证明：<br>\begin{align*}<br>I(X;Y)&amp;=\sum_{X\in \bold{X},Y\in \bold{Y}}p(X,Y)log(\frac{p(Y,Y)}{p(X)p(Y)})\\<br>&amp;=\sum_{X\in \bold{X},Y\in \bold{Y}}p(X,Y)log(\frac{p(Y,Y)}{p(X)})-\sum_{X\in \bold{X},Y\in \bold{Y}}p(X,Y)logp(Y)\\<br>&amp;=\sum_{X\in \bold{X},Y\in \bold{Y}}p(X)P(Y|X)logp(Y|X)-\sum_{X\in \bold{X},Y\in \bold{Y}}p(X,Y)logp(Y)\\<br>&amp;=\sum_{X\in \bold{X}}p(X)(\sum_{Y\in \bold{Y}}P(Y|X)logp(Y|X))-\sum_{Y\in \bold{Y}}(\sum_{X\in \bold{X}}p(X,Y))logp(Y)\\<br>&amp;=\sum_{X\in \bold{X}}p(X)H(Y|X=x)-\sum_{Y\in \bold{Y}}p(Y)logp(Y)\\<br>&amp;=-H(Y|X)+H(Y)\\<br>&amp;=H(Y)-H(Y|X)<br>\end{align*}</p>
<p>互信息和KL散度的联系：<br>从联合分布$p(x,y)$到边缘分布$p(X)p(Y)$或者条件分布$p(X|Y)p(X)$的KL散度。</p>
<h2 id="参考文献-references"><a href="#参考文献-references" class="headerlink" title="参考文献(references)"></a>参考文献(references)</h2><p>1.<a href="https://en.wikipedia.org/wiki/Entropy_(information_theory" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Entropy_(information_theory</a>)<br>2.<a href="https://zh.wikipedia.org/wiki/熵_(信息论" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/熵_(信息论</a>)<br>3.<a href="https://www.zhihu.com/question/22178202/answer/49929786" target="_blank" rel="noopener">https://www.zhihu.com/question/22178202/answer/49929786</a><br>4.<a href="https://en.wikipedia.org/wiki/Cross_entropy" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Cross_entropy</a><br>5.<a href="https://en.wikipedia.org/wiki/Kullback-Leibler_divergence" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Kullback-Leibler_divergence</a><br>6:<a href="https://www.zhihu.com/question/41252833/answer/108777563" target="_blank" rel="noopener">https://www.zhihu.com/question/41252833/answer/108777563</a><br>7.<a href="https://www.zhihu.com/question/41252833/answer/141598211" target="_blank" rel="noopener">https://www.zhihu.com/question/41252833/answer/141598211</a><br>8.<a href="https://stats.stackexchange.com/questions/265966/why-do-we-use-kullback-leibler-divergence-rather-than-cross-entropy-in-the-t-sne" target="_blank" rel="noopener">https://stats.stackexchange.com/questions/265966/why-do-we-use-kullback-leibler-divergence-rather-than-cross-entropy-in-the-t-sne</a><br>9.<a href="https://en.wikipedia.org/wiki/Conditional_entropy" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Conditional_entropy</a><br>10.<a href="https://en.wikipedia.org/wiki/Mutual_information" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Mutual_information</a><br>11.<a href="https://zhuanlan.zhihu.com/p/26551798" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/26551798</a><br>12.<a href="https://blog.csdn.net/gangyin5071/article/details/82228827#4相对熵kl散度" target="_blank" rel="noopener">https://blog.csdn.net/gangyin5071/article/details/82228827#4相对熵kl散度</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2018/12/22/convex-optimization-chapter-1-Introduction/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/22/convex-optimization-chapter-1-Introduction/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">convex optimization chapter 1 Introduction</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-22 13:44:11" itemprop="dateCreated datePublished" datetime="2018-12-22T13:44:11+08:00">2018-12-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/凸优化笔记/" itemprop="url" rel="index"><span itemprop="name">凸优化笔记</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数学优化-mathematical-optimization"><a href="#数学优化-mathematical-optimization" class="headerlink" title="数学优化(mathematical optimization)"></a>数学优化(mathematical optimization)</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个数学优化问题（或者称为优化问题）通常有如下的形式：<br>\begin{align*}<br>&amp;minimize \quad f_0(x)\\<br>&amp;subject \ to \quad f_i(x) \le b_i, i = 1,\cdots,m.<br>\end{align*}<br>其中$x = (x_1, \cdots, x_m)$被称为优化变量(optimization variables), 或者决策变量(decision variables)。 $f_0(x):R^n\rightarrow R$是目标函数(object function), $f_i(x):R^n\rightarrow R,i =1,\cdots,m$是约束函数(constraint functions)。 常量(constraints) $b_1,\cdots,b_m$是约束的限界(limits)或者边界(bounds), $b_i$可以为0，这个可以通过移项构造出新的$f_i(x)$实现。如果向量$x$使得目标函数取得最小的值，并且满足所有的约束条件，那么这个向量被称为最优解$x^*$。 </p>
<h4 id="线性优化-linear-program"><a href="#线性优化-linear-program" class="headerlink" title="线性优化(linear program)"></a>线性优化(linear program)</h4><p>目标函数和约束函数$f_0,\cdots,f_m$是线性的, 它们满足不等式： </p>
<script type="math/tex; mode=display">f_i(\alpha x+\beta y) = \alpha f_i(x) + \beta f_i(y)</script><p>对于所有的$x,y \epsilon R^n$和所有的$\alpha, \beta \epsilon R$。<br>线性优化是凸优化的一个特殊形式, 它的目标函数和约束函数都是线性的等式或者不等式。</p>
<h4 id="非线性问题-non-linear-problem"><a href="#非线性问题-non-linear-problem" class="headerlink" title="非线性问题(non-linear problem)"></a>非线性问题(non-linear problem)</h4><p>如果优化问题不是线性的，就是非线性问题。只要目标函数或者约束函数至少有一个不是线性的，那么这个优化问题就是非线性优化问题。</p>
<h4 id="凸问题-convex-problem"><a href="#凸问题-convex-problem" class="headerlink" title="凸问题(convex problem)"></a>凸问题(convex problem)</h4><p>凸问题是目标函数和约束函数都是凸的的优化问题，它们满足：</p>
<script type="math/tex; mode=display">f_i(\alpha x + \beta y) \le \alpha f_i(x) + \beta f_i(y)</script><p>对于所有的$x,y \epsilon R^n$和所有的$\alpha, \beta  \epsilon R$且$\alpha + \beta = 1, \alpha \ge 0, \beta \ge 0$。<br>凸性比线性的范围更广，不等式取代了更加严格的等式，不等式只有在$\alpha$和$\beta$取一些特定值时才成立。凸优化和线性问题以及非线性问题都有交集，它是线性问题的超集(superset)，是非线性问题的子集(subset)。技术上来说，nonlinear problem包括convex optimization(除了linear programming), 可以用来描述不确定是非凸的问题。<br>Nonlinear program &gt; convex problem &gt; linear problem</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="组合优化-portfolio-optimization"><a href="#组合优化-portfolio-optimization" class="headerlink" title="组合优化(portfolio optimization)"></a>组合优化(portfolio optimization)</h4><p>变量：不同资产的投资数量<br>约束：预算，每个资产最大/最小投资数量，至少要得到的回报<br>目标：所有的风险，获利的变化</p>
<h4 id="电子设备的元件大小-device-sizing-in-electronic-circuits"><a href="#电子设备的元件大小-device-sizing-in-electronic-circuits" class="headerlink" title="电子设备的元件大小(device sizing in electronic circuits)"></a>电子设备的元件大小(device sizing in electronic circuits)</h4><p>变量：元件的宽度和长度<br>约束：生产工艺的炼制，时间要求，面积等<br>目标：节约能耗</p>
<h4 id="数据拟合-data-fitting"><a href="#数据拟合-data-fitting" class="headerlink" title="数据拟合(data fitting)"></a>数据拟合(data fitting)</h4><p>变量：模型参数<br>约束：先验知识，参数约束条件<br>目标：错误率</p>
<h3 id="优化问题求解-solving-optimization-problems"><a href="#优化问题求解-solving-optimization-problems" class="headerlink" title="优化问题求解(solving optimization problems)"></a>优化问题求解(solving optimization problems)</h3><p>所有的问题都是优化问题。<br>绝大部分优化问题我们解不出来。</p>
<h4 id="一般的优化问题-general-optimization-problem"><a href="#一般的优化问题-general-optimization-problem" class="headerlink" title="一般的优化问题(general optimization problem)"></a>一般的优化问题(general optimization problem)</h4><ul>
<li>很难解出来。</li>
<li>做一些compromise，比如要很长时间才能解出来，或者并不总能找到解。</li>
</ul>
<h4 id="一些例外-some-exceptions"><a href="#一些例外-some-exceptions" class="headerlink" title="一些例外(some exceptions)"></a>一些例外(some exceptions)</h4><ul>
<li>最小二乘问题(least-squares problems)</li>
<li>线性规划问题(linear programming problems)</li>
<li>凸优化问题(convex optimization problems)</li>
</ul>
<h2 id="最小二乘-least-squares-和线性规划-linear-programming"><a href="#最小二乘-least-squares-和线性规划-linear-programming" class="headerlink" title="最小二乘(least-squares)和线性规划(linear programming)"></a>最小二乘(least-squares)和线性规划(linear programming)</h2><p>least-squares和linear programming是凸优化问题中最有名的两个子问题。</p>
<h3 id="最小二乘问题-least-squares-problems"><a href="#最小二乘问题-least-squares-problems" class="headerlink" title="最小二乘问题(least-squares problems)"></a>最小二乘问题(least-squares problems)</h3><p>最小二乘问题是一个无约束的优化问题，它的目标函数是项$a_i^Tx-b_i$的平方和。<br>\begin{align*}<br>minimize \quad f_0(x) &amp;= {||Ax-b||}^2_2\\<br>&amp;=\sum_{i=1}^k(a_i^Tx-b_i)^2<br>\end{align*}</p>
<h4 id="求解-solving-least-squares-problems"><a href="#求解-solving-least-squares-problems" class="headerlink" title="求解(solving least-squares problems)"></a>求解(solving least-squares problems)</h4><ul>
<li>最小二乘问题的解可以转换为求线性方程组$(A^TA)x = A^Tb$的解。线性代数上我们学过该方程组的解析解为$x=(A^TA)^{-1}A^Tb$。</li>
<li>时间复杂度是$n^2k = n*k*n+n*k+n*n*n, (k &gt; n)$(转置，求逆，矩阵乘法)。</li>
<li>该问题具有可靠且高效的求解算法。</li>
<li>是一个很成熟的算法</li>
</ul>
<h4 id="应用-using-least-squares"><a href="#应用-using-least-squares" class="headerlink" title="应用(using least-squares)"></a>应用(using least-squares)</h4><p>很容易就可以看出来一个问题是最小二乘问题，我们只需要验证目标函数是不是二次函数，以及对应的二次型是不是正定的即可。</p>
<h5 id="加权最小二乘-weighted-least-squares"><a href="#加权最小二乘-weighted-least-squares" class="headerlink" title="加权最小二乘(weighted least-squares)"></a>加权最小二乘(weighted least-squares)</h5><p>加权最小二乘形式如下:</p>
<script type="math/tex; mode=display">\sum_{i=1}^k \omega_i(a_i^Tx-b_i)^2,</script><p>其中$\omega_1,\cdots,\omega_k$是正的，被最小化。 这里选出权重$\omega$来体现不同项$a_i^Tx-b_i$的比重, 或者仅仅用来影响结果。</p>
<h5 id="正则化-regularization"><a href="#正则化-regularization" class="headerlink" title="正则化(regularization)"></a>正则化(regularization)</h5><p>目标函数中被加入了额外项, 形式如下：</p>
<script type="math/tex; mode=display">\sum_{i=1}^k(a_i^Tx-b_i)^2 + \rho \sum_{i=1}^n x_i^2,</script><p>正则项是用来惩罚大的$x$, 求出一个仅仅最小化第一个求和项的不出来的好结果。合理的选择参数$\rho$在原始的目标函数和正则化项之间做一个trade-off, 使得$\sum_{k=1}^i(a_i^T - b_i)^2$和$\rho \sum_{k=1}^n x_i^2$都很小。<br>正则化项和加权最小二乘会在第六章中讲到，它们的统计解释在第七章给出。</p>
<h3 id="线性规划-linear-programming"><a href="#线性规划-linear-programming" class="headerlink" title="线性规划(linear programming)"></a>线性规划(linear programming)</h3><p>线性规划问题装目标函数和约束函数都是线性的：<br>\begin{align*}<br>&amp;minimize \quad c^Tx\\<br>&amp;subject \ to \quad a_i^T \le b_i, i = 1, \cdots, m.<br>\end{align*}<br>其中向量$c,a_1,\cdots,a_m \epsilon R^n$, 和标量$b_1,\cdots, b_m \epsilon R$是指定目标函数和约束函数条件的参数。</p>
<h4 id="求解线性规划-solving-linear-programs"><a href="#求解线性规划-solving-linear-programs" class="headerlink" title="求解线性规划(solving linear programs)"></a>求解线性规划(solving linear programs)</h4><ul>
<li>除了一个特例，没有解析解公式(和least-squares不同)；</li>
<li>有可靠且高效的算法实现；</li>
<li>时间复杂度是$O(n^2m)$, m是约束条件的个数, m是维度$；</li>
<li>是一个成熟的方法。</li>
</ul>
<h4 id="应用-using-linear-programs"><a href="#应用-using-linear-programs" class="headerlink" title="应用(using linear programs)"></a>应用(using linear programs)</h4><p>一些应用直接使用线性规划的标准形式,或者其中一个标准形式。在很多时候，原始的优化问题没有一个标准的线性规划形式，但是可以被转化为等价的线性规划形式。比如切米雪夫近似问题(Chebyshev approximation problem)。它的形式如下：</p>
<script type="math/tex; mode=display">minimize \quad max_{i=1,\cdots,k}|a_i^Tx-b_i|</script><p>其中$x\epsilon R^n$是变量，$a_1,\cdots,a_k \epsilon R^n, b_1,\cdots,b_k \epsilon R$是实例化的问题参数,和least-squares相似的是，它们的目标函数都是项$a^T_ix-b_i$。不同之处在于，least-squares用的是该项的平方和作为目标函数，而Chebyshev approximation中用的是绝对值的最大值。Chebyshev approximation problem的目标函数是不可导的(max operation), least-squares problem的目标函数是二次的(quadratic), 因此可导的(differentiable)。</p>
<h2 id="凸优化-Convex-optimization"><a href="#凸优化-Convex-optimization" class="headerlink" title="凸优化(Convex optimization)"></a>凸优化(Convex optimization)</h2><p>凸优化问题是优化问题的一种,它的目标函数和优化函数都是凸的。<br>具有以下形式的问题是一种凸优化问题：<br>\begin{align*}<br>&amp;minimize \quad f_0(x)\\<br>&amp;subject \ to \quad f_i(x) \le b_i, i = 1,\cdots,m.<br>\end{align*}<br>其中函数$f_0,\cdots,f_m:R^n \rightarrow R$是凸的(convex), 如满足</p>
<script type="math/tex; mode=display">f_i(\alpha x+ \beta y) \le \alpha f_i(x) + \beta f_i(y)</script><p>对于所有的$x,y \epsilon R^n$和所有的$\alpha, \beta \epsilon R$且$\alpha + \beta = 1, \alpha \ge 0, \beta \ge 0$。<br>或者：</p>
<script type="math/tex; mode=display">f_i(\theta x+ (1-\theta) y) \le \theta f_i(x) + (1 - \theta) f_i(y)</script><p>其中$\theta \epsilon [0,1]$。<br>课上有人问这里为$\theta$是0和1, 有没有什么物理意义，Stephen Boyd回答说这是定义，就是这么定义的。<br>The least-squares和linear programming problem都是convex optimization problem的特殊形式。线性函数(linear functions)也是convex，它们正处在边界上，它们的曲率(curvature)为0。一种方式是用正曲率去描述凸性。</p>
<h3 id="凸优化求解-solving-convex-optimization-problems"><a href="#凸优化求解-solving-convex-optimization-problems" class="headerlink" title="凸优化求解(solving convex optimization problems)"></a>凸优化求解(solving convex optimization problems)</h3><ul>
<li>没有解析解；</li>
<li>有可靠且有效的算法；</li>
<li>时间复杂度正比于$max{n^3, n^2m,F},$F$是评估$f$和计算一阶导数和二阶导数的时间；</li>
<li>有成熟的方法，如interior-point methods。</li>
</ul>
<h3 id="凸优化的应用-using-convex-optimization"><a href="#凸优化的应用-using-convex-optimization" class="headerlink" title="凸优化的应用(using convex optimization)"></a>凸优化的应用(using convex optimization)</h3><p>将实际问题形式化称凸优化问题。</p>
<h2 id="非线性优化-Nonlinear-optimization"><a href="#非线性优化-Nonlinear-optimization" class="headerlink" title="非线性优化(Nonlinear optimization)"></a>非线性优化(Nonlinear optimization)</h2><h3 id="非线性优化"><a href="#非线性优化" class="headerlink" title="非线性优化"></a>非线性优化</h3><p>非线性优化用来描述目标函数和约束函数都是非线性函数(但不是凸的)优化问题。因为凸优化问题包括least-squares和linear programming, 它们是线性的。刚开始给出的优化问题就是非线性优化问题，目前没有有效的方法解该问题。目前有一些方法来解决一般的非线性问题，但是都做了一些compromise。</p>
<h4 id="局部优化-local-optimization"><a href="#局部优化-local-optimization" class="headerlink" title="局部优化(local optimization)"></a>局部优化(local optimization)</h4><p>局部优化是非线性优化的一种解法，compromise是寻找局部最优点，而不是全局最优点，在可行解附近最小化目标函数，不保证能得到一个最小的目标值。<br>局部优化需要随机初始化一个初值，这个初值很关键，很大程度的影响了局部解得到的目标值, 也就是说是一个初值敏感的算法。关于初始值和全局最优值距离有多远并没有很多有用的信息。局部优化对于算法的参数值很敏感，需要根据具体问题去具体调整。<br>使用局部优化的方法比解least-squares problems, linear program, convex optimization problem更有技巧性，因为它牵扯到算法的选择，算法参数的选择，以及初值的选取。</p>
<h4 id="全局优化-global-optimization"><a href="#全局优化-global-optimization" class="headerlink" title="全局优化(global optimization)"></a>全局优化(global optimization)</h4><p>全局优化也是非线性优化的一种解法, 在全局优化中，优化目标的全局最优解被找到， compromise是效率。</p>
<h4 id="凸优化问题在非凸优化问题中的应用-role-of-convex-optimization-in-nonconvex-problems"><a href="#凸优化问题在非凸优化问题中的应用-role-of-convex-optimization-in-nonconvex-problems" class="headerlink" title="凸优化问题在非凸优化问题中的应用(role of convex optimization in nonconvex problems)"></a>凸优化问题在非凸优化问题中的应用(role of convex optimization in nonconvex problems)</h4><h5 id="初始化局部优化-initialization-for-local-optimization"><a href="#初始化局部优化-initialization-for-local-optimization" class="headerlink" title="初始化局部优化(initialization for local optimization)"></a>初始化局部优化(initialization for local optimization)</h5><h5 id="用于非凸优化的凸的启发式搜索-convex-heuristics-for-nonconvex-optimization"><a href="#用于非凸优化的凸的启发式搜索-convex-heuristics-for-nonconvex-optimization" class="headerlink" title="用于非凸优化的凸的启发式搜索(convex heuristics for nonconvex optimization)"></a>用于非凸优化的凸的启发式搜索(convex heuristics for nonconvex optimization)</h5><h5 id="全局最优的边界-bounds-for-global-optimization"><a href="#全局最优的边界-bounds-for-global-optimization" class="headerlink" title="全局最优的边界(bounds for global optimization)"></a>全局最优的边界(bounds for global optimization)</h5><h2 id="大纲-outline"><a href="#大纲-outline" class="headerlink" title="大纲(outline)"></a>大纲(outline)</h2><h3 id="理论-part-one-Theory"><a href="#理论-part-one-Theory" class="headerlink" title="理论(part one: Theory)"></a>理论(part one: Theory)</h3><p>第一部分是理论，给出一些概念和定义，第一章是Introduction, 第二章和第三章分别介绍凸集(convex set)和凸函数(convex function), 第四章介绍凸优化问题， 第五章引入拉格朗日对偶性。 </p>
<h3 id="应用-part-two-Applications"><a href="#应用-part-two-Applications" class="headerlink" title="应用(part two: Applications)"></a>应用(part two: Applications)</h3><p>第二部分主要给出凸优化在一些领域的应用，如概率论与数理统计，经济学，计算几何以及数据拟合等领域。<br>凸优化如何应用在实践中。</p>
<h3 id="算法-part-three-Algorithms"><a href="#算法-part-three-Algorithms" class="headerlink" title="算法(part three: Algorithms)"></a>算法(part three: Algorithms)</h3><p>第三部分给出了凸优化的数值解法，如牛顿法(Newton’s algorithm)和内点法(interior-point)。<br>第三部分有三章，分别包含了无约束优化，等式约束优化和不等式约束优化。章节之间是递进的，解一个问题被分解为解一系列简单问题。二次优化问题(包括，如least-squares)是最底层的基石，它可以通过线性方程组精确求解。牛顿法，在第十章和第十一章介绍到，是下个层次，无约束问题或者等式约束问题被转化成一系列二次优化问题的求解。第十一章介绍了内点法，是最顶层, 这些方法将不等式约束问题转化为一系列无约束或者等式约束的问题。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2018/12/22/latex笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/22/latex笔记/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">latex笔记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-22 10:08:26" itemprop="dateCreated datePublished" datetime="2018-12-22T10:08:26+08:00">2018-12-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/工具/" itemprop="url" rel="index"><span itemprop="name">工具</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="命令重命名"><a href="#命令重命名" class="headerlink" title="命令重命名"></a>命令重命名</h2><p>在写博客时也能用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">\newcommand&#123;\mmm&#125;&#123;\mathbf&#125;</span><br><span class="line">\mmm&#123;x&#125;</span><br><span class="line">\bf&#123;x&#125;</span><br></pre></td></tr></table></figure></p>
<p>$\newcommand{\mmm}{\mathbf}$<br>$\mmm{x}$<br>$\bf{x}$</p>
<h2 id="常用Latex符号"><a href="#常用Latex符号" class="headerlink" title="常用Latex符号"></a>常用Latex符号</h2><h3 id="括号"><a href="#括号" class="headerlink" title="括号"></a>括号</h3><p>\left(\frac{1}{2}\right)    $\left(\frac{1}{2} \right)$<br>\left[\frac{1}{2} \right]    $\left[\frac{1}{2} \right]$<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;cases&#125;x=1\\y=x\end&#123;cases&#125;</span><br></pre></td></tr></table></figure></p>
<script type="math/tex; mode=display">\begin{cases}x=1\\y=x\end{cases}</script><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;matrix&#125;1&amp;2\\3&amp;4\end&#123;matrix&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{matrix}1&2\\3&4\end{matrix}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;pmatrix&#125;1&amp;2\\3&amp;4\end&#123;pmatrix&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{pmatrix}1&2\\3&4\end{pmatrix}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;bmatrix&#125;1&amp;2\\3&amp;4\end&#123;bmatrix&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{bmatrix}1&2\\3&4\end{bmatrix}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;Bmatrix&#125;1&amp;2\\3&amp;4\end&#123;Bmatrix&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{Bmatrix}1&2\\3&4\end{Bmatrix}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;vmatrix&#125;1&amp;2\\3&amp;4\end&#123;vmatrix&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{vmatrix}1&2\\3&4\end{vmatrix}</script><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;Vmatrix&#125;1&amp;2\\3&amp;4\end&#123;Vmatrix&#125;</span><br></pre></td></tr></table></figure>
<script type="math/tex; mode=display">\begin{Vmatrix}1&2\\3&4\end{Vmatrix}</script><h3 id="希腊字母"><a href="#希腊字母" class="headerlink" title="希腊字母"></a>希腊字母</h3><p>$\eta$ \eta<br>$\gamma$ \gamma<br>$\epsilon$ \epsilon<br>$\varepsilon$ \varepsilon<br>$\lambda$ \lambda<br>$\Lambda$ \Lambda<br>$\sigma$ \sigma<br>$\Sigma$ \Sigma<br>$\phi$ \phi<br>$\varphi$ \varphi<br>$\Phi$ \Phi<br>$\Delta$ \Delta<br>$\delta$ \delta<br>$\nabla$ \nabla</p>
<h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><p>$\mathbf{A}$ \mathbf{A}<br>$\boldsymbol{A}$ \boldsymbol{A}<br>$\mathit{A}$ \mathit{A}<br>$\mathrm{A}$ \mathrm{A}<br>$\mathcal{A}$ \mathcal{A}</p>
<h3 id="数学运算"><a href="#数学运算" class="headerlink" title="数学运算"></a>数学运算</h3><p>求积$\prod$ \prod<br>求和$\sum$ \sum<br>积分$\int$ \int<br>根号$\sqrt{x}$ \sqrt{x}<br>根号$\sqrt[4]{y}$ \sqrt[4]{y}<br>分数$(\frac{1}{2})$ (\frac{1}{2})<br>分数$\left(\frac{1}{2}\right)$ \left(\frac{1}{2}\right)<br>无穷$\infty$ \infty<br>期望$\mathbb{E}$ \mathbb{E}<br>$\mathbb{\pi}$ \mathbb{\pi} # 可以看出来，没有起作用，因为mathbb没有只支持大写字母。<br>$\pm$ \pm<br>$\mp$ \mp</p>
<h3 id="上下花括号"><a href="#上下花括号" class="headerlink" title="上下花括号"></a>上下花括号</h3><p>$\overbrace{x+y}^{1+2}=\underbrace{z}_3$ \overbrace{x+y}^{1+2}=\underbrace{z}_3</p>
<h3 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h3><p>真含于$\subset$ \subset<br>含于$\subsetneqq$ \subsetneqq<br>真包含$\supset$ \supset<br>包含$\supsetneqq$ \supsetneqq<br>交$\cap$ \cap<br>并$\cup$ \cup<br>属于$\in$ \in<br>$\succ$ \succ<br>$\succeq$ \succeq<br>$\prec$ \prec<br>$\preceq$ \preceq</p>
<h3 id="谓词逻辑"><a href="#谓词逻辑" class="headerlink" title="谓词逻辑"></a>谓词逻辑</h3><p>否定$\neg$ \neg<br>任意$\forall$ \forall<br>存在$\exists$ \exists<br>合取$\wedge$ \wedge<br>析取$\vee$ \vee</p>
<h3 id="空格"><a href="#空格" class="headerlink" title="空格"></a>空格</h3><p>$a\qquad b$ a\qquad b<br>$a\quad b$ a\quad b<br>$a\ b$ a\ b<br>$a\;b$ a\;b<br>$a\,b$ a\,b<br>$ab$ ab<br>$a!b$ a!b</p>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>长竖线$\big|$ \big|<br>长竖线$\Big|$ \Big|<br>长竖线$\bigg|$ \bigg|<br>长竖线$\Bigg|$ \Bigg|<br>双箭头$\Leftrightarrow$ \Leftrightarrow<br>左箭头$\leftarrow$ \leftarrow<br>右箭头$\rightarrow$ \rightarrow<br>范数$\Vert$ \Vert<br>上划线$\overline{A}$ \overline{A}<br>下划线$\underline{A}$ \underline{A}<br>$\backslash$ \backslash<br>$\sim$ \sim</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;enumerate&#125;</span><br><span class="line"> \item First.</span><br><span class="line"> \item Second.</span><br><span class="line"> \item Third.</span><br><span class="line">\end&#123;enumerate&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ol>
<li>First.</li>
<li>Second.</li>
<li>Third.</li>
</ol>
<h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;itemize&#125;</span><br><span class="line"> \item &#123;First.&#125;</span><br><span class="line"> \item &#123;Second.&#125;</span><br><span class="line"> \item &#123;Third.&#125;</span><br><span class="line">\end&#123;itemize&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<ul>
<li>First.</li>
<li>Second.</li>
<li>Third.</li>
</ul>
<h2 id="跨多行公式对齐"><a href="#跨多行公式对齐" class="headerlink" title="跨多行公式对齐"></a>跨多行公式对齐</h2><p><strong>注意：不要忘了每行后面的两个\\</strong></p>
<h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align*&#125;</span><br><span class="line">f(x) &amp;= (3 + 4)^2 + 4\\</span><br><span class="line">&amp;= 7^2 + 4\\</span><br><span class="line">&amp;= 49 + 4\\</span><br><span class="line">&amp;= 53</span><br><span class="line">\end&#123;align*&#125;</span><br></pre></td></tr></table></figure>
<p>效果如下：<br>\begin{align*}<br>f(x) &amp;= (3 + 4)^2 + 4\\<br>&amp;= 7^2 + 4\\<br>&amp;= 49 + 4\\<br>&amp;= 53<br>\end{align*}</p>
<h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">\begin&#123;align*&#125;</span><br><span class="line">v &amp;= R + \gamma Pv\\</span><br><span class="line">(1-\gamma P) &amp;= R\\</span><br><span class="line">v &amp;= (1 - \gamma P)^&#123;-1&#125; R</span><br><span class="line">\end&#123;align*&#125;</span><br></pre></td></tr></table></figure>
<p>\begin{align*}<br>v &amp;= R + \gamma Pv\\<br>(1-\gamma P) &amp;= R\\<br>v &amp;= (1 - \gamma P)^{-1} R<br>\end{align*}</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="http://blog.huangyuanlove.com/2018/02/27/LaTeX笔记-六/" target="_blank" rel="noopener">http://blog.huangyuanlove.com/2018/02/27/LaTeX笔记-六/</a><br>2.<a href="https://blog.csdn.net/xxzhangx/article/details/52778539" target="_blank" rel="noopener">https://blog.csdn.net/xxzhangx/article/details/52778539</a><br>3.<a href="https://blog.csdn.net/hunauchenym/article/details/7330828" target="_blank" rel="noopener">https://blog.csdn.net/hunauchenym/article/details/7330828</a><br>4.<a href="http://geowu.blogspot.com/2012/10/latex_25.html" target="_blank" rel="noopener">http://geowu.blogspot.com/2012/10/latex_25.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2018/12/21/reinforcement-learning-an-introduction-第3章笔记/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2018/12/21/reinforcement-learning-an-introduction-第3章笔记/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/12/index.html">reinforcement learning an introduction 第3章笔记</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2018-12-21 15:13:38" itemprop="dateCreated datePublished" datetime="2018-12-21T15:13:38+08:00">2018-12-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-07 00:22:27" itemprop="dateModified" datetime="2019-05-07T00:22:27+08:00">2019-05-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/强化学习/" itemprop="url" rel="index"><span itemprop="name">强化学习</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="马尔科夫过程-markov-process-、马尔科夫链-markov-chain"><a href="#马尔科夫过程-markov-process-、马尔科夫链-markov-chain" class="headerlink" title="马尔科夫过程(markov process)、马尔科夫链(markov chain)"></a>马尔科夫过程(markov process)、马尔科夫链(markov chain)</h2><p>马尔科夫过程或者马尔科夫链(markov chain)是一个tuple $\lt S,P\gt$,其中S是一个有限(或者无限)的状态集合,P是状态转移矩阵(transition probability matrix)或马尔科夫矩阵(markov matrix),$P_{ss’}= P[S_{t+1} = s’|S_t = s]$.</p>
<h2 id="马尔科夫奖励过程-markov-reward-process"><a href="#马尔科夫奖励过程-markov-reward-process" class="headerlink" title="马尔科夫奖励过程(markov reward process)"></a>马尔科夫奖励过程(markov reward process)</h2><p>马尔科夫奖励过程是一个tuple $\lt S,P,R,\gamma\gt$,和马尔科夫过程相比，它多了一个奖励R，R和某个具体的状态相关，MRP中的reward只和state有关,和action无关。<br>S是一个(有限)状态的集合。<br>P是一个状态转移概率矩阵。<br>R是一个奖励函数$R = \mathbb{E}[R_{t+1}|S_t = s]$, <strong>这里为什么是t+1时刻的reward?这仅仅是一个约定，为了描述RL问题中涉及到的observation，action，reward比较方便。这里可以理解为离开这个状态才能获得奖励而不是进入这个状态即获得奖励。如果改成$R_t$也是可以的，这时可以理解为进入这个状态获得的奖励。</strong><br>$\gamma$称为折扣因子(discount factor), $\gamma \epsilon [0,1]$.<strong>为什么引入$\gamma$，David Silver的公开课中提到了四个原因:(1)数学上便于计算回报(return)；(2)避免陷入无限循环；(3)长远利益具有一定的不确定性；(4)符合人类对眼前利益的追求。</strong></p>
<h3 id="奖励-reward"><a href="#奖励-reward" class="headerlink" title="奖励(reward)"></a>奖励(reward)</h3><p>每个状态s在一个时刻t立即可得到一个reward,reward的值需要由环境给出,这个值可正可负。目前的强化学习算法中reward都是人为设置的。</p>
<h3 id="回报-return"><a href="#回报-return" class="headerlink" title="回报(return)"></a>回报(return)</h3><p>回报是累积的未来的reward,其计算公式如下:</p>
<script type="math/tex; mode=display">G_t = R_{t+1} + R_{t+2} + ... = \sum_{k=0}^{\infty}{\gamma^k R_{t+k+1}} \tag{1}</script><p>它是一个马尔科夫链上从t时刻开始往后所有奖励的有衰减(带折扣因子)的总和。</p>
<h3 id="值函数-value-function"><a href="#值函数-value-function" class="headerlink" title="值函数(value function)"></a>值函数(value function)</h3><p>值函数是回报(return)的期望(expected return), 一个MRP过程中某一状态的value function为从该状态开始的markov charin return的期望，即$v(s) = \mathbb{E}[G_t|S_t=s]$.<br>MRP的value function和MDP的value function是不同的, MRP的value function是对于state而言的，而MDP的value function是针对tuple $\lt$state, action$\gt$的。<br>这里为什么要取期望,因为policy是stotastic的情况时，在每个state时，采取每个action都是可能的，都有一定的概率，next state也是不确定的了，所以value funciton是一个随机变量，因此就引入期望来刻画随机变量的性质。<br>为什么在当前state就知道下一时刻的state了?对于有界的RL问题来说，return是在一个回合结束时候计算的；对于无界的RL问题来说，由于有衰减系数，只要reward有界，return就可以计算出来。</p>
<h3 id="马尔科夫奖励过程的贝尔曼方程-bellman-equation-for-MRP"><a href="#马尔科夫奖励过程的贝尔曼方程-bellman-equation-for-MRP" class="headerlink" title="马尔科夫奖励过程的贝尔曼方程(bellman equation for MRP)"></a>马尔科夫奖励过程的贝尔曼方程(bellman equation for MRP)</h3><p>\begin{align*}<br>v(s) &amp;= \mathbb{E}[G_t|S_t = s]\\<br>&amp;= \mathbb{E}[R_{t+1} + \gamma R_{t+2} + … | S_t = s]\\<br>&amp;= \mathbb{E}[R_{t+1} + \gamma (R_{t+2} + \gamma R_{t+3} + …|S_t = s]\\<br>&amp;= \mathbb{E}[R_{t+1} + \gamma G_{t+1} |S_t = s]\\<br>&amp;= \mathbb{E}[R_{t+1} + \gamma v(S_{t+1})|S_t = s]\\<br>v(s) &amp;= \mathbb{E}[R_{t+1} + \gamma v(S_{t+1})|S_t = s]<br>\end{align*}<br>v(s)由两部分组成，一部分是immediate reward的期望(expectation)，$\mathbb{E}[R_{t+1}]$, 只与当前时刻state有关；另一部分是下一时刻state的value function的expectation。如果用s’表示s状态下一时刻的state，那么bellman equation可以写成：</p>
<script type="math/tex; mode=display">v(s) = R_s + \gamma \sum_{s' \epsilon S} P_{ss'}v(s')</script><p>我们最终的目的是通过迭代使得t轮迭代时的v(s)和第t+1轮迭代时的v(s)相等。将其写成矩阵形式为：</p>
<script type="math/tex; mode=display">v_t = R + \gamma P v_{t+1}</script><script type="math/tex; mode=display">(v_1,v_2,...,v_n)^T = (R_1,R_2,...,R_n)^T + \gamma \begin{bmatrix}P_{11}&P_{12}&...&P_{1n}\\P_{21}&P_{22}&...&P_{2n}\\&&...&\\P_{n1}&P_{n2}&...&P_{nn}\end{bmatrix} (v_1,v_2,...,v_n)^T</script><p>MRP的Bellman方程组是线性的，可以直接求解:<br>\begin{align*}<br>v &amp;= R + \gamma Pv\\<br>(1-\gamma P) &amp;= R\\<br>v &amp;= (1 - \gamma P)^{-1} R<br>\end{align*}<br>可以直接解方程，但是复杂度为$O(n^3)$，对于大的MRP方程组不适用，可以通过迭代法求解，常用的迭代法有动态规划,蒙特卡洛算法和时序差分算法等求解(动态规划是迭代法吗？）</p>
<h2 id="马尔科夫决策过程-markov-decision-process"><a href="#马尔科夫决策过程-markov-decision-process" class="headerlink" title="马尔科夫决策过程(markov decision process)"></a>马尔科夫决策过程(markov decision process)</h2><p>马尔科夫决策过程，比markov reward process多了一个A,它也是一个tuple $\lt S,A,P,R,\gamma\gt$, 在MRP中奖励R仅仅和状态S相关，在MDP中奖励R和概率P对应的是某个状态S和某个动作A的组合。<br>\begin{align*}<br>P_{ss’}^a &amp;= P[S_{t+1} = s’ | S_t = s, A_t = a]\\<br>R_s^a &amp;= \mathbb{E}[R_{t+1} | S_t = s, A_t = a]<br>\end{align*}<br>这里的reward不仅仅与state相关，而是与tuple $\lt state，action\gt$相关。</p>
<h3 id="回报"><a href="#回报" class="headerlink" title="回报"></a>回报</h3><p>MDP中的$G_t$和式子$(1)$的$G_t$是一样的，将$G_t$写成和后继时刻相关的形式如下：<br>\begin{align*}<br>G_t &amp;= R_{t+1} + \gamma R_{t+2} + \gamma^2 R_{t+3} + \gamma^3 R_{t+4} + …\\<br>&amp;= R_{t+1} + \gamma (R_{t+2} + \gamma^1 R_{t+3} + \gamma^2 R_{t+4} + …)\\<br>&amp;= R_{t+1} + \gamma G_{t+1} \tag{2}<br>\end{align*}<br>这里引入$\gamma$之后，即使是在continuing情况下，只要$G_t$是非零常数，$G_t$也可以通过等比数列求和公式进行计算，即:</p>
<script type="math/tex; mode=display">G_t = \sum_{k=1}^{\infty}\gamma^k = \frac{1}{1-\gamma} \tag{3}</script><h3 id="策略-policy"><a href="#策略-policy" class="headerlink" title="策略(policy)"></a>策略(policy)</h3><p>策略$\pi$的定义:给定状态时采取各个动作的概率分布。</p>
<script type="math/tex; mode=display">\pi(a|s) = P[A_t = a | S_t = a] \tag{4}</script><h3 id="值函数-value-function-1"><a href="#值函数-value-function-1" class="headerlink" title="值函数(value function)"></a>值函数(value function)</h3><p>这里给出的是值函数的定义，就是这么定义的。<br>MDP的值函数有两种，状态值函数(state value function)和动作值函数(action value function), 这两种值函数的含义其实是一样的，也可以相互转换。具体来说, 值函数定义为给定一个policy $\pi$，得到的回报的期望(expected return)。<br>一个MDP的状态s对应的值函数(state value function) $v_{\pi}(s)$是从状态s开始采取策略$\pi$得到的回报的期望。<br>\begin{align*}<br>v_{\pi}(s) &amp;= \mathbb{E}_{\pi}[G_t|S_t = s]\\<br>&amp;=\mathbb{E}_{\pi}[\sum_{k=0}^{\infty} \gamma^{k}R_{t+k+1}|S_t=s] \tag{5}<br>\end{align*}<br>这里的$G_t$是式子(2)中的回报。<br>一个MDP过程中动作值函数(action value function) $q_{\pi}(s,a)$是从状态s开始,采取action a，采取策略$\pi$得到的回报的期望。</p>
<p><action value function $q_{\pi}(s,a)$ is the expected return starting from states, taking action a, and then following policy \pi.><br>\begin{align*}<br>q_{\pi}(s,a) &amp;= \mathbb{E}_{\pi}\left[G_t | S_t = s, A_t = a\right]\\<br>&amp;= \mathbb{E}_{\pi}\left[\sum_{k=0}^{\infty} \gamma^{k}R_{t+k+1}|S_t=s, A_t=a\right] \tag{6}<br>\end{align*}</action></p>
<h4 id="状态值函数-state-value-function"><a href="#状态值函数-state-value-function" class="headerlink" title="状态值函数(state value function)"></a>状态值函数(state value function)</h4><p>\begin{align*}<br>v_{\pi}(s) &amp;= \sum_{a \epsilon A} \pi(a|s) q_{\pi} (s,a) \tag{7}\\<br>v_{\pi}(s) &amp;= \sum_a \pi(a|s)\sum_{s’,r}p(s’,r|s,a) \left[r + \gamma v_{\pi}(s’) \right] \tag{8}\\<br>\end{align*}<br>式子$(7)$是$v(s)$和$q(s,a)$的关系，式子$(8)$是$v(s)$和它的后继状态$v(s’)$的关系。<br>式子$(8)$的推导如下：<br>\begin{align*}<br>v_{\pi}(s) &amp;= \mathbb{E}_{\pi}[G_t|S_t = s]\\<br>&amp;= \mathbb{E}_{\pi}\left[R_{t+1}+\gamma G_{t+1}|S_t = s\right]\\<br>&amp;= \sum_a \pi(a|s)\sum_{s’}\sum_rp(s’,r|s,a) \left[r + \gamma \mathbb{E}_{\pi}\left[G_{t+1}|S_{t+1}=s’\right]\right]\\<br>&amp;= \sum_a \pi(a|s)\sum_{s’,r}p(s’,r|s,a) \left[r + \gamma v_{\pi}(s’) \right]\\<br>\end{align*}</p>
<h4 id="动作值函数-action-value-function"><a href="#动作值函数-action-value-function" class="headerlink" title="动作值函数(action value function)"></a>动作值函数(action value function)</h4><p>\begin{align*}<br>q_{\pi}(s,a) &amp;= \sum_{s’}\sum_r p(s’,r|s,a)(r + \gamma  v_{\pi}(s’)) \\<br>q_{\pi}(s,a) &amp;= \sum_{s’}\sum_r p(s’,r|s,a)(r + \gamma  \sum_{a’}\pi(a’|s’)q(s’,a’)) \tag{10}\\<br>\end{align*}<br>式子$(9)$是$q(s,a)$和$v(s)$的关系，式子$(10)$是$q(s,a)$和它的后继状态$q(s’,a’)$的关系。<br>以上都是针对MDP来说的，在MDP中，给定policy $\pi$下，状态s下选择a的action value function，$q_{\pi}(s,a)$类似MRP里面的v(s)，而MDP中的v(s)是要考虑在state s下采率各个action后的情况。</p>
<h3 id="贝尔曼期望方程-Bellmam-expectation-equation"><a href="#贝尔曼期望方程-Bellmam-expectation-equation" class="headerlink" title="贝尔曼期望方程(Bellmam expectation equation)"></a>贝尔曼期望方程(Bellmam expectation equation)</h3><p>\begin{align*}<br>v_{\pi}(s) &amp;= \mathbb{E}_{\pi}[R_{t+1} + \gamma v_{\pi}(S_{t+1})|S_t = s] \tag{11}\\<br>v_{\pi}(s) &amp;= \mathbb{E}_{\pi}\left[q_{\pi}(S_t,A_t)|S_t=s,A_t=a\right]\tag{12}\\<br>q_{\pi}(s,a)&amp;= \mathbb{E}_{\pi}\left[R+\gamma v_{\pi}(S_{t+1}) |S_t=s,A_t=a\right]\tag{13}\\<br>q_{\pi}(s,a) &amp;= \mathbb{E}_{\pi}[R_{t+1} + \gamma q_{\pi}(S_{t+1},A_{t+1}) | S_t = s, A_t = a] \tag{14}<br>\end{align*}</p>
<h4 id="矩阵形式"><a href="#矩阵形式" class="headerlink" title="矩阵形式"></a>矩阵形式</h4><p>\begin{align*}<br>v_{\pi} &amp;= R^{\pi} + \gamma P^{\pi} v_{\pi}\\<br>v_{\pi} &amp;= (I-\gamma P^{\pi})^{-1} R^{\pi}<br>\end{align*}</p>
<h2 id="最优策程的求解-how-to-find-optimal-policy"><a href="#最优策程的求解-how-to-find-optimal-policy" class="headerlink" title="最优策程的求解(how to find optimal policy)"></a>最优策程的求解(how to find optimal policy)</h2><h3 id="最优价值函数-optimal-value-function"><a href="#最优价值函数-optimal-value-function" class="headerlink" title="最优价值函数(optimal value function)"></a>最优价值函数(optimal value function)</h3><p>$v_{*} = max_{\pi}v_{\pi}(s)$,从所有策略产生的state value function中，选取使得state s的价值最大的函数<br>$q_{*}(s,a) = max_{\pi} q_{\pi}(s,a)$,从所有策略产生的action value function中，选取使$\lt s,a\gt$价值最大的函数<br>当我们得到了optimal value function，也就知道了每个state的最优价值，便认为这个MDP被解决了</p>
<h3 id="最优策略-optimal-policy"><a href="#最优策略-optimal-policy" class="headerlink" title="最优策略(optimal policy)"></a>最优策略(optimal policy)</h3><p>对于每一个state s，在policy $\pi$下的value 大于在policy $\pi’$的value， 就称策略$\pi$优于策略$\pi’$， $\pi \ge \pi’$ if $v_{\pi}(s) \ge v_{\pi’}(s)$, 对于任意s都成立<br>对于任何MDP，都满足以下条件：</p>
<ol>
<li>都存在一个optimal policy，它比其他策略好或者至少相等；</li>
<li>所有的optimal policy的optimal value function是相同的；</li>
<li>所有的optimal policy 都有相同的 action value function.</li>
</ol>
<h3 id="寻找最优策略"><a href="#寻找最优策略" class="headerlink" title="寻找最优策略"></a>寻找最优策略</h3><p>寻找optimal policy可以通过寻找optimal action value function来实现： </p>
<script type="math/tex; mode=display">{\pi}_{*}(a|s) = 
\begin{cases}
1, &if\quad a = argmax\ q_{*}(s,a)\\
0, &otherwise\end{cases}</script><h3 id="贝尔曼最优方程-bellman-optimal-equation"><a href="#贝尔曼最优方程-bellman-optimal-equation" class="headerlink" title="贝尔曼最优方程(bellman optimal equation)"></a>贝尔曼最优方程(bellman optimal equation)</h3><p>*号表示最优的策略。</p>
<h4 id="最优状态值函数-state-value-function"><a href="#最优状态值函数-state-value-function" class="headerlink" title="最优状态值函数(state value function)"></a>最优状态值函数(state value function)</h4><p>\begin{align*}<br>v_{*}(s) &amp;= max_a q_{*}(s,a)\\<br>&amp;= max_a\mathbb{E}_{\pi_{*}}\left[G_t|S_t=s,A_t=a\right]\\<br>&amp;= max_a\mathbb{E}_{\pi_{*}}\left[R_{t+1}+\gamma G_t|S_t=s,A_t=a\right]\\<br>&amp;= max_a\mathbb{E}\left[R_{t+1} +\gamma v_{*}(S_{t+1})|S_t=s,A_t=a\right]\\<br>&amp;= max_a \left[\sum_{s’,r} p(s’,r|s,a){*}(r+\gamma v_{*}(s’) )\right] \tag{15}\\<br>\end{align*}</p>
<h4 id="最优动作值函数-action-value-function"><a href="#最优动作值函数-action-value-function" class="headerlink" title="最优动作值函数(action value function)"></a>最优动作值函数(action value function)</h4><p>\begin{align*}<br>q_{*}(s,a) &amp;= \sum_{s’,r} p(s’,r|s,a) (r + \gamma v_{*}(s’))\\<br>&amp;= \sum_{s’,r} p(s’,r|s,a) (r + \gamma max_{a’} q_{*}(s’,a’))\\<br>&amp;=\mathbb{E}\left[R_{t+1}+\gamma max_{a’}q_{*}(S_{t+1},a’)|S_t=s,A_t=a \right]\tag{16}\\<br>\end{align*}</p>
<h3 id="贝尔曼最优方程的求解-solution-to-Bellman-optimal-equation"><a href="#贝尔曼最优方程的求解-solution-to-Bellman-optimal-equation" class="headerlink" title="贝尔曼最优方程的求解(solution to Bellman optimal equation)"></a>贝尔曼最优方程的求解(solution to Bellman optimal equation)</h3><p>Bellman equation和Bellman optimal equation相比，一个是对于给定的策略，求其对应的value function,是对一个策略的估计，而bellman optimal equation是要寻找最优策略，通过对action value function进行贪心。<br>Bellman最优方程是非线性的，没有固定的解决方案，只能通过迭代法来解决，如Policy iteration，value iteration，Q-learning，Sarsa等。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.<a href="http://incompleteideas.net/book/the-book-2nd.html" target="_blank" rel="noopener">http://incompleteideas.net/book/the-book-2nd.html</a><br>2.<a href="https://www.bilibili.com/video/av32149008/?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/av32149008/?p=2</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/11/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><span class="page-number current">12</span><a class="page-number" href="/page/13/">13</a><a class="extend next" rel="next" href="/page/13/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">122</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">12</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">106</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  

  

</body>
</html>
