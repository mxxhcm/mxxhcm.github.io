<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/3/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/3/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/28/C-separate-compilation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/C-separate-compilation/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">C/C++ separate compilation</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 23:24:38" itemprop="dateCreated datePublished" datetime="2019-11-28T23:24:38+08:00">2019-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-10 19:27:09" itemprop="dateModified" datetime="2019-12-10T19:27:09+08:00">2019-12-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="功能文件头文件和实现">功能文件头文件和实现</h2>
<h3 id="头文件">头文件</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print_string.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT_STRING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_STRING</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="实现">实现</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print_string.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print_string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,  str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试文件实现">测试文件实现</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print_string.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line">    print_string(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译和链接">编译和链接</h2>
<p>执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp print_string.cpp -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>
<h2 id="理解">理解</h2>
<p>在<code>main</code>中包含了<code>print_string.h</code>头文件，相当于对函数进行了声明。然后使用<code>g++</code>编译的时候相当于提供了<code>print_string</code>的实现。</p>
<p>关于分离式编译的原理可以查看<a href>CSAPP linking</a>。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/28/UNIX-Process-Relationships/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/UNIX-Process-Relationships/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">Process Relationships</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 00:06:11" itemprop="dateCreated datePublished" datetime="2019-11-28T00:06:11+08:00">2019-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-04 15:22:26" itemprop="dateModified" datetime="2019-12-04T15:22:26+08:00">2019-12-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>在UNIX Process Control中，介绍了：</p>
<ol>
<li>每一个进程都有一个父进程，初始的kernel-level的进程通常是它自己。</li>
<li>当子进程终止的时候，父进程可以获得子进程的exit status。</li>
<li>同时在介绍<code>waitpid</code>的时候`提到了process groups，并且解释了我们可以等待一个进程组中任意进程的终止。</li>
</ol>
<p>这一篇文章更详细的介绍了process groups，以及POSIX.1中引入的session的概念。同时还介绍了用于登录的login shell和所有从login shell中启动的进程的关系。</p>
<h2 id="终端登录">终端登录</h2>
<h3 id="bsd登录">BSD登录</h3>
<p>系统bootstrap时，内核创建进程号为1的init进程。init进程使系统进行入多用户模式，init读取文件<code>/etc/tty</code>，对每一个允许登录的终端设备，init调用一次<code>fork</code>，它所生成的子程序<code>exec getty</code>程序。<br>
<code>getty</code>对终端设备调用<code>open</code>函数，以读写方式打开终端。一旦终端被打开，文件描述符0,1,2就被关联到该设备。然后<code>getty</code>输出<code>login</code>等字样，等待用户输入。当用户输入username之后，<code>getty</code>工作就结束了，接下来通过类似于以下的方式调用<code>login</code>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execle(&quot;/bin/login&quot;, &quot;login&quot;, &quot;-p&quot;, username, (char*)0, envp);</span><br></pre></td></tr></table></figure></p>
<p><code>login</code>得到了用户名，接下来调用<code>getpasswd</code>提示用户键入密码，然后调用<code>crypt</code>将用户键入的口令和shadow中的pwsswd比较，判断密码是否正确。如果密码正确的话，<code>login</code>还会进行以下工作：</p>
<ol>
<li>将当前工作目录改为用户的主目录。</li>
<li>调用<code>chown</code>更改终端的控制权，使登录用户成为它的所有者。</li>
<li>对终端设备的权限改成用户读和写。</li>
<li>用<code>login</code>得到的所有参数进行初始化</li>
<li><code>login</code>进程更改登录用户的<code>uid</code>并调用该用户的登录shell。</li>
</ol>
<p>当然现代的<code>login</code>不仅仅进行这些工作，还会根据启动文件更改或者增加用户的环境变量等等。</p>
<h2 id="网络登录">网络登录</h2>
<h3 id="bsd登录-v2">BSD登录</h3>
<p>网络登录的话，BSD中有一个inetd进程，等待绝大多数互联想链接。作为系统启动的一部分，<code>init</code>调用一个shell，使其执行shell脚本/etc/rc，shell脚本启动一个守护进程inetd。当这个shell脚本终止时，inetd的进程变成init。inetd等待TCP/IP连接，每当有一个连接到达时，就执行一次<code>fork</code>，然后使用<code>exec</code>执行相应的子程序。<br>
比如一个TELNET服务请求。客服进程打开一个到服务主机的TCP连接，客户机运行TELNET服务进程（用telnetd表示）。它们之间使用TELNET应用协议通过TCP交换数据。客服进程的用户登录到服务进程所在的主机。<br>
然后telnetd进程打开一个伪终端设备，并且使用<code>fork</code>将它们分成两个进程。父进程处理通过网络的通信，子进程执行login程序。父进程和子进程之间通过伪终端相连接。在调用<code>exec</code>之前，子进程使其文件描述符0,1,2和伪终端相连。登录成功的话，执行和终端操作类似的设置。</p>
<p>当通过终端或者网络登录时，我们得到一个登录shell，它的标准输入，标准输出和标准错误要么连接到一个终端设备，要么连接到一个伪终端设备。</p>
<h2 id="进程组">进程组</h2>
<p>除了pid，每一个进程还属于一个process group。进程组是一个或者一组进程的集合。他们都是同一个job的进程，每一个进程组都有一个唯一的进程组id，和pid类似，可以存放在pid_t中。函数<code>getpgrp</code>获得process group的ID，<code>getpgid</code>获得指定进程的进程组ID，它们都是SUS定义的。<br>
每个进程组有一个组长进程，组长进程的进程组ID和它的进程ID一样。进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，那么该进程组就存在，跟其组长是否终止无关。<br>
可以调用<code>setpgid</code>创建一个新的进程组后者加入一个现有的进程组。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>setpgid</code>将pid号为pid的进程的进程组ID设置为pgid。当子进程调用了<code>exec</code>之后，父进程就不能修改子进程的进程组ID了。<br>
通常在job control shell中，在fork之后调用此函数，父进程设置子进程的进程组ID，子进程也设置子进程的进程组ID，这两个调用总有一个是重复的，但是可以确保子进程的组ID被正确设置了。</p>
<h2 id="session">Session</h2>
<p>Session是一个或者多个进程组的集合。比如一个session可以有三个进程组：<br>
进程组1：登录shell，<br>
进程组2：proc1, proc2<br>
进程组3：proc3, proc4, proc5<br>
等等。通常一个进程组的进程是由一个shell pipeline生成的。比如上面的进程组可能是通过以下shell命令实现的：<br>
proc1 | proc2 &amp;<br>
proc3 | proc4 | proc5</p>
<p>可以调用<code>setsid</code>创建一个新的session：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个函数具有以下性质：<br>
如果调用这个函数的进程不是一个进程组的组长，就创建一个新的session：</p>
<ol>
<li>该进程变成新的session的session leader，这个session leader是创建该session的进程。注意SUS只说明了session leader，而没有像pid和process gid之类的session id。也就是说session leader是有唯一PID的单个进程，可以将session leader的ID当做session ID。<strong>注意什么是session leader，它是一个进程，而session ID是session leader的PID，或者也把session ID较为session leader的process group ID</strong>。</li>
<li>调用进程是新进程组和新session中的唯一一个进程。</li>
<li>新的session没有controlling terminal。</li>
</ol>
<h2 id="控制终端">控制终端</h2>
<p>session和process group的一些其他属性：</p>
<ul>
<li>一个session通常会有一个controlling terminal，通常是终端设备或者伪终端设备。</li>
<li>建立和控制终端连接的session leader被称为controlling process（控制进程）。</li>
<li>一个session中的几个process group可以被分为一个foreground process group（前台进程组）和多个background process group（后台进程组）。</li>
<li>如果一个session有一个controlling terminal，那么它有一个前台进程组，其它进程组为后台进程组。</li>
<li>无论何时键入终端的中断键，ctrl+C，都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键，ctrl+\，都会将退出信号发送到前台进程组的所有进程。</li>
<li>如果终端接口检测到网络已经断开，将挂断信号发送到session leader。</li>
</ul>
<p>登录shell属于后台进程组，它是session leader，也就是controlling process。登录时，会自动建立controlling terminal。有时候不管标准输入，标准输出是否重定向，程序都要和控制终端交互，可以open文件/dev/tty。在内核中，/dev/tty是controlling terminal的同义词，如果没有controlling terminal，对于这个设备的open失败。</p>
<h2 id="tcgetpgrp-tcsetpgrp和tcgetsid"><code>tcgetpgrp</code>, <code>tcsetpgrp</code>和<code>tcgetsid</code></h2>
<h3 id="函数原型">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> tcgetpgrp(<span class="keyword">int</span> fd);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> tcgetsid(<span class="keyword">int</span> fd);</span><br></pre></td></tr></table></figure>
<h3 id="属性">属性</h3>
<ol>
<li><code>tcgetpgrp</code>返回前台进程组ID，它与在fd上打开的终端相关联。</li>
<li>如果进程有一个controlling terminal，这个进程可以调用<code>tcsetpgrp</code>将前台进程组ID设置为pgrpid，fd必须引用该session的controlling terminal。</li>
<li>可以通过<code>tcgetsid</code>函数获得session leader的进程组ID。</li>
</ol>
<h2 id="job-control">job control</h2>
<p>可以在一个终端上启动多个jobs（groups of process），它控制哪个job可以访问终端，哪个job应该在后台运行，job control需要满足以下三个条件：</p>
<ol>
<li>支持job control的shell</li>
<li>内核的终端驱动程序必须支持job contrl</li>
<li>内核必须支持某些特定的job-control signals。</li>
</ol>
<p>在shell中使用job contrl，我们可以创建前台的job，也可以创建后台的job，一个job是进程的集合，通常是进程的pipeline，可以在后台运行多个job。<br>
可以通过键入几个特殊字符和终端驱动程序进行交互作用，控制前台进程组的所有进程：</p>
<ul>
<li>中断，ctrl+C，产生SIGINT</li>
<li>退出，ctrl+\，产生SIGQUIT</li>
<li>挂起，ctrl+Z，产生SIGSTRP</li>
</ul>
<p>终端驱动程序还需要处理一些情况：</p>
<ol>
<li>当后台job试图读取终端时<br>
如果有一个前台job和多个后台jobs。一般情况下，只有前台job接收终端输入，当后台job试图从终端读取，并不会报错，终端驱动程序会检测这种情况，并且向后台job发出一个SIGTTIN signal。这个signal会停止后台job，shell向有关用户发出通知说你的后台job停止啦！然后用户可以用shell命令将它转换后前台job，从终端读取。<br>
如果</li>
<li>当后台job试图写终端时<br>
当用户禁止后台job向controlling terminal写后，当后台job试图写向标准输出，终端驱动程序识别出这个写操作来自于后台job，向该job发出SIGTTOU signal，阻塞相应的job。当用户使用fg将后台job转换为前台job时，job继续执行。</li>
</ol>
<h2 id="shell执行过程">shell执行过程</h2>
<p>有些shell支持job control，比如bash，有些不支持，比如Bourne shell。</p>
<p>执行以下命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,comm | cat      // 后台job</span><br><span class="line">ps -o pid,ppid,pgid,sid,comm | cat &amp;    // 前台job</span><br></pre></td></tr></table></figure></p>
<h3 id="不支持job-control的shell">不支持job control的shell</h3>
<p>在不支持job control的shell中，管道的最后一个进程是shell的子进程，而执行管道中其他命令的进程是该最后进程的子进程。当最后一个进程终止时，shell得到通知。<br>
所有的job的process group id和shell的都一样。<br>
<img src="/2019/11/28/UNIX-Process-Relationships/shell_no_job_control.png" alt="shell_no_job_control"></p>
<h3 id="支持job-control的shell">支持job control的shell</h3>
<p>而在支持job control的shell中<br>
每一个job都有一个自己的process group id，和shell的不一样。<br>
shell是两个job的父进程。</p>
<h2 id="孤儿进程组">孤儿进程组</h2>
<p>当一个进程组的父进程退出之后，而子进程还没有结束，这个时候整个进程组就成了孤儿进程组。<br>
什么是孤儿进程组：<br>
进程组中每个成员的父进程要么是它组内的一个成员，要么不是这个进程组所在session的成员。</p>
<h2 id="freebsd实现">FreeBSD实现</h2>
<p>每个session都会有一个seesion结构，它包含：</p>
<ul>
<li><code>s_count</code></li>
<li><code>s_leader</code></li>
<li><code>s_ttyvp</code></li>
<li><code>s_ttyp</code></li>
<li><code>s_sid</code>，这一部分不是SUS的组成，只有FreeBSD有。</li>
</ul>
<p>每个终端或者伪终端会在内核中分配一个tty结构，它包含：</p>
<ul>
<li><code>t_session</code></li>
<li><code>t_pgrp</code></li>
<li><code>t_termios</code></li>
<li><code>t_winsize</code></li>
</ul>
<p>每个进程组都包含一个pgrp结构，它包含：</p>
<ul>
<li><code>pg_id</code></li>
<li><code>pg_session</code></li>
<li><code>pg_memebers</code></li>
</ul>
<p>每个进程都有一个<code>proc</code>结构，它包含：</p>
<ul>
<li><code>p_pid</code></li>
<li><code>p_ptr</code></li>
<li><code>p_grp</code></li>
<li><code>p_pglist</code></li>
</ul>
<p>进程通过v_node结构体访问/dev/tty。</p>
<p>它们之间的关系如下图所示：<br>
<img src="/2019/11/28/UNIX-Process-Relationships/" alt="session_and_process_group"></p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/27/assembly-languages/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/27/assembly-languages/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">assembly languages</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-27 21:36:52 / 修改时间：22:00:57" itemprop="dateCreated datePublished" datetime="2019-11-27T21:36:52+08:00">2019-11-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/汇编/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="机器指令">机器指令</h2>
<p>计算机指令可以表示为序列化的bits，一般来说，这是一个程序最低级别的表示-每一条指令都等于CPU的一个单个的，不可分隔的指令。这种表示方法叫做机器语言，因为它是机器可以理解的唯一一种形式。</p>
<h2 id="汇编语言">汇编语言</h2>
<p>一种更高level的表示叫做assembly language。Assembly language和机器语言的很类似，通常可以很方便的把程序从汇编语言转换成机器语言。因为机器语言和汇编语言的相似性，每一个不同的机器架构都有它自己的汇编语言。事实上，每一个架构都可能有好几个汇编语言。<br>
汇编语言的优势是汇编语言对于人类来说是更容易阅读和理解的。举例来说，将寄存器20和寄存器17的内容相加，并将结果存放在寄存器16的MIPS机器语言指令是：0x02918020。给出这个指令，很难直接理解它是怎么工作的。相同的MISP汇编指令是：<br>
<code>add $16, $20, $17</code><br>
可读性更强。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/26/C-strlen-vs-sizeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/C-strlen-vs-sizeof/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">C/C++ strlen vs sizeof</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 10:07:37 / 修改时间：10:10:14" itemprop="dateCreated datePublished" datetime="2019-11-26T10:07:37+08:00">2019-11-26</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C/++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><code>strlen</code>不计算字符串数组的null字节，而<code>sizeof</code>会计算null字节所占的字节。</li>
<li><code>strlen</code>是一个函数，使用时需进行一次系统调用。而<code>sizeof</code>会在编译时计算。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版8.3节</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-struct/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">UNIX struct</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 17:34:51" itemprop="dateCreated datePublished" datetime="2019-11-25T17:34:51+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-08 13:52:58" itemprop="dateModified" datetime="2019-12-08T13:52:58+08:00">2019-12-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>struct FILE<br>
{</p>
<p>};</p>
<p>struct DIR<br>
{</p>
<p>};</p>
<h2 id="结构体">结构体</h2>
<p>POSIX定义了<br>
struct dirent<br>
{</p>
<p>};</p>
<p>struct pwd<br>
{</p>
<p>};</p>
<p>struct spwd<br>
{</p>
<p>};</p>
<p>struct grp<br>
{</p>
<p>};</p>
<p>struct timespec<br>
{</p>
<p>};</p>
<p>struct sm{</p>
<p>};</p>
<h2 id="进程资源限制">进程资源限制</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct rlimit&#123;</span><br><span class="line">    rlim_t rlim_cur;</span><br><span class="line">    rlim_t rlim_max;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版<br>
2.<a href="https://en.cppreference.com/w/c/chrono/timespec" target="_blank" rel="noopener">https://en.cppreference.com/w/c/chrono/timespec</a><br>
3.<a href="https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html" target="_blank" rel="noopener">https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-Process-Control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-Process-Control/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">UNIX Process Control</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 10:31:02" itemprop="dateCreated datePublished" datetime="2019-11-25T10:31:02+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-02 16:35:12" itemprop="dateModified" datetime="2019-12-02T16:35:12+08:00">2019-12-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一节主要介绍UNIX系统的进程控制，包括进程创建，进程执行和进程控制。以及进程属性的各种的ID-real UID, real GID和effective UID, effective GID和save UID， set UID和set GID，以及它们如何收到进程控制原语的影响。</p>
<h2 id="进程标识-pid">进程标识(pid)</h2>
<p>每一个进程都有一个非负整数表示它的唯一进程ID。进程ID标识符总是唯一的，但是可以复用。<br>
系统中有一些专用进程，具体细节跟实现有关。<br>
获得当前进程的各项id：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// real uid</span></span><br><span class="line"><span class="keyword">uid_t</span> ruid = getuid()</span><br><span class="line"><span class="comment">// effective uid</span></span><br><span class="line"><span class="keyword">uid_t</span> euid = geteuid()</span><br><span class="line"></span><br><span class="line"><span class="comment">// real gid</span></span><br><span class="line"><span class="keyword">uid_t</span> rgid = getgid()</span><br><span class="line"><span class="comment">// effective gid</span></span><br><span class="line"><span class="keyword">uid_t</span> egid = getegid()</span><br><span class="line"></span><br><span class="line"><span class="comment">// pid</span></span><br><span class="line"><span class="keyword">uid_t</span> pid = getpid()</span><br><span class="line"><span class="comment">// parent pid</span></span><br><span class="line"><span class="keyword">uid_t</span> ppid = getppid()</span><br></pre></td></tr></table></figure>
<h2 id="fork"><code>fork</code></h2>
<p><code>fork</code>创建一个子进程。函数原型：</p>
<h3 id="fork原型"><code>fork</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="fork性质"><code>fork</code>性质</h3>
<ol>
<li><strong>进程ID</strong>。<code>fork</code>调用一次，返回两次，分别是0和子进程ID，用以区别父进程和子进程。对于父进程，返回子进程ID，对于子进程，返回0。因为父进程可能有多个子进程，并且没有提供获得一个进程所有子进程ID的函数，而fork只有一个父进程，可以通过<code>getppid</code>获得它的父进程的ID。所以这样子进行区分。</li>
<li>子进程和父进程分别继续执行调用<code>fork</code>之后的指令。子进程是父进程的副本。子进程获得父本的数据段，堆和栈的完全副本。这是子进程的副本，和父进程不一样，它们并不共享数据的内存空间，但是它们共享text segment。</li>
<li>现代的操作系统实现，使用写时复制代替了父进程数据段，堆和栈的完全副本。这些区域是由父进程和子进程共享的，但是它们的访问权限是只读。如果父进程或者子进程想要对这些区域进行修改的话，内核会为修改区域的那块内存制作一个副本，用于进程修改。</li>
<li>父进程和子进程因为不共享数据，堆和栈，每个进程都有自己的变量，不会相互影响。</li>
<li><strong>执行顺序</strong>。<code>fork</code>后父进程和子进程的执行顺序是不确定的，这跟内核的调度算法有关。如果要求父进程和子进程之间进行同步，需要它们之间进行某种形式的进程通信。</li>
<li><strong>文件共享</strong>。对于父进程打开的文件，<code>fork</code>相当于将父进程的文件描述符都复制到了子进程中，相当于对父进程的每一个文件描述符，都调用了<code>dup</code>函数。父进程和子进程每个相同的打开文件描述符共享同一个文件表项。一般来说，在<code>fork</code>之后处理文件描述符有以下两种情况：
<ul>
<li>父进程等待子进程完成。父进程不需要对它的文件描述符做任何处理。</li>
<li>父进程和子进程分别执行不同的程序段。父进程和子进程各自关闭它们不需要的文件描述符。</li>
</ul>
</li>
<li><strong><code>fork</code>后子进程继承的信息</strong>。
<ul>
<li>real UID, real GID, effective UID, effective GID</li>
<li>set UID和 set GID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>Session ID</li>
<li>控制终端</li>
<li>cwd</li>
<li>root dir</li>
<li>umask</li>
<li>signal mask</li>
<li>文件描述符标志</li>
<li>环境</li>
<li>共享的内存段</li>
<li>内存映像</li>
<li>Resource limits</li>
</ul>
</li>
<li><strong>父进程和子进程的区别。</strong>
<ul>
<li><code>fork</code>的返回值不同</li>
<li>pid不同</li>
<li>它们有不同的ppid</li>
<li>子进程的很多时间设置为0</li>
<li>父进程设置的文件锁子进程不继承。</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号被设置为空集。</li>
</ul>
</li>
<li><strong><code>fork</code>的两种用法</strong>。
<ul>
<li>父进程和子进程分别执行不同的代码。比如网络服务中，父进程负责等待客户端请求，子进程负责处理父进程接收到的请求。</li>
<li>一个进程要执行不同的程序。对shell比较常见，通常执行完<code>fork</code>返回后立即调用<code>exec</code>。</li>
</ul>
</li>
</ol>
<h2 id="vfork"><code>vfork</code></h2>
<p>创建一个子进程，并且阻塞父进程，函数原型如下：</p>
<h3 id="vfork原型"><code>vfork</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="vfork属性"><code>vfork</code>属性</h3>
<ol>
<li><code>vfork</code>和<code>fork</code>都创建一个新进程，但是<code>vfork</code>并不会将父进程的地址空间完全复制到子进程中。因为子进程会立即调用<code>exec</code>或者<code>exit</code>，就不会引用该地址空间。但是如果在调用<code>exec</code>或者<code>exit</code>之前，它会在父进程的空间中运行，这种做法会提高效率。但是如果子进程修改除了<code>vfork</code>的返回值，或者在没有调用<code>exit</code>或者<code>exec</code>之前调用其他函数，这种行为是未定义的。</li>
<li><code>vfork</code>保证子进程先运行，在子进程没有调用<code>exec</code>或者<code>exit</code>时，内核会使父进程休眠，在子进程调用<code>exec</code>或者<code>exit</code>之后父进程才会恢复运行。如果子进程需要父进程进一步操作的时候，就会产生死锁。</li>
</ol>
<h2 id="exit函数"><code>exit</code>函数</h2>
<p>关于<code>exit</code>函数的介绍，可以查看<a href>C/C++ exit and return</a>。<br>
总共有八种方式可以让进程终止，包括五种正常和三种异常，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回，相当于调用<code>exit</code>。</li>
<li>调用<code>exit</code>，ISO C定义的，它的操作包括调用各个exit handler，处理所有标准I/O流。<code>exit</code>会冲洗标准I/O流，如果这是函数库所采取的唯一的动作，那么不会出现什么问题。而如果<code>exit</code>除了冲洗标准I/O流，还会关闭I/O流，那么在<code>vfork</code>时就会出问题了。当然，现在的<code>exit</code>实现都不会关闭流了，这个操作一般都交给内核实现。</li>
<li>调用<code>_exit</code>或者<code>_Exit</code>，ISO C定义了<code>_Exit</code>，而POSIX.1说明了<code>_exit</code>。它的目的是提供一种无需运行exit handler或者信号处理程序而终止的方法。是否对标准I/O流进行flush，取决于实现。在UNIX中，<code>_Exit</code>和<code>_exit</code>是同义的，并不冲洗I/O流。</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程以哪种方式终止，最后都会执行内核中的同一段代码，这段代码为相关进程关闭所有打开的文件描述符，释放它使用的内存。<br>
为了让终止进程能够通知父进程它是如何终止的。对于3个终止函数，将它的<code>exit status</code>作为参数传递给函数。在异常终止的情况下，内核产生一个指示其异常终止原因的terminaiton status（终止状态）。在任意终止情况下，这个终止进程的父进程都能用<code>wait</code>或者<code>waitpid</code>函数获得它的终止状态。<br>
<strong>如果父进程在子进程之前终止</strong>，那么对于父进程终止的所有进程，它们的父进程都变成<code>init</code>进程，终止状态返回到<code>init</code>进程。具体是怎么操作：对于一个即将终止的进程，内核检查所有活动进程，判断其中是否有待终止进程的子进程，如果有的话，将这些进程的父进程的ID改为<code>init</code>进程的ID 1。<br>
<strong>如果子进程在父进程之前终止</strong>，那么父进程是无法获取它的终止状态的。内核为每一个终止进程保留了一部分信息，当终止进程的父进程调用<code>wait</code>或者<code>waitpid</code>时，可以获取这些信息，这些信息包含终止进程PID，进程的终止状态，进程占用的CPU时间总量。内核可以释放这些进程的内存，关闭打开的文件。如果一个进程终止了，但是它的父进程没有等待它，它被称为一个zombie（僵尸）进程。如果一个长期运行的进程，<code>fork</code>了很多子进程，除非父进程等到取得子进程的终止状态，要不它们就会变成僵尸进程。<strong>当父进程结束时，僵尸进程就会结束？？？</strong><br>
<code>init</code>的子进程，不会变成僵尸进程，因为<code>init</code>进程被编写成无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数获得其终止状态。</p>
<h2 id="wait和waitpid"><code>wait</code>和<code>waitpid</code></h2>
<p>当一个进程终止的话（无论正常还是异常），内核就会向它的父进程发送<code>SIGCHLD</code>信号。而子进程终止是个异步事件，可以在父进程运行的任何时候发生。对于这种信号，父进程可以忽略它，或者调用一个信号处理函数。<br>
调用了<code>wait</code>或者<code>waitpid</code>的进程，可能会处于以下几种状态之一：</p>
<ol>
<li>所有子进程都还在运行，则阻塞。</li>
<li>一个子进程已经终止，正在等待父进程获取其终止状态，那么取得该子进程的终止状态立即返回。</li>
<li>如果它没有任何子进程，立即出错返回。</li>
</ol>
<p>如果进程由于接收到<code>SIGCHLD</code>而调用<code>wait</code>，我们期望<code>wait</code>会立即返回。如果在随机的时间点调用<code>wait</code>，进程可能会阻塞。</p>
<h3 id="wait和waitpid原型"><code>wait</code>和<code>waitpid</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *wstatus);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<h3 id="wait和waitpid性质"><code>wait</code>和<code>waitpid</code>性质</h3>
<ol>
<li>在一个子进程终止前，<code>wait</code>使其调用者阻塞，直到任意一个子进程终止。<code>wait</code>返回终止子进程的进程ID。如果<code>wait</code>要等待一个特定的进程，将返回的pid和要等待的pid相比，如果不相等，将这个pid和termination status保存起来，再次调用<code>wait</code>，直到等到目标pid。下一次想要等待一个特定进程的时候，现场看已经终止的进程列表中是否已有它 ，没有的haunted继续调用<code>wait</code>。</li>
<li>ISO中定义了<code>waitpid</code>中option的四个可能值：0，<code>WNOHANG</code>, <code>WUNTRACED</code>和<code>WCONTINUED</code>。POSXI扩展了许多其他选项。其中0表示阻塞调用，<code>WNOHANG</code>表示如果没有子进程结束就立刻退出，<code>WUNTRACED</code>表示如果一个子进程停止了也返回，<code>WCONTINUED</code>表示一个子进程恢复运行了也会返回。</li>
<li>指定option为0时，设置<code>waitpid</code>阻塞等待指定的进程pid。当<code>pid</code>为-1时，<code>waitpid</code>和<code>wait</code>一样。当<code>pid</code>大于或者小于0时，等待相应的pid（绝对值）。当pid等于0时，等待gid等于调用进程组id的任意一个子进程。</li>
<li>指定option为<code>WNOHANG</code>，设置<code>waitpid</code>不阻塞，表示如果没有子进程结束，就立刻返回。在Linux上，<code>WNOHANG</code>是1。</li>
<li>指定option为<code>WUNTRACED</code>和<code>WCONTINUED</code>，设置<code>waitpid</code>支持job control。</li>
<li>对于<code>wait</code>，只有当调用进程没有子进程时，才出错。对于<code>waitpid</code>，指定的进程或者进程组不存在，或者参数pid不是调用进程的子进程时，都会出错。</li>
<li><code>wstatus</code>是一个整形指针。如果它不为空指针，终止进程的终止状态就存放在它所指的单元内。</li>
<li><code>wstatus</code>指向的整形变量的意义是由实现定义的，其中的某一些位表示exit status，即正常退出。另外一些位表示signal number，表示不正常退出，一位表示是否产生core file，等等。POSIX.1指定了termination status可以用<code>&lt;sys/wait.h&gt;</code>中定义的宏查看。四个互斥宏可以用来取得进程终止的原因：
<ul>
<li><code>WIFEXITED(status)</code>，如果status是一个正常终止子进程返回的，为true。执行<code>WEXITSTATUS(statue)</code>获取子进程传递给<code>exit</code>或者<code>_exit</code>的参数的低八位。</li>
<li><code>WIFSIGNALED(status)</code>，如果status是一个异常终止子进程返回的，为true。执行<code>WTERMSIG(status)</code>获取使得子进程终止的signal。</li>
<li><code>WIFSTOPPED(status)</code>，如果status是一个当前暂停的子进程返回的，为true。执行<code>WSTOPSIG(status)</code>获取使得子进程暂停的signal。</li>
<li><code>WIFCONTINUED(status)</code>，。</li>
</ul>
</li>
<li><code>fork</code>两次可以让原始进程不用自己调用<code>wait</code>，也可以避免产生僵尸进程。</li>
</ol>
<h2 id="waitid"><code>waitid</code></h2>
<h3 id="waitid原型"><code>waitid</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="waitid性质"><code>waitid</code>性质</h3>
<ol>
<li><code>waitid</code>是SUS指定的，不是ISO C的部分。</li>
<li><code>waitid</code>和<code>waitpid</code>类似，但是它使用两个单独的参数表示要等到的子进程所属的类型，用<code>idtype</code>表明<code>id</code>的类型，用<code>id</code>表示pid或者进程组id。<code>idtype</code>的取值如下：
<ul>
<li><code>P_PID</code>，等待特定进程，id指定要等待的子进程的pid</li>
<li><code>P_PGID</code>，等待特定进程组中的任一子进程，id是包含要等待子进程的组ID</li>
<li><code>P_ALL</code>，等待任意子进程，忽略id。</li>
</ul>
</li>
<li><code>options</code>参数是以下标志的按位或运算。
<ul>
<li><code>WCONTINUED</code></li>
<li><code>WEXITED</code></li>
<li><code>WNOHANG</code></li>
<li><code>WNOWAIT</code></li>
<li><code>WSTOPPED</code></li>
</ul>
</li>
<li><code>siginfo_t</code>结构体包含了子进程状态改变有关signal的详细信息。</li>
</ol>
<h2 id="wait3和wait4"><code>wait3</code>和<code>wait4</code></h2>
<p>大多数UNIX系统都支持<code>wait3</code>和<code>wait4</code>，它们是从BSD延续下来的。它们的功能比POSIX.1函数<code>wait</code>, <code>waitpid</code>和<code>waitid</code>要多一个。可以通过附加参数允许内核返回终止进程以及其所有子进程使用的资源概况。包含用户CPU时间总量，系统CPU时间总量，缺页次数，接收到的signal次数。<br>
它们的原型如下：</p>
<h3 id="wait3和wait4原型"><code>wait3</code>和<code>wait4</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options, struct rusage *rusage);</span><br><span class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options, struct rusage *rusage);</span><br></pre></td></tr></table></figure>
<h2 id="race-condition">race condition</h2>
<p>如果多个进程都企图对共享数据进行某种处理，而且最后的结果取决于进程运行的顺序时，我们认为发生了race condition。<br>
如果一个进程希望等待子进程终止，可以调用<code>wait</code>函数中的一个。如果一个子进程想要等待父进程终止，可以使用下列形式的循环，称为轮询（polling)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式浪费了很多CPU时间。为了避免这些问题，可以使用signal或者进程间通信解决这些问题。</p>
<h2 id="exec"><code>exec</code></h2>
<p>通常使用<code>fork</code>创建新的子进程之后，子进程往往会调用一种<code>exec</code>函数执行另一个程序。当进程调用<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序从其<code>main</code>函数开始执行。调用<code>exec</code>并不会创建新进程，所以前后的进程ID不变。<code>exec</code>使用磁盘上的一个新程序替换了当前进程的text segment, data segment, heap和stack。<code>exec</code>函数只有在出错的时候才返回-1，并且设置<code>errno</code>。<br>
总共有七种不同的<code>exec</code>函数，它们被统称为<code>exec</code>函数。它们的原型如下：</p>
<h3 id="exec函数原型"><code>exec</code>函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> fexecve(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[]);</span></span></span><br></pre></td></tr></table></figure>
<h3 id="exec函数属性"><code>exec</code>函数属性</h3>
<ol>
<li><strong>传入参数的区别。</strong> <code>path</code>是路径名作为参数，<code>file</code>是文件名作为参数。如果<code>path</code>中包含<code>'/'</code>，将它看成路径名。否则按照PATH环境变量，在它指定的目录中搜寻可执行文件。如果函数<code>execlp</code>和<code>execvp</code>在PATH指定的目录中找到的文件不是link editor产生的可执行文件，就会把它当做一个shell脚本，调用<code>/bin/sh</code>，把这个文件当做shell的输入。</li>
<li><strong>argmuent list的区别。</strong> l表示的是列表，v表示的是向量。<code>execl</code>, <code>execlp</code>和<code>execle</code>要求将新程序的每个命令行参数都说明为一个单独的参数，这种参数表以空指针结尾。而<code>execv</code>,<code>execvp</code>, <code>execve</code>和<code>fexecve</code>，需要先构造一个指向各个参数的指针数组，然后将该数组的地址作为这四个函数的参数。</li>
<li><strong>environment list的区别。</strong> 以e结尾的函数，<code>execve</code>, <code>execvpe</code>,<code>execle</code>, <code>fexecve</code>等可以传递一个指向environment字符串指针数组的指针，这个是自己指定的环境。其他几个不带e的函数使用进程中的environ变量为新程序复制现有的环境。</li>
<li>调用<code>exec</code>后，进程ID没有改变，但是新程序从调用进程继承了以下属性：
<ul>
<li>pid和ppid</li>
<li>real UID, real GID,</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>Session ID</li>
<li>控制终端</li>
<li>闹钟余留时间</li>
<li>cwd</li>
<li>root dir</li>
<li>umask</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li>时间</li>
</ul>
</li>
<li>在<code>exec</code>前后，real UID和real GID不变，effective ID取决于是否设置set UID和set GID。如果新程序的set UID已经设置，则effective ID变成程序文件所有者的ID，否则不变。</li>
<li>这几个函数中，只有<code>execve</code>是系统调用，其他几个都只是库函数，最终都要调用<code>execve</code>。</li>
</ol>
<h2 id="更改uid和gid">更改UID和GID</h2>
<p>进程的real UID, real GID以及effective UID，effective GID都是可以改变的。可以使用<code>setuid</code>, <code>seteuid</code>和<code>setgid</code>, <code>setegid</code>更改real UID， effective UID，和real GID以及effective GID。它们的原型如下：</p>
<h3 id="setuid-seteuid和setgid-setegid原型"><code>setuid</code>, <code>seteuid</code>和<code>setgid</code>, <code>setegid</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> egid)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="setuid-seteuid和setgid-setegid属性"><code>setuid</code>, <code>seteuid</code>和<code>setgid</code>, <code>setegid</code>属性</h3>
<p>更改进程的UID需要遵守以下规则：</p>
<ol>
<li>如果进程具有超级用户权限。<code>setuid</code>函数将real UID, effective UID和saved set UID都保存为uid。</li>
<li>如果进程没有超级用户权限。但是uid等于real UID或者saved set UID，则<code>setuid</code>只将real UID改成uid。其他UID不变。</li>
<li>如果两个条件都不满足，设置<code>errno</code>为<code>EPERM</code>，返回-1。</li>
<li>只有superuser进程可以改变real UID。一般来说，real UID是用户登录时，login程序设置的，而且不会改变它。login是一个超级用户进程，当它调用<code>setuid</code>时，设置所有三个uid。</li>
<li>只有set-user-ID位被设置时，<code>exec</code>才设置effective UID。如果set-user-ID位没有被设置，<code>exec</code>不修改effective UID。任何时候，都可以调用<code>setuid</code>将effective UID设置为real UID和saved set UID修改为。</li>
<li>saved set-user-ID是<code>exec</code>从effective UID复制而来的。如果设置了set-user-ID位，在<code>exec</code>根据文件的UID设置了进程的effective UID之后，这个副本就被保存起来了。</li>
</ol>
<p>总结得到以下的表格：</p>
<table>
<thead>
<tr>
<th style="text-align:center">ID</th>
<th style="text-align:center"></th>
<th style="text-align:center"><code>exec</code></th>
<th style="text-align:center"></th>
<th style="text-align:center"><code>setuid</code></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">set-user-ID位关闭</td>
<td style="text-align:center">set-user-ID位开启</td>
<td style="text-align:center">超级用户</td>
<td style="text-align:center">非超级用户</td>
</tr>
<tr>
<td style="text-align:center">real UID</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">设置为uid</td>
<td style="text-align:center">不变</td>
</tr>
<tr>
<td style="text-align:center">effective UID</td>
<td style="text-align:center">不变</td>
<td style="text-align:center">程序文件的UID</td>
<td style="text-align:center">设置为uid</td>
<td style="text-align:center">设置为uid</td>
</tr>
<tr>
<td style="text-align:center">saved set-UID</td>
<td style="text-align:center">从effective ID复制</td>
<td style="text-align:center">从effective ID复制</td>
<td style="text-align:center">设置为uid</td>
<td style="text-align:center">不变</td>
</tr>
</tbody>
</table>
<h3 id="setreuid和setregid"><code>setreuid</code>和<code>setregid</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setreuid</span><span class="params">(<span class="keyword">uid_t</span> ruid, <span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setregid</span><span class="params">(<span class="keyword">gid_t</span> rgid, <span class="keyword">gid_t</span> egid)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>交换real UID和effective UID。一个非root用户总能交换real UID和effective UID。允许一个set-user-ID程序交换成用户的普通权限，然后再次交换回去。</li>
<li>某个参数设置为1，表示相应的ID不变</li>
</ol>
<h3 id="seteuid和setegid"><code>seteuid</code>和<code>setegid</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> euid)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> egid)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>一个非root用户可以将effective UID设置为real UID或者saved set-UID。<br>
对于一个特权用户，可以将effective UID设置为uid。和<code>setuid</code>的区别在于，它修改三个UID。</li>
</ol>
<h3 id="组id">组ID</h3>
<p>修改进程的GID和修改进程的UID类似。附属组ID不受<code>setgid</code>，<code>setegid</code>和<code>setrugid</code>的影响。</p>
<h2 id="解释器文件">解释器文件</h2>
<p>所有的UNIX系统都支持解释器文件。这种文件是文本文件，起始形式是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! pathname [optional-argument]</span><br></pre></td></tr></table></figure></p>
<p>在感叹号和pathname之间的空格是可以选的。常见的解释器文件以下列行开始：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>pathname通常是绝对路径名。对这种文件的识别是由内核作为<code>exec</code>系统调用处理的一部分完成的。内核是调用<code>exec</code>函数的进程实际执行的并不是该解释器文件，而是在该解释器文件第一行中pathname指定的文件。解释器文件是文本文件，它以!#开头，而解释器是二进制文件，由解释器中的文件第一行的pathname指定。</p>
<p>是否一定需要解释器文件呢？不完全如此，但是它们确实使得用户得到效率方面的好处，代价是内核的额外开销，因为识别解释器文件的是内核。由于下列原因，解释器文件是有用的：</p>
<ol>
<li>有些程序是用某种脚本语言写的脚本，解释器文件可以将这一事实隐藏起来。</li>
<li>解释器脚本在效率方面提供了好处。</li>
<li>解释器脚本使我们可以使用除了/bin/sh以外的其他shell编写shell脚本。</li>
</ol>
<h2 id="system"><code>system</code></h2>
<p>ISO C定义了<code>system</code>函数，它用来执行一个shell命令，对系统的依赖性很强。<code>system</code>库函数调用<code>fork</code>创建一个子进程使用<code>execl</code>执行参数<code>system</code>指定的shell命令。相当于:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, command, (<span class="keyword">char</span> *) <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>POSIX.1包括了<code>system</code>接口，扩展了ISO C定义，描述了<code>system</code>在POSIX.1环境中的运行行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure>
<p><code>system</code>在其实现中调用了<code>fork</code>, <code>exec</code>和<code>waitpid</code>，可能有以下的返回值：</p>
<ol>
<li>如果<code>command</code>是一个空指针，当前系统是有可用的shell时，<code>system</code>返回非0值，否则返回0。在UNIX的各个实现中，一定提供了shell，当<code>command</code>是空指针时，总是返回非零值。</li>
<li><code>fork</code>失败或者<code>waitpid</code>返回处<code>EINTR</code>之外的出错，返回-1，设置errno。</li>
<li>如果<code>exec</code>失败，表示不能执行shell，返回值如同shell执行了exit(127)一样</li>
<li>所有三个函数都成功，<code>system</code>的返回值和在shell中执行相应命令的的termination status一样。</li>
</ol>
<p>其中一种<code>system</code>的可能实现如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cmdstring == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>,  <span class="string">"-c"</span>, cmdstring, (<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>system</code>而不是直接使用<code>fork</code>和<code>exec</code>的好处是：<code>system</code>进行了各种所需要的各种出错处理和信号处理。但是早期的系统中，没有<code>waitpid</code>函数，于是父进程使用下列语句等待子进程结束：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((lastpid = wait(&amp;status) != pid &amp;&amp; lastpid !=<span class="number">-1</span>)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></p>
<p>如果在调用<code>system</code>之前产生了其它子进程，如果这些子进程在<code>system</code>产生的子进程之前结束，那么上面的代码会将这些提前结束的子进程的进程ID和termination都给丢弃。<br>
<strong>system函数还有可能会出现漏洞。如果设置了set UID或者set GID位的程序执行<code>system</code>，那么这个进程的高级别权限可能会保持下来（现代的系统都解决了这个问题）。如果一个进程正在以特殊的权限(set UID和set GID)运行，它又想生成另一个进程执行另一个程序，它应该直接使用<code>fork</code>和<code>exec</code>，而且在<code>fork</code>之后，<code>exec</code>之前要改回普通权限，set UID和set GID程序绝不应该调用<code>system</code>函数。</strong></p>
<h2 id="进程会计">进程会计</h2>
<p>大多数UNIX系统都提供了一个选项进行进程会计处理。启动该选项之后，每当进程结束时内核就会写一个会记记录。典型的会计记录是一个二进制数据，一般包括命令名，所有的CPU时间总量，UID和GID，启动时间等。所有的标准都没有定义进程会记，所以实现上就千差万别。<br>
<code>acct</code>函数启用和关闭进程会计。<br>
会记记录结构定义在头文件<code>&lt;sys/acct.h&gt;</code>的<code>struct acct</code>中，其中<code>ac_flag</code>标志记录了进程执行期间的某些事件：</p>
<ul>
<li><code>AFORK</code>，进程是<code>fork</code>产生的，但是未调用<code>exec</code></li>
<li><code>ASU</code>，进程使用superuser权限</li>
<li><code>ACORE</code>，进程转储到core</li>
<li><code>AXSIG</code>，进程由一个signal杀死</li>
<li><code>AEXPND</code>，扩展的会计条目</li>
<li><code>ANVER</code>，新纪录格式</li>
</ul>
<p>在LINUX上，<code>ac_flag</code>是枚举类型，所以不能使用<code>#ifdef</code>判断是否支持<code>ACCORE</code>等flag，可以使用<code>if !defied HAS_ACCORE</code>进行判断。</p>
<p>会计记录所需的各个数据（各CPU时间，传输的字符数等）都由内核保存在process table中，并在一个新进程被创建时初始化，进程终止时写一个会计记录。这产生了两个后果：</p>
<ol>
<li>对于那些不会终止的进程，比如<code>init</code>进程，我们无法获得它的会计记录。内核守护进程也不会终止，所以也不会产生会计记录。</li>
<li>在会计文件中记录的顺序对应于进程终止的顺序，而不是它们启动的顺序。</li>
</ol>
<p>会记记录对应于进程而不是程序。在<code>fork</code>之后，内核为子进程初始化一个记录，而不是在一个新程序被执行初始化时。<code>exec</code>并不会创建一个新的记录，但是相应记录中的名字会改变，<code>AFORK</code>标志没了。</p>
<h2 id="获得当前登录用户名">获得当前登录用户名</h2>
<p>可以使用<code>getlogin</code>获得当前登录用户的用户名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="进程调度">进程调度</h2>
<p>调度策略和调度优先级是由内核确定的。</p>
<h3 id="nice-getpriority-setpriority原型"><code>nice</code>, <code>getpriority</code>, <code>setpriority</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> inc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> prio)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="nice-getpriority-setpriority属性"><code>nice</code>, <code>getpriority</code>, <code>setpriority</code>属性</h3>
<ol>
<li><code>nice</code>函数将输入的参数加到当前的<code>nice</code>值上。<code>nice</code>值越大，优先级越低，否则越高。</li>
<li>在单核的机器中，同时运行一个父进程和一个子进程，它们的<code>nice</code>值不同的话，CPU占用比也可能会不同，这取决于进程调度程序如何使用<code>nice</code>值。在多核的机器上可能看不到这样的结果。</li>
</ol>
<h2 id="进程时间">进程时间</h2>
<p>可以使用<code>times</code>获得某进程和它的子进程的CPU时间以及墙上时钟时间，<code>times</code>通过<code>struct tms</code>传递信息。它的内容如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_utime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_stime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_cutime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_cstime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>它包含进程的用户CPU时间，系统CPU时间和子进程的用户CPU时间和系统CPU时间。但是不包含墙上时钟时间，墙上时钟时间是通过函数的返回值得到的，而且得到的时间是相对于过去某个时间点得到的，所以不能使用它的绝对值，要使用相对值。比如第一次调用<code>times</code>，记录返回值，等到下一次调用<code>times</code>时，用新的值减去刚才保存的值，得到墙上时间时间。<br>
<strong>所有时间（结构体和返回值）的单位都是滴答数。</strong><br>
函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> times(struct tms *buf);</span><br></pre></td></tr></table></figure></p>
<p>shell的<code>time(1)</code>可以使用<code>times(2)</code>实现，看程序。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-Process-Environment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-Process-Environment/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">UNIX Process Environment</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 10:22:51" itemprop="dateCreated datePublished" datetime="2019-11-25T10:22:51+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-02 10:54:56" itemprop="dateModified" datetime="2019-12-02T10:54:56+08:00">2019-12-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一部分介绍的是进程运行的环境。主要包括进程执行时，<code>main</code>函数是如何被调用的，命令行参数如何传递给进程的，进程的存储空间结构，如何分配存储空间，环境变量的使用，以及进程是怎么终止的。</p>
<h2 id="main函数和argc-argv"><code>main</code>函数和<code>argc</code>, <code>argv</code></h2>
<p>C语言总是从<code>main</code>函数开始执行，C语言中<code>main</code>有两个原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>argc</code>是命令行参数的个数，<code>argv</code>是一个指针数组，ISO C和POSIX.1都要求<code>argv[argc]</code>设置为<code>NULL</code>，所以可以用它作为参数处理的循环终止条件。关于更多指针的信息可以查看<a href></a>。<br>
当内核执行C程序（使用一个<code>exec</code>函数）时，在调用<code>main</code>函数之前设置一个特殊的启动例程。可执行程序文件将这个启动例程指定为程序的起始地址，这是由link editor设置的，它会被C编译器调用。启动例程从内核命令获得命令行参数和环境变量值，然后为调用<code>main</code>函数做好准备。</p>
<p>关于更多C和C++中<code>main</code>的介绍，可以查看<a href="https://mxxhcm.github.io/2019/11/12/C-CPP-main-argc-argv/">C/C++ main argc argv</a>。</p>
<h2 id="全局变量environ">全局变量<code>environ</code></h2>
<p>每个C程序都会接收到一个environment list，和<code>argv</code>一样，它是一个指针数组。每个指针指向一个以<code>null</code>结束的C字符串的地址，这个指针数组的地址存放在全局变量<code>environ</code>中：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br></pre></td></tr></table></figure></p>
<p>在历史上，UNIX大多支持三个参数的<code>main</code>函数，第三个参数就是environment list：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但是ISO C规定<code>main</code>只能有两个参数，POSIX.1也就规定使用全局变量<code>environ</code>而不是第三个参数。如果要查看所有的环境变量时，使用<code>environ</code>，而访问某个特定的环境变量时，使用<code>getenv</code>和<code>setenv</code>。</p>
<h2 id="进程终止">进程终止</h2>
<p>总共有八种方式可以让进程终止，包括五种正常和三种异常，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回</li>
<li>调用<code>exit</code></li>
<li>调用<code>_exit</code>或者<code>_Exit</code></li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h3 id="exit函数"><code>exit</code>函数</h3>
<h4 id="函数原型">函数原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h4 id="性质">性质</h4>
<ol>
<li><code>exit</code>和<code>_Exit</code>是ISO C的内容，而<code>_exit</code>是POSIX.1的内容</li>
<li>它们都用于正常终止一个程序，<code>_Exit</code>和<code>_exit</code>立刻进入内核，而<code>exit</code>先执行一些清理操作，然后返回内核。<code>exit</code>函数总是执行一个标准I/O库的关闭操作，对于所有打开的流调用<code>fclose</code>函数，所有带有未写缓冲的标准I/O流被flush。</li>
<li>三个退出函数都需要一个整形的参数，被称为exit status。</li>
<li>如果满足以下条件：
<ul>
<li>调用这三个函数不带终止状态</li>
<li><code>main</code>执行了一个不带返回值的<code>return</code>语句</li>
<li><code>main</code>没有声明返回类型为整形，进程的终止状态是未定义的。<br>
那么这个进程的终止状态是未定义的。</li>
</ul>
</li>
<li><code>main</code>返回返回一个整型值和用该值调用<code>exit</code>是等价的。对于某些C编译器和UNIX lint(1)程序来说，会产生警告信息，因为这些编译器并不了解<code>main</code>中的<code>return</code>和<code>exit</code>的作用是相同的。避开这种警告信息的一种方法是在<code>main</code>中使用<code>return</code>而不是<code>exit</code>，这样做的结果是UNIX grep命令无法找出程序中所有的<code>exit</code>调用。另一个方法是将<code>main</code>声明为<code>void</code>而不是<code>int</code>，然后调用<code>exit</code>，但是这不并不是标准，ISO C和POSIX.1定义<code>main</code>的返回值应当是带符号整形。</li>
</ol>
<p>关于更多<code>exit</code>函数的内容，可以查看<a href></a>。<br>
关于<code>exit</code>和<code>return</code>的内容，更多可以查看<a href>C/C++ exit and return</a>。</p>
<h3 id="atexit"><code>atexit</code></h3>
<p>每个进程可以通过<code>atexit</code> register至多32个由<code>exit</code>自动调用的函数，这些函数被称为exit handler（终止处理程序）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>atexit</code>的参数是一个函数地址，不会有返回值</li>
<li><code>exit</code>调用<code>atexit</code> register的程序的顺序和使用<code>atexit</code>进行register的顺序相反。</li>
<li>ISO C和POSIX.1标准规定，<code>exit</code>首先调用各个exit handler，然后使用<code>fclose</code>关闭所有标准I/O流。</li>
<li>POSIX.1对ISO C进行了扩展，如果程序调用了任何<code>exec</code>函数，清除exit handler。</li>
<li>内核执行一个程序的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一办法是显式或者隐式的（通过<code>exit</code>）调用<code>_exit</code>和<code>_Exit</code>。</li>
</ol>
<h2 id="c程序的存储空间布局">C程序的存储空间布局</h2>
<p>更多关于C程序存储空间布局可以查看<a href="https://mxxhcm.github.io/2019/10/19/C-program-memory-layout/">C/C++ program memory layout</a>。</p>
<h2 id="共享库">共享库</h2>
<p>共享库使得可执行文件中不再需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，使用动态链接的方法将程序和共享库函数链接，这减少了每个可执行文件的长度，但是增加了一些时间运行开销。这种时间开销发生在程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个优点是可以使用库函数的新版本代替老版本而无需对使用该库的程序重新链接和编辑。</p>
<h2 id="内存空间分配">内存空间分配</h2>
<p>ISO C说明了三个用于memory allocation的函数，<code>malloc</code>, <code>calloc</code>和<code>realloc</code>，它们的原型如下，更多关于C中<code>malloc</code>的内容可以查看<a href>C/C++ malloc(alloc) free new and delete</a>。</p>
<h3 id="malloc-calloc和realloc原型"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reallocarray</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-calloc和realloc属性"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>属性</h3>
<ol>
<li><code>malloc</code>，分配指定字节的内存空间，初始值不定。</li>
<li><code>calloc</code>，为指定长度的固定数量的对象分配空间，每一个bit都被初始化为0。</li>
<li><code>realloc</code>，增加或者减少已经分配的内存空间的大小。当这个大小增加时，可能需要将之前分配的空间中的数据移到另一个足够大的区域以便于增加大小，新增加的区域内的值是不确定的。</li>
<li>这三个函数返回的指针一定是对齐的，保证它可以用于任何对象。比如<code>double</code>的要求最严格，需要从8的倍数的地址单元开始，这三个函数返回的地址一定满足这个要求。</li>
<li>它们的返回类型都是<code>void*</code>，需要使用强制类型转换。</li>
<li><code>realloc</code>函数可以增加或者减少之前分配的内存空间的大小。比如分配了一个固定大小的数组，后来发小它不够用了，可以使用<code>realloc</code>对它进行扩充，如果原有的存储后有足够的大小进行扩充，则可以在原存储区的位置上向高地址进行扩充，无需移动原有数组，返回和传入相同的指针。如果原来的内存空间后没有足够的空间，就重新分配一个足够大的内存空间，再将原有数据的内容复制过去，然后释放原来的内存空间，返回新的指针。</li>
<li><code>realloc</code>传入的参数是存储区的新长度。如果传入的<code>ptr</code>参数是<code>NULL</code>指针，那就退化成了<code>malloc</code>。</li>
<li><code>free</code>可以释放<code>ptr</code>指向的内存空间，释放的空间通常送入可用内存池，之后可以通过这三个函数重新分配。</li>
<li><code>malloc</code>和<code>free</code>底层通常使用<code>sbrk</code>系统调用实现，这个系统调用扩充或者减小进程的堆，虽然<code>sbrk</code>可以扩充或者缩小进程的堆，但是一般<code>malloc</code>和<code>free</code>的实现不会减少进程的内存空间，释放的内存空间保存在<code>malloc</code>池中，而不是交给内核。</li>
<li>大多数实现分配的空间要比请求的空间大一些，因为需要存储一些管理信息，如block的大小，指向下一个block的指针等等。因此，如果对超过一个分配区域的内存进行读写的话，会造成很严重的错误。</li>
<li><code>free</code>一个已经释放了的块，<code>free</code>的不是<code>alloc</code>函数的返回值，没有进行<code>free</code>等等，都有可能造成很严重的后果。</li>
</ol>
<h2 id="环境变量">环境变量</h2>
<p>环境变量的形式是：<br>
<code>name = value</code><br>
UNIX内核并不使用环境变量，通常都是应用程序使用这些环境变量。比如shell使用了大量的环境变量。</p>
<h3 id="标准定义">标准定义</h3>
<p>ISO C定义了<code>getenv</code>函数可以获取环境变量。但是ISO C没有定义任何环境变量，SUS环境变量包括POSIX.1和XSI环境变量。<br>
除了获取环境变量，有时候我们也需要设置环境变量。ISO C没有定义获取环境变量的函数。SUS除了定义了ISO C，还定义了<code>putenv</code>, <code>setenv</code>和<code>unsetenv</code>对环境变量进行操作。</p>
<h3 id="putenv-setenv和unsetenv原型"><code>putenv</code>,<code>setenv</code>和<code>unsetenv</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="putenv-setenv和unsetenv性质"><code>putenv</code>,<code>setenv</code>和<code>unsetenv</code>性质</h3>
<ol>
<li><code>putenv</code>，创建或者重置一个<code>name</code>。</li>
<li><code>setenv</code>，如果<code>name</code>不存在，创建<code>name</code>；如果<code>name</code>存在，<code>rewrite</code>不为零，重写，<code>rewrite</code>为零，不进行重写。</li>
<li><code>unsetenv</code>，移除<code>name</code>的定义。如果<code>name</code>不存在，不会出错。</li>
<li>环境变量的修改和增加可能会遇到一些问题。因为环境变量存放在进程地址空间的最上面的一个不可扩展的空间。<br>
<strong>如果修改一个存在的<code>name</code></strong>：<br>
当新的<code>value</code>的长度小于等于原来的<code>value</code>长度时，直接覆盖就行；<br>
当新的<code>value</code>的长度大于原来的<code>value</code>长度时，只需要给新的<code>name-value</code>字符串分配空间就行了。使用<code>malloc</code>为新的字符串分配空间，然后将该字符串复制到新的空间，让environment list中<code>name</code>的指针指向新分配的存放字符串的空间即可。</li>
</ol>
<p><strong>如果增加一个新的<code>name</code>，不仅需要给新的<code>name-value</code>分配空间，指针数组的元素也增加了，还需要给指针数组分配新的空间</strong>。首先给新的<code>name-value</code>字符串分配空间，调用<code>malloc</code>先为字符串分配空间，然后将该字符串复制到这个空间：<br>
如果这是第一次增加一个<code>name</code>，必须调用<code>malloc</code>为指针数组增加空间。将原来的指针数组复制到新分配的空间中，然后将新字符串的指针放在指针数组的尾部，然后存放一个空指针。最后让全局变量<code>char **environ</code>指向这个指针数组。如果原来的指针数组存放在栈顶之上，需要将它复制到堆中。需要注意的是，这个指针数组中的未修改的环境变量的指针还是指向栈顶的字符串上。<br>
如果这不是第一个添加<code>name</code>，只需要使用<code>realloc</code>重新多分配一个指针数组的空间即可，然后将它指向新字符串的地址即可。</p>
<h2 id="setjmp和longjmp"><code>setjmp</code>和<code>longjmp</code></h2>
<h3 id="setjmp和longjmp原型"><code>setjmp</code>和<code>longjmp</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="setjmp和longjmp属性"><code>setjmp</code>和<code>longjmp</code>属性</h3>
<ol>
<li>自动变量存储在每个函数的栈帧中。</li>
<li><code>setjmp</code>和<code>longjmp</code>实在栈上跳过若干调用栈，返回到当前函数调用路径上的某个函数中。</li>
</ol>
<h2 id="getrlimit和setrlimit"><code>getrlimit</code>和<code>setrlimit</code></h2>
<p>每个进程能使用的资源都是有限的，可以使用<code>getrlimt</code>和<code>setrlimit</code>进行修改。它们都是XSI扩展，不是ISO C的定义。有些资源可以设置为<code>RLIM_INFINITY</code>，表示无限。</p>
<h3 id="getrlimit和setrlimit性质"><code>getrlimit</code>和<code>setrlimit</code>性质</h3>
<ol>
<li>任何一个进程都可以将<code>rlim_cur</code>改为小于等于<code>rlim_max</code>。</li>
<li>任何一个进程都可以将<code>rlim_max</code>改小，但是不能小于<code>rlim_cur</code>，且这个更改是不可逆的。</li>
<li>只有root用户可以更改<code>rlim_max</code>。</li>
</ol>
<p>它们的原型原型如下：</p>
<h3 id="getrlimit和setrlimit原型"><code>getrlimit</code>和<code>setrlimit</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="resource种类">resource种类</h4>
<ul>
<li>RLIMIT_AS</li>
<li>RLIMIT_VMEM</li>
<li>RLIMIT_DATA</li>
<li>RLIMIT_SWAP</li>
<li>RLIMIT_STACK</li>
<li>RLIMIT_NPROC</li>
<li>RLIMIT_FSIZE</li>
<li>RLIMIT_NOFILE</li>
<li>RLIMIT_NICE</li>
<li>…</li>
</ul>
<h4 id="结构体">结构体</h4>
<p>结构体<code>struct rlimt</code>的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;    <span class="comment">// soft limit</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;    <span class="comment">// hard limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>《APUE》第三版</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/24/UNIX-system-data-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/24/UNIX-system-data-file/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">UNIX system data file</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 14:17:20" itemprop="dateCreated datePublished" datetime="2019-11-24T14:17:20+08:00">2019-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-08 14:02:58" itemprop="dateModified" datetime="2019-12-08T14:02:58+08:00">2019-12-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/24/linux-glibc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/24/linux-glibc/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">linux glibc</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 11:57:59 / 修改时间：12:13:01" itemprop="dateCreated datePublished" datetime="2019-11-24T11:57:59+08:00">2019-11-24</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="查看当前linux系统的glibc版本">查看当前linux系统的glibc版本</h2>
<blockquote>
<p>ldd --version</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldd (Ubuntu GLIBC 2.27-3ubuntu1) 2.27</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure>
<p>我的笔记本上的glibc是2.27版本。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://www.linuxquestions.org/questions/linux-software-2/how-to-check-glibc-version-263103/" target="_blank" rel="noopener">https://www.linuxquestions.org/questions/linux-software-2/how-to-check-glibc-version-263103/</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/22/ISO-C-Standard-I-O-library/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/22/ISO-C-Standard-I-O-library/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/3/index.html">ISO C Standard I/O library</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-22 23:28:22" itemprop="dateCreated datePublished" datetime="2019-11-22T23:28:22+08:00">2019-11-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-10 18:14:54" itemprop="dateModified" datetime="2019-12-10T18:14:54+08:00">2019-12-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="总结">总结</h2>
<ol>
<li><code>fgets</code>, <code>sprintf</code>, <code>snprintf</code>会在缓冲区数组的结尾加上一个null字节，但是使用的时候不会包含这个字节。</li>
<li><code>fgets</code>和<code>getline</code>都会读入回车，并且将它存入缓冲区，<code>getchar</code>, <code>getc</code>和<code>fgetc</code>也会读入回车，并且将它存起来。</li>
<li>每个标准I/O流都有一个和它相关联的文件描述符，可以对一个流调用<code>fileno</code>获得它的文件描述符。<code>fileno</code>不是ISO C的部分，因为文件描述符不属于ISO C。</li>
<li>标准I/O库的一个不足是效率不高。这和它复制的数据量有关。每当使用一次<code>fgets</code>和<code>fputs</code>时，通常需要复制两次数据，一次是在用户程序的行缓冲区和标准I/O缓冲区之间，一次是在内核和标准I/O缓冲区之间。<br>
使用<code>fgets</code>需要用户指定<code>fgets</code>使用的缓冲区，或者使用<code>getline</code>，如果传入的指针指向NULL，<code>getline</code>会负责分配缓冲区大小。<br>
<code>read</code>和<code>write</code>需要设置缓冲区，这是系统调用级别的，大小可以任意指定，通常使用<code>sturct stat.st_blksize</code>的大小，用户如果直接调用<code>read</code>和<code>write</code>的话，需要自己设置缓冲区。而标准I/O库可以自己选择是否进行缓冲，如果缓冲的话，标准I/O库可以负责进行缓冲区大小选择和分配，也可以用户自己进行指定缓冲类型：行缓冲和全缓冲，用户也可以自己通过<code>setbuf</code>和<code>setvbuf</code>更改缓冲区大小和地址。而在<code>setbuf</code>中，如果<code>buf</code>是<code>NULL</code>的话，是关闭缓冲区，如果不为空的话，必须是<code>BUFSIZ</code>大小。在<code>setvbuf</code>中，通过<code>mode</code>指定缓冲区的类型，<code>buf</code>是<code>NULL</code>的话，库函数负责分配缓冲区。否则<code>buf</code>是多大就用多大的缓冲区。<br>
而在内核中，还存在buffer cache和page cache，用于“延迟写”，减少和磁盘的交互。</li>
</ol>
<h2 id="概述">概述</h2>
<h3 id="特殊符号的ascii">特殊符号的ASCII</h3>
<p>'\n’是10。<br>
EOF是-1。</p>
<h3 id="标准i-o和文件i-o">标准I/O和文件I/O</h3>
<p>文件I/O是围绕文件描述符进行的，使用<code>open</code>打开一个文件时，返回一个文件描述符，然后使用文件描述符进行后续I/O操作。文件I/O是UNIX相关的实现，其他系统可能有不同的实现，是不跨平台的。<br>
标准I/O是围绕stream进行I/O操作的。当标准I/O库打开或者创建一个文件时，一个流已经和文件相关联。标准I/O库处理很多细节，比如缓冲区分配，使用优化的长度块执行I/O等，使用户不用担心选择多大的block进行I/O会更快。标准I/O库是ISO C标准定义的，不仅仅UNIX系统有实现，凡是支持ISO C标准的操作系统都应该实现，是支持跨平台的。标准I/O在UNIX上需要使用文件I/O实现，在windows等其他系统上就需要其他的实现。</p>
<h3 id="stream和file对象">stream和<code>FILE</code>对象</h3>
<blockquote>
<p>12.1 Streams<br>
For historical reasons, the type of the C data structure that represents a stream is called FILE rather than “stream”. Since most of the library functions deal with objects of type FILE *, sometimes the term file pointer is also used to mean “stream”. This leads to unfortunate confusion over terminology in many books on C.</p>
</blockquote>
<p>标准I/O的操作是围绕stream进行的，当打开一个stream时，它返回一个指向FILE类型的指针（通常叫做文件指针）。FILE是一个结构体，包含了标准I/O管理这个stream需要的所有信息，包含用于实际I/O的文件描述符，指向这个流缓冲区的指针，缓冲区的长度，当前缓冲区中的字符等。为了引用一个stream，需要将FILE指针作为参数传递给每个标准I/O函数。</p>
<h3 id="stream的定向">stream的定向</h3>
<p>对于ASCII字符集，一个字符用一个字节表示。对于国际字符集，一个字符用多个字节表示。标准I/O FILE stream可以用于单字节也可以用于多字节字符集。stream的orientation决定了读写的字符是单字节还是多字节，最开始创建stream时，它的orientation没有被确定，使用什么字符的I/O就会将stream的orientation定义为什么。<br>
有两个函数可以改变stream的orientation，它们是<code>freopen</code>和<code>fwide</code>，原型如下：</p>
<h3 id="freopen和fwide原型"><code>freopen</code>和<code>fwide</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *stream, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="freopen和fwide性质"><code>freopen</code>和<code>fwide</code>性质</h3>
<ol>
<li><code>fwide</code>用于设置stream的orientation。如果<code>mode</code>为负，是单字节定向的。如果<code>mode</code>为正，是多字节定向的。如果<code>mode</code>为0，<code>fwide</code>确定当前stream的oritentation并返回。</li>
<li><code>fwide</code>不能改变已经定向的stream的orientation。</li>
<li><code>fwide</code>没有出错返回</li>
</ol>
<h3 id="标准输入-标准输出和标准错误">标准输入，标准输出和标准错误</h3>
<p>通常对一个进程预定义了三个stream，它们可以自动的被进程使用。它们是标准输入，标准输出和标准错误，这些stream引用的文件和文件描述符<code>STDIN_FILENO</code>,<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>所引用的文件一样。<br>
这三个stream定义在头文件<code>&lt;stdio.h&gt;</code>中，通过预定义文件指针<code>stdin</code>, <code>stdou</code>和<code>stderr</code>使用。</p>
<h2 id="三种缓冲类型">三种缓冲类型</h2>
<p>标准I/O库提供缓冲的目的是尽可能减少<code>read</code>和<code>write</code>的调用次数，标准I/O库对每个流自动的进行缓冲管理，使得应用程序不用考虑缓冲区的管理。<br>
标准I/O提供了三种类型的缓冲：</p>
<h3 id="全缓冲">全缓冲</h3>
<p>填满标准I/O的缓冲区之后，进行实际的I/O操作。对于存储在磁盘上的文件通常是由标准I/O实施全缓冲的。在一个流上第一次执行I/O操作时，相关的标准I/O函数调用<code>malloc</code>获得需要的缓冲区。</p>
<h3 id="行缓冲">行缓冲</h3>
<p>在行缓冲中，当输入和输出遇到换行符时，标准I/O库执行I/O操作。但是需要注意的是行缓冲区的长度是固定的，当行缓冲区满时即使没有遇到换行符也进行I/O操作。当涉及终端的I/O时，通常使用行缓冲。使用标准I/O的<code>fputc</code>允许我们一次输出一个字符，但是只有在写了一行之后才能进行实际I/O操作。<br>
此外，任何时候只要通过标准I/O库要求从一个不带缓冲的流或者一个行缓冲的流中得到输入数据，那么就会flush所有行缓冲输出流。从行缓冲的流中得到输入数据的一个例子就是从终端按下回车，刚才输入的数据就会立刻从输出流中输出。</p>
<h3 id="不带缓冲">不带缓冲</h3>
<p>标准I/O库不对字符进行缓冲存储。如果将字符传入不带缓冲的输出流中，字符会立即输出到输出流关联的文件或者设备。</p>
<h3 id="fflush函数"><code>fflush</code>函数</h3>
<p>标准I/O库使用flush将输出流缓冲区的内容写到和输出流相关联的文件，缓冲区可以使用标准I/O例程自动的flush，比如当缓冲区填满时，或者缓冲区不满时可以手动调用<code>fflush</code>函数进行flush。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flussh</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>任何时候，都可以手动强制冲洗一个流，当<code>fp</code>是<code>NULL</code>时，冲洗所有的输出流。<br>
注意<code>fflush</code>和<code>fsync</code>的区别，<code>fflush</code>是将位于主存中的缓冲区的内存冲洗到内核。而内核也有一个缓冲区，叫做buffer cache或者page cache，内核接收到数据会首先将它们写入buffer cache或者page cache中，然后排入队列，晚些时候再写，这种方式叫做延迟写。<code>fsync</code>是将buff cache中的内容立即写入磁盘而不等待。</p>
<h3 id="iso-c缓冲标准和unix具体实现">ISO C缓冲标准和UNIX具体实现</h3>
<p>ISO C要求：</p>
<ol>
<li>当且仅当标准输入和标准输出不指向交互设备时，它们才是全缓冲的。</li>
<li>标准错误不会是全缓冲的。</li>
</ol>
<p>UNIX具体实现：</p>
<ol>
<li>标准错误不带缓冲</li>
<li>指向终端设备的流，都是行缓冲的，否则是全缓冲的。</li>
</ol>
<h3 id="修改默认缓冲">修改默认缓冲</h3>
<p>可以通过<code>setbuf</code>和<code>setvbuf</code>更改流的缓冲类型。</p>
<h3 id="setbuf和setvfuf原型"><code>setbuf</code>和<code>setvfuf</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="setbuf和setvfuf性质"><code>setbuf</code>和<code>setvfuf</code>性质</h3>
<ol>
<li>这些函数需要在流被打开后调用，因为他们需要文件指针作为参数，而且应该在对流执行任何操作之前调用。</li>
<li>可以使用<code>setbuf</code>函数打开和关闭缓冲机制。将<code>buf</code>设置为<code>NULL</code>，就是关闭缓冲。如果<code>buf</code>不为<code>NULL</code>，它必须指向一个长度为<code>BUFSIZ</code>的缓冲区，通常在这之后就是全缓冲的，如果和终端设备关联，可能会是行缓冲的。</li>
<li><code>setvbuf</code>可以通过<code>mode</code>指定缓冲的类型，<code>_IOFBF</code>是全缓冲，<code>_IOLBF</code>是行缓冲，<code>_IONBF</code>是不缓冲。指定不缓冲，忽略<code>buf</code>和<code>size</code>参数。如果指定全缓冲或者行缓冲，<code>buf</code>和<code>size</code>可以通过<code>buf</code>和<code>size</code>指定缓冲区的位置和大小。如果指定带缓冲，而<code>buf</code>是<code>NULL</code>，系统会自动分配<code>BUFSIZE</code>大小的缓冲区。</li>
<li>一般而言，应该由操作系统选择缓冲区的长度，并且自动分配缓冲区，这种情况下，关闭流，标准I/O库会自动释放缓冲区。</li>
</ol>
<h2 id="打开一个stream">打开一个stream</h2>
<p>可以使用<code>fopen</code>, <code>freopen</code>和<code>fdopen</code>函数打开一个standard I/O stream。它们的原型如下：</p>
<h3 id="fopen-freopen和fdopen原型"><code>fopen</code>, <code>freopen</code>和<code>fdopen</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="fopen-freopen和fdopen性质"><code>fopen</code>, <code>freopen</code>和<code>fdopen</code>性质</h3>
<ol>
<li><code>fopen</code>打开路径名为<code>pathname</code>的一个文件</li>
<li><code>fdopen</code>使用一个已有的文件描述符，并将一个标准I/O stream和该文件描述符结合。<strong>这个函数通常用于由创建管道和网络通信通道函数返回的文件描述符，因为这些特殊文件不能使用标准I/O函数<code>fopen</code>打开，所以需要使用设备专用函数获得一个文件描述符，然后使用<code>fdopen</code>将文件描述符和一个I/O stream结合。</strong></li>
<li><code>freopen</code>函数在一个指定的stream打开一个指定的文件，如果这个stream已经打开，先关闭这个stream；如果这个stream已经进行了定向，使用<code>freopen</code>清楚该定向。<strong>这个函数一般用于将一个指定的文件打开为一个预定义的stream：stdin, stdout和stderr。</strong></li>
<li><code>fopen</code>和<code>freopen</code>是ISO C的部分，因为ISO C不包含文件描述符，所以只有POSIX.1有<code>fdopen</code>。</li>
<li><code>mode</code>有15种取值：<code>r</code>, <code>w</code>, <code>a</code>, <code>rb</code>, <code>wb</code>, <code>ab</code>,<code>r+</code>,<code>r+b</code>, <code>rb+</code>,<code>w+</code>,<code>w+b</code>,<code>wb+</code>, <code>a+</code>, <code>a+b</code>, <code>ab+</code>。对于标准I/O来说，使用<code>b</code>可以区分二进制和文本文件。但是对于UNIX来说，二进制和文本文件没有区别，有没有<code>b</code>无所谓。</li>
<li>当用追加写时，如果有多个进程用追加写方式打开同一个文件，每个进程的数据都会正确的写入文件中。</li>
<li><code>fdopen</code>不会截断也不会创建文件。对于<code>fdopen</code>来说，因为需要文件描述符，所以文件必须是打开的，当<code>mode</code>是<code>w</code>,<code>wb</code>时，并不会截断文件，<code>a</code>和<code>ab</code>也不能用于创建文件，因为文件描述符必须引用一个存在的文件。而如果使用<code>a+</code>, <code>ab+</code>, <code>w+</code>, <code>wb+</code>等，这个时候文件已经存在了，不会创建，也不会截断，需要写或者追加就行了，就不会有前半句说的问题了。</li>
<li>使用<code>a</code>和<code>w</code>相关的<code>mode</code>创建文件时，没有办法指定文件的权限位。而POSIX.1要求使用如下的权限创建文件：<br>
<code>S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IOTH|S_IWOTH</code><br>
可以在使用<code>fopen</code>等函数之前，使用<code>umask</code>指定文件的权限位。</li>
<li>如果流引用终端设备，是行缓冲的，否则是全缓冲的。</li>
</ol>
<h3 id="fclose函数和性质"><code>fclose</code>函数和性质</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在文件被关闭之前，flush输出数据。缓冲区中的输入数据被丢弃。如果标准I/O库为这个stream自动分配了缓冲区，释放该缓冲区。<br>
当一个进程正常终止时，所有带未写缓冲数据的标准I/O都被flush，所有打开的标准I/O都被关闭。</p>
<h2 id="读写stream">读写stream</h2>
<p>对于一个打开的stream，可以使用3种不同的类型的非格式化I/O以及格式化I/O，对其进行读写操作。<br>
3种非格式化I/O包括：</p>
<ol>
<li>单字符的I/O。如果流是带缓冲的，标准I/O会负责处理缓冲。</li>
<li>单行的I/O。<strong>这里需要注意一下，单行I/O指定的buffer和标准I/O的buffer不一样。</strong></li>
<li>直接I/O（direct I/O）。</li>
</ol>
<h2 id="ferror和feof-clearerr函数和属性"><code>ferror</code>和<code>feof</code>, <code>clearerr</code>函数和属性</h2>
<p>不管是出错还是到达文件结束，<code>getc</code>,<code>fgetc</code>和<code>ungetc</code>等许多函数都返回同样的值<code>EOF</code>，<code>EOF</code>是-1，可以使用<code>ferro</code>和<code>feof</code>判断到底是出错还是到达文件尾端。大多数实现中是为每个流在<code>FILE</code>对象中维护了出错标志和文件结束标志，可以使用<code>clearerr</code>清除相应的标志。函数的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="单字符i-o">单字符I/O</h2>
<p><code>getc</code>, <code>fgetc</code>和<code>getchar</code>函数可以用于一个读一个字符。它们的原型如下：</p>
<h3 id="getc-fgetc和getchar-ungetc原型"><code>getc</code>, <code>fgetc</code>和<code>getchar</code>, <code>ungetc</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="getc-fgetc和getchar-ungetc性质"><code>getc</code>, <code>fgetc</code>和<code>getchar</code>, <code>ungetc</code>性质</h3>
<p><code>getc</code>和<code>fgetc</code>功能一样，只不过<code>getc</code>可以被实现为宏，而<code>fgetc</code>不能被实现为宏。所以：</p>
<ol>
<li><code>getc</code>的参数不应该是具有副作用的表达式，因为它可能会被计算多次。</li>
<li><code>fgetc</code>一定是函数，所以可以得到它的地址。可以当做参数传递给其他函数。</li>
<li><code>fgetc</code>的调用时间通常要比<code>getc</code>长，因为调用函数的时间通常比调用宏的时间长。</li>
</ol>
<h3 id="ungetchar函数和属性"><code>ungetchar</code>函数和属性</h3>
<ol>
<li>从流中读取的数据可以送回流中。</li>
<li>ISO C规定可以支持任何次数的回送，但是一次只能送一个字符。</li>
<li>回送的字符可以不是上次读到的字符。</li>
<li>回送的字符不能是<code>EOF</code>，但是读到文件尾端时，还可以回送一个字符，因为一次成功的<code>ungetc</code>调用会清除<code>EOF</code>标志。</li>
<li>用<code>ungetc</code>只能将字符写入到标准I/O库的流缓冲区中，并没有将它们写到底层设备或者文件中。</li>
</ol>
<p>函数的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="输出函数putc-fputc和putchar">输出函数<code>putc</code>, <code>fputc</code>和<code>putchar</code></h3>
<p>它们的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;     <span class="comment">//相当于putc(c, stdout);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="单行i-o">单行I/O</h2>
<p><code>fgets</code>和<code>gets</code>,<code>getline</code>提供了单行输入的功能，单行I/O需要指定一个缓冲区，这个缓冲区是用户自己定义的，是应用程序级别的，它和标准I/O的buffer不一样，我们可以通过<code>setbuf</code>和<code>setvbuf</code>设置标准I/O的buffer，这是标准I/O即库函数层级的，而<code>read</code>和<code>write</code>等使用的buffer又是一类buffer，这是系统调用层级的，我们也可以自己指定。<br>
它们的原型如下：</p>
<h3 id="fgets和gets-getline原型"><code>fgets</code>和<code>gets</code>,<code>getline</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> getline(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream);</span><br><span class="line"><span class="keyword">ssize_t</span> getdelim(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, <span class="keyword">int</span> delim, FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="fgets和gets-getline性质"><code>fgets</code>和<code>gets</code>,<code>getline</code>性质</h3>
<ol>
<li><code>gets</code>从标准输入读，而<code>fgets</code>从指定的流中读</li>
<li><code>gets</code>不会读入<code>'\n'</code>，而<code>fgets</code>, <code>getline</code>都会读入<code>'\n'</code>;</li>
<li><code>fgets</code>需要指定缓冲的长度，遇到<code>&quot;\n&quot;</code>停止，但是不能超过<code>n-1</code>个字符，读入的字符送入缓冲区。缓冲区以<code>NULL</code>字节结尾，如果这一行包含最后一个换行符超过了<code>n-1</code>个字符，<code>fgets</code>只返回一个不完整的行，但是这一行还是以<code>NULL</code>结束，下一次调用继续从该行读。</li>
<li><code>gets</code>不推荐使用，因为没有指定缓冲区的长度，可能会造成缓冲区溢出，很危险。</li>
</ol>
<h3 id="fputs和puts原型"><code>fputs</code>和<code>puts</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="fputs和puts性质"><code>fputs</code>和<code>puts</code>性质</h3>
<ol>
<li><code>fputs</code>将一个以<code>NULL</code>字节结束的字符串写到指定的流中，尾端的<code>NULL</code>不输出。这并不是每次输出一行，只有<code>NULL</code>前面的字节中包含<code>'\n'</code>时，才会输出一行。</li>
<li><code>puts</code>不会输出<code>NULL</code>字节，但是会自动将字符串后添加一个换行符。</li>
<li><code>puts</code>并不像<code>gets</code>那样不安全，但是因为自动加了换行符很难受。所以尽量使用<code>fgets</code>和<code>fputs</code>。</li>
</ol>
<h2 id="二进制直接i-o">二进制直接I/O</h2>
<p>除了可以以字符和行为单位进行读取，还可以使用二进制stream进行I/O。</p>
<h3 id="fread和fwrite原型"><code>fread</code>和<code>fwrite</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="fread和fwrite性质"><code>fread</code>和<code>fwrite</code>性质</h3>
<ol>
<li><code>fread</code>和<code>fwrite</code>通常用来读写一个二进制数组或者一个结构体。<code>ptr</code>是要读写的首地址，<code>size</code>是每个对象的大小，<code>nmemb</code>是要写的对象的个数。</li>
<li><code>fread</code>和<code>fwrite</code>返回读写的对象数，读出错或者到达文件结尾，返回的数可以少于<code>nmemb</code>。可以调用<code>ferror</code>或者<code>feof</code>判断是结束还是出错。如果写返回的数值小于<code>nmemb</code>，那么就是出错。</li>
<li><code>fread</code>只能用于读在同一个系统上的数据，因为不同的系统上二进制文件的格式可能不同。</li>
<li><code>fread</code>和<code>read</code>的区别，<code>read</code>是系统调用，而<code>fread</code>是ISO C的函数。<code>read</code>的buf大小是字节，而<code>fread</code>的size是每个对象的大小，<code>nmemb</code>是对象的个数。</li>
</ol>
<h2 id="格式化i-o">格式化I/O</h2>
<p>除了三种非格式化的I/O，还有标准化I/O函数。标准化I/O函数需要指定格式说明。</p>
<h3 id="输出格式说明">输出格式说明</h3>
<p>格式说明控制其余参数如何编写，以后如何限制。每个参数按照转换说明编写，转换说明以%号开始。除了转换说明外，格式化字符串中的其他字符都按照原样输出。<br>
一个输出格式说明由四个可选部分构成：<br>
<code>%[flags][fldwidth][precision][lenmodifier] convtype</code></p>
<h4 id="flags">flags</h4>
<ul>
<li><code>'</code>，将整数按千位分组字符</li>
<li>‘-’，左对齐</li>
<li><code>+</code>，显示带符号数的正负号</li>
<li><code></code>，如果第一个字符不是正负号，在前面加上一个空格</li>
<li><code>#</code>，指定另一种形式，比如0x指定十六进制</li>
<li><code>0</code>，添加前导0而不是空格进行填充</li>
</ul>
<h4 id="fldwitdth">fldwitdth</h4>
<p>最小宽度，多余字符用空格填充</p>
<h4 id="precision">precision</h4>
<p>整形转换后最少输出数字位数<br>
浮点数转换后小数点后的最少位数。<br>
字符串转换后最大字节数</p>
<p>精度使用一个<code>.</code>，然后跟着一个可选的非负十进制整数或者<code>x</code>。</p>
<h4 id="lenmodifier">lenmodifier</h4>
<p><code>l</code>, <code>ll</code> , <code>L</code>分别表示<code>long</code>, <code>long long</code>以及<code>long double</code>。</p>
<h4 id="convtype">convtype</h4>
<ul>
<li><code>d</code>, <code>i</code>，有符号十进制</li>
<li><code>o</code>，无符号八进制</li>
<li><code>u</code>，无符号十进制</li>
<li><code>x</code>, <code>X</code>，无符号十六禁止</li>
<li><code>f</code>, <code>F</code>，双精度浮点数</li>
<li><code>e</code>, <code>E</code>，指数形式双精度浮点苏</li>
<li><code>g</code>, <code>G</code></li>
<li><code>a</code>, <code>A</code>，十六进制指数形式双精度浮点数</li>
<li><code>c</code>，字符</li>
<li><code>s</code>，字符串</li>
<li><code>p</code>，指向void的指针</li>
<li><code>n</code>，</li>
<li><code>%</code>，一个<code>%</code>字符</li>
<li><code>C</code>，宽字符，等于<code>lc</code></li>
<li><code>S</code>，宽字符串，等于<code>ls</code></li>
</ul>
<p>常见的格式化输出函数原型如下：</p>
<h3 id="printf-frpintf-dprintf-snprintf和fpritnf原型"><code>printf</code>, <code>frpintf</code>, <code>dprintf</code>, <code>snprintf</code>和<code>fpritnf</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="printf-frpintf-snprintf-dprintf和fpritnf性质"><code>printf</code>,<code>frpintf</code>, <code>snprintf</code>,<code>dprintf</code>和<code>fpritnf</code>性质</h3>
<ol>
<li><code>printf</code>将格式化数据输出到标准输出</li>
<li><code>fprintf</code>将格式化数据写到指定的流。</li>
<li><code>dprintf</code>将格式化数据写到指定的文件描述符。</li>
<li><code>sprintf</code>将格式化数据送入数组<code>buf</code>中，<code>sprintf</code>在数组的尾端自动加一个null字节，但是该字符不包含在返回值中。</li>
<li><code>sprintf</code>可能会造成<code>buf</code>指向的缓冲区溢出，调用者有责任保证该缓冲区足够大。</li>
<li><code>snprintf</code>是为了解决缓冲区溢出的问题而引入的，它需要显式指定缓冲区的长度，超过这个长度的话，输入数据都会被丢弃，同样<code>ssprintf</code>在数组的尾端自动加一个null字节，但是该字符不包含在返回值中。</li>
</ol>
<h3 id="输入格式说明">输入格式说明</h3>
<p>一个输入格式转换说明由三个可选部分：<br>
<code>%[*][fldwidth][m][lenmodifier] convtype</code></p>
<ol>
<li>fldwidth用于说明最大宽度</li>
<li>lenmodifier说明要用转换结果赋值的参数大小，<code>printf</code>函数族支持的长度修饰符同样能够得到<code>scanf</code>函数族的支持。</li>
<li>而convtype符号和<code>printf</code>中类似，但是有一些区别。比如，输入中的带符号数可以复制给无符号类型。</li>
</ol>
<h3 id="scanf-fscnaf-sscanf原型"><code>scanf</code>, <code>fscnaf</code>, <code>sscanf</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="scanf-fscnaf-sscanf性质"><code>scanf</code>, <code>fscnaf</code>, <code>sscanf</code>性质</h3>
<ol>
<li><code>scanf</code>用于分析输入字符串，并将字符序列转换成指定类型的变量。格式后的各个参数给出了变量的地址，用转换结果对这些变量赋值。</li>
<li>格式说明控制如何转换参数，以便于对他们赋值，除了转换说明和空白字符外，格式字符串中的其他字符必须和输入匹配，如果有一个不匹配，就停止处理。</li>
</ol>
<h2 id="标准i-o效率">标准I/O效率</h2>
<p><code>fgets</code>, <code>fgetc</code>, <code>getc</code>, <code>read</code>这几个函数，哪个效率更高？<br>
当他们同时读取一个300万行的98.5M的程序时，<code>read</code>效果最好。它们的系统CPU时间基本一样，但是用户CPU时间查了很多，以及等待I/O的时间也差了很多。为什么呢？</p>
<ol>
<li>系统CPU时间相同，因为它们对内核提出的读写请求数基本相同。</li>
<li>CPU时间差太多是因为，<code>getc</code>和<code>fgetc</code>需要进行上亿次的循环（上亿个字符），而<code>fgets</code>需要进行百万次的循环，而<code>read</code>只需要几万次（缓冲区大小设置为4096时）。</li>
<li><code>fgetc</code>和<code>read</code>缓冲区大小设置为1时，<code>read</code>要慢很多，因为<code>read</code>调用了两亿次系统调用，而<code>fget</code>调用了两亿次函数调用。系统调用的时间和各项开销要比函数调用大得多。</li>
</ol>
<h2 id="定位stream">定位stream</h2>
<p>有三种方法对I/O stream进行定位，分别是<code>ftell</code>和<code>fseek</code>，<code>ftello</code>和<code>fseeko</code>，<code>fgetpos</code>和<code>fsetpos</code>。它们的原型如下：</p>
<h3 id="ftell-feek-ftello-fseeko和fgetpos-fsetpos原型"><code>ftell</code>, <code>feek</code>, <code>ftello</code>, <code>fseeko</code>和<code>fgetpos</code>, <code>fsetpos</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *stream, <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *stream, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="keyword">off_t</span> ftello(FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="ftell-feek-ftello-fseeko和fgetpos-fsetpos性质"><code>ftell</code>, <code>feek</code>, <code>ftello</code>, <code>fseeko</code>和<code>fgetpos</code>, <code>fsetpos</code>性质</h3>
<ol>
<li><code>ftell</code>和<code>fseek</code>假设文件的位置可以存放在一个长整形中，而<code>ftello</code>和<code>fseeko</code>使用<code>off_t</code>代替了长整形。除此之外，它们完全相同。</li>
<li><code>fgetpos</code>和<code>fsetpos</code>是ISO C的标准，其他是SUS，所以跨平台时，使用<code>fgetpos</code>和<code>fsetpos</code>。</li>
<li>对于二进制文件，<code>whence</code>可以使用<code>SEEK_SET</code>, <code>SEEK_CUR</code>，这是跨平台的，而<code>SEEK_END</code>不是平台的。</li>
<li>对于文本文件，<code>whence</code>必须要用<code>SEEK_SET</code>且<code>offset</code>只能是0或者<code>ftell</code>返回的值。</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<p>所有的standard I/O库都要使用到文件的I/O。每个I/O stream都有一个和其相关的文件描述符，可以使用<code>fileno</code>函数获得stream的文件描述符。</p>
<h2 id="临时文件">临时文件</h2>
<p>ISO C提供了两个函数<code>tmpnam</code>和<code>tmpfile</code>帮助创建临时文件。它们的原型如下：</p>
<h3 id="tmpnam和tmpfile原型"><code>tmpnam</code>和<code>tmpfile</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="tmpnam和tmpfile性质"><code>tmpnam</code>和<code>tmpfile</code>性质</h3>
<ol>
<li><code>tmpnam</code>产生一个与现有文件名不同的一个有效路径名字符串。避免使用<code>tmpnam</code>。</li>
<li><code>tmpfile</code>创建一个临时二进制文件(wb+)，在关闭文件或者程序结束时自动删除这个文件。注意UNIX对于二进制文件不做特殊区分。</li>
<li><code>tmpfile</code>函数经常使用的标准UNIX技术是先使用<code>tmpnam</code>产生一个唯一的路径名，然后使用它创建一个文件，并且立刻<code>unlink</code>它。注意，对一个文件<code>unlink</code>之后，如果链接计数等于0，并不立即删除它，因为可能有进程在使用这个文件，关闭文件时才删除文件。</li>
<li><code>mkdtemp</code>和<code>mkstemp</code>是XSI的扩展部分。</li>
<li><code>mkstemp</code>和<code>mkdtemp</code>都需要传入一个字符串，它的后六位设置为<code>XXXXXX</code>，函数通过将这些占位符替换成不同的字符构建一个唯一的路径名。如果只指定了名字，就创建在当前目录下。</li>
<li><code>mkdtemp</code>创建的目录的权限是<code>S_IRUSR</code>,<code>S_IWUSR</code>, <code>S_IXUSR</code>。<code>mkstemp</code>创建的文件的权限是<code>S_IRUSR</code>,<code>S_IWUSR</code>，可以使用<code>umask</code>进行修改。</li>
<li><code>mkstemp</code>创建的文件不会被自动删除。</li>
</ol>
<h2 id="内存stream">内存stream</h2>
<p>Standard I/O把数据缓存在内存中，因此字符和单行的I/O更有效一些，我们也可以使用<code>setbuf</code>和<code>setvbuf</code>让标准I/O库使用自己指定的缓冲区。<br>
在SUS4之后添加了对memory streams的支持，这些standard I/O streams没有底层文件支持，但是仍然可以使用FILE指针访问，所有的I/O都是通过在缓冲区和主存中来回交换字节实现的。这些流虽然看起来像文件流，但是某些特征更像字符串操作。</p>
<p>有三个函数可以用于内存流的创建，它们分别是<code>fmemopen</code>，<code>open_memstream</code>和<code>open_wmemstream</code>。</p>
<h3 id="fmemopen函数和属性"><code>fmemopen</code>函数和属性</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>fmemopen</code>函数open memory as stream</li>
<li><code>fmemopen</code>函数允许调用者提供缓冲区用于memory stream，<code>size</code>指定了缓冲区大小的字节数。如果<code>buf</code>为空，<code>fmemopen</code>会分配<code>size</code>字节数的缓冲区，流关闭时缓冲区会被释放。</li>
<li><code>type</code>和<code>fopen</code>的取值一样，总共有15种取值，</li>
</ol>
<h3 id="open-memstream和open-wmemstream函数和属性"><code>open_memstream</code>和<code>open_wmemstream</code>函数和属性</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">open_memstream</span><span class="params">(<span class="keyword">char</span> **ptr, <span class="keyword">size_t</span> *sizeloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">open_wmemstream</span><span class="params">(<span class="keyword">wchar_t</span> **ptr, <span class="keyword">size_t</span> *sizeloc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它们一个面向字节，一个面向宽字节。它们和<code>fmemopen</code>之间的区别：</p>
<ol>
<li>创建的流只能打开；</li>
<li>不能指定自己的缓冲区，但是可以访问缓冲区地址和大小。</li>
<li>关闭流后需要自己释放缓冲区</li>
<li>对流添加字节会增加缓冲区大小。</li>
<li>缓冲区地址和长度只有在调用<code>fclose</code>或者<code>fflush</code>后才有效。这些值只有在下一次流写入或者调用<code>fclose</code>前。</li>
</ol>
<h2 id="标准i-o的替代软件">标准I/O的替代软件</h2>
<p>标准I/O库的一个不足是效率不高。这和它复制的数据量有关。每当使用一次<code>fgets</code>和<code>fputs</code>时，通常需要复制两次数据，一次是在用户程序的行缓冲区和标准I/O缓冲区之间，一次是在内核和标准I/O缓冲区之间。<br>
OK，这章我就认识到了这一个很重要的知识点。。<br>
使用<code>fgets</code>需要用户指定<code>fgets</code>使用的缓冲区，或者使用<code>getline</code>，如果传入的指针指向NULL，<code>getline</code>会负责分配缓冲区大小。<br>
标准I/O可以设置行缓冲和全缓冲，如果设置缓冲的话也需要一个缓冲区，通常是由系统指定的，当然也可以通过<code>setbuf</code>和<code>setvbuf</code>自己进行更改。而在<code>setbuf</code>中，如果<code>buf</code>是<code>NULL</code>的话，是关闭缓冲区，如果不为空的话，必须是<code>BUFSIZ</code>大小。在<code>setvbuf</code>中，通过<code>mode</code>指定缓冲区的类型，<code>buf</code>是<code>NULL</code>的话，库函数负责分配缓冲区。否则<code>buf</code>是多大就用多大的缓冲区。<br>
直接使用系统调用<code>read</code>和<code>write</code>函数也需要设置缓冲区，这是系统调用级别的，大小可以任意指定，通常使用<code>sturct stat.st_blksize</code>的大小。标准I/O库用的缓冲区和<code>read</code>,<code>write</code>指的是一个（我自己的理解）。<br>
内核中有buffer cache和page cache，调用<code>write</code>只是将数据复制到buffer cache和page cache，然后排入队列，实际的写磁盘操作可能在满足某个条件之后才实际写入磁盘。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuffer</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://stackoverflow.com/questions/20937616/what-is-the-difference-between-a-stream-and-a-file" target="_blank" rel="noopener">https://stackoverflow.com/questions/20937616/what-is-the-difference-between-a-stream-and-a-file</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/31/">31</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">304</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">28</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">381</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
