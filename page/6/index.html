<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/6/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/6/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/12/06/C-return/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/06/C-return/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">C/C++ return</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-06 15:31:03" itemprop="dateCreated datePublished" datetime="2019-12-06T15:31:03+08:00">2019-12-06</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-07 15:58:42" itemprop="dateModified" datetime="2019-12-07T15:58:42+08:00">2019-12-07</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="return和返回值类型"><code>return</code>和返回值类型</h2>
<p><code>return</code>语句结束当前正在执行的函数并将控制权返回到函数调用的地方。<br>
<code>return</code>语句有两种形式：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> ;</span><br><span class="line"><span class="keyword">return</span> expression ;</span><br></pre></td></tr></table></figure></p>
<h2 id="无返回值函数">无返回值函数</h2>
<p>没有返回值的语句只能出现在返回值类型是<code>void</code>的函数中。返回<code>void</code>类型的函数不一定非得有<code>return</code>语句，因为这类函数的最后一句会隐式的执行<code>return</code>。</p>
<h2 id="有返回值函数">有返回值函数</h2>
<p>只要函数的返回值不是<code>return</code>，就一定得有返回值。<code>return</code>语句返回值的类型必须和函数的返回类型相同，或者能隐式的转换成函数的返回类型。</p>
<h3 id="值是如何返回到的">值是如何返回到的</h3>
<p>返回一个值的方式和初始化一个变量或者一个形参的方式完全一样：返回的值用于初始化调用点的一个变量，这个临时变量就是函数调用的结果。<br>
如果函数返回引用，那么这个引用仅仅是它所引用对象的一个别名。</p>
<h3 id="不要返回局部对象的引用或者指针">不要返回局部对象的引用或者指针</h3>
<p>函数完成后，它所占用的存储空间也被释放掉了（函数的栈帧被释放了）。因此，函数终止意味着局部变量的引用将指向不再有效的内存空间，同样的，返回局部对象的指针也是错误的，函数一旦完成，局部对象被释放，指针将指向一个不存在的对象。</p>
<h3 id="返回类类型的的函数和调用运算符">返回类类型的的函数和调用运算符</h3>
<p>函数的返回值可以是应用，指针，类等对象，可以使用函数调用的结果访问结果对象的成员。</p>
<h3 id="引用返回左值">引用返回左值</h3>
<p>函数的返回值类型决定函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。</p>
<h3 id="列表初始化返回值">列表初始化返回值</h3>
<p>函数可以返回花括号包围的值的列表。这个列表也用来对表示函数返回的临时量进行初始化。如果列表为空，临时量进行值初始化。否则，返回的值由函数的返回类型决定。<br>
如果函数返回的是内置类型，则花括号包围的列表最多包含一个值，而且这个值所占空间不应该大于目标类型的空间。如果函数返回的是类类型，由类本身定义初始值如何使用。</p>
<h3 id="main函数的返回值"><code>main</code>函数的返回值</h3>
<p>对于<code>main</code>来说，允许它没有<code>return</code>语句直接结束，如果控制流到了<code>main</code>函数的结尾处而没有<code>return</code>语句，编译器将隐式的插入一条返回0的<code>return</code>语句。</p>
<h3 id="递归">递归</h3>
<p>如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为递归函数。</p>
<h2 id="返回数组指针">返回数组指针</h2>
<p>因为数组不能被拷贝，所以函数不能返回数组。不过可以返回数组的指针或者引用。</p>
<h3 id="声明一个返回数组指针的函数">声明一个返回数组指针的函数</h3>
<p>返回数组指针的函数形式如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type (*function(parameter_list)) [dimension]</span><br></pre></td></tr></table></figure></p>
<p>类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小，<code>(*function(parameter_list))</code>两端的括号必须在，否则函数的返回类型就是指针的数组。如下示例:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p><code>func</code>带有参数，说明它是一个函数，前面带有解引用操作，说明可以对函数调用的结果执行解引用操作，括号右面说明这是一个维度为10的数组，括号左面是数组类型。</p>
<h3 id="使用尾置返回类型">使用尾置返回类型</h3>
<p>可以使用尾置返回类型，任何函数的定义都能使用尾置返回，但是这种形式一般用于比较复杂的返回类型，比如数组的指针或者数组的引用。形式如下：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto func() -&gt; int (*)[10];</span><br></pre></td></tr></table></figure></p>
<h3 id="使用decltype">使用<code>decltype</code></h3>
<p>可以使用<code>decltype</code>声明返回值类型。比如返回一个指针时，<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(odd) *func(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>)? &amp;odd: &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="返回指向函数的指针">返回指向函数的指针</h2>
<p>和数组类似，虽然不能返回一个函数，但是可以返回指向函数类型的指针。**然后，我们必须把返回类型手动写成指针，编译器不会自动的将函数返回类型当成对应的指针类型处理。**最好的办法是使用类型别名：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> F = <span class="keyword">int</span>(<span class="keyword">int</span>*, <span class="keyword">int</span>);   <span class="comment">//F是函数，不是指针</span></span><br><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>*, <span class="keyword">int</span>);   <span class="comment">//PF是指针类型</span></span><br></pre></td></tr></table></figure></p>
<p>必须注意的是，和函数类型的形参不一样，返回类型不会自动的转换成指针，我们必须显式的将返回类型指定为指针。</p>
<h3 id="auto和decltype作用于函数指针"><code>auto</code>和<code>decltype</code>作用于函数指针</h3>
<p>将<code>decltype</code>作用于某个函数时，它返回函数类型而非指针类型，需要我们显式的加上<code>*</code>表示我们需要返回指针，而非函数本身。当<code>decltyp</code>作用于函数指针时，它返回的是函数指针类型。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/12/05/UNIX-Signals/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/05/UNIX-Signals/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">UNIX Signals</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-05 10:20:16" itemprop="dateCreated datePublished" datetime="2019-12-05T10:20:16+08:00">2019-12-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-24 18:50:58" itemprop="dateModified" datetime="2020-02-24T18:50:58+08:00">2020-02-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="program-error-signals">Program Error Signals</h2>
<p>当操作系统或者计算机本身检测到一个严重的程序错误时，它就会产生program error signals。一般来说，这些signals都表示你的程序出现了很严重的问题，没有办法继续进行计算了。<br>
一些程序为了在进程终止前进行清理，会建立handle program。这个handler结束的时候应该指定该signal的默认动作或者重新raise这个signal，这样子和原来没有建立signal处理程序的时候相比，仅仅多了清理的一部分，其他还和原来一样。一般来说，这些signal的默认动作都是终止进程。如果不是<code>raise</code>或者<code>kill</code>发出的这些signals，选择block或者忽略这些singals或者建立handlers让它们正常返回，程序可能会崩溃。<br>
当某一个program error signals终止一个进程的时候，它会写一个core dump文件记录进程终止状态。这个core dump文件的名字叫做core，保存在进程终止时所在目录。（在ubuntu中，没有保存文件，而是直接输出了出来[3]）</p>
<h3 id="sigfpe"><code>SIGFPE</code></h3>
<h3 id="sigill"><code>SIGILL</code></h3>
<h3 id="sigbus"><code>SIGBUS</code></h3>
<h3 id="sigsegv"><code>SIGSEGV</code></h3>
<h3 id="sigabrt"><code>SIGABRT</code></h3>
<h3 id="sigtrap"><code>SIGTRAP</code></h3>
<h3 id="sigemt"><code>SIGEMT</code></h3>
<h2 id="terminal-signals">Terminal Signals</h2>
<p>这一小节介绍的signal都是由于terminate一个进程的。它们之间的区别在于使用目的不同，并且程序可能对不同的signals有不同的处理方法。<br>
处理这些signals的目的是让进程在terminate之前能够进行合适的清理。比如，删除临时文件等等。</p>
<h3 id="sigint-程度最轻"><code>SIGINT</code>（程度最轻）</h3>
<p><code>SIGINT</code>是程序中断singal，当用户输入INTR字符（通常是C-c）时中断，发送到前台进程组的所有进程。</p>
<h3 id="sigtem-正常的kill"><code>SIGTEM</code>（正常的kill）</h3>
<p>这个signal可以被blocked, handled和忽略，shell命令的<code>kill(1)</code>默认会产生<code>SIGTERM</code> signal。</p>
<blockquote>
<p>It is the normal way to politely ask a program to terminate.</p>
</blockquote>
<h3 id="sigquit-可以忽略的最harvest信号"><code>SIGQUIT</code>（可以忽略的最harvest信号）</h3>
<p><code>SIGQUIT</code>和<code>SIGINT</code>很像，会中断一个进程，但是它被QUIT（通常是C-\）控制，发送给前台进程组的所有进程。并且当它terminate一个进程时，它会产生一个core dump，就像一个程序出错信号一样。<br>
在处理<code>SIGQUIT</code>的时候，最好不进行某些cleanups。比如，如果程序创建临时文件，处理其他termination时，最好把临时文件给删除了，但是对于<code>SIGQUIT</code>来说，最好不把它们给删了，因为用户可以用它们查找原因。</p>
<h3 id="sigkill-不能被捕捉或者忽略"><code>SIGKILL</code>（不能被捕捉或者忽略）</h3>
<p><code>SIGKILL</code> signal用于立刻终止程序。这是两个不能被捕捉或者忽略的信号之一（另一个是作业控制信号SIGSTOP）。它向系统管理员提供了一种可以杀死任一进程的可靠方法。<br>
这个singal通常是显式请求。因为他不能被handled，所以一般把它作为最后一个选择，在尝试了C-c或者<code>SIGTERM</code>不起作用之后，最后再使用<code>SIGKILL</code>。</p>
<h3 id="sighup"><code>SIGHUP</code></h3>
<p>如果终端接口检测到一个连接断开（可能因为网络或者电话连接断了），就将这个signal报告和这个终端相关的控制进程（会话首进程），会话首进程可能在后台，而上述几个SIGNAL都是发送给前台进程（除了SIGKILL)。</p>
<h3 id="其他">其他</h3>
<blockquote>
<p>The default behavior of SIGINT, SIGTERM, SIGQUIT and SIGHUP is to kill the program. However applications are allowed to install a handler for these signals. So the actual behavior of applications when they receive these signals is a matter of convention (which each application may or may not follow), not of system design.<br>
SIGINT is the “weakest” of the lot. Its conventional meaning is “stop what you’re doing right now and wait for further user input”. It’s the signal generated by Ctrl+C in a terminal. Non-interactive programs generally treat it like SIGTERM.<br>
SIGTERM is the “normal” kill signal. It tells the application to exit cleanly. The application might take time to save its state, to free resources such as temporary files that would otherwise stay behind, etc. An application that doesn’t want to be interrupted during a critical application might ignore SIGTERM for a while.<br>
SIGQUIT is the harshest of the ignorable signals. It’s meant to be used when an application is misbehaving and needs to be killed now, and by default it traditionally left a core dump file (modern systems where most users wouldn’t know what a core file is tend to not produce them by default). Applications can set a handler but should do very little (in particular not save any state) because the intent of SIGQUIT is to be used when something is seriously wrong.<br>
SIGKILL never fails to kill a running process, that’s the point. Other signals exist to give the application a chance to react.<br>
SIGHUP is about the same as SIGTERM in terms of harshness, but it has a specific role because it’s automatically sent to applications running in a terminal when the user disconnects from that terminal (etymologically, because the user was connecting via a telephone line and the modem hung up). SIGHUP is often involuntary, unlike SIGTERM which has to be sent explicitly, so applications should try to save their state on a SIGHUP. SIGHUP also has a completely different conventional meaning for non-user-facing applications (daemons), which is to reload their configuration file.</p>
</blockquote>
<h2 id="job-control-signals">Job Control Signals</h2>
<h3 id="sigcld"><code>SIGCLD</code></h3>
<h3 id="sigcont"><code>SIGCONT</code></h3>
<h3 id="sigstop"><code>SIGSTOP</code></h3>
<h3 id="sigstp"><code>SIGSTP</code></h3>
<p>交互停止信号，当用户在终端上按下(C-z)时，终端驱动程序产生这个信号，发送到前台进程组的所有进程。</p>
<h3 id="sigttin"><code>SIGTTIN</code></h3>
<h3 id="sigttou"><code>SIGTTOU</code></h3>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://unix.stackexchange.com/questions/251195/difference-between-less-violent-kill-signal-hup-1-int-2-and-term-15" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/251195/difference-between-less-violent-kill-signal-hup-1-int-2-and-term-15</a><br>
2.<a href="https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals" target="_blank" rel="noopener">https://www.gnu.org/software/libc/manual/html_node/Termination-Signals.html#Termination-Signals</a><br>
3.<a href="https://stackoverflow.com/questions/2065912/core-dumped-but-core-file-is-not-in-the-current-directory" target="_blank" rel="noopener">https://stackoverflow.com/questions/2065912/core-dumped-but-core-file-is-not-in-the-current-directory</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/12/04/UNIX-signal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/04/UNIX-signal/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">UNIX signal</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-04 15:22:47" itemprop="dateCreated datePublished" datetime="2019-12-04T15:22:47+08:00">2019-12-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-25 00:20:49" itemprop="dateModified" datetime="2020-02-25T00:20:49+08:00">2020-02-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>Signals是软件终端。它提供了一种处理异步事件的方法。</p>
<h2 id="什么是signal">什么是signal</h2>
<p>每一个signal都有一个名字，它们以三个字符<code>SIG</code>开头。例如：</p>
<ul>
<li><code>SIGABRT</code>是abort signal，调用abort函数时产生这种signal</li>
<li><code>SIGALRM</code>是闹钟signal，由alarm函数设置的定时器超时后产生这种signal</li>
</ul>
<p>在头文件<code>&lt;singal.h&gt;</code>中，signal name都被定义成正整数常量。如果内核包含对用户级应用程序有意义的文件，被认为是一种不好的形式，如果应用程序和内核需要使用同一个定义，那么就将有关信息放在内核头文件中，然后用户级头文件再包含该内核头文件。比如Linux 3.2.0将signal定义在<code>&lt;bits/signum.h&gt;</code>中。</p>
<p>很多条件可以产生signal：</p>
<ul>
<li>用户按一些键</li>
<li>硬件异常</li>
<li>调用<code>kill(2)</code>函数</li>
<li>调用<code>kill(1)</code>命令，它是<code>kill(2)</code>的接口</li>
<li>检测到某种软件条件已经发生</li>
</ul>
<p>常见的signal可以分为以下几类：</p>
<ul>
<li>程序出错signals，用于report程序错误</li>
<li>Termination singals，用于中断或者终止程序</li>
<li>Alarm signals,</li>
<li>异步I/O signals</li>
<li>Joc control signals</li>
<li>操作错误signal</li>
<li>miscellaneous signals</li>
<li>signal messages</li>
</ul>
<p>关于具体的每个signal的介绍，可以看书，看文档<code>man 7 signal</code>，或者查看另一篇文章<a href>UNIX signals</a>。</p>
<p>在某个signal出现后，可以按照以下三种方式之一进行signal处理：</p>
<ol>
<li>忽略singal。有两个signal不能被忽略：<code>SIGKILL</code>和<code>SIGTSTP</code>，它们向内核或者root用户踢欧冠呢了停止或者终止进程的可靠方法。还有某些硬件signal，除零或者非法内存引用，进程的行为是未定义的。</li>
<li>捕获signal。通过内核接收到某个signal后，调用相应的用户函数。</li>
<li>执行系统默认动作。对于大多数系统，默认动作是终止进程的执行。</li>
</ol>
<h2 id="函数signal">函数<code>signal</code></h2>
<p><code>signal</code>是ISO C定义的。但是ISO C不涉及多进程，进程组，终端I/O等概念。所以它对signal的定义非常含糊，对于UNIX的用处很小。<code>signal</code>的实现在不同UNIX版本上是不同的，最好使用<code>sigaction</code>函数代替<code>signal</code>。</p>
<h3 id="signal定义"><code>signal</code>定义</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure>
<h3 id="signal性质"><code>signal</code>性质</h3>
<ol>
<li><code>signal</code>函数有两个参数和一个返回值。第一个参数<code>signum</code>是整形，表示一个signal，第二个参数handler是函数指针，返回值也是一个函数指针。</li>
<li><code>handler</code>的值是常量<code>SIG_IGN</code>，<code>SIG_DFL</code>或者一个函数的地址。分别表示忽略该信号，执行默认动作，或者调用相应的函数。</li>
<li>**<code>signal</code>函数的返回值是指向之前的信号处理程序的函数指针。**所以，对于signal来说，只有改变信号的处理方式才能确定信号的当前处理方式。</li>
</ol>
<h3 id="exec和fork"><code>exec</code>和<code>fork</code></h3>
<p>当使用<code>exec</code>执行一个程序时，所有signal的状态都是系统默认或者忽略。<code>exec</code>函数将原先设置为要捕获的signal更改为默认动作，其他signal的状态不变。比如一个进程原先要捕获的signal，执行一个新程序后就不再catch了，因为signal catch函数的地址可能在执行的新程序文件中无意义了。</p>
<p>而fork因为复制了父进程的内存映像，所以信号捕捉函数的地址在子进程中是有意义的，子进程继承了父进程的信号处理方式。</p>
<h2 id="不可靠的signal">不可靠的<code>signal</code></h2>
<p>之前一些版本的signal是不可靠的，不可靠说的是：</p>
<ol>
<li>signal会丢失。比如一个signal发生了，但是进程却不知道。</li>
<li>进程对signal的控制能力很差。进程只能catch或者ignore signal，并不能阻塞signal。</li>
<li>进程每次接到signal对其进行处理时，然后将signal重置为默认值。</li>
<li>进程不希望发生某种signal时，不能关闭它，只能ignore它。</li>
</ol>
<h2 id="中断的系统调用">中断的系统调用</h2>
<p>如果进程在执行一个<strong>低速系统调用</strong>而<strong>阻塞</strong>期间捕捉到一个signal，这个系统调用就会被中断不再继续执行（不再阻塞），返回出错，errno设置为EINTR。<br>
什么是低速系统调用？系统调用被分为两类，一类是低速系统调用，另一类是其他系统调用。低速系统调用是指<strong>可能会使进程永远阻塞</strong>的一类系统调用，比如：</p>
<ol>
<li>如果某些类型文件（管道，终端设备和网络设备）的数据不存在，则读操作可能会使调用者永远阻塞。</li>
<li>pause和wait函数等。</li>
<li>…</li>
</ol>
<p>注意，与磁盘I/O有关的系统调用大多数时候总是会很快返回。</p>
<h2 id="可重入函数">可重入函数</h2>
<p>signal发生的时间是任意的，进程正在执行的正常指令可能会被信号处理程序中断，会对进程造成破坏。<br>
SUS说明了在信号处理程序中保证调用安全的函数，这些函数是可重入的，被称为异步信号安全的(async-signal safe)。如下所示是异步信号安全的函数：<br>
<img src="/2019/12/04/UNIX-signal/re.png" alt="re"><br>
其余的大多数函数是不可重入的，因为它们可能满足以下条件：</p>
<ol>
<li>使用静态数据结构；</li>
<li>调用<code>malloc</code>或者<code>free</code>；</li>
<li>是标准I/O函数。</li>
</ol>
<p>因为每个线程只有一个errno变量，所以信号处理程序可能会修改它的原值。因此，在调用可重入函数之前，应该先保存errno，在调用后恢复errno。</p>
<h2 id="sigcld语义">SIGCLD语义</h2>
<h2 id="可靠signal">可靠signal</h2>
<h2 id="函数">函数</h2>
<p>ISO C并不涉及多进程，所以它不能定义以进程ID为参数的函数。</p>
<h3 id="kill和raise"><code>kill</code>和<code>raise</code></h3>
<p>kill向参数pid指定的进程或者进程组发送一个signal。<br>
raise向调用者发送一个signal，ISO C中没有线程，POSIX.1扩展了raise可以处理多线程。单线程程序中等价于<code>kill(getpid(), sig)</code>。在多线程程序中等价于<code>pthread_kill(pthread_self(), sig)</code>。</p>
<h3 id="alarm和pause"><code>alarm</code>和<code>pause</code></h3>
<p>alarm不阻塞，当某个时刻到达时，内核会产生一个SIGALRM信号。<br>
pause使调用进程挂起，直到捕捉到任意一个信号，执行相应的信号处理程序，并从其返回时，pause才返回。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://www.gnu.org/software/libc/manual/html_node/Standard-Signals.html#Standard-Signals" target="_blank" rel="noopener">https://www.gnu.org/software/libc/manual/html_node/Standard-Signals.html#Standard-Signals</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/28/C-function-passing-arguments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/C-function-passing-arguments/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">C/C++ function passing arguments</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 23:49:24" itemprop="dateCreated datePublished" datetime="2019-11-28T23:49:24+08:00">2019-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-15 23:05:42" itemprop="dateModified" datetime="2019-12-15T23:05:42+08:00">2019-12-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参数传递">参数传递</h2>
<p>形参初始化的机理和变量初始化一样。形参的类型决定了形参和实参交互的方式。如形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。<br>
当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>，或者函数被<strong>传引用调用</strong>。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。<br>
当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>或者函数被<strong>传值调用</strong>。</p>
<p>因为C中没有引用，所以C中传递参数的方式只有值传递，而C++中还有引用，不仅有值传递，还有引用传递。</p>
<h2 id="值传参和引用传参">值传参和引用传参</h2>
<h3 id="值传参">值传参</h3>
<p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。值传参的原理和这个一样，函数对形参做的所有操作都不会影响实参。</p>
<h4 id="指针形参">指针形参</h4>
<p>指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。但是因为指针可以让我们间接访问它所指向的对象，所以可以通过指针修改它所指对象的值。</p>
<h3 id="引用传参">引用传参</h3>
<p>函数接受的参数是引用类型的话就是引用传参。通过使用引用形参，函数可以改变一个或者多个实参的值。<br>
引用传参的好处：</p>
<ol>
<li>避免拷贝，可以避免低效的拷贝操作，或者有些类型不支持拷贝，比如IO类型。</li>
<li>间接的实现多个返回值（也可以通过值传递指针实现）。</li>
</ol>
<h3 id="值传参和引用传参的区别">值传参和引用传参的区别</h3>
<p>值传参是将原始变量的值拷贝一份给形参，函数对形参的操作不会影响实参（指针可以简介的修改）。<br>
而引用传参是相当于直接把实参的引用给传递了形参，任何对形参的修改都是直接对实参的修改。</p>
<h2 id="const形参和实参"><code>const</code>形参和实参</h2>
<p>当形参是<code>const</code>时，必须注意顶层<code>const</code>，顶层<code>const</code>作业于对象本身。当用实参初始化形参时，会忽略掉顶层<code>const</code>，即形参的顶层<code>const</code>被忽略掉了。当形参有顶层<code>const</code>时，传递给它常量或者非常量对象都是可以的。</p>
<h3 id="指针或者引用形参和const">指针或者引用形参和<code>const</code></h3>
<p>形参的初始化方式和变量的初始化方式是一样的，所以指针或者引用形参和<code>const</code>结合时，按照<code>const</code>变量的初始化规则执行就行。</p>
<h3 id="尽量使用常量引用">尽量使用常量引用</h3>
<p>把函数不会修改的形参定义成普通的引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。（比如，不能把<code>const</code>对象，字面值或者需要类型转换的对象传递给普通的引用传参）</p>
<h2 id="数组形参">数组形参</h2>
<p>数组有两个特殊的性质：</p>
<ol>
<li>不允许拷贝，因为不能拷贝数组，所以不能以值传递的方式使用数组参数。</li>
<li>在使用数组时通常会将其转换成指针。因为数组会被转换成指针，所以为函数传递数组时，实际上传递的是指向数组首元素的指针，这样子可以节约开销。</li>
</ol>
<h3 id="管理数组转换的指针">管理数组转换的指针</h3>
<p>当传递给函数一个数组时，实参自动的转成指向数组首元素的指针，数组的大小对于函数的调用没有什么影响。因为数组是以指针的形式传递给函数的，所以函数其实是不知道数组的大小的，调用者应该为此提供一些额外的信息。通常有三种方式：</p>
<ol>
<li>显示传递一个表示数组大小的形参</li>
<li>使用标记指定数组长度，要求数组本身包含一个结束标记，典型的例子是C风格字符串。</li>
<li>使用标准库规范，传递数组首元素和尾后元素的指针。可以使用<code>begin</code>和<code>end</code>函数获得数组的首元素和尾后元素的指针。</li>
</ol>
<h3 id="数组形参和const">数组形参和<code>const</code></h3>
<p>当函数不需要对数组进行写操作时，数组形参应该是指向<code>const</code>的指针（底层const）。只有当函数确实需要改变数组元素值的时候，才把形参定义成指向非常量的指针。</p>
<h3 id="数组引用形参">数组引用形参</h3>
<p>C++允许将变量定义成数组的引用，形参也可以是数组的引用。此时，引用形参绑定到数组上。</p>
<h3 id="传递多维数组">传递多维数组</h3>
<p>C++其实没有真正的多维数组，多维数组其实就是数组的数组。把多维数组传递给函数时，传递的是指向数组首元素的指针。而多维数组是数组的数组，首元素本身就是一个数组，多维数组转换成指向数组的指针。数组第二维以及后面维度都是数组类型的一部分，不能省略。</p>
<h2 id="函数指针形参">函数指针形参</h2>
<p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。这个时候，形参看起来是函数类型，实际上是当成指针使用。<br>
可以直接把函数作为实参使用，这个时候它会自动的转换成指针：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个参数是函数类型，它会自动的转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"><span class="comment">//第三个参数是显式声明的指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"><span class="comment">// 函数lengthCompare会被自动的转换成函数指针</span></span><br><span class="line">useBigger(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用typedef和delctype简化函数指针">使用<code>typedef</code>和<code>delctype</code>简化函数指针</h3>
<p>可以使用下列语句定义函数指针：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个是函数类型：</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">delctype</span><span class="params">(lengthCompare)</span> Func2</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个是函数指针类型：</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">delctype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>decltype</code>返回函数类型，不会将函数自动转换成指针类型，只有在前面加上<code>*</code>才能得到指针。</p>
<h2 id="可变形参">可变形参</h2>
<p>当不知道向函数传递多少个参数时，C++ 11提供了两种方法处理不同数量实参，如果所有实参类型相同，传递<code>initializer_list</code>标准库类型，如果实参类型不同，编写特殊的函数，可变参数模板。<br>
此外，C++ 还有一种特殊的形参，叫做省略符，可以用它传递可变数量的实参。</p>
<h3 id="initializer-list形参"><code>initializer_list</code>形参</h3>
<p>如果实参数量未知，但是类型相同，可以使用标准库类型<code>initializer_list</code>类型的形参。该标准库提供的操作如下：</p>
<ul>
<li><code>initializer_list&lt;T&gt; lst</code>，默认初始化，T类型元素的空列表</li>
<li><code>initializer_list&lt;T&gt; lst{a, b, c...}</code>，list元素是对应初始值的副本，列表中的元素是<code>const</code></li>
<li><code>lst2(lst)</code>和<code>lst2 = lst</code>，注意，拷贝或者赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。</li>
<li><code>lst.size()</code></li>
<li><code>lst.begin()</code></li>
<li><code>lst.end()</code></li>
</ul>
<p><code>initializer_list</code>是一个标准库类型，它也是一个模板，它的元素永远都是常量。</p>
<p>有一个疑问，就是<code>std::initializer_list</code>和<code>std::vector</code>有什么区别？[2,3,4]<br>
拷贝<code>std::initializer_list</code>的时候并不会拷贝底层的对象。相当于拷贝了“指针”，或者说<code>std::initializer_list</code>有reference semantics而<code>std::vector</code>具有value semantics。</p>
<blockquote>
<p>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a std::initializer_list does not copy the underlying objects.</p>
</blockquote>
<h3 id="省略符形参">省略符形参</h3>
<p>省略符形参是为了便于C++访问某些特殊的C代码而设置的。省略符形参只能出现在形参列表的最后一个位置：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(param_list, ...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="main命令行选项"><code>main</code>命令行选项</h2>
<p>详细可以查看<a href>C/C++ main argc argv</a>。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版<br>
2.<a href="https://stackoverflow.com/questions/27753420/initializer-list-vs-vector" target="_blank" rel="noopener">https://stackoverflow.com/questions/27753420/initializer-list-vs-vector</a><br>
3.<a href="https://en.cppreference.com/w/cpp/utility/initializer_list" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/initializer_list</a><br>
4.<a href="https://stackoverflow.com/questions/14414832/why-use-initializer-list-instead-of-vector-in-parameters" target="_blank" rel="noopener">https://stackoverflow.com/questions/14414832/why-use-initializer-list-instead-of-vector-in-parameters</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/28/C-separate-compilation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/C-separate-compilation/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">C/C++ separate compilation</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 23:24:38" itemprop="dateCreated datePublished" datetime="2019-11-28T23:24:38+08:00">2019-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-10 19:27:09" itemprop="dateModified" datetime="2019-12-10T19:27:09+08:00">2019-12-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="功能文件头文件和实现">功能文件头文件和实现</h2>
<h3 id="头文件">头文件</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print_string.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT_STRING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_STRING</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="实现">实现</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print_string.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print_string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,  str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试文件实现">测试文件实现</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print_string.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line">    print_string(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译和链接">编译和链接</h2>
<p>执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp print_string.cpp -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>
<h2 id="理解">理解</h2>
<p>在<code>main</code>中包含了<code>print_string.h</code>头文件，相当于对函数进行了声明。然后使用<code>g++</code>编译的时候相当于提供了<code>print_string</code>的实现。</p>
<p>关于分离式编译的原理可以查看<a href>CSAPP linking</a>。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/28/UNIX-Process-Relationships/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/UNIX-Process-Relationships/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">Process Relationships</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 00:06:11" itemprop="dateCreated datePublished" datetime="2019-11-28T00:06:11+08:00">2019-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-04 12:30:45" itemprop="dateModified" datetime="2020-01-04T12:30:45+08:00">2020-01-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>在UNIX Process Control中，介绍了：</p>
<ol>
<li>每一个进程都有一个父进程，初始的kernel-level的进程通常是它自己。</li>
<li>当子进程终止的时候，父进程可以获得子进程的exit status。</li>
<li>同时在介绍<code>waitpid</code>的时候`提到了process groups，并且解释了我们可以等待一个进程组中任意进程的终止。</li>
</ol>
<p>这一篇文章更详细的介绍了process groups，以及POSIX.1中引入的session的概念。同时还介绍了用于登录的login shell和所有从login shell中启动的进程的关系。</p>
<h2 id="终端登录">终端登录</h2>
<h3 id="bsd登录">BSD登录</h3>
<p>系统bootstrap时，内核创建进程号为1的init进程。init进程使系统进行入多用户模式，init读取文件<code>/etc/tty</code>，对每一个允许登录的终端设备，init调用一次<code>fork</code>，它所生成的子程序<code>exec getty</code>程序。<br>
<code>getty</code>对终端设备调用<code>open</code>函数，以读写方式打开终端。一旦终端被打开，文件描述符0,1,2就被关联到该设备。然后<code>getty</code>输出<code>login</code>等字样，等待用户输入。当用户输入username之后，<code>getty</code>工作就结束了，接下来通过类似于以下的方式调用<code>login</code>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execle(&quot;/bin/login&quot;, &quot;login&quot;, &quot;-p&quot;, username, (char*)0, envp);</span><br></pre></td></tr></table></figure></p>
<p><code>login</code>得到了用户名，接下来调用<code>getpasswd</code>提示用户键入密码，然后调用<code>crypt</code>将用户键入的口令和shadow中的pwsswd比较，判断密码是否正确。如果密码正确的话，<code>login</code>还会进行以下工作：</p>
<ol>
<li>将当前工作目录改为用户的主目录。</li>
<li>调用<code>chown</code>更改终端的控制权，使登录用户成为它的所有者。</li>
<li>对终端设备的权限改成用户读和写。</li>
<li>用<code>login</code>得到的所有参数进行初始化</li>
<li><code>login</code>进程更改登录用户的<code>uid</code>并调用该用户的登录shell。</li>
</ol>
<p>当然现代的<code>login</code>不仅仅进行这些工作，还会根据启动文件更改或者增加用户的环境变量等等。</p>
<h2 id="网络登录">网络登录</h2>
<h3 id="bsd登录-v2">BSD登录</h3>
<p>网络登录的话，BSD中有一个inetd进程，等待绝大多数互联想链接。作为系统启动的一部分，<code>init</code>调用一个shell，使其执行shell脚本/etc/rc，shell脚本启动一个守护进程inetd。当这个shell脚本终止时，inetd的进程变成init。inetd等待TCP/IP连接，每当有一个连接到达时，就执行一次<code>fork</code>，然后使用<code>exec</code>执行相应的子程序。<br>
比如一个TELNET服务请求。客服进程打开一个到服务主机的TCP连接，客户机运行TELNET服务进程（用telnetd表示）。它们之间使用TELNET应用协议通过TCP交换数据。客服进程的用户登录到服务进程所在的主机。<br>
然后telnetd进程打开一个伪终端设备，并且使用<code>fork</code>将它们分成两个进程。父进程处理通过网络的通信，子进程执行login程序。父进程和子进程之间通过伪终端相连接。在调用<code>exec</code>之前，子进程使其文件描述符0,1,2和伪终端相连。登录成功的话，执行和终端操作类似的设置。</p>
<p>当通过终端或者网络登录时，我们得到一个登录shell，它的标准输入，标准输出和标准错误要么连接到一个终端设备，要么连接到一个伪终端设备。</p>
<h2 id="进程组">进程组</h2>
<p>除了pid，每一个进程还属于一个process group。进程组是一个或者一组进程的集合。他们都是同一个job的进程，每一个进程组都有一个唯一的进程组id，和pid类似，可以存放在pid_t中。函数<code>getpgrp</code>获得process group的ID，<code>getpgid</code>获得指定进程的进程组ID，它们都是SUS定义的。<br>
每个进程组有一个组长进程，组长进程的进程组ID和它的进程ID一样。进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，那么该进程组就存在，跟其组长是否终止无关。<br>
可以调用<code>setpgid</code>创建一个新的进程组后者加入一个现有的进程组。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>setpgid</code>将pid号为pid的进程的进程组ID设置为pgid。当子进程调用了<code>exec</code>之后，父进程就不能修改子进程的进程组ID了。<br>
通常在job control shell中，在fork之后调用此函数，父进程设置子进程的进程组ID，子进程也设置子进程的进程组ID，这两个调用总有一个是重复的，但是可以确保子进程的组ID被正确设置了。</p>
<h2 id="session">Session</h2>
<p>Session是一个或者多个进程组的集合。比如一个session可以有三个进程组：<br>
进程组1：登录shell，<br>
进程组2：proc1, proc2<br>
进程组3：proc3, proc4, proc5<br>
等等。通常一个进程组的进程是由一个shell pipeline生成的。比如上面的进程组可能是通过以下shell命令实现的：<br>
proc1 | proc2 &amp;<br>
proc3 | proc4 | proc5</p>
<p>可以调用<code>setsid</code>创建一个新的session：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个函数具有以下性质：<br>
如果调用这个函数的进程不是一个进程组的组长，就创建一个新的session：</p>
<ol>
<li>该进程变成新的session的session leader，这个session leader是创建该session的进程。注意SUS只说明了session leader，而没有像pid和process gid之类的session id。也就是说session leader是有唯一PID的单个进程，可以将session leader的ID当做session ID。<strong>注意什么是session leader，它是一个进程，而session ID是session leader的PID，或者也把session ID较为session leader的process group ID</strong>。</li>
<li>调用进程是新进程组和新session中的唯一一个进程。</li>
<li>新的session没有controlling terminal。</li>
</ol>
<h2 id="控制终端">控制终端</h2>
<p>session和process group的一些其他属性：</p>
<ul>
<li>一个session通常会有一个controlling terminal，通常是终端设备或者伪终端设备。</li>
<li>建立和控制终端连接的session leader被称为controlling process（控制进程）。</li>
<li>一个session中的几个process group可以被分为一个foreground process group（前台进程组）和多个background process group（后台进程组）。</li>
<li>如果一个session有一个controlling terminal，那么它有一个前台进程组，其它进程组为后台进程组。</li>
<li>无论何时键入终端的中断键，ctrl+C，都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键，ctrl+\，都会将退出信号发送到前台进程组的所有进程。</li>
<li>如果终端接口检测到网络已经断开，将挂断信号发送到session leader。</li>
</ul>
<p>登录shell属于后台进程组，它是session leader，也就是controlling process。登录时，会自动建立controlling terminal。有时候不管标准输入，标准输出是否重定向，程序都要和控制终端交互，可以open文件/dev/tty。在内核中，/dev/tty是controlling terminal的同义词，如果没有controlling terminal，对于这个设备的open失败。</p>
<h2 id="tcgetpgrp-tcsetpgrp和tcgetsid"><code>tcgetpgrp</code>, <code>tcsetpgrp</code>和<code>tcgetsid</code></h2>
<h3 id="函数原型">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> tcgetpgrp(<span class="keyword">int</span> fd);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> tcgetsid(<span class="keyword">int</span> fd);</span><br></pre></td></tr></table></figure>
<h3 id="属性">属性</h3>
<ol>
<li><code>tcgetpgrp</code>返回前台进程组ID，它与在fd上打开的终端相关联。</li>
<li>如果进程有一个controlling terminal，这个进程可以调用<code>tcsetpgrp</code>将前台进程组ID设置为pgrpid，fd必须引用该session的controlling terminal。</li>
<li>可以通过<code>tcgetsid</code>函数获得session leader的进程组ID。</li>
</ol>
<h2 id="job-control">job control</h2>
<p>可以在一个终端上启动多个jobs（groups of process），它控制哪个job可以访问终端，哪个job应该在后台运行，job control需要满足以下三个条件：</p>
<ol>
<li>支持job control的shell</li>
<li>内核的终端驱动程序必须支持job contrl</li>
<li>内核必须支持某些特定的job-control signals。</li>
</ol>
<p>在shell中使用job contrl，我们可以创建前台的job，也可以创建后台的job，一个job是进程的集合，通常是进程的pipeline，可以在后台运行多个job。<br>
可以通过键入几个特殊字符和终端驱动程序进行交互作用，控制前台进程组的所有进程：</p>
<ul>
<li>中断，ctrl+C，产生SIGINT</li>
<li>退出，ctrl+\，产生SIGQUIT</li>
<li>挂起，ctrl+Z，产生SIGSTRP</li>
</ul>
<p>终端驱动程序还需要处理一些情况：</p>
<ol>
<li>当后台job试图读取终端时<br>
如果有一个前台job和多个后台jobs。一般情况下，只有前台job接收终端输入，当后台job试图从终端读取，并不会报错，终端驱动程序会检测这种情况，并且向后台job发出一个SIGTTIN signal。这个signal会停止后台job，shell向有关用户发出通知说你的后台job停止啦！然后用户可以用shell命令将它转换后前台job，从终端读取。<br>
如果</li>
<li>当后台job试图写终端时<br>
当用户禁止后台job向controlling terminal写后，当后台job试图写向标准输出，终端驱动程序识别出这个写操作来自于后台job，向该job发出SIGTTOU signal，阻塞相应的job。当用户使用fg将后台job转换为前台job时，job继续执行。</li>
</ol>
<h2 id="shell执行过程">shell执行过程</h2>
<p>有些shell支持job control，比如bash，有些不支持，比如Bourne shell。</p>
<p>执行以下命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,comm | cat      // 后台job</span><br><span class="line">ps -o pid,ppid,pgid,sid,comm | cat &amp;    // 前台job</span><br></pre></td></tr></table></figure></p>
<h3 id="不支持job-control的shell">不支持job control的shell</h3>
<p>在不支持job control的shell中，管道的最后一个进程是shell的子进程，而执行管道中其他命令的进程是该最后进程的子进程。当最后一个进程终止时，shell得到通知。<br>
所有的job的process group id和shell的都一样。<br>
<img src="/2019/11/28/UNIX-Process-Relationships/shell_no_job_control.png" alt="shell_no_job_control"></p>
<h3 id="支持job-control的shell">支持job control的shell</h3>
<p>而在支持job control的shell中<br>
每一个job都有一个自己的process group id，和shell的不一样。<br>
shell是两个job的父进程。</p>
<h2 id="孤儿进程组">孤儿进程组</h2>
<p>当一个进程的父进程退出之后，而子进程还没有结束，这个进程就成了孤儿进程。进程组也可以是孤儿进程组。<br>
什么是孤儿进程组：<br>
进程组中每个成员的父进程要么是它组内的一个成员，要么不是这个进程组所在session的成员。</p>
<h2 id="freebsd实现">FreeBSD实现</h2>
<p>每个session都会有一个seesion结构，它包含：</p>
<ul>
<li><code>s_count</code></li>
<li><code>s_leader</code></li>
<li><code>s_ttyvp</code></li>
<li><code>s_ttyp</code></li>
<li><code>s_sid</code>，这一部分不是SUS的组成，只有FreeBSD有。</li>
</ul>
<p>每个终端或者伪终端会在内核中分配一个tty结构，它包含：</p>
<ul>
<li><code>t_session</code></li>
<li><code>t_pgrp</code></li>
<li><code>t_termios</code></li>
<li><code>t_winsize</code></li>
</ul>
<p>每个进程组都包含一个pgrp结构，它包含：</p>
<ul>
<li><code>pg_id</code></li>
<li><code>pg_session</code></li>
<li><code>pg_memebers</code></li>
</ul>
<p>每个进程都有一个<code>proc</code>结构，它包含：</p>
<ul>
<li><code>p_pid</code></li>
<li><code>p_ptr</code></li>
<li><code>p_grp</code></li>
<li><code>p_pglist</code></li>
</ul>
<p>进程通过v_node结构体访问/dev/tty。</p>
<p>它们之间的关系如下图所示：<br>
<img src="/2019/11/28/UNIX-Process-Relationships/" alt="session_and_process_group"></p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/27/assembly-languages/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/27/assembly-languages/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">assembly languages</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-27 21:36:52 / 修改时间：22:00:57" itemprop="dateCreated datePublished" datetime="2019-11-27T21:36:52+08:00">2019-11-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/汇编/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="机器指令">机器指令</h2>
<p>计算机指令可以表示为序列化的bits，一般来说，这是一个程序最低级别的表示-每一条指令都等于CPU的一个单个的，不可分隔的指令。这种表示方法叫做机器语言，因为它是机器可以理解的唯一一种形式。</p>
<h2 id="汇编语言">汇编语言</h2>
<p>一种更高level的表示叫做assembly language。Assembly language和机器语言的很类似，通常可以很方便的把程序从汇编语言转换成机器语言。因为机器语言和汇编语言的相似性，每一个不同的机器架构都有它自己的汇编语言。事实上，每一个架构都可能有好几个汇编语言。<br>
汇编语言的优势是汇编语言对于人类来说是更容易阅读和理解的。举例来说，将寄存器20和寄存器17的内容相加，并将结果存放在寄存器16的MIPS机器语言指令是：0x02918020。给出这个指令，很难直接理解它是怎么工作的。相同的MISP汇编指令是：<br>
<code>add $16, $20, $17</code><br>
可读性更强。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/26/C-strlen-vs-sizeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/C-strlen-vs-sizeof/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">C/C++ strlen vs sizeof</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 10:07:37" itemprop="dateCreated datePublished" datetime="2019-11-26T10:07:37+08:00">2019-11-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:33:22" itemprop="dateModified" datetime="2019-12-17T15:33:22+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><code>strlen</code>不计算字符串数组的null字节，而<code>sizeof</code>会计算null字节所占的字节。</li>
<li><code>strlen</code>是一个函数，使用时需进行一次系统调用。而<code>sizeof</code>会在编译时计算。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版8.3节</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-struct/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">UNIX struct</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 17:34:51" itemprop="dateCreated datePublished" datetime="2019-11-25T17:34:51+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-08 13:52:58" itemprop="dateModified" datetime="2019-12-08T13:52:58+08:00">2019-12-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>struct FILE<br>
{</p>
<p>};</p>
<p>struct DIR<br>
{</p>
<p>};</p>
<h2 id="结构体">结构体</h2>
<p>POSIX定义了<br>
struct dirent<br>
{</p>
<p>};</p>
<p>struct pwd<br>
{</p>
<p>};</p>
<p>struct spwd<br>
{</p>
<p>};</p>
<p>struct grp<br>
{</p>
<p>};</p>
<p>struct timespec<br>
{</p>
<p>};</p>
<p>struct sm{</p>
<p>};</p>
<h2 id="进程资源限制">进程资源限制</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct rlimit&#123;</span><br><span class="line">    rlim_t rlim_cur;</span><br><span class="line">    rlim_t rlim_max;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版<br>
2.<a href="https://en.cppreference.com/w/c/chrono/timespec" target="_blank" rel="noopener">https://en.cppreference.com/w/c/chrono/timespec</a><br>
3.<a href="https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html" target="_blank" rel="noopener">https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-Process-Control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-Process-Control/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/6/index.html">UNIX Process Control</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 10:31:02" itemprop="dateCreated datePublished" datetime="2019-11-25T10:31:02+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-20 16:45:20" itemprop="dateModified" datetime="2020-02-20T16:45:20+08:00">2020-02-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一节主要介绍UNIX系统的进程控制，包括进程创建，进程执行和进程控制。以及进程属性的各种的ID-real UID, real GID和effective UID, effective GID和save UID， set UID和set GID，以及它们如何收到进程控制原语的影响。</p>
<h2 id="进程标识-pid">进程标识(pid)</h2>
<p>每一个进程都有一个非负整数表示它的唯一进程ID。进程ID标识符总是唯一的，但是可以复用。<br>
关于和进程ID相关的内容，可以查看<a href></a>。</p>
<h2 id="fork"><code>fork</code></h2>
<p><code>fork</code>创建一个子进程。函数原型：</p>
<h3 id="fork原型"><code>fork</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="fork性质"><code>fork</code>性质</h3>
<ol>
<li><strong>进程ID</strong>。<code>fork</code>调用一次，返回两次，分别是0和子进程ID，用以区别父进程和子进程。对于父进程，返回子进程ID，对于子进程，返回0。因为父进程可能有多个子进程，并且没有提供获得一个进程所有子进程ID的函数，而fork只有一个父进程，可以通过<code>getppid</code>获得它的父进程的ID。所以这样子进行区分。</li>
<li>子进程和父进程分别继续执行调用<code>fork</code>之后的指令。子进程是父进程的副本。子进程获得父本的数据段，堆和栈的完全副本。这是子进程的副本，和父进程不一样，它们并不共享数据的内存空间，但是它们共享text segment。</li>
<li>现代的操作系统实现，使用写时复制代替了父进程数据段，堆和栈的完全副本。这些区域是由父进程和子进程共享的，但是它们的访问权限是只读。如果父进程或者子进程想要对这些区域进行修改的话，内核会为修改区域的那块内存制作一个副本，用于进程修改。</li>
<li>父进程和子进程因为不共享数据，堆和栈，每个进程都有自己的变量，不会相互影响。</li>
<li><strong>执行顺序</strong>。<code>fork</code>后父进程和子进程的执行顺序是不确定的，这跟内核的调度算法有关。如果要求父进程和子进程之间进行同步，需要它们之间进行某种形式的进程通信。</li>
<li><strong>文件共享</strong>。对于父进程打开的文件，<code>fork</code>相当于将父进程的文件描述符都复制到了子进程中，相当于对父进程的每一个文件描述符，都调用了<code>dup</code>函数。父进程和子进程每个相同的打开文件描述符共享同一个文件表项。一般来说，在<code>fork</code>之后处理文件描述符有以下两种情况：
<ul>
<li>父进程等待子进程完成。父进程不需要对它的文件描述符做任何处理。</li>
<li>父进程和子进程分别执行不同的程序段。父进程和子进程各自关闭它们不需要的文件描述符。</li>
</ul>
</li>
<li><strong><code>fork</code>后子进程继承的信息</strong>。
<ul>
<li>real UID, real GID, effective UID, effective GID</li>
<li>set UID和 set GID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>Session ID</li>
<li>控制终端</li>
<li>cwd</li>
<li>root dir</li>
<li>umask</li>
<li>signal mask</li>
<li>文件描述符标志</li>
<li>环境</li>
<li>共享的内存段</li>
<li>内存映像</li>
<li>Resource limits</li>
</ul>
</li>
<li><strong>父进程和子进程的区别。</strong>
<ul>
<li><code>fork</code>的返回值不同</li>
<li>pid不同</li>
<li>它们有不同的ppid</li>
<li>子进程的很多时间设置为0</li>
<li>父进程设置的文件锁子进程不继承。</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号被设置为空集。</li>
</ul>
</li>
<li><strong><code>fork</code>的两种用法</strong>。
<ul>
<li>父进程和子进程分别执行不同的代码。比如网络服务中，父进程负责等待客户端请求，子进程负责处理父进程接收到的请求。</li>
<li>一个进程要执行不同的程序。对shell比较常见，通常执行完<code>fork</code>返回后立即调用<code>exec</code>。</li>
</ul>
</li>
</ol>
<h2 id="vfork"><code>vfork</code></h2>
<p>创建一个子进程，并且阻塞父进程，函数原型如下：</p>
<h3 id="vfork原型"><code>vfork</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="vfork属性"><code>vfork</code>属性</h3>
<ol>
<li><code>vfork</code>和<code>fork</code>都创建一个新进程，但是<code>vfork</code>并不会将父进程的地址空间完全复制到子进程中。因为子进程会立即调用<code>exec</code>或者<code>exit</code>，就不会引用该地址空间。但是如果在调用<code>exec</code>或者<code>exit</code>之前，它会在父进程的空间中运行，这种做法会提高效率。但是如果子进程修改除了<code>vfork</code>的返回值，或者在没有调用<code>exit</code>或者<code>exec</code>之前调用其他函数，这种行为是未定义的。</li>
<li><code>vfork</code>保证子进程先运行，在子进程没有调用<code>exec</code>或者<code>exit</code>时，内核会使父进程休眠，在子进程调用<code>exec</code>或者<code>exit</code>这两个中的任何一个后，父进程才会恢复运行。如果子进程需要父进程进一步操作的时候，就会产生死锁。</li>
</ol>
<h2 id="exit函数"><code>exit</code>函数</h2>
<p>关于<code>exit</code>函数的介绍，可以查看<a href>C/C++ exit and return</a>。<br>
总共有八种方式可以让进程终止，包括五种正常和三种异常，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回，相当于调用<code>exit</code>。</li>
<li>调用<code>exit</code>，ISO C定义的，它的操作包括调用各个exit handler，处理所有标准I/O流。<code>exit</code>会冲洗标准I/O流，如果这是函数库所采取的唯一的动作，那么不会出现什么问题。而如果<code>exit</code>除了冲洗标准I/O流，还会关闭I/O流，那么在<code>vfork</code>时就会出问题了。当然，现在的<code>exit</code>实现都不会关闭流了，这个操作一般都交给内核实现。</li>
<li>调用<code>_exit</code>或者<code>_Exit</code>，ISO C定义了<code>_Exit</code>，而POSIX.1说明了<code>_exit</code>。它的目的是提供一种无需运行exit handler或者信号处理程序而终止的方法。是否对标准I/O流进行flush，取决于实现。在UNIX中，<code>_Exit</code>和<code>_exit</code>是同义的，并不冲洗I/O流。</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程以哪种方式终止，最后都会执行内核中的同一段代码，这段代码为相关进程关闭所有打开的文件描述符，释放它使用的内存。<br>
为了让终止进程能够通知父进程它是如何终止的。对于3个终止函数，将它的<code>exit status</code>作为参数传递给函数。在异常终止的情况下，内核产生一个指示其异常终止原因的terminaiton status（终止状态）。在任意终止情况下，这个终止进程的父进程都能用<code>wait</code>或者<code>waitpid</code>函数获得它的终止状态。<br>
<strong>如果父进程在子进程之前终止</strong>，所有终止进程的子进程的父进程都变成<code>init</code>进程，<code>init</code>进程负责获得终止状态。对于一个即将终止的进程，内核检查所有活动进程，判断其中是否有待终止进程的子进程，如果有的话，将这些进程的父进程的ID改为<code>init</code>进程的PID 1。<br>
<strong>如果子进程在父进程之前终止</strong>。内核为每一个终止进程保留了一部分信息，当终止进程的父进程调用<code>wait</code>或者<code>waitpid</code>时，可以获取这些信息，这些信息包含终止进程PID，进程的终止状态，进程占用的CPU时间总量。内核可以释放这些进程的内存，关闭打开的文件。如果一个进程终止了，但是它的父进程没有等待它，它被称为一个zombie（僵尸）进程，这些信息不会被释放。如果一个长期运行的进程，<code>fork</code>了很多子进程，除非父进程调用wait得到子进程的终止状态，否则它们就会变成僵尸进程。<br>
<code>init</code>的子进程，不会变成僵尸进程，因为<code>init</code>进程被编写成无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数获得其终止状态。</p>
<h2 id="wait和waitpid"><code>wait</code>和<code>waitpid</code></h2>
<p>当一个进程终止的话（无论正常还是异常），内核就会向它的父进程发送<code>SIGCHLD</code>信号。而子进程终止是个异步事件，可以在父进程运行的任何时候发生。对于这种信号，父进程可以忽略它，或者调用一个信号处理函数。<br>
调用了<code>wait</code>或者<code>waitpid</code>的进程，可能会处于以下几种状态之一：</p>
<ol>
<li>所有子进程都还在运行，则阻塞。</li>
<li>一个子进程已经终止，正在等待父进程获取其终止状态，那么取得该子进程的终止状态立即返回。</li>
<li>如果它没有任何子进程，立即出错返回。</li>
</ol>
<p>如果进程由于接收到<code>SIGCHLD</code>而调用<code>wait</code>，我们期望<code>wait</code>会立即返回。如果在随机的时间点调用<code>wait</code>，进程可能会阻塞。</p>
<h3 id="wait和waitpid原型"><code>wait</code>和<code>waitpid</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *wstatus);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<h3 id="wait和waitpid性质"><code>wait</code>和<code>waitpid</code>性质</h3>
<ol>
<li>在一个子进程终止前，<code>wait</code>使其调用者阻塞，直到任意一个子进程终止。<code>wait</code>返回终止子进程的进程ID。如果<code>wait</code>要等待一个特定的进程，将返回的pid和要等待的pid相比，如果不相等，将这个pid和termination status保存起来，再次调用<code>wait</code>，直到等到目标pid。下一次想要等待一个特定进程的时候，现场看已经终止的进程列表中是否已有它 ，没有的haunted继续调用<code>wait</code>。</li>
<li>ISO中定义了<code>waitpid</code>中option的四个可能值：0，<code>WNOHANG</code>, <code>WUNTRACED</code>和<code>WCONTINUED</code>。POSXI扩展了许多其他选项。其中0表示阻塞调用，<code>WNOHANG</code>表示如果没有子进程结束就立刻退出，<code>WUNTRACED</code>表示如果一个子进程停止了也返回，<code>WCONTINUED</code>表示一个子进程恢复运行了也会返回。</li>
<li>指定option为0时，设置<code>waitpid</code>阻塞等待指定的进程pid。当<code>pid</code>为-1时，<code>waitpid</code>和<code>wait</code>一样。当<code>pid</code>大于或者小于0时，等待相应的pid（绝对值）。当pid等于0时，等待gid等于调用进程组id的任意一个子进程。</li>
<li>指定option为<code>WNOHANG</code>，设置<code>waitpid</code>不阻塞，表示如果没有子进程结束，就立刻返回。在Linux上，<code>WNOHANG</code>是1。</li>
<li>指定option为<code>WUNTRACED</code>和<code>WCONTINUED</code>，设置<code>waitpid</code>支持job control。</li>
<li>对于<code>wait</code>，只有当调用进程没有子进程时，才出错。对于<code>waitpid</code>，指定的进程或者进程组不存在，或者参数pid不是调用进程的子进程时，都会出错。</li>
<li><code>wstatus</code>是一个整形指针。如果它不为空指针，终止进程的终止状态就存放在它所指的单元内。</li>
<li><code>wstatus</code>指向的整形变量的意义是由实现定义的，其中的某一些位表示exit status，即正常退出。另外一些位表示signal number，表示不正常退出，一位表示是否产生core file，等等。POSIX.1指定了termination status可以用<code>&lt;sys/wait.h&gt;</code>中定义的宏查看。四个互斥宏可以用来取得进程终止的原因：
<ul>
<li><code>WIFEXITED(status)</code>，如果status是一个正常终止子进程返回的，为true。执行<code>WEXITSTATUS(statue)</code>获取子进程传递给<code>exit</code>或者<code>_exit</code>的参数的低八位。</li>
<li><code>WIFSIGNALED(status)</code>，如果status是一个异常终止子进程返回的，为true。执行<code>WTERMSIG(status)</code>获取使得子进程终止的signal。</li>
<li><code>WIFSTOPPED(status)</code>，如果status是一个当前暂停的子进程返回的，为true。执行<code>WSTOPSIG(status)</code>获取使得子进程暂停的signal。</li>
<li><code>WIFCONTINUED(status)</code>，。</li>
</ul>
</li>
<li><code>fork</code>两次可以让原始进程不用自己调用<code>wait</code>，也可以避免产生僵尸进程。</li>
</ol>
<h2 id="waitid"><code>waitid</code></h2>
<h3 id="waitid原型"><code>waitid</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="waitid性质"><code>waitid</code>性质</h3>
<ol>
<li><code>waitid</code>是SUS指定的，不是ISO C的部分。</li>
<li><code>waitid</code>和<code>waitpid</code>类似，但是它使用两个单独的参数表示要等到的子进程所属的类型，用<code>idtype</code>表明<code>id</code>的类型，用<code>id</code>表示pid或者进程组id。<code>idtype</code>的取值如下：
<ul>
<li><code>P_PID</code>，等待特定进程，id指定要等待的子进程的pid</li>
<li><code>P_PGID</code>，等待特定进程组中的任一子进程，id是包含要等待子进程的组ID</li>
<li><code>P_ALL</code>，等待任意子进程，忽略id。</li>
</ul>
</li>
<li><code>options</code>参数是以下标志的按位或运算。
<ul>
<li><code>WCONTINUED</code></li>
<li><code>WEXITED</code></li>
<li><code>WNOHANG</code></li>
<li><code>WNOWAIT</code></li>
<li><code>WSTOPPED</code></li>
</ul>
</li>
<li><code>siginfo_t</code>结构体包含了子进程状态改变有关signal的详细信息。</li>
</ol>
<h2 id="wait3和wait4"><code>wait3</code>和<code>wait4</code></h2>
<p>大多数UNIX系统都支持<code>wait3</code>和<code>wait4</code>，它们是从BSD延续下来的。它们的功能比POSIX.1函数<code>wait</code>, <code>waitpid</code>和<code>waitid</code>要多一个。可以通过附加参数允许内核返回终止进程以及其所有子进程使用的资源概况。包含用户CPU时间总量，系统CPU时间总量，缺页次数，接收到的signal次数。<br>
它们的原型如下：</p>
<h3 id="wait3和wait4原型"><code>wait3</code>和<code>wait4</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options, struct rusage *rusage);</span><br><span class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options, struct rusage *rusage);</span><br></pre></td></tr></table></figure>
<h2 id="race-condition">race condition</h2>
<p>如果多个进程都企图对共享数据进行某种处理，而且最后的结果取决于进程运行的顺序时，我们认为发生了race condition。<br>
如果一个进程希望等待子进程终止，可以调用<code>wait</code>函数中的一个。如果一个子进程想要等待父进程终止，可以使用下列形式的循环，称为轮询（polling)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式浪费了很多CPU时间。为了避免这些问题，可以使用signal或者进程间通信解决这些问题。</p>
<h2 id="exec"><code>exec</code></h2>
<p>通常使用<code>fork</code>创建新的子进程之后，子进程往往会调用一种<code>exec</code>函数执行另一个程序。当进程调用<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序从其<code>main</code>函数开始执行。调用<code>exec</code>并不会创建新进程，所以前后的进程ID不变。<code>exec</code>使用磁盘上的一个新程序替换了当前进程的text segment, data segment, heap和stack。<code>exec</code>函数只有在出错的时候才返回-1，并且设置<code>errno</code>。<br>
总共有七种不同的<code>exec</code>函数，它们被统称为<code>exec</code>函数。它们的原型如下：</p>
<h3 id="exec函数原型"><code>exec</code>函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> fexecve(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[]);</span></span></span><br></pre></td></tr></table></figure>
<h3 id="exec函数属性"><code>exec</code>函数属性</h3>
<ol>
<li><strong>传入参数的区别。</strong> <code>path</code>是路径名作为参数，<code>file</code>是文件名作为参数。如果<code>path</code>中包含<code>'/'</code>，将它看成路径名。否则按照PATH环境变量，在它指定的目录中搜寻可执行文件。如果函数<code>execlp</code>和<code>execvp</code>在PATH指定的目录中找到的文件不是link editor产生的可执行文件，就会把它当做一个shell脚本，调用<code>/bin/sh</code>，把这个文件当做shell的输入。</li>
<li><strong>argmuent list的区别。</strong> l表示的是列表，v表示的是向量。<code>execl</code>, <code>execlp</code>和<code>execle</code>要求将新程序的每个命令行参数都说明为一个单独的参数，这种参数表以空指针结尾。而<code>execv</code>,<code>execvp</code>, <code>execve</code>和<code>fexecve</code>，需要先构造一个指向各个参数的指针数组，然后将该数组的地址作为这四个函数的参数。</li>
<li><strong>environment list的区别。</strong> 以e结尾的函数，<code>execve</code>, <code>execvpe</code>,<code>execle</code>, <code>fexecve</code>等可以传递一个指向environment字符串指针数组的指针，这个是自己指定的环境。其他几个不带e的函数使用进程中的environ变量为新程序复制现有的环境。</li>
<li>调用<code>exec</code>后，进程ID没有改变，但是新程序从调用进程继承了以下属性：
<ul>
<li>pid和ppid</li>
<li>real UID, real GID,</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>Session ID</li>
<li>控制终端</li>
<li>闹钟余留时间</li>
<li>cwd</li>
<li>root dir</li>
<li>umask</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li>时间</li>
</ul>
</li>
<li>在<code>exec</code>前后，real UID和real GID不变，effective ID取决于是否设置set UID和set GID。如果新程序的set UID已经设置，则effective ID变成程序文件所有者的ID，否则不变。</li>
<li>这几个函数中，只有<code>execve</code>是系统调用，其他几个都只是库函数，最终都要调用<code>execve</code>。</li>
</ol>
<h2 id="解释器文件">解释器文件</h2>
<p>关于解释器文件，可以查看<a href></a>。</p>
<h2 id="system"><code>system</code></h2>
<p>关于system的介绍，可以查看<a href></a>。</p>
<h2 id="进程会计">进程会计</h2>
<p>大多数UNIX系统都提供了一个选项进行进程会计处理。启动该选项之后，每当进程结束时内核就会写一个会记记录。典型的会计记录是一个二进制数据，一般包括命令名，所有的CPU时间总量，UID和GID，启动时间等。所有的标准都没有定义进程会记，所以实现上就千差万别。<br>
<code>acct</code>函数启用和关闭进程会计。<br>
会记记录结构定义在头文件<code>&lt;sys/acct.h&gt;</code>的<code>struct acct</code>中，其中<code>ac_flag</code>标志记录了进程执行期间的某些事件：</p>
<ul>
<li><code>AFORK</code>，进程是<code>fork</code>产生的，但是未调用<code>exec</code></li>
<li><code>ASU</code>，进程使用superuser权限</li>
<li><code>ACORE</code>，进程转储到core</li>
<li><code>AXSIG</code>，进程由一个signal杀死</li>
<li><code>AEXPND</code>，扩展的会计条目</li>
<li><code>ANVER</code>，新纪录格式</li>
</ul>
<p>在LINUX上，<code>ac_flag</code>是枚举类型，所以不能使用<code>#ifdef</code>判断是否支持<code>ACCORE</code>等flag，可以使用<code>if !defied HAS_ACCORE</code>进行判断。</p>
<p>会计记录所需的各个数据（各CPU时间，传输的字符数等）都由内核保存在process table中，并在一个新进程被创建时初始化，进程终止时写一个会计记录。这产生了两个后果：</p>
<ol>
<li>对于那些不会终止的进程，比如<code>init</code>进程，我们无法获得它的会计记录。内核守护进程也不会终止，所以也不会产生会计记录。</li>
<li>在会计文件中记录的顺序对应于进程终止的顺序，而不是它们启动的顺序。</li>
</ol>
<p>会记记录对应于进程而不是程序。在<code>fork</code>之后，内核为子进程初始化一个记录，而不是在一个新程序被执行初始化时。<code>exec</code>并不会创建一个新的记录，但是相应记录中的名字会改变，<code>AFORK</code>标志没了。</p>
<h2 id="获得当前登录用户名">获得当前登录用户名</h2>
<p>可以使用<code>getlogin</code>获得当前登录用户的用户名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="进程调度">进程调度</h2>
<p>调度策略和调度优先级是由内核确定的。</p>
<h3 id="nice-getpriority-setpriority原型"><code>nice</code>, <code>getpriority</code>, <code>setpriority</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> inc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> prio)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="nice-getpriority-setpriority属性"><code>nice</code>, <code>getpriority</code>, <code>setpriority</code>属性</h3>
<ol>
<li><code>nice</code>函数将输入的参数加到当前的<code>nice</code>值上。<code>nice</code>值越大，优先级越低，否则越高。</li>
<li>在单核的机器中，同时运行一个父进程和一个子进程，它们的<code>nice</code>值不同的话，CPU占用比也可能会不同，这取决于进程调度程序如何使用<code>nice</code>值。在多核的机器上可能看不到这样的结果。</li>
</ol>
<h2 id="进程时间">进程时间</h2>
<p>可以使用<code>times</code>获得某进程和它的子进程的CPU时间以及墙上时钟时间，<code>times</code>通过<code>struct tms</code>传递信息。它的内容如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_utime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_stime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_cutime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_cstime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>它包含进程的用户CPU时间，系统CPU时间和子进程的用户CPU时间和系统CPU时间。但是不包含墙上时钟时间，墙上时钟时间是通过函数的返回值得到的，而且得到的时间是相对于过去某个时间点得到的，所以不能使用它的绝对值，要使用相对值。比如第一次调用<code>times</code>，记录返回值，等到下一次调用<code>times</code>时，用新的值减去刚才保存的值，得到墙上时间时间。<br>
<strong>所有时间（结构体和返回值）的单位都是滴答数。</strong><br>
函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> times(struct tms *buf);</span><br></pre></td></tr></table></figure></p>
<p>shell的<code>time(1)</code>可以使用<code>times(2)</code>实现，看程序。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/5/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/7/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">327</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
