<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/8/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/8/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-compound-type-array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-compound-type-array/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">C/C++ compound type array</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:09:40" itemprop="dateCreated datePublished" datetime="2019-11-13T14:09:40+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:38:11" itemprop="dateModified" datetime="2019-12-17T16:38:11+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组">数组</h2>
<p>数组和<code>vector</code>类似，但是数组是定长的，大小不变，而<code>vector</code>是可变的，可以把<code>vector</code>看成可变长度的数组。<br>
如果不清楚元素的确切个数，使用vector。</p>
<h3 id="定义和初始化">定义和初始化</h3>
<p>数组的维度必须是确定的，在编译时就知道，即是一个常量表达式（值不会改变并且在编译时就已知）。<br>
默认情况下，数组的元素被默认初始化。和内置类型的变量一样，如果在数组内部定义了某种内置类型的数组，那么默认初始化得到的数组含有未定义的值。</p>
<h3 id="显式的初始化数组">显式的初始化数组</h3>
<ol>
<li>可以忽略维度，编译器会根据初始值推测出来；</li>
<li>如果指明维度，初始值的数量不应该超出指定的大小；</li>
<li>如果维度比提供的初始值大，其它的元素被初始化成默认值（值初始化）。</li>
</ol>
<h3 id="数组不支持直接拷贝和直接赋值">数组不支持直接拷贝和直接赋值</h3>
<p>不能将数组或的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。</p>
<h3 id="数组和vector">数组和<code>vector</code></h3>
<p>不允许使用一个数组为另一个数组赋初值，也不允许使用<code>vector</code>初始化数组。但是支持使用数组来初始化<code>vector</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi(begin(arr), end(arr));</span><br></pre></td></tr></table></figure></p>
<h3 id="复杂数组的声明">复杂数组的声明</h3>
<p>对于数组声明的理解，从变量名开始，先往右，再往左读。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];    <span class="comment">//数组arr，有10个元素，每个元素是int类型</span></span><br><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];  <span class="comment">//数组ptrs，有10个int*类型元素，</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>];  <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;   <span class="comment">//数组的指针Parray，指向一个有10个int类型的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;    <span class="comment">//数组的引用arrRef，引用一个10个int类型的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;<span class="built_in">array</span>)[<span class="number">10</span>] = ptrs;   <span class="comment">//数组的引用array，引用一个10个int*类型的数组</span></span><br></pre></td></tr></table></figure></p>
<h2 id="访问数组元素">访问数组元素</h2>
<ol>
<li>范围for 语句。</li>
<li>下标运算符。下标的类型是<code>size_t</code>类型。它是一种机器相关的无符号类型，足够大能够表示内存中任意对象的大小。定义在<code>&lt;stddef.c&gt;</code>或者<code>&lt;cstddef&gt;</code>头文件中。</li>
</ol>
<h2 id="数组和指针">数组和指针</h2>
<h3 id="数组名和指针">数组名和指针</h3>
<ol>
<li>一般情况下，可以使用取地址符获取某个对象的指针。数组元素也是对象，使用下标运算符得到数组指定位置的对象，使用取地址符就能得到指向该元素的指针。([1]3.5.3)</li>
<li>数组的另一个特性是，在大多用到数组名字的时候，编译器都会自动的将它转换成一个指向数组首元素的指针，而且数组名是一个常量指针([1]3.5.3)。或者说数组作为右值时，编译器会自动将数组转化成数组首元素的地址([2)]。</li>
<li>在C中，只有两种操作不把数组名字当做常量指针，当数组名字用作<code>sizeof</code>和<code>&amp;</code>的操作对象时。当<code>sizeof</code>的输入是数组名时，返回的是数组的长度（字节为单位）。而<code>&amp;</code>对数组名取地址时，返回的是指向数组的指针。</li>
</ol>
<p>在<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">C++复合类型指针</a>中介绍了指针的算术运算。指针的算术运算有一个要求，就是指针必须指向数组中某一个元素。如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[sz] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line">ip = arr;   <span class="comment">//这个不是数组的赋值。事实上，这是指针的赋值。</span></span><br><span class="line"><span class="keyword">int</span> *ip2 = ip+<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = arr + sz;</span><br><span class="line"><span class="keyword">int</span> *p2 = arr + <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，给<code>arr</code>加上<code>sz</code>时，编译器自动的将它转换成指向数组<code>arr</code>中首元素的指针。执行加法操作，其实就是指针的算术运算，最后指向<code>arr</code>的第五个元素之后的位置。如果超出了这个位置，就会出错，编译器不会检查这种错误。</p>
<h3 id="下标引用">下标引用</h3>
<ol>
<li>对于内置数组来说，执行下标运算，相当于先将数组转换为首元素的指针，然后执行数组的算术运算。如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = ia[<span class="number">2</span>];  <span class="comment">//这行代码其实相当于以下两行代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = ia;</span><br><span class="line">i = *(p+<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>除了优先级外，下标运算和间接访问（解引用）完全一样。</p>
<ol start="2">
<li>
<p><strong>而且只要指针指向的是数组中的元素或者数组中尾元素的下一个位置，都可以执行下标操作。当指针指向数组尾后元素时，该位置不可访问！但是可以访问其他位置。</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>];</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>和标准库<code>string</code>，<code>vector</code>下标操作的不同之处在于，内置数组的下标操作中，，下标可以是负的，而标准<code>string</code>,<code>vector</code>中下标必须是无符号类型。</p>
</li>
</ol>
<h3 id="数组-指针">数组!=指针</h3>
<p>需要注意的是，数组和指针并不是等价的！考虑以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> *b;</span><br></pre></td></tr></table></figure>
<p><code>a</code>和<code>b</code>不能互换使用，即使它们都可以使用指针运算，可以进行间接访问和下标引用操作。它们并不一样。<br>
定义一个数组时，编译器会根据声明指定的元素数量为数组保留内存空间，然后再创建数组名，它的值是一个常量，指向这段空间的起始位置。定义一个指针变量时，编译器只为指针本身保留内存空间。所以，进行了上述定义以后，<code>*a</code>合法，而<code>*b</code>不合法。</p>
<h3 id="c-中的数组和指针">C++中的数组和指针</h3>
<ol>
<li>使用decltype关键字对数组进行解析时，不会将数组转换成指针，它会将识别出数组类型。使用<code>auto</code>分析数组类型时会推断出指针类型。</li>
<li>指针也是迭代器。通过数组名字或者数组首元素地址都可以得到指向数组第一个元素的指针。</li>
<li><code>begin</code>和<code>end</code>获取数组首元素指针和尾后指针。尾后指针不能执行解引用和递增操作。</li>
</ol>
<h2 id="c风格字符串">C风格字符串</h2>
<p>C风格字符串不是一种类型，而是一种约定俗成的写法。按照约定，C风格字符串存放在数组中，并且以空字符<code>'\0'</code>结束。关于C风格字符串更多的内容可以查看<a href></a>。</p>
<h3 id="字符数组">字符数组</h3>
<ol>
<li>
<p>使用列表初始化。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str2[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> str3[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>使用字符串字面值初始化。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line"><span class="comment">//编译器会隐式的在最后加一个"\0"，sizeof(str)会计算这个"\0", strlen(str)不会</span></span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这种方式是字符数组初始化的简便写法。</p>
<ol start="3">
<li>指针和C风格字符串<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *messages= <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>对于以上三种方式来说，方式1和2是等价的，这种方式中的&quot;helloworld&quot;存放在栈中。而第三种有些特殊，在第三种方式中，&quot;hello world&quot;是一个字符串字面值常量，存放在数据区的字符串常量部分[6,7,8,9]。事实上，它是一个常量字符数组，是一个不可修改的左值[9]，把它作为右值时，会进行类型转换将左值转换成右值，即使用常量字符数组首字符的地址进行初始化。</p>
<h3 id="c风格字符串操作函数">C风格字符串操作函数</h3>
<p>C语言标准库<code>&lt;string.h&gt;</code>或者C++版本的<code>&lt;string.h&gt;</code>提供了以下的字符串操作函数，它们的参数必须是指向以空字符结束的字符数组的指针。在函数内存不会验证这些字符串参数是否满足要求。</p>
<ul>
<li><code>strlen(p)</code>，返回p指向的字符串的长度，不包括空字符</li>
<li><code>strcmp(p1, p2)</code>，p1==p2，返回0,p1&gt;p2，返回正值，否则返回负值。</li>
<li><code>strcat(p1, p2)</code>，p2拼接到p1，返回p1</li>
<li><code>sctcpy(p1, p2)</code>，p2拷贝到p1，返回p1</li>
</ul>
<p>有一点需要注意的是，<code>p2</code>必须能够容纳下拼接后或者拷贝后的字符串，编译器不会进行检查，这需要由程序员自己进行检查。</p>
<h3 id="c风格字符串的比较">C风格字符串的比较</h3>
<p>两个C风格字符串的比较，其实比较的是指针而不是字符串本身。如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str1[] = &quot;hello&quot;;</span><br><span class="line">char str2[] = &quot;world&quot;;</span><br><span class="line">if(str1 &lt; str2) //这行代码比较的不是两个字符串，而是两个指针。</span><br></pre></td></tr></table></figure></p>
<h3 id="string和c风格字符串的相互转换"><code>string</code>和C风格字符串的相互转换</h3>
<ol>
<li>允许使用以空字符结束的字符数组初始化<code>string</code>对象或者为<code>string</code>对象赋值。</li>
<li><code>string</code>对象的加法运算中允许使用空字符结束的字符数组作为其运算对象，不能两个都是。</li>
<li><code>string</code>对象的复合赋值运算中允许使用以空字符结束的字符数组作为其右侧运算对象。</li>
</ol>
<h4 id="string转换成c风格字符串"><code>string</code>转换成C风格字符串</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world!&quot;);</span><br><span class="line">const char *str = s.c_str();</span><br></pre></td></tr></table></figure>
<h2 id="多维数组">多维数组</h2>
<p>多维数组指的是数组的数组。多维数组的定义方式如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];   <span class="comment">//大小为3的数组，每个元素是一个大小为4的数组</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>];    <span class="comment">//大小为10的数组，每个元素是大小为20的数组，每个数组的元素又是一个大小为30的数组。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="存储顺序">存储顺序</h3>
<p>按照从右到左的维度顺序依次进行存储，实际上它们存储在了线性空间内。比如对于一个数组<code>int array[3][6]</code>，它在内存中的存储顺序其实是：<br>
a[0][0], a[0][1], a[0][2], a[0][3], a[0][4], a[0][5], a[1][0], a[1][1], a[1][2], a[1][3], a[1][4], a[1][5], a[2][0], a[2][1], a[2][2], a[2][3], a[2][4], a[2][5]。</p>
<h3 id="多维数组的初始化">多维数组的初始化</h3>
<p>使用花括号括起来的一组值初始化多维数组。</p>
<ol>
<li>
<p>指定所有元素的值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>初始化一部分，其余的进行值初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>只对a[0]进行了初始化。</p>
<ol start="3">
<li>初始化每一行的部分元素。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>只对每一行的第一个值进行了初始化。</p>
<h3 id="多维数组数组名和指针">多维数组数组名和指针</h3>
<p>一维数组的数组名是一个指针，它的类型是指向元素类型的指针。多维数组也一样，多维数组的数组名也是一个指针，只不过它的类型是指向数组的指针。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>数组名<code>matrix</code>实际上是指向数组首元素的一个指针，数组首元素是一个<code>int [10]</code>类型的数组，所以<code>matrix</code>是一个指向<code>int [10]</code>类型数组的指针，解引用操作<code>*matrix</code>得到一个<code>int [10]</code>类型的数组，这个东西其实也是一个数组名，相当于一个指针，指向一个<code>int</code>类型。<code>*(*(matrix+1)+2)</code>其实就是<code>matrix[1][2]</code>。</p>
<h3 id="多维数组的下标">多维数组的下标</h3>
<p>如果要访问多维数组中的某个元素，必须指定所有维度的下标。即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//要访问第2行的第16个元素，使用下标[1][15]。</span></span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">15</span>];</span><br></pre></td></tr></table></figure></p>
<p>但是，实际上，下标和间接引用是等价的，在多维数组中也一样。数组名<code>matrix</code>可以当成一个指针，<code>matrix +1</code>实际上指向第二个<code>int [10]</code>的数组，<code>*(matrix+1)</code>是一个<code>int [10]</code>的数组。</p>
<h3 id="指向数组的指针">指向数组的指针</h3>
<p>在下面的代码中，<code>pa</code>是一个int指针，<code>p</code>是一个<code>int [10]</code>类型的指针，指向<code>matrix</code>的第一行的10个元素。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>], *pa = <span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>], (*p)[<span class="number">10</span>] = matrix;</span><br></pre></td></tr></table></figure></p>
<h2 id="指针数组">指针数组</h2>
<p>我们可以创建指针的数组。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *api[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>创建了一个数组，数组有10个元素，每个元素都是一个<code>int*</code>类型的指针。可以创建一个<code>char*</code>类型的指针数组：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *keyword[] = &#123;</span><br><span class="line">    <span class="string">"do"</span>,</span><br><span class="line">    <span class="string">"while"</span>,</span><br><span class="line">    <span class="string">"if"</span>,</span><br><span class="line">    <span class="string">"for"</span>,</span><br><span class="line">    <span class="string">"return"</span>,</span><br><span class="line">    <span class="string">"switch"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以参考下面示意图：<br>
<img src="/2019/11/13/C-compound-type-array/char_pointer_array.jpg" alt="char_pointer_array"></p>
<h2 id="数组和左值">数组和左值</h2>
<p>数组本身是一个不可修改的左值。</p>
<h2 id="字符串字面值和左值">字符串字面值和左值</h2>
<p>字符串字面值常量是一个常量，不可修改的左值，它以数组的形式存储。</p>
<h2 id="为什么数组不支持赋值">为什么数组不支持赋值</h2>
<ol>
<li>不支持数组的拷贝是为了避免不必要的复制开销，数组复制将会导致连续的内存读和写。</li>
<li>为什么用指针代替数组，不是因为他们太像了，而是避免赋值的开销，因为c里面只有值传递，如果对数组采用pass by value，会有很大的开销。</li>
</ol>
<h2 id="array-array和-array-0"><code>array</code>,<code>&amp;array</code>和<code>&amp;array[0]</code></h2>
<p><code>array</code>和<code>&amp;array[0]</code>是一样的，它们和&amp;array有什么区别呢？[3]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"array=%p, &amp;array=%p\n"</span>, <span class="built_in">array</span>, &amp;<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"array+1=%p: &amp;array+1=%p\n"</span>, <span class="built_in">array</span>+<span class="number">1</span>, &amp;<span class="built_in">array</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array=0x7ffc50c541c0: &amp;array=0x7ffc50c541c0</span><br><span class="line">array+1=0x7ffc50c541c4: &amp;array+1=0x7ffc50c541d4</span><br></pre></td></tr></table></figure>
<p>根据上面程序的输出，<code>array</code>和<code>&amp;array</code>得到了一样的地址。但是它们并不是一样的！！！它们的地址相同，但是地址的类型不同。<br>
对指针进行算术运算，将<code>array</code>和<code>&amp;array</code>都加一，我们却得到了不同的结果。事实上，<code>array</code>是指向数组第一个元素的指针，而<code>&amp;array</code>是指向整个<code>int [5]</code>数组的指针。因此，根据指针运算规则，对地址<code>array</code>和<code>&amp;array</code>进行算术运算，得到了不同的结果。</p>
<h2 id="数组和函数">数组和函数</h2>
<h3 id="数组形参">数组形参</h3>
<p>数组有两个特殊的性质：</p>
<ol>
<li>不允许拷贝，因为不能拷贝数组，所以不能以值传递的方式使用数组参数。</li>
<li>在使用数组时通常会将其转换成指针。因为数组会被转换成指针，所以为函数传递数组时，实际上传递的是指向数组首元素的指针，这样子可以节约开销。</li>
</ol>
<h3 id="管理数组转换的指针">管理数组转换的指针</h3>
<p>当传递给函数一个数组时，实参自动的转成指向数组首元素的指针，数组的大小对于函数的调用没有什么影响。因为数组是以指针的形式传递给函数的，所以函数其实是不知道数组的大小的，调用者应该为此提供一些额外的信息。通常有三种方式：</p>
<ol>
<li>显示传递一个表示数组大小的形参</li>
<li>使用标记指定数组长度，要求数组本身包含一个结束标记，典型的例子是C风格字符串。</li>
<li>使用标准库规范，传递数组首元素和尾后元素的指针。可以使用<code>begin</code>和<code>end</code>函数获得数组的首元素和尾后元素的指针。</li>
</ol>
<h3 id="数组形参和const">数组形参和<code>const</code></h3>
<p>当函数不需要对数组进行写操作时，数组形参应该是指向<code>const</code>的指针。只有当函数确实需要改变数组元素值的时候，才把形参定义成指向非常量的指针。</p>
<h3 id="数组引用形参">数组引用形参</h3>
<p>C++允许将变量定义成数组的引用，形参也可以是数组的引用。此时，引用形参绑定到数组上。</p>
<h3 id="传递多维数组">传递多维数组</h3>
<p>C++其实没有真正的多维数组，多维数组其实就是数组的数组。把多维数组传递给函数时，传递的是指向数组首元素的指针。而多维数组是数组的数组，首元素本身就是一个数组，多维数组转换成指向数组的指针。数组第二维以及后面维度都是数组类型的一部分，不能省略。</p>
<h2 id="函数返回值和数组">函数返回值和数组</h2>
<p>因为数组不能被拷贝，所以函数不能返回数组。不过可以返回数组的指针或者引用。</p>
<h3 id="声明一个返回数组指针的函数">声明一个返回数组指针的函数</h3>
<p>返回数组指针的函数形式如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type (*function(parameter_list)) [dimension]</span><br></pre></td></tr></table></figure></p>
<p>类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小，<code>(*function(parameter_list))</code>两端的括号必须在，否则函数的返回类型就是指针的数组。如下示例:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p><code>func</code>带有参数，说明它是一个函数，前面带有解引用操作，说明可以对函数调用的结果执行解引用操作，括号右面说明这是一个维度为10的数组，括号左面是数组类型。</p>
<h3 id="使用尾置返回类型">使用尾置返回类型</h3>
<p>可以使用尾置返回类型，任何函数的定义都能使用尾置返回，但是这种形式一般用于比较复杂的返回类型，比如数组的指针或者数组的引用。形式如下：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto func() -&gt; int (*)[10];</span><br></pre></td></tr></table></figure></p>
<h3 id="使用decltype">使用<code>decltype</code></h3>
<p>可以使用<code>decltype</code>声明返回值类型。比如返回一个指针时，<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(odd) *func(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>)? &amp;odd: &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer" target="_blank" rel="noopener">https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer</a><br>
3.<a href="https://www.geeksforgeeks.org/whats-difference-between-array-and-array-for-int-array5/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/whats-difference-between-array-and-array-for-int-array5/</a><br>
4.<a href="https://stackoverflow.com/questions/3437110/why-do-c-and-c-support-memberwise-assignment-of-arrays-within-structs-but-not/3439969" target="_blank" rel="noopener">https://stackoverflow.com/questions/3437110/why-do-c-and-c-support-memberwise-assignment-of-arrays-within-structs-but-not/3439969</a><br>
5.<a href="https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type" target="_blank" rel="noopener">https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type</a><br>
6.<a href="https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s" target="_blank" rel="noopener">https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s</a><br>
7.<a href="https://stackoverflow.com/questions/2938895/difference-between-char-a-string-char-p-string" target="_blank" rel="noopener">https://stackoverflow.com/questions/2938895/difference-between-char-a-string-char-p-string</a><br>
8.<a href="http://c-faq.com/decl/strlitinit.html" target="_blank" rel="noopener">http://c-faq.com/decl/strlitinit.html</a><br>
9.<a href="https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-getline-vs-C-getline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-getline-vs-C-getline/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">C getline vs C++ getline</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 13:11:10" itemprop="dateCreated datePublished" datetime="2019-11-13T13:11:10+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:14:11" itemprop="dateModified" datetime="2019-12-17T15:14:11+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="getline-in-c">getline in C</h2>
<h3 id="原型">原型</h3>
<p>使用<code>man getline</code>可以看到UNIX提供的库函数<code>getline</code>的原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> getline(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream);</span><br><span class="line"><span class="keyword">ssize_t</span> getdelim(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, <span class="keyword">int</span> delim, FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="性质">性质</h3>
<ol>
<li><code>getline()</code>从stream中读入一整行，</li>
<li>如果<code>*lineptr</code>设置为NULL并且<code>*n=0</code>，<code>getline()</code>会分配一个buffer存储读入的line。这个buffer应该被用户程序释放，即使<code>geline()</code>失败了。</li>
<li>如果<code>*lineptr</code>包含一个指针，大小是<code>*n</code>字节。当buffer不能存下读入的line时，<code>getline()</code>会使用<code>realloc(3)</code>对buffer进行resize，更新<code>*lineptr</code>和<code>*n</code>。</li>
<li>只要成功调用，<code>*lineptr</code>和<code>*n</code>分别表示的是buffer的地址和分配的内存大小。</li>
<li><code>getdelim()</code>和<code>getline()</code>一样，只不过可以指定一个delimiter而不是使用newline作为delimiter。任何delimiter都会存进<code>*lineptr</code>中。</li>
<li>为什么<code>getline</code>需要的是<code>char**</code>而不是<code>char*</code>，因为<code>getline</code>在lineptr指向的空间不足时，重新分配内存，如果使用的是<code>char*</code>的话，当<code>getline</code>重新分配内存后，我们就失去了对<code>line</code>的访问，而使用一个<code>char**</code>类型的字符串，使用一个<code>char**</code>类型，即指针的指针记录每次分配的<code>char*</code>。[3]。</li>
</ol>
<h2 id="getline-in-c-v2">getline in C++</h2>
<h3 id="cin-getline">cin.getline</h3>
<p><code>cin.getline()</code>是操作C strings，即字符数组的。不会将<code>'\n'</code>读入。</p>
<h3 id="std-getline">std::getline</h3>
<ol>
<li><code>std::getline()</code>是操作C++ strings的，即<code>std::string</code>。</li>
<li><code>std::getline()</code>从input stream中读一个string，遇到delimiter就停止，默认的delimiter是<code>'\n'</code>。即使输入开始就是delimiter也会停止。</li>
<li><code>std::getline()</code>会把delimiter也读进来，然后把读到的内容存到<code>string</code>对象中去，存入的内容不包含delimiter。</li>
</ol>
<h2 id="代码示例">代码示例</h2>
<h3 id="getline">getline</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    FILE *stream = <span class="built_in">stdin</span>;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread = getline(&amp;line, &amp;len, stream)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Retrieved line of length %zu:\n"</span>, nread);</span><br><span class="line">        fwrite(line, nread, <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getdelim">getdelim</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    FILE *stream = <span class="built_in">stdin</span>;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">int</span> delim = <span class="string">','</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread = getdelim(&amp;line, &amp;len, delim, stream)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Retrieved line of length %zu:\n"</span>, nread);</span><br><span class="line">        fwrite(line, nread, <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/4872361/why-are-there-two-different-getline-functions-if-indeed-there-are" target="_blank" rel="noopener">https://stackoverflow.com/questions/4872361/why-are-there-two-different-getline-functions-if-indeed-there-are</a><br>
2.<a href="https://www.reddit.com/r/learnprogramming/comments/4fx64h/is_there_a_difference_between_cingetline_and/" target="_blank" rel="noopener">https://www.reddit.com/r/learnprogramming/comments/4fx64h/is_there_a_difference_between_cingetline_and/</a><br>
3.<a href="https://stackoverflow.com/questions/5744393/why-is-the-first-argument-of-getline-a-pointer-to-pointer-char-instead-of-c/36098042" target="_blank" rel="noopener">https://stackoverflow.com/questions/5744393/why-is-the-first-argument-of-getline-a-pointer-to-pointer-char-instead-of-c/36098042</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/12/C-exit-and-return/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/12/C-exit-and-return/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">C/C++ exit and return</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-12 13:51:20" itemprop="dateCreated datePublished" datetime="2019-11-12T13:51:20+08:00">2019-11-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-23 18:00:59" itemprop="dateModified" datetime="2020-02-23T18:00:59+08:00">2020-02-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进程终止">进程终止</h2>
<p>总共有八种方式可以让进程终止，包括五种正常终止和三种异常终止，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回，相当于调用<code>exit</code>。</li>
<li>调用<code>exit</code>，ISO C定义的，它的操作包括调用各个exit handler，处理所有标准I/O流。</li>
<li>调用<code>_exit</code>或者<code>_Exit</code>，ISO C定义了<code>_Exit</code>，而POSIX.1说明了<code>_exit</code>。它的目的是提供一种无需运行exit handler或者信号处理程序而终止的方法。是否对标准I/O流进行flush，取决于实现。在UNIX中，<code>_Exit</code>和<code>_exit</code>是同义的，并不flush I/O流。</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程以哪种方式终止，最后都会执行内核中的同一段代码，这段代码为相关进程关闭所有打开的文件描述符，释放它使用的内存。<br>
为了让终止进程能够通知父进程它是如何终止的。对于3个终止函数(<code>exit</code>, <code>_exit</code>, <code>_Exit</code>)，将它们的<code>exit status</code>作为参数传递给函数。在异常终止的情况下，内核产生一个指示其异常终止原因的terminaiton status（终止状态）。在任意终止情况下，这个终止进程的父进程都能用<code>wait</code>或者<code>waitpid</code>函数获得它的终止状态。<br>
<strong>如果父进程在子进程之前终止</strong>，那么对于父进程终止的所有进程，它们的父进程都变成<code>init</code>进程，终止状态返回到<code>init</code>进程。具体是怎么操作：对于一个即将终止的进程，内核检查所有活动进程，判断其中是否有待终止进程的子进程，如果有的话，将这些进程的父进程的ID改为<code>init</code>进程的ID 1。<br>
<strong>如果子进程在父进程之前终止</strong>。内核为每一个终止进程保留了一部分信息，当终止进程的父进程调用<code>wait</code>或者<code>waitpid</code>时，可以获取这些信息，这些信息包含终止进程PID，进程的终止状态，进程占用的CPU时间总量。内核可以释放这些进程的内存，关闭打开的文件。如果一个进程终止了，但是它的父进程没有等待它，它被称为一个zombie（僵尸）进程。如果一个长期运行的进程，<code>fork</code>了很多子进程，除非父进程等到取得子进程的终止状态，要不它们就会变成僵尸进程。<strong>当父进程结束时，僵尸进程就会结束？？？将所有的子进程交给init进程？但是这些进程都已经结束了。</strong><br>
<code>init</code>的子进程，不会变成僵尸进程，因为<code>init</code>进程被编写成无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数获得其终止状态。</p>
<h3 id="exit和-exit函数"><code>exit</code>和<code>_Exit</code>函数</h3>
<h4 id="c11标准定义">C11标准定义</h4>
<p><code>exit</code>定义在<code>&lt;stdlib.h&gt;</code>头文件中</p>
<blockquote>
<p>void exit( int exit_code ); (until C11)<br>
_Noreturn void exit( int exit_code );(since C11)<br>
Causes normal program termination to occur.<br>
Several cleanup steps are performed:</p>
</blockquote>
<ul>
<li>functions passed to atexit are called, in reverse order of registration（调用atexit注册的函数）</li>
<li>all C streams are flushed and closed （冲洗C的缓冲区，不是不关闭流吗？？？）</li>
<li>files created by tmpfile are removed  (删除临时文件）</li>
<li>control is returned to the host environment. If exit_code is zero or EXIT_SUCCESS, an implementation-defined status, indicating successful termination is returned. If exit_code is EXIT_FAILURE, an implementation-defined status, indicating unsuccessful termination is returned. In other cases implementation-defined status value is returned.（将控制权返还给操作系统。）</li>
</ul>
<p><code>-Exit</code>定义在<code>&lt;stdlib.h&gt;</code>头文件中</p>
<blockquote>
<p>void _Exit( int exit_code ); (since C99) (until C11)<br>
_Noreturn void _Exit( int exit_code );(since C11)<br>
Causes normal program termination to occur without completely cleaning the resources.<br>
Functions passed to at_quick_exit() or atexit() are not called. Whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed is implementation-defined. （不调用atexit注册的函数，是否冲洗缓冲区，关闭打开的stream和删除临时文件是由实现定义的，UNIX都不做这些操作）<br>
If exit_code is 0 or EXIT_SUCCESS, an implementation-defined status indicating successful termination is returned to the host environment. If exit_code is EXIT_FAILURE, an implementation-defined status, indicating unsuccessful termination, is returned. In other cases an implementation-defined status value is returned.</p>
</blockquote>
<h4 id="性质">性质</h4>
<ol>
<li><code>exit</code>和<code>_Exit</code>是ISO C的内容，而<code>_exit</code>是POSIX.1的内容。</li>
<li>它们都用于正常终止一个程序，<code>_Exit</code>和<code>_exit</code>立刻进入内核，<code>_Exit</code>和<code>_exit</code>是否冲洗缓冲区是由实现定义的，UNIX上选择不冲洗。而<code>exit</code>先执行一些清理操作，然后返回内核，<code>exit</code>函数首先调用<code>atexit</code>函数登记的终止处理程序，然后冲洗标准I/O流，现代的<code>exit</code>实现都不会关闭标准I/O流，之前的一些实现还会关闭标准I/O流，这在调用<code>vfork</code>的时候可能会出现问题，还会删除临时文件。</li>
<li>三个退出函数都需要一个整形的参数，被称为exit status。</li>
<li>如果满足以下条件：
<ul>
<li>调用这三个函数不带终止状态</li>
<li><code>main</code>执行了一个不带返回值的<code>return</code>语句</li>
<li><code>main</code>没有声明返回类型为整形，进程的终止状态是未定义的。<br>
那么这个进程的终止状态是未定义的。</li>
</ul>
</li>
<li><code>main</code>返回返回一个整型值和用该值调用<code>exit</code>是等价的。对于某些C编译器和UNIX lint(1)程序来说，会产生警告信息，因为这些编译器并不了解<code>main</code>中的<code>return</code>和<code>exit</code>的作用是相同的。避开这种警告信息的一种方法是在<code>main</code>中使用<code>return</code>而不是<code>exit</code>，这样做的结果是UNIX grep命令无法找出程序中所有的<code>exit</code>调用。另一个方法是将<code>main</code>声明为<code>void</code>而不是<code>int</code>，然后调用<code>exit</code>，但是这不并不是标准，ISO C和POSIX.1定义<code>main</code>的返回值应当是带符号整形。</li>
</ol>
<h4 id="函数原型">函数原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h3 id="atexit"><code>atexit</code></h3>
<h4 id="c11标准定义-v2">C11标准定义</h4>
<blockquote>
<p>Registers the function pointed to by func to be called on normal program termination (via exit() or returning from main()). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.<br>
The same function may be registered more than once.<br>
atexit is thread-safe: calling the function from several threads does not induce a data race.<br>
The implementation is guaranteed to support the registration of at least 32 functions. The exact limit is implementation-defined.</p>
</blockquote>
<h4 id="性质-v2">性质</h4>
<p>每个进程可以通过<code>atexit</code> register至多32个由<code>exit</code>自动调用的函数，这些函数被称为exit handler（终止处理程序）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>atexit</code>的参数是一个函数地址，不会有返回值</li>
<li><code>exit</code>调用<code>atexit</code> register的程序的顺序和使用<code>atexit</code>进行register的顺序相反。</li>
<li>ISO C和POSIX.1标准规定，<code>exit</code>首先调用各个exit handler，然后使用<code>fclose</code>关闭所有标准I/O流。</li>
<li>POSIX.1对ISO C进行了扩展，如果程序调用了任何<code>exec</code>函数，清除exit handler。</li>
<li>内核执行一个程序的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一办法是显式或者隐式的（通过<code>exit</code>）调用<code>_exit</code>和<code>_Exit</code>。</li>
</ol>
<h2 id="return和exit"><code>return</code>和<code>exit</code></h2>
<ol>
<li><code>return</code>是C/C++语言的关键字，是语言级别的；而<code>exit()</code>是一个函数，它是对系统调用<code>_exit()</code>的封装，是系统调用层次的。</li>
<li><code>return</code>结束一个函数的执行；而<code>exit()</code>结束一个进程，删除进程使用的内存空间，并且将应用程序的一个状态返回给OS，这个状态标识了进程的运行信息。</li>
<li><code>exit(0)</code>表示正常运行程序并退出程序，<code>exit(1)</code>表示非正常运行导致退出程序；<code>return 0</code>和<code>retrun 1</code>能够起类似的作用。</li>
<li>对于我们自定的函数，可以return给操作系统，交给相关的处理程序调用exit或者程序自身直接调用exit。</li>
</ol>
<h3 id="c-中的区别">C++中的区别</h3>
<p>在C++中，退出程序时，<code>exit</code>并不会调用局部非静态对象的析构函数，而<code>return</code>会调用局部非静态对象的析构函数。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main" target="_blank" rel="noopener">https://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main</a><br>
2.<a href="https://www.geeksforgeeks.org/return-statement-vs-exit-in-main/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/return-statement-vs-exit-in-main/</a><br>
3.<a href="https://www.zhihu.com/question/26591968/answer/33839473" target="_blank" rel="noopener">https://www.zhihu.com/question/26591968/answer/33839473</a><br>
4.<a href="https://www.zhihu.com/question/26591968/answer/33330774" target="_blank" rel="noopener">https://www.zhihu.com/question/26591968/answer/33330774</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/12/UNIX-system-call-vs-library-call/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/12/UNIX-system-call-vs-library-call/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">UNIX system call vs library call</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-12 13:01:01" itemprop="dateCreated datePublished" datetime="2019-11-12T13:01:01+08:00">2019-11-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:49:18" itemprop="dateModified" datetime="2019-12-17T15:49:18+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="系统调用-system-call-和库函数-library-function">系统调用(system call)和库函数(library function)</h2>
<h3 id="系统调用">系统调用</h3>
<p>所有的操作系统都提供多种服务的入口点，通过这些入口点向内核请求服务，这些入口点被称为系统调用(system call)。系统调用处于kernel mode，一些任务只能在kernel mode运行。比如和硬件的交互，系统调用使得用户mode的进程可以通过系统调用进入kernel mode，从而实现和硬件的交互。。<br>
系统调用接口可以在man的第二部分查看，它是用C语言定义的，与具体系统如何调用一个系统调用的实现技术无关。这些和早期的操作系统按照传统方式用机器的汇编语言定义内核入口点。<br>
UNIX使用的方法是为每个系统调用在标准C库中设置一个同名函数。用户进程使用标准C调用相应的函数，这些函数又根据系统调用调用相应的内核服务。</p>
<h3 id="库函数">库函数</h3>
<p>库函数可以在man手册的第三部分查看，第三部分定义了程序员可以使用的通用库函数。库函数可以调用系统调用，也可以不调用系统调用，比如<code>read</code>函数会调用系统调用，而<code>atoi</code>等并不使用任何系统调用。</p>
<h3 id="系统调用和库函数之间的关系">系统调用和库函数之间的关系</h3>
<ol>
<li>从实现角度来看，系统调用和库函数有着根本的区别，系统调用处于内核mode，库函数属于用户mode。</li>
<li>从用户应用角度考虑，可以把系统调用看做C函数，使用系统调用还是库函数不重要，它们都是为应用程序提供服务的。</li>
<li>C函数只是系统调用和库函数的一种实现，系统调用和库函数都可以以其他方式实现。</li>
<li>系统调用通常只是提供一种最小接口，而库函数实现更复杂的功能。</li>
<li>库函数可以被替换，但是系统调用通常是不能替换的。</li>
<li>库函数可以调用系统调用，也可以不调用系统调用。</li>
<li>应用程序既可以调用库函数也可以调用系统调用。</li>
<li>进程控制系统调用(fork, exec和wait)等通常由应用程序直接调用。为了简化一些常见情况，UNIX也提供了一些库函数，如system和popen。</li>
<li>库函数链接到用户程序，在user space执行，而syste call没有链接到用户程序，在kernel space执行</li>
<li>库函数的执行时间被计算为user level time，而system call的执行事件算作system time的一部分。</li>
<li>库函数可以简单的进行debug，而系统调用不能debug，因为它们被kernel执行。</li>
</ol>
<p>对于第4条，可以考虑以下例子：<br>
sbrk(2)是分配存储空间的UNIX系统调用，它按照指定字节数增加或者减少进程地址空间。如何管理进程的地址空间由进程决定。<br>
malloc(3)是公用函数库中的一个存储分配空间函数，它负责进行进程的存储地址管理。<br>
我们可以自己实现一个malloc，但是它很有可能还要使用sbrk(2)。内核中的系统调用ssbrk是系统层面的空间分配，而库函数malloc是在用户层面进行操作。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://www.thegeekstuff.com/2012/07/system-calls-library-functions/" target="_blank" rel="noopener">https://www.thegeekstuff.com/2012/07/system-calls-library-functions/</a><br>
3.<a href="https://stackoverflow.com/questions/29816791/what-is-the-difference-between-system-call-and-library-call" target="_blank" rel="noopener">https://stackoverflow.com/questions/29816791/what-is-the-difference-between-system-call-and-library-call</a><br>
4.<a href="https://unix.stackexchange.com/questions/6931/what-is-the-difference-between-a-library-call-and-a-system-call-in-linux" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/6931/what-is-the-difference-between-a-library-call-and-a-system-call-in-linux</a><br>
5.<a href="https://unix.stackexchange.com/questions/57232/difference-between-system-calls-and-library-functions" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/57232/difference-between-system-calls-and-library-functions</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/12/C-main-argc-argv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/12/C-main-argc-argv/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">C/C++ main argc argv</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-12 00:43:21" itemprop="dateCreated datePublished" datetime="2019-11-12T00:43:21+08:00">2019-11-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:09:33" itemprop="dateModified" datetime="2019-12-17T15:09:33+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="main函数">main函数</h2>
<p><code>main</code>函数是C语言和C++ 程序的入口，C和C++ 的标准要求它们的实现必须支持以下两种形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>任何C和C++ 库实现都必须实现以上两种形式的<code>main</code>，除此以外，可以根据标准进行其他扩展实现，但是这样子可能在一个平台上能运行的程序在另一个平台上不能运行，即除了标准的两种<code>main</code>，其他扩展都是不可移植的。<br>
需要注意的一点是，C和C++ 标准对于<code>main</code>的扩展有要求，C++ 标准要求所有的<code>main</code>都必须返回<code>int</code>类型，只有它们的参数可以改变。而C要自由一些，可以有<code>void main(char, dobule)</code>的实现，但是在C++ 标准中这是不支持的。<code>int main(int ,char*, char**)</code>在C和C++ 标准中都是允许的。</p>
<h2 id="main函数示例">main函数示例</h2>
<p>假设有一个名为prog的可执行文件，其中包含一个<code>main</code>函数，可以通过命令行选项向程序传递参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o file data0</span><br></pre></td></tr></table></figure>
<p>这些参数通过两个形参<code>argc</code>和<code>argv</code>传递给<code>main</code>函数。形参<code>argv</code>是一个数组，数组元素是字符串指针，即<code>argv</code>是一个C风格字符串指针数组。而<code>argc</code>表示的是字符串数组的长度。<br>
当一个实参传递给<code>main</code>函数之后，<code>argv</code>的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次存放命令行提供的实参。最后一个指针指向的元素应该保证为0。<br>
注意，当使用<code>argv</code>中的实参时，注意<code>argv[0]</code>保存的是程序名字或者空字符串，可选的实参从<code>argv[1]</code>开始。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.<a href="https://stackoverflow.com/questions/9554513/c-main-vs-c-main" target="_blank" rel="noopener">https://stackoverflow.com/questions/9554513/c-main-vs-c-main</a><br>
3.《你必须知道的495个C语言问题》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/12/OS-process-vs-thread/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/12/OS-process-vs-thread/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">OS process vs thread</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-12 00:09:16" itemprop="dateCreated datePublished" datetime="2019-11-12T00:09:16+08:00">2019-11-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:49:26" itemprop="dateModified" datetime="2019-12-17T15:49:26+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="程序">程序</h2>
<p>程序是一个存储在硬盘上的可执行文件。</p>
<h2 id="进程">进程</h2>
<p>程序的执行实例被称为进程，它是操作系统对一个正在运行的程序的一个抽象。</p>
<h2 id="线程">线程</h2>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread" target="_blank" rel="noopener">https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread</a><br>
2.<a href="https://www.geeksforgeeks.org/difference-between-process-and-thread/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/difference-between-process-and-thread/</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/11/UNIX-standard/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/11/UNIX-standard/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">UNIX standard and implement</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-11 18:09:41" itemprop="dateCreated datePublished" datetime="2019-11-11T18:09:41+08:00">2019-11-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-18 19:19:10" itemprop="dateModified" datetime="2019-11-18T19:19:10+08:00">2019-11-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="unix-standard">UNIX standard</h2>
<h3 id="iso-c">ISO C</h3>
<p>ISO C是国际标准化组织给出的C语言的标准。它包含两部分：C语言的语法和语义，标准库。但是标准只是给出了C标准函数的原型和功能，并没有给出他们的实现。具体的实现由编译器决定，只要编译器声称它们支持ISO C标准，那么这个编译器就必须严格遵守ISO C标准中的各项规定。<br>
ISO C标准现在由ISO/IEC的C程序国际标准工作组维护和开发，该工作组称为ISO/IEC JTC1/SC22/WG14，简称WG14。ISO C标准的目的是提供C程序的可移植性，使其能适合大量不同的操作系统，而不仅仅是适合UNIX系统。<br>
根据C语言的发展来说：<br>
1972年，丹里斯发明了C语言，这个版本的C语言叫做K&amp;R C。<br>
ISO C的前身是ANSI C，1989年，美国国家标准学会(ANSI)提出了ANSI标准X3.159-1989，这个标准就是ANSI C，它也被采纳为国际标准ISO/IEC 9899:1990，也就是ISO C90。其中IEC是国际电子技术委员会的缩写。后来陆续有了ISO C99，ISO C11等标准。</p>
<p>按照ISO标准定义的头文件，可以将ISO C库分为24个区。下面要介绍的POSIX.1标准包含ISO C的头文件以及另外一些头文件。</p>
<h3 id="ieee-posix">IEEE POSIX</h3>
<p>POSIX是由国际电气和电子工程学会制定的标准族。POSIX是可移植操作系统接口（Portable Operating System Interface）。它原来只是IEEE操作系统接口的标准1003.1，后来扩展成了许多其他标准和标准草案，如shell和实用程序等。<br>
和本书相关的是操作系统接口标准，它的目的是提高应用程序在各种UNIX操作系统之间的可移植性。它定义了符合POSIX的操作系统必须提供的各种服务，但是它并不局限于UNIX和类UNIX类的系统。<br>
由于1003.1标准只给出了接口而不是一种实现，所以并不区分系统调用和库函数。1988版本的1003.1标准，即1003.1-1988递交给了ISO，最后作为IEEE标准1003.1-1990正式出版，这就是国际标准ISO/IEC 9945-1:1990，通常也称为POSIX.1。</p>
<h3 id="single-unix-specification">Single UNIX Specification</h3>
<p>单一UNIX规范(SUS)是POSIX.1标准的一个超集，它对POSIX.1进行了扩展，POSIX.1相当于SUS的基本规范部分。<br>
POSIX.1中的X/Open系统接口(XSI)选项描述了可选的接口，也定义了遵循XSI的实现必须支持POSIX1的哪些可选部分，这些必须支持的部分包括：文件同步，线程栈地址，长度属性，线程进程共享同步以及<code>_XOPEN_UNIX</code>符号常量，只有遵循SXI的实现才能称为UNIX系统。</p>
<h2 id="unix-implement">UNIX implement</h2>
<ol>
<li>SVR4</li>
<li>4.4BSD</li>
<li>FreeBSD</li>
<li>Linux</li>
<li>Mac OS X</li>
<li>Solaris</li>
<li>其他UNIX系统</li>
</ol>
<h2 id="标准和实现的关系">标准和实现的关系</h2>
<p>标准其实是任一实际系统的子集。</p>
<h2 id="限制">限制</h2>
<p>UNIX实现定义了很多幻数和常量。已经有若干种可以移植的方法确定这些幻数和具体实现定义的限制。以下两种类型的限制是必须的：</p>
<ol>
<li>编译时限制，比如<code>int</code>的最大值是什么。</li>
<li>运行时限制，比如文件名的字符，这个只有在我们运行程序时才能知道。</li>
</ol>
<p>编译时限制可以在头文件中定义。程序在编译时可以包含这些头文件，运行时限制需要进程调用另一个函数获得限制值。<br>
但是有时候可能某些限制在给定的实现中是固定的，而在另一个实现中是变动的。比如文件的名字。为了解决这类问题，提供了以下三种限制：</p>
<ol>
<li>编译时限制</li>
<li>与文件和目录无关的运行时限制（<code>sysconf</code>函数）</li>
<li>与文件和目录有关的运行时限制（<code>pathconf</code>函数和<code>fpathconf</code>函数）</li>
</ol>
<h3 id="iso-c限制">ISO C限制</h3>
<p>包含在<code>&lt;limits.h&gt;</code>头文件中，ISO C标准给出了各种类型的最小范围，每个实现必须满足这个最小范围，具体取多少由实现决定。常见的比如<code>int</code>, <code>float</code>,<code>char</code>等的最大值和最小值。以及可同时打开的标准I/O流的最小个数。</p>
<h3 id="posix限制">POSIX限制</h3>
<p>POSIX.1定义了大量限制和常量，我们只关心和基本POSIX.1接口有关的部分。它们被分为以下7类：</p>
<ol>
<li>数值限制</li>
<li>最小值</li>
<li>最大值</li>
<li>运行时可以增加的值</li>
<li>运行时不变值</li>
<li>其他不变值</li>
<li>路径可变名</li>
</ol>
<p>这些限制有些在<code>&lt;limits.h&gt;</code>中定义，其余的限制按具体条件可以定义，可以不定义。</p>
<h3 id="xsi限制">XSI限制</h3>
<ol>
<li>最小值</li>
<li>运行时不变值</li>
</ol>
<h3 id="sysconf-pathconf和fpathconf"><code>sysconf</code>, <code>pathconf</code>和<code>fpathconf</code></h3>
<p>如何获得一个特定系统中实际支持的限制值？</p>
<ol>
<li>某些限制值在编译时是可以使用的，而有些限制值只有在运行时才能确定。</li>
<li>也有某些限制值在一个给定的系统中可能是不会改变的，而其他限制值可能会改变，因为它们与文件和目录相关。</li>
</ol>
<p>运行时限制可以通过下面三个函数之一获得：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">sysconf</span><span class="params">(<span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">pathconf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">fpathconf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> name)</span></span>;</span><br><span class="line"><span class="comment">// 所有函数如果成功，返回相应值，出错，返回-1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="选项">选项</h2>
<h2 id="基本系统数据类型">基本系统数据类型</h2>
<p>头文件<code>&lt;sys/types.h&gt;</code>定义了许多和实现相关的数据类型，它们被称为基本系统数据类型。这些数据类型都是用C的typedef定义的，大多数以<code>_t</code>结尾。常见的如下：</p>
<ul>
<li><code>clock_t</code></li>
<li><code>gid_t</code></li>
<li><code>uid_t</code></li>
<li><code>pid_t</code></li>
<li><code>pthread_t</code></li>
<li><code>ptrdiff_t</code></li>
<li><code>size_t</code></li>
<li><code>ssize_t</code></li>
<li><code>time_t</code></li>
</ul>
<h2 id="标准之间的冲突">标准之间的冲突</h2>
<p>如果出现冲突，POSIX.1服从ISO C标准。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》<br>
2.<a href="https://www.zhihu.com/question/40175738/answer/154308906" target="_blank" rel="noopener">https://www.zhihu.com/question/40175738/answer/154308906</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/11/UNIX-basic/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/11/UNIX-basic/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">UNIX basic</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-11 18:08:07" itemprop="dateCreated datePublished" datetime="2019-11-11T18:08:07+08:00">2019-11-11</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:31:13" itemprop="dateModified" datetime="2019-12-17T16:31:13+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="unix-system">UNIX system</h2>
<p>UNIX是一类操作系统，所有的操作系统都为它们运行的程序提供服务。典型的服务包括：执行新程序，读写文件，分配存储区域，获得当前时间等等。</p>
<h2 id="unix体系结构">UNIX体系结构</h2>
<p>严格意义上来说，可以把操作系统定义为一种系统软件，它控制计算机硬件资源，提供程序运行环境，这种软件称为内核。从广义上来说，操作系统包含了内核和其它一些软件，这些软件使得计算机能够发挥作用，其他软件包括应用程序，shell和公共函数库等。比如，Linux是GNU操作系统的内核，我们有时候也把GNU/Linux操作系统称为Linux，所以Linux可以表示两层含义，一种是内核，一种是操作系统。<br>
内核的接口称为系统调用（system call），公用函数库在系统调用接口之上，应用程序可以使用公用函数库，也可以使用系统调用。shell是一个特殊的应用程序，它为运行其他应用程序提供了一个接口。<br>
系统调用提供了访问内核的接口，公用函数库构建在系统调用上，应用程序可以构建在公用函数库上，也可以构建在shell和系统调用之上，shell建立在系统调用之上。</p>
<h2 id="登录-login">登录(Login)</h2>
<h3 id="用户名-username-用户组-group-和密码-passwd">用户名(username)，用户组(group)和密码(passwd)</h3>
<p>/etc/group和/etc/passwd文件分别给出了user的group和passwd相关信息，这些文件的具体格式可以使用<code>man 5 passwd</code>和<code>man 5 group</code>查看。</p>
<h3 id="shell">shell</h3>
<p>shell是一个命令行解释器，它读取用户输入，然后执行命令。shell的用户输入通常来自终端，这种是交互式shell；有时shell的输入也可以来自文件，这种文件叫做shell脚本。<br>
常见系统的shell有：</p>
<ul>
<li>Bourne shell，/bin/sh，是Steve Bourne在贝尔实验室开发的shell，几乎所有的UNIX系统都支持这种shell，</li>
<li>Bourne-again shell, /bin/bash，GNU shell，所有的Linux系统都提供这种shell，它的设计遵循了POSIX标准，同时保留了和Bourne shell的兼容性。更多关于/bin/bash的内容可以参考<a href>linux /bin/bash</a>。</li>
<li>C shell,/bin/csh，Bill Joy在博客里开发的shell，所有BSD版本都提供这种shell</li>
<li>Korn shell,/bin/ksh，贝尔实验室的David Korn开发的，在大多数UNIX系统上运行，与Bourne shell向上兼容。</li>
<li>TENEX C shell,/bin/tcsh，是C shell的加强版本，它从TENEX系统借鉴而来，常用来替换C shell。</li>
</ul>
<p>不同的Linux版本使用不同的默认shell，一些Linux默认使用Bourne-again shell，另外一些使用BSD对Bourne shell的替代品dash(Debian Almquist shell)。<br>
FreeBSD的默认用户shell衍生于Debian Almquist shell。<br>
Mac OS X的默认shell是Bourne-again shell。<br>
Solaris继承了BSD和System V，它提供了所有的shell。</p>
<h2 id="文件和目录-file-and-dir">文件和目录(File and dir)</h2>
<h3 id="文件系统">文件系统</h3>
<p>UNIX文件系统是文件和目录的一种树状结构，所有目录和文件的起点是根目录(root dir)，用&quot;/&quot;表示。</p>
<h3 id="文件名">文件名</h3>
<p>目录中的各个名字称为文件名，只有&quot;/“和空格不能出现在文件名中。”/“用来分隔构成路径名的各文件名，而空格用来终止一个路径名。<br>
创建新的目录时会自动创建”.“目录指向当前目录和”…“指向父目录，在根目录中，”.“和”…&quot;都指向根目录。</p>
<h3 id="目录名">目录名</h3>
<p>由斜线分隔的一个或者多个文件名组成的序列构成路径名，以斜线开头的路径名称为绝对路径名，否则是相对路径名。&quot;/&quot;是一个特殊的绝对路径名，它不包含文件名。</p>
<h3 id="工作目录">工作目录</h3>
<p>相对路径名都是从工作目录开始解释的。在shell中可以通过cd更改工作目录，进程可以通过chdir更改工作目录。</p>
<h3 id="起始目录-用户主目录">起始目录（用户主目录）</h3>
<p>用户登录后，工作目录默认设置为用户主目录，可以从/etc/passwd文件查看。</p>
<h2 id="输入和输出-input-and-output">输入和输出(Input and Output)</h2>
<h3 id="文件描述符">文件描述符</h3>
<p>文件描述符是一个小的非负整数，内核用它来标示一个进程正在访问的文件。当内核打开或者创建一个文件时，都会返回一个文件描述符。在读写文件时，可以使用这个文件描述符。</p>
<h3 id="标准输入-标准输出和标准错误">标准输入，标准输出和标准错误</h3>
<p>在shell中运行一个新程序时，所有的shell都会为这个程序打开三个文件描述符，标准输入，标准输出和标准错误。如果没有指定的话，它们都链接向终端。可以通过重定向将它们链接到文件。</p>
<h3 id="不带缓冲区的i-o">不带缓冲区的I/O</h3>
<p>函数<code>open</code>，<code>read</code>,<code>read</code>,<code>lseek</code>和<code>close</code>提供了不带缓冲的I/O。这些函数都使用文件描述符。<br>
头文件<code>&lt;unistd.h&gt;</code>包含了两个常量<code>STDIN_FILENO</code>和<code>STDOUT_FILENO</code>，分别指向标准输入和标准输出的文件描述符。它们是POSIX标准的一部分，在POSXI标准中分别是0和1，但是为了可读性，一般不用它们的具体值。</p>
<h3 id="标准i-o">标准I/O</h3>
<p>标准I/O函数为那些不带缓冲的I/O函数提供了一个带缓冲的借口。使用标准I/O不用担心如何选取最佳的缓冲区大小，还简化了对输入行的处理。</p>
<h2 id="程序和进程-process">程序和进程(Process)</h2>
<h3 id="程序">程序</h3>
<p>程序是一个存储在磁盘上的某个目录中的可执行文件。内核使用<code>exec</code>函数将程序读入内存，并执行该程序。</p>
<h3 id="进程和进程id-pid">进程和进程ID(PID)</h3>
<p>程序的执行实例被称为进程(process)。每一个进程都有一个唯一的数字标示符，叫做进程ID(process ID, PID),PID是一个非负整数。可以使用<code>getpid</code>函数获得PID，<code>getpid</code>返回一个<code>pid_t</code>类型，我们不知道它的大小，但是标准保证它能存放在一个长整形中，所以可以把它强制转换成它可能会用到的最大数据类型即长整形，提高程序的可移植性。</p>
<h3 id="进程控制">进程控制</h3>
<p>有三个用于进程控制的主要函数，他们分别是<code>fork</code>,<code>exec</code>和<code>waitpid</code>。</p>
<ul>
<li><code>fork</code>创建一个新进程，新进程是调用进程的一个副本，称调用进程为父进程，新创建的进程为子进程。<code>fork</code>对父进程返回子进程的进程ID（一个非负整数），对子进程则返回0。</li>
<li><code>execlp</code>函数要求参数以null结束而不是换行符结束。</li>
<li>子进程中调用<code>execlp</code>执行从标准输入读入的命令，用新的程序文件代替子进程原先执行的程序文件。<code>fork</code>和<code>exec</code>两者组合就是某些操作系统所称的spawn一个新进程。在UNIX系统中，这两部分分成了两个独立的函数。</li>
<li>子进程调用<code>execlp</code>执行新的程序文件，父进程希望等待子进程终止，这是通过<code>waitpid</code>实现的，<code>waitpid</code>接收要等待进程的ID，以及接收一个整形的地址，用来存放子进程的终止状态。出错返回-1，否则返回state改变的子进程的PID，或者返回0（子进程的状态没有改变）。</li>
</ul>
<h3 id="线程-thread-和线程i-o">线程(thread)和线程I/O</h3>
<ol>
<li>通常来说一个进程只有一个控制线程，即某一时刻执行的一组机器指令。对于某些问题，如果有多个控制线程分别多用于它的不同部分，可以使得问题变得更加容易。也可以充分利用多处理器系统的并行能力。</li>
<li>一个进程内的所有线程共享同一地址空间，文件描述符，栈以及和进程相关的属性。因为线程能够访问同一个存储区域，所以线程在访问共享数据时需要采取同步措施避免不一致性。</li>
<li>线程也有ID，但是线程ID只在它所属的进程内起作用。一个进程中的线程ID在另一个进程中没有意义。当一个进程中对某个特定线程进程处理时，可以使用线程ID引用它。</li>
</ol>
<h2 id="出错处理">出错处理</h2>
<p>当UNIX系统函数出错时，通常会返回一个负值，整形变量errno通常被设置为具有特定信息的值。比如对于<code>open</code>函数，errno大约有15种不同的值（文件不存在，权限问题），成功执行返回一个非负文件描述符，出错则返回-1。另外有一些函数对于出错使用约定值而不是返回值。比如返回对象指针的函数，出错时会返回一个NULL指针。<br>
头文件<code>&lt;errno.h&gt;</code>定义了errno以及可以赋值给它的各种常量。这些常量都以字符E开头。可以使用<code>man 2 intro</code>列出这些常量，在linux中使用<code>man 3 errno</code>列出这些常量。</p>
<p>**关于errno的两条规则:</p>
<ol>
<li>如果没有出错，errno的值不会被清除，所以，只有在函数的返回值指明出错的时候，errno的值才是有意义的，否则不要使用它；</li>
<li>任何函数都不会将errno的值设置为0，而且<code>&lt;errno.h&gt;</code>头文件中的任何常量都不等于0。**</li>
</ol>
<h3 id="出错恢复">出错恢复</h3>
<p>可以将<code>&lt;errno.h&gt;</code>中定义的各种出错分为两类：致命性的和非致命性的。<br>
对于致命性的错误，无法恢复，可以输出错误信息帮助用户处理。<br>
对于非致命的错误，可以妥善的进行处理。大多数非致命性出错都是暂时的，比如因为资源短缺。常见的与资源相关的非致命性出错包含：<code>EAGAIN</code>,<code>ENFILE</code>,<code>ENOBUFS</code>,<code>ENOLCK</code>,<code>ENOSPC</code>,<code>EWOULDBLOCK</code>，有时候<code>ENOMEM</code>也是非致命性出错。当<code>EBUSY</code>指明共享资源正在被使用时，也可以将它作为非致命性出错。当<code>EINTR</code>中断一个慢速调用时，也可将它作为非致命性出错处理。对于资源相关的非致命性出错，最典型的恢复操作是延迟一段时间重试。</p>
<h2 id="用户标识">用户标识</h2>
<h3 id="用户id-uid">用户ID(UID)</h3>
<p>用于标识不同的用户。可以在口令文件/etc/passwd中找到用户的UID。root用户的UID是0。</p>
<h3 id="组id-gid">组ID(GID)</h3>
<p>用于标识不同的group。口令文件/etc/passwd中也包含了用户的GID。组文件将组名映射为数值的GID。</p>
<p>为什么使用数值的UID和GID，对于磁盘上的每个文件，都应该存储该文件所有者的GID和PID，存储这两个值只需要4个字节（假设每个都用双字节的整形存放，早期的UNIX系统使用16位整数表示UID和GID，而现在的UNIX系统使用32位整数表示UID和GID。<br>
）。如果使用ASCII user name和group name，需要更多的磁盘空间。在进行权限检验时，整形也比字符串更快。<br>
但是对于用户来说，使用ASCII name比较方便，所以在/etc/passwd和/etc/group中存放了UID和user name以及GID和group name的映射。</p>
<h3 id="附属组id">附属组ID</h3>
<p>每个登录名除了/etc/passwd指定的一个group外，还可以属于其他的group，大多数系统至少支持16个附属组，通过查找/etc/group中有该登录名的前16个项作为它的附属组ID。</p>
<h2 id="信号-signal">信号(signal)</h2>
<p>Signal用于通知进程发生了某种特殊情况。比如进程在执行除法操作的时候，发生了除0操作，内核会将SIGFPE signal发送给进程。对于每一个signal，进程有以下三种方式进行处理：</p>
<ol>
<li>忽略某个signal。不推荐这种处理方式，如果发生了除0操作，就会出错。</li>
<li>按系统默认方式处理。比如除0操作，系统默认是终止进程。</li>
<li>提供一个函数，某个signal发生时，调用该函数，这称为捕捉signal。</li>
</ol>
<p>很多情况都会产生signal，通过键盘有两种产生signal的方法：</p>
<ul>
<li>中断键(interrupt key)，通常是ctrl+C或者Delete键和退出建(quit key)，通常是Ctrl+\ 键，这两个signal用于中断当前运行的进程。</li>
<li>调用kill函数，向进程发送一个signal，注意我们必须是root用户或者这个进程的所有者。</li>
</ul>
<h3 id="捕获signal示例">捕获signal示例</h3>
<p>在bash中运行程序时，使用中断键，相应的程序会终止。为什么会发生这种结果，对于中断信号(SIGINT)的系统默认动作是终止进程，因为进程没有告诉系统内核该怎么处理，所以系统按照默认方式终止该进程。<br>
为了捕获该信号，程序需要调用signal函数，其中指定了产生SIGINT信号时要调用的函数的名字。</p>
<h2 id="时间-time">时间(time)</h2>
<p>UNIX系统使用过两种不同的时间值。</p>
<ol>
<li>日历时间。协调世界时(Coordinated Universal Time, UTC)，即从1970年1月1日00:00:00这个时间开始经过的累计秒数。<br>
系统基本数据类型time_t用于保存这种时间值。</li>
<li>进程时间。也称为CPU时间，用来度量进程使用的CPU资源。进程时间用始终滴答计算，每秒钟曾经取过50,60或者100个时钟滴答。<br>
系统基本数据类型clock_t保存这种时间值。</li>
</ol>
<p>当度量一个进程的执行时间时，UNIX系统为一个进程维护了三个进程时间值：</p>
<ul>
<li>时钟时间，进程运行的时间总量，它的值和系统中同时运行的进程数有关。APUE中用到的时钟时间指的都是系统中没有其他活动时进行度量的。其实就是这个进程从开始到结束总共花了多长时间，包括阻塞，等待和运行的时间。</li>
<li>用户CPU时间，执行用户指令所用的时间。</li>
<li>系统CPU时间，为该进程执行内核程序所经历的时间。</li>
</ul>
<p>用户CPU时间和系统CPU时间被称为CPU时间，可以使用time命令获得一个进程的时钟时间，用户CPU时间和系统CPU时间。比如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$:time ls</span><br><span class="line">~$:time man ls</span><br></pre></td></tr></table></figure></p>
<h2 id="系统调用-system-call-和库函数-library-function">系统调用(system call)和库函数(library function)</h2>
<h3 id="系统调用">系统调用</h3>
<p>所有的操作系统都提供多种服务的入口点，通过这些入口点向内核请求服务，这些入口点被称为系统调用(system call)。系统调用处于kernel mode，一些任务只能在kernel mode运行。比如和硬件的交互，系统调用使得用户mode的进程可以通过系统调用进入kernel mode，从而实现和硬件的交互。。<br>
系统调用接口可以在man的第二部分查看，它是用C语言定义的，与具体系统如何调用一个系统调用的实现技术无关。这些和早期的操作系统按照传统方式用机器的汇编语言定义内核入口点。<br>
UNIX使用的方法是为每个系统调用在标准C库中设置一个同名函数。用户进程使用标准C调用相应的函数，这些函数又根据系统调用调用相应的内核服务。</p>
<h3 id="库函数">库函数</h3>
<p>库函数可以在man手册的第三部分查看，第三部分定义了程序员可以使用的通用库函数。库函数可以调用系统调用，也可以不调用系统调用，比如<code>read</code>函数会调用系统调用，而<code>atoi</code>等并不使用任何系统调用。</p>
<h3 id="系统调用和库函数之间的关系">系统调用和库函数之间的关系</h3>
<ol>
<li>从实现角度来看，系统调用和库函数有着根本的区别，系统调用处于内核mode，库函数属于用户mode。</li>
<li>从用户应用角度考虑，可以把系统调用看做C函数，使用系统调用还是库函数不重要，它们都是为应用程序提供服务的。</li>
<li>C函数只是系统调用和库函数的一种实现，系统调用和库函数都可以以其他方式实现。</li>
<li>系统调用通常只是提供一种最小接口，而库函数实现更复杂的功能。</li>
<li>库函数可以被替换，但是系统调用通常是不能替换的。</li>
<li>库函数可以调用系统调用，也可以不调用系统调用。</li>
<li>应用程序既可以调用库函数也可以调用系统调用。</li>
<li>进程控制系统调用(fork, exec和wait)等通常由应用程序直接调用。为了简化一些常见情况，UNIX也提供了一些库函数，如system和popen。</li>
<li>库函数链接到用户程序，在user space执行，而syste call没有链接到用户程序，在kernel space执行</li>
<li>库函数的执行时间被计算为user level time，而system call的执行事件算作system time的一部分。</li>
<li>库函数可以简单的进行debug，而系统调用不能debug，因为它们被kernel执行。</li>
</ol>
<p>对于第4条，可以考虑以下例子：<br>
sbrk(2)是分配存储空间的UNIX系统调用，它按照指定字节数增加或者减少进程地址空间。如何管理进程的地址空间由进程决定。<br>
malloc(3)是公用函数库中的一个存储分配空间函数，它负责进行进程的存储地址管理。<br>
我们可以自己实现一个malloc，但是它很有可能还要使用sbrk(2)。内核中的系统调用ssbrk是系统层面的空间分配，而库函数malloc是在用户层面进行操作。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://www.thegeekstuff.com/2012/07/system-calls-library-functions/" target="_blank" rel="noopener">https://www.thegeekstuff.com/2012/07/system-calls-library-functions/</a><br>
3.<a href="https://stackoverflow.com/questions/29816791/what-is-the-difference-between-system-call-and-library-call" target="_blank" rel="noopener">https://stackoverflow.com/questions/29816791/what-is-the-difference-between-system-call-and-library-call</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/11/APUE-overview/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/11/APUE-overview/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">APUE-overview</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-11 16:31:06 / 修改时间：18:07:20" itemprop="dateCreated datePublished" datetime="2019-11-11T16:31:06+08:00">2019-11-11</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="apue是什么">APUE是什么</h2>
<p>APUE是Advandaced Programming in the UNIX environment的简称，即UNIX高级环境编程。<br>
很多人都把这本书和UNP(UNIX Network Programming)当做UNIX编程的神书。一直想拜读这两本书，但是每次翻开之后就放弃了，因为看不懂它在讲些什么，这篇博客简单介绍了APUE到底是什么，它能用来干什么。</p>
<h2 id="apue包含的内容">APUE包含的内容</h2>
<p>UNIX系统提供了两类程序设计接口：</p>
<ol>
<li>系统调用接口：UNIX为程序运行提供的大量服务－打开文件，读文件，启动一个新程序，分配存储区以及获得当前时间等等，这些服务被称为系统调用接口(system call interface)。</li>
<li>标准C库：提供大量广泛用于C程序中的函数（格式化输入出入，字符串比较等等）。</li>
</ol>
<p>APUE这本书并不是介绍UNIX中有哪些系统调用接口和库函数，这些可以从《UNIX程序员手册》中找到，APUE给出的是这些系统调用接口和库函数该怎么使用，以及它们的基本原理。</p>
<h2 id="unix标准">UNIX标准</h2>
<p>20世纪80年代，有各个版本的UNIX，为了让这些UNIX版本统一起来，人们制定了数个国际标准，包含C程序设计的ANSI C标准，IEEE POSIX标准，以及X/Open可移植性等等。</p>
<h2 id="apue样例">APUE样例</h2>
<p>APUE中给出的所有示例代码，都是ANSI C编写的。这些程序的<a href="http://www.apuebook.com/code2e.html" target="_blank" rel="noopener">下载地址</a>。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-generic-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-generic-algorithm/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/8/index.html">C++ generic algorithm</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:57:52" itemprop="dateCreated datePublished" datetime="2019-11-10T12:57:52+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-08 22:30:03" itemprop="dateModified" datetime="2020-01-08T22:30:03+08:00">2020-01-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="泛型算法">泛型算法</h2>
<p>头文件<code>&lt;algorithm&gt;</code>定义了许多通用算法，而头文件<code>&lt;numeric&gt;</code>定义了一组数值泛型算法。<br>
<strong>算法并不依赖于容器，即算法不直接操作容器，而是运行于迭代器之上，执行迭代器的操作。因此算法永远不会改变底层容器的大小，但是它可能改变容器中保存的元素，也可能在容器内移动元素，但永远不会直接添加或者删除元素。</strong><br>
<strong>标准库定义了一类特殊的迭代器，叫做插入器(inserter)，插入器可以向容器添加元素。给插入器赋值的时候，它们会在底层的容器上执行插入操作。因此，当一个算法操作这样的迭代器时，迭代器可以完成向容器添加元素的效果，但是算法自身不会直接操作容器。</strong></p>
<p>绝大部分算法的都对一个范围内的元素进行操作，这个范围被称为输入范围，接收输入范围的算法总是使用前两个参数表示这个范围。可以将它们分为：</p>
<ul>
<li>只读算法，如find, find_if, count, count_if accumulate，equal等。</li>
<li>写容器元素的算法，如fill,fill_n，copy,replace,replace_copy等。</li>
<li>重排容器元素的算法，如sort, unique等。</li>
</ul>
<h2 id="定制操作">定制操作</h2>
<p>这一节主要介绍了如何向算法传递可调用对象。总共有三种方法：</p>
<ol>
<li>predicate。predicate是一个可调用的表达式，返回结果是一个能用作条件的值。C++ 使用了unary predicate和binary predicate。</li>
<li>lambda表达式，具体的可以查看<a href></a>。</li>
<li>bind 绑定参数。</li>
</ol>
<h2 id="再谈迭代器">再谈迭代器</h2>
<p>这一节介绍了四种特殊的迭代器：</p>
<ol>
<li>insert iterator</li>
<li>iostream iterator</li>
<li>reverse iterator</li>
<li>move iterator</li>
</ol>
<h2 id="迭代器类别">迭代器类别</h2>
<h2 id="算法形参模式">算法形参模式</h2>
<h2 id="算法命令规范">算法命令规范</h2>
<h2 id="特定容器算法">特定容器算法</h2>
<p>list和forward_list单独定义了sort, merge, remove, reverse和unique。<br>
因为通用的sort需要使用random_access_iterator，所以不能用于list和forward_list。而上述的其他算法的通用版本可以用于list和forwrad_list，但是代价太高了。这些算法需要交换输入序列中的算法，list和forward_list可以仅仅通过改变元素之间的链接而不是真的交换它们的值实现更快的交换，这样的性能比通用的版本要更好一些。list和froward_list还有一个特殊的splice算法。<br>
<img src="/2019/11/10/C-generic-algorithm/" alt><br>
<img src="/2019/11/10/C-generic-algorithm/" alt></p>
<p><strong>注意，链表特有版本的算法会改变底层的容器。</strong></p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版中文版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/7/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/page/9/">9</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/9/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">324</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">74</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
