<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/10/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/10/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-generic-algorithm/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-generic-algorithm/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ generic algorithm</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:57:52" itemprop="dateCreated datePublished" datetime="2019-11-10T12:57:52+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-08 22:30:03" itemprop="dateModified" datetime="2020-01-08T22:30:03+08:00">2020-01-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="泛型算法">泛型算法</h2>
<p>头文件<code>&lt;algorithm&gt;</code>定义了许多通用算法，而头文件<code>&lt;numeric&gt;</code>定义了一组数值泛型算法。<br>
<strong>算法并不依赖于容器，即算法不直接操作容器，而是运行于迭代器之上，执行迭代器的操作。因此算法永远不会改变底层容器的大小，但是它可能改变容器中保存的元素，也可能在容器内移动元素，但永远不会直接添加或者删除元素。</strong><br>
<strong>标准库定义了一类特殊的迭代器，叫做插入器(inserter)，插入器可以向容器添加元素。给插入器赋值的时候，它们会在底层的容器上执行插入操作。因此，当一个算法操作这样的迭代器时，迭代器可以完成向容器添加元素的效果，但是算法自身不会直接操作容器。</strong></p>
<p>绝大部分算法的都对一个范围内的元素进行操作，这个范围被称为输入范围，接收输入范围的算法总是使用前两个参数表示这个范围。可以将它们分为：</p>
<ul>
<li>只读算法，如find, find_if, count, count_if accumulate，equal等。</li>
<li>写容器元素的算法，如fill,fill_n，copy,replace,replace_copy等。</li>
<li>重排容器元素的算法，如sort, unique等。</li>
</ul>
<h2 id="定制操作">定制操作</h2>
<p>这一节主要介绍了如何向算法传递可调用对象。总共有三种方法：</p>
<ol>
<li>predicate。predicate是一个可调用的表达式，返回结果是一个能用作条件的值。C++ 使用了unary predicate和binary predicate。</li>
<li>lambda表达式，具体的可以查看<a href></a>。</li>
<li>bind 绑定参数。</li>
</ol>
<h2 id="再谈迭代器">再谈迭代器</h2>
<p>这一节介绍了四种特殊的迭代器：</p>
<ol>
<li>insert iterator</li>
<li>iostream iterator</li>
<li>reverse iterator</li>
<li>move iterator</li>
</ol>
<h2 id="迭代器类别">迭代器类别</h2>
<h2 id="算法形参模式">算法形参模式</h2>
<h2 id="算法命令规范">算法命令规范</h2>
<h2 id="特定容器算法">特定容器算法</h2>
<p>list和forward_list单独定义了sort, merge, remove, reverse和unique。<br>
因为通用的sort需要使用random_access_iterator，所以不能用于list和forward_list。而上述的其他算法的通用版本可以用于list和forwrad_list，但是代价太高了。这些算法需要交换输入序列中的算法，list和forward_list可以仅仅通过改变元素之间的链接而不是真的交换它们的值实现更快的交换，这样的性能比通用的版本要更好一些。list和froward_list还有一个特殊的splice算法。<br>
<img src="/2019/11/10/C-generic-algorithm/" alt><br>
<img src="/2019/11/10/C-generic-algorithm/" alt></p>
<p><strong>注意，链表特有版本的算法会改变底层的容器。</strong></p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版中文版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-template/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-template/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ template</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:54:56" itemprop="dateCreated datePublished" datetime="2019-11-10T12:54:56+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-25 15:06:34" itemprop="dateModified" datetime="2020-02-25T15:06:34+08:00">2020-02-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="模板面试知识点">模板面试知识点</h2>
<ol>
<li>模板特化和偏特化[2]。</li>
<li>函数模板和类模板的定义通常需要放在头文件中。为了生成一个实例化版本，编译器需要掌握函数模板或者类模板成员函数的定义[3]。</li>
<li>函数重载和模板特化的关系。模板特化不影响函数匹配，实际上，我们是替编译器实现了重载之后的某个特殊类型的实例化。</li>
</ol>
<h2 id="一些函数">一些函数</h2>
<ol>
<li><code>remove_reference</code>，可以将一个引用类型（包括左值引用和右值引用）变成非引用类型，通过类模板特化完成。</li>
<li><code>std::move</code>，将一个左值转换成右值，或者保持右值不变。通过static_cast完成。</li>
<li><code>std::forward&lt;T&gt;(arg)</code>。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Type &amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    another_func(<span class="built_in">std</span>::forward&lt;Type&gt;(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>上述代码会做到将func的实参原封不动的（保持所有属性）转发到another_func中，具体的过程：首先根据引用折叠和右值引用参数推断出Type的类型，如果arg是右值，Type是普通类型，如果arg是左值，则Type是引用的右值，通过引用折叠，得到Type是一个左值引用。推断出Type的类型之后，std::forward<type>返回的是Type的&amp;&amp;，再和arg进行引用折叠，得到相应的左值或者右值。</type></p>
<h2 id="模板定义">模板定义</h2>
<h3 id="模板参数列表">模板参数列表</h3>
<p>模板定义以关键字template开始，后跟一个模板参数列表，是一个逗号分隔的一个或者多个模板参数的列表，用<code>&lt;</code>和<code>&gt;</code>分隔开来。模板参数可以是模板类型参数和非类型模板参数。</p>
<h4 id="模板类型参数">模板类型参数</h4>
<p>一个模板类型参数表示一个类型，类型参数前需要加上<code>class</code>或者<code>typename</code>关键字，它们是等价的。</p>
<h4 id="非类型模板参数">非类型模板参数</h4>
<p>而非类型模板参数是一个值，而不是一个类型，通过一个特定的类型名指定非类型参数。</p>
<p>模板参数列表的作用很像函数参数列表。<strong>函数参数列表</strong>定义了若干特定类型的局部变量，但是没有指出如何初始化它们。运行时，需要调用者提供实参来初始化形参。而模板参数表示在类或者函数定义中用到的类型或者值。使用模板时，我们需要显式或者隐式的指定模板实参，将它绑定到模板参数上。</p>
<h2 id="模板种类">模板种类</h2>
<h3 id="函数模板">函数模板</h3>
<p>调用函数模板时，编译器会用函数实参推断模板实参。</p>
<h3 id="类模板">类模板</h3>
<p>编译器不能为类模板推断模板类型参数，为了使用类模板，必须在<strong>模板名</strong>后的尖括号提供模板实参列表代替模板参数。</p>
<ol>
<li><strong>实例化类模板。</strong><br>
使用类模板时，需要提供显式模板实参列表，编译器使用这些模板实参进行实例化。</li>
<li><strong>类模板的成员函数。</strong><br>
定义在类模板之外的成员函数必须以关键字template开始，后接类模板参数列表。在类外定义一个成员时，不仅要说明成员属于哪个类，从<strong>一个模板生成的类的名字</strong>中必须包含它的模板实参（比如<code>Blob&lt;T&gt;</code>)。</li>
<li><strong>类模板成员函数的实例化。</strong><br>
对于一个实例化了的类模板，它的成员只有在使用时才被实例化，所以即使某种类型不完全符合模板操作的类型，也能用这个类型实例化类。</li>
<li><strong>在类的作用域内简化模板类名的使用。</strong><br>
在类模板自己的作用域内，不需要使用<code>Blob&lt;T&gt;</code>，使用<code>Blob</code>即可。</li>
<li><strong>类模板和友元。</strong><br>
仅仅每个实例类型之间互为友元。（template_friend_1.cpp)<br>
一个类可以将另一个模板的所有实例都声明为友元。（template_friend_2.cpp)<br>
一个类可以是一个类模板所有实例的友元。（template_friend_3.cpp)<br>
一个类模板将另一个类模板的所有实例都声明为友元。（template_friend_4.cpp)<br>
一个模板将模板类型参数声明为友元。</li>
<li><strong>模板类型别名。</strong><br>
使用using可以为类模板定义一个别名。</li>
<li><strong>类模板的static成员。</strong><br>
每个实例都有一个自己的static成员。</li>
</ol>
<h3 id="模板参数">模板参数</h3>
<ol>
<li><strong>模板参数和作用域。</strong><br>
模板内的变量名不能和模板参数名冲突。</li>
<li><strong>使用类的类型成员。</strong><br>
默认情况下，假定通过作用域运算符访问的是名字不是类型。如果需要访问类型的话，必须使用typename关键字告诉编译器这是一个类型。</li>
<li><strong>默认模板实参。</strong><br>
C++ 11之后，可以为函数和类模板都提供默认实参。在使用类模板的时候，必须在模板名后加上尖括号，如果一个类模板的所有模板参数都有默认实参，而且想要使用默认实参，需要使用`&lt;&gt;。</li>
</ol>
<h3 id="成员模板">成员模板</h3>
<p>一个类（普通类或者类模板）都可以包含本身是模板的函数，这种成员被称为成员模板，成员模板不能是虚函数。</p>
<ol>
<li><strong>普通类的成员模板。</strong></li>
<li><strong>类模板的成员模板。</strong><br>
类模板和成员模板有各自的模板参数。当在类模板外定义成员模板的时候，必须同时为类模板和成员模板提供模板参数列表，类模板的参数列表在前，成员模板的参数列表在后。</li>
</ol>
<h3 id="实例化定义">实例化定义</h3>
<p>模板在使用时才被实例化，当多个独立编译的源文件同时使用了相同的模板和模板参数列表时，可能而存在多个同一模板的示例，使用<strong>显式实例化</strong>避免这种开销。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;    <span class="comment">//实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;           <span class="comment">//实例化定义</span></span><br><span class="line"><span class="comment">// 示例</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> Blob&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="keyword">template</span> Blob&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure></p>
<p>实例化定义会实例化所有的成员，所以用来实例化的类型，必须能用于模板的所有成员。</p>
<h3 id="效率和灵活性">效率和灵活性</h3>
<p><code>shared_ptr</code>在运行时绑定deleter，deleter不是<code>shared_ptr</code>的成员。<br>
<code>unique_ptr</code>在编译是绑定deleter，deleter是<code>unique_ptr</code>的一个成员。</p>
<h2 id="模板实参推断">模板实参推断</h2>
<h3 id="类型转换和模板类型参数">类型转换和模板类型参数</h3>
<ol>
<li><strong>能用于函数模板的类型转化。</strong>
<ul>
<li><code>const</code>转换，可以将非顶层const 转换为顶层const</li>
<li>数组或者函数转换为相应的指针。</li>
</ul>
</li>
<li><strong>相同模板类型参数的函数形参。</strong></li>
<li><strong>不同模板类型参数的函数形参。</strong></li>
<li><strong>正常类型转换对应于普通函数实参。</strong></li>
</ol>
<h3 id="函数模板显式实参">函数模板显式实参</h3>
<p>对于一些编译器无法推断出的模板实参类型，可以指定显式模板实参。而且显式模板实参的顺序和模板参数声明的顺序一致。</p>
<h3 id="尾置返回类型">尾置返回类型</h3>
<p>可以使用尾置返回类型声明不知道返回结果的类型。</p>
<h3 id="函数指针的实参推断">函数指针的实参推断</h3>
<p>当参数是一个函数模板实例的地址时，程序的上下文必须满足，对于每个模板参数，能唯一确定它的类型或者值。</p>
<h3 id="模板实参推断和引用">模板实参推断和引用</h3>
<ol>
<li>当函数参数是一个普通左值引用的时候，只能给他传递一个左值，实参可以是const，也可以不是。如果实参是const的，T会被推断成const类型。<br>
当函数参数是一个常量引用的时候，实参可以是任何对象。这个const是函数参数类型的一部分，而不是模板参数类型的一部分。</li>
<li>也可以推断出右值实参的类型。</li>
<li>引用折叠和右值引用参数。如果一个函数参数是指向模板参数类型的右值引用，比如T&amp;&amp; val，可以给val传递任意类型的实参（左值或者右值）。如果将一个左值传递给这样的参数，则函数参数被实例化为一个普通的<strong>左值引用</strong>。</li>
</ol>
<h3 id="理解std-move">理解std::move</h3>
<p>std::move的源代码如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以，从代码中我们可以看出来，是可以显式的将一个左值static_cast到一个右值引用。</p>
<h3 id="forward">forward</h3>
<p>forward指的是将实参的所有性质原封不动的转发给其他函数，包括实参类型是否是const的以及实参是左值还是右值。<br>
**forward<t>的返回类型是T&amp;&amp;。**如下代码：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;Typename T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(Type &amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 首先对右值引用模板参数进行推导，如果arg是右值，那么推断出Type是普通非引用类型。如果arg是左值，推断出Type是左值引用类型。</span></span><br><span class="line">    <span class="built_in">std</span>::forward&lt;Type&gt;(arg);</span><br><span class="line">    <span class="comment">// 调用std::forward获得Type的右值引用，通过引用折叠，可以得到相应的左值和右值类型变量。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></t></p>
<h2 id="重载与模板">重载与模板</h2>
<p>函数模板匹配规则，如果有多个函数都满足要求，选择其中最特殊的那个：普通函数比函数模板特殊，都是函数模板的时候，选择更特殊的那个，否则就有歧义。</p>
<h2 id="可变参数模板">可变参数模板</h2>
<p><strong>可变参数模板</strong>是一个接收可变数目参数的模板函数或模板类。可变数目的参数被称为参数包。存在两种参数包：模板参数包和函数参数包，模板参数包表示零个或者多个模板参数，就是typename加上… ，函数参数包表示零个或者多个函数参数，是模板类型加上…。</p>
<h2 id="模板特化">模板特化</h2>
<p>函数模板特化和类模板特化。特化一个函数模板时，必须为原函数模板中的每个模板参数都提供实参，叫做全特化。类模板的特化不需要给所有的模板参数提供实参，可以指定一部分参数而不是所有参数，即偏特化。<br>
<strong>特化</strong>的本质是实例化，和模板的重载本质上是不同的，特化不会影响函数匹配。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版中文版<br>
2.<a href="https://stackoverflow.com/questions/8061456/c-function-template-partial-specialization" target="_blank" rel="noopener">https://stackoverflow.com/questions/8061456/c-function-template-partial-specialization</a><br>
3.<a href="https://isocpp.org/wiki/faq/templates" target="_blank" rel="noopener">https://isocpp.org/wiki/faq/templates</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-object-oriented-programming/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-object-oriented-programming/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ object-oriented programming</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:52:25" itemprop="dateCreated datePublished" datetime="2019-11-10T12:52:25+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-06 23:14:47" itemprop="dateModified" datetime="2020-02-06T23:14:47+08:00">2020-02-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念">概念</h2>
<ol>
<li>类的基本思想是数据抽象和封装。数据抽象是一种依赖于<strong>接口</strong>和<strong>实现</strong>分离的编程技术。类的接口包括用户所能执行的操作；类的实现包括类的数据成员，接口的实现部分（函数体），类所需要的各种私有函数的实现。<strong>封装</strong>指的是用访问说明符(public, private, protected)实现对类的访问控制。</li>
<li>继承。有一个类作为基类，派生类从基类继承而来，具有基类的全部或者部分成员。</li>
<li>动态绑定，也叫运行时绑定。在运行时选择函数的版本。</li>
<li>虚函数。基类将希望派生类override的函数声明为虚函数。</li>
<li>类派生列表。冒号后面跟着以逗号分隔的基类列表，每个基类前面可以有三种访问说明符中的一个：<code>public</code>,<code>private</code>, <code>protected</code>。</li>
</ol>
<h2 id="什么是面向对象">什么是面向对象</h2>
<p>面向对象程序设计的核心思想是<strong>数据抽象</strong>，<strong>继承</strong>，<strong>动态绑定</strong>。</p>
<ol>
<li>数据抽象和封装。数据抽象依赖于接口和实现分离的编程技术。接口包括用户所能执行的操作，实现包括类的数据成员，接口实现的函数体，定义类所需要的各种私有函数。封装指的是用访问说明符(public, private, protected)实现对类的访问控制。</li>
<li>继承，定义相似的类型并对其相似关系建模。有一个类作为基类，派生类从基类继承而来，具有基类的全部或者部分成员。</li>
<li>动态绑定，也叫运行时绑定，在运行时选择函数的版本。动态绑定在一定程序上忽略相似类型的区别，用统一的方式使用它们的对象。</li>
</ol>
<h2 id="基类和派生类">基类和派生类</h2>
<h3 id="定义基类">定义基类</h3>
<ol>
<li>成员函数和继承。派生类可以继承基类的成员函数，也可以提供自己的函数对基类的函数进行覆盖(override)。基类需要将这两种成员函数分开：一种是基类希望派生类覆盖的函数，一种是基类希望派生类直接使用的函数。<br>
<strong>定义虚函数表明基类希望派生类覆盖的函数</strong>，在使用对象的指针或者引用调用虚函数时，这个调用会被动态绑定。而没有定义为虚函数的成员函数，解析过程发生在编译时而非运行时。<br>
<strong>除了构造函数之外的所有非静态函数都可以是虚函数。在基类中声明的虚函数，在派生类中无需声明为虚函数就隐式的是虚函数。</strong></li>
<li>访问控制和继承。派生类可以继承基类的成员，但是派生类的成员函数不一定有权限访问继承来的成员。派生类可以访问基类的公用成员，但是无法访问基类的私有成员。<code>protected</code>访问运算符声明的成员表示派生类可以访问，但是其他用户无法访问的成员。</li>
</ol>
<h3 id="定义派生类">定义派生类</h3>
<p>通过<strong>派生类列表</strong>，指出它是从哪个或者哪些基类中继承而来的。首先是一个冒号，后面跟着用逗号分隔的基类列表，每个基类前面可以有三种访问说明符中的一个：public、protected或者private，默认是private。</p>
<ol>
<li>派生类中的虚函数。派生类可以不override他继承的虚函数，这样子派生类会直接继承基类中的版本。<br>
C++ 11中，不一定需要在要override的函数前加上virtual关键字，可以使用override关键字修饰，表明这个函数是override的函数。</li>
<li>**派生类对象和派生类向基类的类型转换。可以把派生类对象当做基类对象使用，也可以将基类指针或引用绑定到派生类对象上，也可以把派生类指针用在需要基类指针的地方。**一个派生类对象包含多个组成部分：一个含有派生类自己定义的成员的子对象，以及一个与该派生类继承的基类对应的子对象，如果有多个基类，就会有多个这样的子对象。一个基类的对象可以独立存在，也可以作为派生类对象的一部分存在。如果基类对象不是派生类对象的一部分，那么它只含有基类定义的成员，而不含有派生类定义的对象。而一个基类对象可能是派生类对象的一部分，也可能不是，所以不存在从基类到派生类的自动类型转换。</li>
<li>派生类的构造函数。派生类的构造函数中，需要调用基类的构造函数对于基类部分进行初始化。即每隔类控制它自己的成员的初始化。</li>
<li>派生类使用基类的成员。派生类的对象不能直接初始化基类的成员，尽管语法上是正确的。与类的对象交互必须使用类的接口。</li>
<li>继承与静态成员。整个继承体系中只存在每个静态成员的一个定义。</li>
<li>派生类的声明。派生类的声明中不能包含它的派生列表。</li>
<li>用作基类的类。如果要将某个类用作基类，这个类必须声明而且定义过了。</li>
<li><code>final</code>关键字防止继承的发生。用<code>final</code>关键字修饰的类不能用作基类，但是可以作为子类，不过这个子类不能继续作为基类被继承。</li>
</ol>
<h3 id="类型转换和继承">类型转换和继承</h3>
<ol>
<li>**在具有继承关系的类之间，可以将基类的指针或引用绑定到派生类对象。当使用基类的引用或者指针时，引用或者指针绑定的对象可能是基类的对象，也可能是派生类的对象。**因为每个派生类都包含一个基类部分，基类的引用或者指针可以绑定到基类部分。</li>
<li>表达式的<strong>静态类型</strong>是变量声明时的类型或表达式生成的类型，在编译时就是已知的；<strong>动态类型</strong>是变量或者表达式表示的内存中的对象的类型，在运行时才知道。</li>
<li>不存在从基类向派生类的隐式类型转换。</li>
<li>派生类向基类的类型转换只对指针或者引用类型有效，在派生类类型和基类类型之间不存在这样的转换。当用一个派生类对象为一个基类对象初始化（调用拷贝构造函数）或者赋值（调用拷贝赋值函数）时，只有该派生类中的基类部分会被拷贝，移动或者赋值，它的派生类部分将被忽略掉。</li>
</ol>
<h2 id="虚函数">虚函数</h2>
<ol>
<li>每一个虚函数都必须被定义，因为连编译器也不知道哪个虚函数被使用了。</li>
<li>对虚函数的调用可能在运行时才被解析，编译器产生的代码知道运行时才能确定应该调用哪个版本的函数。</li>
<li><strong>动态绑定只有在通过指针或者引用调用虚函数时才会发生。</strong>（P537页）</li>
<li><strong>C++ 的多态性的根本原因是引用或指针的静态类型可以和动态类型不同。</strong><br>
当使用基类的引用或者指针调用基类中定义的一个函数时，如果这个函数是虚函数，直到运行时才会决定到底执行哪个版本，这个版本取决于引用或者指针绑定的对象的真实类型。<br>
对于非虚函数的调用在编译时进行绑定。同样，通过对象（不是引用也不是指针）进行的函数调用（包含虚函数和非虚函数）都在编译时确定。</li>
<li>派生中override的虚函数必须和基类中的函数形参，返回类型完全一致，除了类的虚函数返回类型是类本身的指针或引用时是一个例外。</li>
<li>final和override关键字。final说明这个类不能被继承，override说明这个函数是对基类中虚函数的重写。它们出现在形参列表（包括const或引用修饰符）之后。final也可以用于修饰某个函数，表示这个函数不能被override。</li>
<li><strong>虚函数和默认实参。<strong>如果虚函数调用</strong>使用了默认实参</strong>，实参值由调用的静态类型决定（也就是基类虚函数定义的默认实参，和派生类定义的默认实参无关）。</li>
<li>可以使用作用域运算符强制调用虚函数的某个特定版本。例如，当一个派生类的虚函数需要调用它覆盖的基类的虚函数版本时。</li>
</ol>
<h2 id="纯虚函数和抽象基类">纯虚函数和抽象基类</h2>
<ol>
<li><strong>纯虚函数</strong>。在函数体的位置书写=0就可以将一个函数声明为纯虚函数，纯虚函数无序定义。</li>
<li>**含有纯虚函数的类是抽象基类。**不能定义抽象基类的对象。抽象基类负责定义接口，而派生类可以覆盖接口。</li>
</ol>
<h2 id="访问控制和继承">访问控制和继承</h2>
<p>每个类控制着自己成员的初始化过程，还控制着成员对于派生类来说是否可访问。</p>
<h3 id="成员访问说明符">成员访问说明符</h3>
<p>protected说明符：</p>
<ol>
<li>对于类的用户来说是不可访问的，对派生类的成员和友元来说是可以访问的。</li>
<li>派生类的成员或者友元只能访问派生类对象的基类部分的protected成员，派生类对于基类对象中的protected成员没有任何访问特权。</li>
</ol>
<p>某个类对它继承而来的成员的访问权限受到两个因素影响：一个是在基类中该成员的访问说明符，另一个是派生类的派生列表中的访问说明符（public, private, protected继承）。<br>
**基类中的访问说明符决定基类的用户（包含派生类的成员和友元）是否能够访问它的直接基类成员，派生列表中的访问说明符决定派生类用户（包含派生类的派生类）对于基类的访问权限。**对于public继承，派生类用户对于基类的成员的访问遵循原来的访问说明符；私有继承，所有的基类成员都是private的；对于protected继承，基类的所有public成员都是protected的，派生类的成员和友元可以访问继承而来的成员，而派生类的用户不能访问。</p>
<h3 id="派生类向基类转换的可访问性">派生类向基类转换的可访问性</h3>
<p>一个类可能有三种用户：普通用户，类的实现者，派生类。普通用户编写的代码使用类的对象，这部分用户只能访问类的公有成员（接口），而实现者负责编写类的成员和友元代码，它们既能访问类的公有部分，也能访问类的私有部分。<br>
派生类向基类的转换会受派生类的派生访问说明符的影响。</p>
<ol>
<li>派生类public继承基类，用户代码可以使用派生类到基类的转换，否则不行。</li>
<li>派生类public, protected, private继承基类，派生类成员或者友元都可以使用派生类到基类的转换。</li>
<li>派生类public或者protected继承基类，派生类的派生类的成员或者友元可以使用派生类到基类的转换，否则不行。</li>
</ol>
<p><strong>基类的public成员，基类成员和友元可以访问，基类的普通用户可以访问，派生类的成员和友元可访问。<br>
基类的protected成员，基类成员和友元可以访问，基类的普通用户不可以访问，派生类的成员和友元可以访问。<br>
private，基类的成员和友元可以访问，基类的普通用户不可以访问，派生类的成员和友元不可以访问。<br>
public继承，派生类的普通用户可以访问基类的public成员，派生类的派生类的成员和友元可以访问基类public和protected成员。<br>
protected继承，派生类的普通用户不可以访问基类的任何成员，派生类的派生类的成员和友元可以访问基类的public和protected成员。<br>
private继承，派生类的普通用户不可以访问基类的任何成员，和派生类的派生类成员和友元不可以访问基类的任何成员。</strong></p>
<h3 id="友元和继承">友元和继承</h3>
<p>友元关系不能继承，每个类负责控制各自的访问权限。</p>
<h3 id="改变个别成员的可访问性">改变个别成员的可访问性</h3>
<p>可以使用using声明改变继承的某些成员的可访问性。</p>
<h2 id="继承中的类作用域">继承中的类作用域</h2>
<ol>
<li>**派生类的作用域嵌套在基类的作用域之内。**所以派生类才能像使用自己的成员一样使用基类的成员。</li>
<li>一个对象，引用或者指针的静态类型决定了该对象的哪些成员是可见的。</li>
<li><strong>和其他的作用域一样，派生类也能重用定义在它的直接基类或者间接基类的名字，定义在内层作用域的名字会隐藏在定义在外层作用域的名字，而不会重载声明在外部作用域的函数</strong>。派生类的成员会隐藏同名的类成员，可以通过作用域运算符使用隐藏的外层作用域成员。<br>
**为什么基类与派生类的虚函数必须有相同的形参列表？**如果它们的形参不同，就不会override了，而是隐藏了。</li>
<li>**名字查找和继承。**当使用对象，指针或者引用调用某个函数时，可以分为四个步骤：<br>
首先确定静态类型。<br>
然后在这个静态类型中查找成员，如果没有找到，依次查找直接基类和间接基类，找到为止，如果一直到最后都没有找到，报错。<br>
找到了的话，就进行类型检验。名字查找优先于类型检查。<br>
如果调用合法，编译器根据调用的是否是虚函数产生不同的代码。如果是通过引用或者指针调用的虚函数，进行动态绑定；如果不是虚函数或者通过对象调用的函数，编译器产生一个常规函数调用。</li>
<li>派生类可以override重载的函数，如果派生类希望所有重载版本对它来说都是可见的，需要override所有的版本，或者一个也不override。可以使用using声明指定一个名字而不指定形参列表。这时，只需要定义派生类特有的函数就可以了。</li>
</ol>
<h2 id="构造函数和拷贝控制">构造函数和拷贝控制</h2>
<h3 id="虚析构函数">虚析构函数</h3>
<p><strong>当存在继承关系时，需要在基类中将析构函数定义成虚函数。如果基类的析构函数不是虚函数，那么delete一个指向派生类对象的基类指针将会产生未定义的行为。</strong><br>
虚析构函数会阻止合成移动操作，即使是默认版本的虚析构函数。</p>
<h3 id="合成拷贝控制和继承">合成拷贝控制和继承</h3>
<ol>
<li>合成的构造函数，赋值运算符和析构函数分别负责使用直接基类中对应的操作对一个对象中的直接基类部分进行初始化，赋值和销毁的操作。</li>
<li>删除的拷贝控制函数和基类的关系。</li>
<li>移动操作和基类的关系。大多数基类都会定义一个虚析构函数，虚析构函数是拷贝控制函数中的一个，所以基类通常不会含有合成的移动操作，而在在它的派生类中也没有合成的移动操作。</li>
</ol>
<h3 id="派生类的拷贝控制成员">派生类的拷贝控制成员</h3>
<ol>
<li>派生类的拷贝或移动构造函数，需要调用基类的拷贝或者移动构造函数进行派生类的基类部分对象的拷贝或者移动。</li>
<li>派生类的赋值运算符，在派生类的赋值运算符中还要调用基类的赋值运算符。</li>
<li>派生类析构函数。析构函数中只需要进行派生类的析构就行了，基类的析构是自动执行的。</li>
<li>在构造函数和析构函数中调用虚函数时，分别调用与构造函数或者析构函数所属类型相对应的虚函数版本。因为派生类对象构造函数被调用时，首先调用基类的构造函数，这个时候派生类的对象还是未初始化的，所以就无法调用派生类的构造函数。而在析构过程中，同理。</li>
</ol>
<h3 id="继承的构造函数">继承的构造函数</h3>
<ol>
<li>派生类可以重用它的直接基类的构造函数，通过使用一条using声明：<br>
<code>using Base::Base;</code><br>
就可以在派生类中使用基类的构造函数，并且在派生类中构造函数的访问级别和基类中相同。</li>
<li>当基类的构造函数含有默认实参的时候，派生类会获得多个继承的构造函数。</li>
<li>除了两个例外情况，派生类会继承所有基类的构造函数。一个是派生类中定义了和基类中参数列表相同的构造函数，另一个是基类的默认，拷贝和移动构造函数不会被继承。继承的构造函数也不会当做用户定义的构造函数使用，所以如果一个类如果只有一个继承的构造函数，它也会有一个合成的默认构造函数。</li>
</ol>
<h2 id="容器和继承">容器和继承</h2>
<p>使用容器存放继承体系中的对象时，在容器中放置（智能）指针而非对象，这些指针的动态类型可能是基类类型，也可能是派生类类型。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-operator-overload/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-operator-overload/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ operator overload</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:49:42" itemprop="dateCreated datePublished" datetime="2019-11-10T12:49:42+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-03 14:33:31" itemprop="dateModified" datetime="2020-02-03T14:33:31+08:00">2020-02-03</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是运算符重载">什么是运算符重载</h2>
<ol>
<li>运算符重载有两种实现形式，一种是成员函数，一种是非成员函数的。如果一个运算符函数是成员函数，它的显式参数数量要比运算对象的数量少一个，第一个运算对象绑定到了隐含的this指针。</li>
<li>一个运算符函数，或者是类的成员，或者至少还有一个类型成员的函数。</li>
<li>一般不重载逗号运算符和取地址运算符，逻辑与和逻辑或运算符。</li>
<li>重载的运算符的求值顺序不确定，但是优先级，结合性以及操作数的数目都不变。</li>
<li>对于输入和输出运算符<code>&lt;&lt;</code>,<code>&gt;&gt;</code>，只能写成非成员函数，因为它们是作用在<code>iostream</code>上的，而不是作用在我们自己的对象上。</li>
<li>重载的运算符的含义应该和内置类型保持一致。</li>
<li>[]，=, ()和-&gt;必须是成员函数，否则就会编译出错。</li>
</ol>
<h2 id="输出和输出运算符">输出和输出运算符</h2>
<h3 id="输出运算符">输出运算符</h3>
<p>输出运算符的第一个形参是一个非常量ostream对象的引用：向流写入内容会改变其状态，所以形参ostream是非常量，因为无法复制ostream对象所以形参ostream是引用。<br>
第二个形参一般来说是一个常量的引用：引用避免复制实参，常量意味着输出操作不会改变对象的内容。<br>
输出运算符尽量减少格式化操作。</p>
<h3 id="输入运算符">输入运算符</h3>
<p>输入运算符的第一个形参是运算符将要读取的流的引用，第二个形参是将要读入的非常量对象的引用。</p>
<h2 id="算术和关系运算符">算术和关系运算符</h2>
<p>可以把算术运算符和关系运算符定义成非成员函数，从而实现对左侧或者右侧对象的转换。</p>
<h3 id="相等运算符">相等运算符</h3>
<ol>
<li>比较对象的每一个数据成员，只有对应的成员都相等时，才认为两个对象相等。</li>
<li>一般定义了==操作，也应该定义!=操作。但是，实际上只有一个操作负责实际比较的操作，另一个运算符工作委托给他。</li>
</ol>
<h3 id="关系运算符">关系运算符</h3>
<p>operator==的结果必须和opeartor&lt;的结果一致，即==为真的话，&lt;为假；&lt;为真，==就为假。</p>
<h2 id="赋值运算符">赋值运算符</h2>
<ol>
<li>赋值运算符必须定义为成员函数。</li>
<li>复合赋值运算符不一定必须定义为类的成员。</li>
<li>普通赋值和复合赋值都返回左侧运算对象的引用。</li>
</ol>
<h2 id="下标运算符">下标运算符</h2>
<ol>
<li>下标运算符必须是成员函数。</li>
<li>下标运算符通常需要定义两个版本，一个返回普通引用，另一个是类的常量成员，返回常量引用。</li>
</ol>
<h2 id="递增和递减运算符">递增和递减运算符</h2>
<ol>
<li>自增自减运算符没有要求是成员函数，但是建议将其设定成成员函数。</li>
<li>前置版本返回递增或者递减后对象的引用。</li>
<li>重载无法区分后置和前置，后置版本接收一个额外的不被使用的int形参，进行区分。后置版本返回对象的原值，返回的是值而不是引用。</li>
</ol>
<h2 id="成员访问运算符">成员访问运算符</h2>
<ol>
<li>箭头运算必须是成员函数，而解引用不必。</li>
</ol>
<h2 id="函数调用运算符">函数调用运算符</h2>
<ol>
<li>函数调用运算符必须是成员函数。</li>
<li>一个类可以定义多个不同版本的调用运算符。</li>
<li>定义了函数调用运算符的类对象被称为函数对象，因为可以调用这种对象。</li>
</ol>
<h3 id="lambda是函数对象">lambda是函数对象</h3>
<h3 id="标准库定义的函数对象">标准库定义的函数对象</h3>
<p>标准库定义了算术，关系，逻辑类型的函数对象，它们都是模板，定义在functional头文件中：<br>
<img src="/2019/11/10/C-operator-overload/function_object.png" alt="function_object"></p>
<h3 id="可调用对象和function">可调用对象和function</h3>
<p>C++ 中的可调用对象：</p>
<ol>
<li>函数</li>
<li>函数指针</li>
<li>lambda表达式</li>
<li>bind创建的对象</li>
<li>重载了函数调用运算符的类</li>
</ol>
<p>可调用对象也有类型。比如每个lambda都有自己唯一的类型，函数和函数指针的类型由返回值类型和实参类型决定。<br>
但是不同的可调用对象类型可能共享同一种调用形式，一种调用形式对应一个函数类型。</p>
<h2 id="重载-类型转换与运算符">重载，类型转换与运算符</h2>
<p>转换构造函数和类型转换运算符共同定义了类类型转换。</p>
<h3 id="类型转换运算符">类型转换运算符</h3>
<ol>
<li>类型转换运算符是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型，它的形式如下：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">type</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>这里的type是int, double等。</p>
<ol start="2">
<li><strong>类型转换运算符没有显式的返回类型，没有形参，必须声明为类的成员函数，而且不应该改变待转换对象的的内容，因此一般定义为const成员。</strong></li>
<li>实践中很少定义类型转换运算符，因为用户会感觉很意外。</li>
<li>通过加上explict关键字，必须使用static_cast显式调用才会进行类型转换。但是，当表达式用作条件时，显式的类型转换会被隐式的执行。</li>
</ol>
<h3 id="避免类型转换运算符产生的二义性">避免类型转换运算符产生的二义性</h3>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-copy-control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-copy-control/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ copy control</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:47:18" itemprop="dateCreated datePublished" datetime="2019-11-10T12:47:18+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-06 21:51:59" itemprop="dateModified" datetime="2020-02-06T21:51:59+08:00">2020-02-06</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>除了构造函数外，一个类通过定义五种特殊的成员函数：</p>
<ol>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动赋值运算符</li>
<li>析构函数</li>
</ol>
<p>控制类对象的拷贝，移动，赋值和销毁时执行的各种动作，这些操作称为拷贝控制操作（copy control)。</p>
<h2 id="拷贝-赋值和销毁">拷贝，赋值和销毁</h2>
<p>在含有指针数据成员的类中，通常需要定义拷贝构造函数，拷贝赋值运算符和析构函数。下面介绍一些它们的主要特点，学习它们通过例子更容易。</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<ol>
<li>拷贝构造函数通常不应该是explicit的。</li>
<li>在含有指针数据成员的类中，默认的拷贝构造函数会失效。</li>
<li>拷贝初始化和直接初始化的区别。使用<code>=</code>号初始化是拷贝初始化，不使用<code>=</code>号就是直接初始化。直接初始化时，实际上是根据传入的参数调用相应的构造函数，是函数匹配。而拷贝初始化是使用拷贝构造函数将右侧的对象拷贝到正在创建的对象那个。</li>
<li>什么时候会用到拷贝构造函数：
<ul>
<li>使用<code>=</code>初始化对象时；</li>
<li>将一个对象作为实参传递给非引用的形参时</li>
<li>将一个对象作为实参传递给一个非引用类型时；</li>
<li>用花括号从列表初始化一个数组中元素或者一个聚合类的成员时；</li>
<li>某些标准容器调用<code>insert</code>或者<code>push</code>成员时。</li>
</ul>
</li>
</ol>
<h3 id="拷贝赋值函数">拷贝赋值函数</h3>
<ol>
<li>在含有指针数据成员的类中，默认的赋值运算<code>=</code>只能将指针指向被拷贝元素的数据。</li>
<li>赋值运算符通常应该返回一个指向其左侧运算对象的引用。</li>
</ol>
<h3 id="析构函数">析构函数</h3>
<ol>
<li>释放对象使用的资源，销毁对象的非static数据成员。</li>
<li>析构函数没有返回值，也不接受重载。</li>
</ol>
<h3 id="default"><code>=default</code></h3>
<p><code>=default</code>将函数定义为合成的。只能对默认构造函数或者拷贝控制函数使用<code>=default</code>，<code>=default</code>可以出现在类外定义成员函数时。</p>
<h3 id="阻止拷贝">阻止拷贝</h3>
<p>有时候某些拷贝控制函数不需要定义，比如iostream类不能拷贝，以避免多个对象写入或者读取相同的IO缓冲。可以通过将拷贝构造函数和拷贝赋值函数定义为删除的函数阻止拷贝。<br>
对于删除的函数：我们虽然声明了它们，但是不能以任何方式使用它们。在函数的参数列表之后加上<code>=delete</code>将函数定义为删除的，这会通知编译器，我们不希望定义这些成员。<code>=delete</code>必须出现在函数第一次声明的时候，而且除了析构函数之外的任何函数都可以指定<code>=delete</code>。对于析构函数来说，如果声明为<code>=delete</code>的，那么这个对象就不能被释放了。而对于除了拷贝控制和默认构造函数之外的其他函数，定义<code>=delete</code>就是多次一举了，如果你不需要，直接不定义就是了，但是实际上这种做法是合法的。<br>
**合成的拷贝控制成员可能是删除的。**如果一个类有一个数据成员不能默认构造，拷贝，复制或者销毁，则对应的成员函数被定义为删除的。比如：</p>
<ol>
<li>类的某个成员的析构函数      是删除的或不可访问的，类的合成析构函数被定义为删除的。</li>
<li>类的某个成员的拷贝构造函数  是删除的或不可访问的，类的合成拷贝构造函数也被定义为删除的。</li>
<li>类的某个成员的拷贝赋值运算符是删除的或不可访问的，类的合成拷贝赋值运算符被定义为删除的。</li>
<li>类的某个成员的析构函数是删除的或者不可访问的，类的合成析构函数，合成默认构造函数，合成拷贝构造函数也被定义为删除的。</li>
<li>类的某个成员是没有类内初始化器的引用，或者有一个没有类内初始化器的const成员，类的默认构造函数和合成拷贝赋值运算符被定义为删除的。</li>
</ol>
<h2 id="拷贝控制和资源管理">拷贝控制和资源管理</h2>
<p>通过定义拷贝操作，可以使得类的行为看起来像一个值或者像一个指针。<br>
类的行为像值，就是说拷贝一个像值的对象时，副本和原来的对象是完全独立的，改变副本不会对原来的对象有任何影响，反之亦然。<br>
类的行为像指针，就是说拷贝一个向指针的对象时，副本和原来的对象使用相同的底层数据，改变副本也会影响原来的对象，反之亦然。</p>
<h3 id="行为像值的类">行为像值的类</h3>
<ol>
<li>定义拷贝构造函数，完成对象内容的拷贝，而不是指针的拷贝。</li>
<li>定义拷贝赋值函数，需要考虑自赋值的情况。一般来说，拷贝赋值运算符组合了析构函数和拷贝构造函数的工作。</li>
<li>定义析构函数，释放对象占用的空间。</li>
</ol>
<h3 id="行为像指针的类">行为像指针的类</h3>
<p>通过引用计数来实现。</p>
<h2 id="swap函数"><code>swap</code>函数</h2>
<p>这个的目的就是交换指针而不是交换对象内容。</p>
<h2 id="对象移动">对象移动</h2>
<p>移动而不是拷贝对象，可能会大幅度提高性能。比如vector在扩容的时候，将元素从旧内存拷贝到新内存是不必要的；另一方面，IO类或者unique_ptr等类，包含不能共享的资源，这些资源不能拷贝但是可以移动。<br>
标准库容器，string和shared_ptr，即支持移动也支持拷贝。IO类和unique_ptr类可以移动但是不能拷贝。</p>
<h3 id="右值引用">右值引用</h3>
<ol>
<li>右值引用只能绑定到临时对象，所以它有两个属性：它所引用的对象将要被销毁，并且该对象没有其他用户。</li>
<li>左值引用不能绑定到要求转换的表达式，字面常量或者是返回右值的表达式。而右值引用可以绑定到上述三类表达式，但是不能将一个右值绑定到一个左值上。<br>
返回左值表达式的例子：返回左值引用的函数，赋值，下标，解引用和前置递增递减运算符。可以将一个左值引用绑定到这类表达式的结果上。<br>
返回右值表达式的例子：返回非引用类型的函数，算符，关系，位和后置递增递减运算符。不能将左值引用绑定到这类表达式上，但是可以将一个const的左值引用或者右值引用绑定到这类表达式上。</li>
<li>变量是左值。变量可以看做只有一个运算对象而没有运算符的表达式。变量表达式都是左值。</li>
<li>move函数。不能将一个右值引用直接绑定到左值上，但是可以使用utility头文件中的move函数将一个左值转换成对应的右值引用类型。</li>
</ol>
<h3 id="移动构造函数和移动赋值函数">移动构造函数和移动赋值函数</h3>
<ol>
<li>不抛出异常的移动构造函数和移动赋值运算符必须标记为noexcept。<br>
移动操作通常不抛出异常，但是抛出异常也是允许的；当异常发生时，标准库容器能够为自身的行为提供保障。比如，vector保证，调用push_back发生异常时，vector自身不会改变。所以，在调用push_back需要重新分配内存时，使用拷贝构造函数抛出异常时，会保证原来的vector不受影响，但是如果调用能够抛出异常的移动构造函数，在调用失败的时候，原来的vector会受到影响，不能保证vector自身不变。<br>
所以，只有将移动构造函数声明为noexcept时，明确说明调用移动构造函数不会抛出异常，在vector扩容重新进行内存分配的时候，才会使用拷贝构造函数。</li>
<li>合成的移动操作。如果一个类定义了自己的拷贝构造函数，拷贝赋值运算符或者析构函数，编译器就不会为它合成移动构造函数和移动赋值运算符。当一个类没有定义任何自己版本的拷贝控制函数，并且类的每个非static数据成员都可以移动时，才会合成移动构造函数或者移动赋值函数。</li>
<li>如果类定义了一个移动构造函数或者一个移动赋值运算符，类的合成拷贝构造函数和合成拷贝赋值运算符会被定义成删除的。</li>
</ol>
<h3 id="成员函数和右值引用">成员函数和右值引用</h3>
<h4 id="成员函数的参数可以是左值或右值">成员函数的参数可以是左值或右值</h4>
<p>除了构造函数和赋值运算符之外，一个成员函数也可以同时提供拷贝和移动版本：一个版本接收一个指向const的左值引用，一个版本接收一个指向非const的右值引用。</p>
<h4 id="左值或者右值调用成员函数">左值或者右值调用成员函数</h4>
<ol>
<li>C++ 可以对右值进行赋值。C++ 11中可以阻止这种用法，通过<strong>引用限定符</strong>强制左侧运算对象是一个左值。</li>
<li>在参数列表后放置一个引用修饰符，&amp;或者&amp;&amp;，分别指出this可以指向一个左值或者右值。</li>
<li>类似const限定符，引用限定符只能用于非static的成员函数，并且需要同时出现在声明和定义中。</li>
<li>对于&amp;修饰的函数，只能将它用于左值，对于&amp;&amp;修饰的函数，只能将它用于右值。</li>
<li>一个函数既可以用const也可以用引用限定，当它们同时出现时，引用限定符必须跟随在const限定符之后。</li>
<li>引用限定符可以区分重载函数。当出现两个或者两个以上具有相同名字或者参数列表的函数时，必须同时有引用修饰符或者同时没有。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-dyncamic-memory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-dyncamic-memory/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ dyncamic memory</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:39:41" itemprop="dateCreated datePublished" datetime="2019-11-10T12:39:41+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-21 23:54:22" itemprop="dateModified" datetime="2020-02-21T23:54:22+08:00">2020-02-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>每一个C程序都把内存划分成静态内存，栈内存，堆内存（自由空间）。静态内存存放局部static对象，类的static数据成员以及定义在任何函数之外的变量。栈存放函数内的非static对象。堆内存是由程序员自己负责管理（申请和释放）的内存。</p>
<h2 id="动态内存和智能指针">动态内存和智能指针</h2>
<p>C++ 中动态内存的管理是通过一对运算符<code>new</code>和<code>delete</code>实现的。<code>new</code>在动态内存中为对象分配空间，并且返回一个指向该对象的指针，可以选择对对象进行初始化；<code>delete</code>接收一个动态对象的指针，销毁该对象，释放和它相关的内存。</p>
<p>动态内存很难管理，有时候忘记释放内存，会产生内存泄露；有时候在有指针引用内存的情况下就释放了它，这种情况下产生非法引用的内存。<br>
C++ 提供了两种智能指针，<code>shared_ptr</code>和<code>unique_ptr</code>管理动态对象。智能指针也是模板。因此，在创建智能指针的时候，需要提供类型信息。<br>
<code>shared_ptr</code>允许多个指针指向一个对象，而<code>unique_ptr</code>则独占所指向的对象。<br>
下面是<code>shared_ptr</code>和<code>unique_ptr</code>都支持的一些操作：<br>
<img src="/2019/11/10/C-dyncamic-memory/smart_pointer.png" alt="smart_pointer"></p>
<h2 id="shared-ptr"><code>shared_ptr</code></h2>
<p><img src="/2019/11/10/C-dyncamic-memory/shared_pointer.png" alt="shared_ptr"></p>
<ol>
<li><code>shared_ptr</code>的声明和创建</li>
<li><code>make_shared</code>创建一个指针。</li>
<li><code>shared_ptr</code>的拷贝和赋值，引用计数。修改引用计数的几种情况：
<ul>
<li>拷贝一个<code>shared_ptr</code>，比如用一个<code>shared_ptr</code>初始化另一个，值传参，返回值等情况，引用计数增加。</li>
<li>给<code>shared_ptr</code>赋一个新值，引用计数减少。</li>
<li>shared_ptr被销毁时，引用计数减少。</li>
</ul>
</li>
<li>通过析构函数自动销毁它管理的对象。</li>
</ol>
<h2 id="new"><code>new</code></h2>
<h3 id="初始化">初始化</h3>
<ol>
<li>默认初始化。<code>new</code>后面加类型，没有小括号，也没有花括号。<br>
默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。这意味着内置类型或组合类型的对象的值是无定义的，而类类型对象将用默认构造函数进行初始化。</li>
<li>值初始化。类型名字后加()即可，对于内置类型的变量，初始化为0，对于类类型的变量，调用默认构造函数。</li>
<li>直接初始化。使用初始化列表加对象值，或者小括号加对象值。</li>
</ol>
<p>对于自定义类型而言，只要一调用new，无论后面有没有加()，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化。</p>
<p>还有auto初始化器。</p>
<h3 id="内存耗尽">内存耗尽</h3>
<p>使用placement new（定位new），当内存耗尽时，防止new抛出bad_alloc异常。</p>
<h2 id="shared-ptr和new"><code>shared_ptr</code>和<code>new</code></h2>
<ol>
<li>定义和改变shared_ptr的其他方法，shared_ptr对象还有其他几个构造函数，分别接收内置指针，unique_ptr，以及内置指针和内置指针的删除器，shared_ptr对象和它的删除器这几类参数。<strong>接收内置指针参数的shared_ptr的构造函数是explict的，也就是必须显式调用构造函数，不能使用隐式转换将一个内置指针转换成shared_ptr。</strong></li>
<li><strong>当把一个shared_ptr指针绑定到一个普通指针时，接下来不应该再使用内置指针访问这部分内存了。</strong></li>
<li><strong>也不要使用shared_ptr的get()函数返回的指针初始化另一个智能指针或者为智能指针赋值。同时也不能使用delete删除get()返回的指针，否则会发生二次delete。</strong></li>
<li>p.reset()函数可以用来重置指针p，如果p是指向shared_ptr的唯一对象，会将p原本指向的对象释放；如果没有传入参数，p置为空；如果传入了参数q，让p指向q；还可以传递一个d，表示调用d而不是delete释放q。</li>
<li>copy on write可以通过shared_ptr实现？？？使用unique()函数检测是否自己是当前的shared_ptr的唯一用户，不是的话，调用reset()函数拷贝一个新的。</li>
</ol>
<h2 id="智能指针和异常">智能指针和异常</h2>
<h3 id="智能指针和哑类">智能指针和哑类</h3>
<h3 id="使用自己的释放操作">使用自己的释放操作</h3>
<p>shared_ptr假设它们指向的内容是动态内存，当它被销毁时，调用delete。我们可以自己定义一个删除器，取代delete的调用。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    disconnect(*p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = connect(&amp;d);</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;connection&gt; p(&amp;c, end_connection);</span><br><span class="line">    <span class="comment">// 创建一个connection类型的智能指针，构造函数的参数是一个内置的指针类型和一个调用函数。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="unique-ptr"><code>unique_ptr</code></h2>
<p><img src="/2019/11/10/C-dyncamic-memory/unique_pointer.png" alt="unique_ptr"></p>
<h2 id="weak-ptr"><code>weak_ptr</code></h2>
<p><code>weak_ptr</code>不控制指向对象的生存周期，它指向一个shared_ptr管理的对象，将一个weak_ptr绑定到shared_ptr不增加引用计数。<br>
<img src="/2019/11/10/C-dyncamic-memory/weak_ptr.png" alt="weak_ptr"></p>
<h2 id="new和数组"><code>new</code>和数组</h2>
<h3 id="初始化-v2">初始化</h3>
<ol>
<li><code>new int[]</code>，默认初始化。</li>
<li><code>new int[]()</code>，值初始化。但是不能在括号中给出初始化器，也就是不能用auto分配数组。</li>
<li><code>new int[10]{1, 2, 3}</code>，列表初始化。</li>
</ol>
<h3 id="动态分配空数组">动态分配空数组</h3>
<p>动态分配一个空数组是允许的，但是不能解引用。<br>
而定义一个长度为0的数组是不允许的。</p>
<h3 id="智能指针和动态数组">智能指针和动态数组</h3>
<p><code>unique_ptr</code>有一个可以管理new分配的数组的版本。而shared_ptr没有相应的版本，如果想要使用<code>shared_ptr</code>管理数组，需要提供自己定义的删除器。</p>
<h2 id="allocate类">allocate类</h2>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-STL-associative-container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-STL-associative-container/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ STL associative container</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:38:19" itemprop="dateCreated datePublished" datetime="2019-11-10T12:38:19+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-10 14:07:57" itemprop="dateModified" datetime="2020-01-10T14:07:57+08:00">2020-01-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="c-标准程序库中的关联容器">C++标准程序库中的关联容器</h2>
<h3 id="有序关联容器">有序关联容器</h3>
<p><code>map</code>, <code>multimap</code>, <code>set</code>, <code>multiset</code>的底层实现是红黑树。</p>
<h3 id="无序关联容器">无序关联容器</h3>
<p><code>unordered_set</code>, <code>unordered_multiset</code>, <code>unordered_map</code>, <code>unordered_multimap</code>的底层实现哈希。</p>
<h2 id="pair"><code>pair</code></h2>
<p><code>pair</code>是一种标准库类型，定义在头文件<code>utility</code>中，一个<code>pair</code>保存两个数据成员，是一个生成特定类型的模板。创建一个pair时，需要提供两个类型名（可以相同，也可以不同）。<br>
<strong>pair的数据成员是public的，两个成员的名字分别为<code>first</code>和<code>second</code></strong>。pair支持的操作如下表。<br>
<img src="/2019/11/10/C-STL-associative-container/pair.png" alt="pair"></p>
<h2 id="关联容器的定义">关联容器的定义</h2>
<h2 id="关联容器的类型">关联容器的类型</h2>
<p>除了所有容器都有的类型之外，关联容器还有一些特有的类型：</p>
<ul>
<li><code>key_type</code>，关键字的类型。</li>
<li><code>mapped_type</code>，每个关键字关联的类型，只有map有。</li>
<li><code>value_type</code>，对于<code>set</code>，和<code>key_type</code>相同，对于<code>map</code>，和<code>pair&lt;key_type, mapped_type&gt;</code>相同。</li>
</ul>
<h2 id="添加元素-增">添加元素（增）</h2>
<p>可以使用以下几个函数进行插入操作：</p>
<ul>
<li><code>c.insert(v)</code></li>
<li><code>c.emplace(args)</code></li>
<li><code>c.insert(b, e)</code></li>
<li><code>c.insert(il)</code></li>
<li><code>c.insert(p, v)</code></li>
<li><code>c.emplace(p, args)</code></li>
</ul>
<p>对map和set进行insert时，insert的返回值是一个pair，pair的第一个元素是迭代器，第二个元素是个bool类型，之处是否插入成功。<br>
而对multimap和multiset进行insert时，insert不需要返回bool值，因为插入总是成功的。</p>
<h2 id="删除元素-删">删除元素（删）</h2>
<ul>
<li><code>c.erase(p)</code>，删除迭代器p指定的元素。</li>
<li><code>c.erase(k)</code>，删除key为k的元素，返回值为删除的元素的数量。</li>
<li><code>c.erase(b, e)</code></li>
</ul>
<h2 id="下标操作">下标操作</h2>
<ul>
<li><code>c[k]</code>，返回关键字为k的元素。如果k不在c中，添加一个关键字为k的元素，进行值初始化。</li>
<li><code>c.at(k)</code>，访问关键字为k的元素，进行参数检查，如果k不在c中，抛出一个out_of_range异常。</li>
</ul>
<h2 id="查找操作-查">查找操作（查）</h2>
<ul>
<li><code>c.find(k)</code>，</li>
<li><code>c.count(k)</code>，</li>
<li><code>c.lower_bound(k)</code>，不适用于无序容器，</li>
<li><code>c.upper_bound(k)</code>，不适用于无序容器，</li>
<li><code>c.equal_range(k)</code></li>
</ul>
<h2 id="关联容器的无序版本">关联容器的无序版本</h2>
<h3 id="bucket的管理">bucket的管理</h3>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-STL-sequential-container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-STL-sequential-container/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ STL sequential container</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:37:41" itemprop="dateCreated datePublished" datetime="2019-11-10T12:37:41+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-09 16:33:09" itemprop="dateModified" datetime="2020-01-09T16:33:09+08:00">2020-01-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="c-标准库中的顺序容器">C++标准库中的顺序容器</h2>
<h3 id="vector"><code>vector</code></h3>
<ul>
<li>内部数据结构为数组，可以自动增长</li>
<li>在后端插入和删除，push_back()和pop_back()，时间复杂度为$O(1)$</li>
<li>在中间和前段插入和删除，insert()和erase()，时间和空间复杂度是$O(n)$</li>
<li>分配连续内存，</li>
<li>支持随机数组存取，查找的时间复杂度$O(1)$</li>
<li>支持[]访问</li>
<li>头文件vector</li>
</ul>
<h3 id="list"><code>list</code></h3>
<ul>
<li>内部数据结构为双向环状链表</li>
<li>任意位置插入和删除的时间复杂度是$O(1)$</li>
<li>链式存储，非连续内存</li>
<li>不支持随机存取，查找的时间复杂度是$O(n)$</li>
<li>不支持[]访问</li>
<li>头文件list</li>
</ul>
<h3 id="forward-list"><code>forward_list</code></h3>
<h3 id="deque"><code>deque</code></h3>
<ul>
<li>vector和deque的结合，使用若干个内存片段进行链接。兼有vector和list的好处。</li>
<li>内部数据结构为数组</li>
<li>头文件deque</li>
</ul>
<h3 id="array"><code>array</code></h3>
<p>大小固定的容器，还需要指定元素类型。</p>
<h2 id="顺序容器的操作">顺序容器的操作</h2>
<h3 id="添加元素-增">添加元素（增）</h3>
<p>容器添加元素使用的是拷贝一份元素的值到容器中（非引用传参）。</p>
<ul>
<li><code>c.push_back(t)</code>在容器尾部插入。除了<code>array</code>和<code>forward_list</code>，每个顺序容器和<code>string</code>都支持。</li>
<li><code>c.push_front(t)</code>在容器头部插入。<code>list</code>, <code>forwrad_list</code>和<code>deque</code>支持。</li>
<li><code>c.insert(p, t)</code>在任意位置插入。<code>vector</code>, <code>list</code>, <code>deque</code>, <code>string</code>都支持<code>insert</code>，<code>forward_list</code>有特殊的<code>insert</code>。将元素插入到<code>vector</code>,<code>deque</code>,<code>string</code>的任何位置都是合法的，但是非常耗时。<br>
<code>insert</code>有多个版本，还可以直接插入一个范围。<br>
如果通过一个迭代器指定插入位置，插入的元素会放在这个迭代器之前，<code>insert</code>的返回值是第一个新加入元素的迭代器，如果没有插入任何元素，返回第一个参数。</li>
<li><code>c.emplace(p, args)</code>是直接构造而不是拷贝元素。<code>emplace</code>，<code>emplace_front</code>，<code>emplace_back</code>分别对应<code>insert</code>, <code>push_front</code>和<code>push_back</code>。</li>
</ul>
<h3 id="删除元素-删">删除元素（删）</h3>
<ul>
<li><code>c.pop_back()</code>，<code>forward_list</code>不支持。</li>
<li><code>c.pop_front()</code>，<code>vector</code>和<code>string</code>不支持。</li>
<li><code>c.erase(p)</code>，删除迭代器p指定的内容。</li>
<li><code>c.erase(b, e)</code>，删除迭代器b和e指定的范围。</li>
<li><code>c.clear()</code>，删除容器中的所有元素。</li>
</ul>
<h3 id="访问元素-改和查">访问元素（改和查）</h3>
<p>下面的四个操作返回的都是引用。</p>
<ul>
<li><code>c.front()</code>，返回begin对应的元素。</li>
<li><code>c.back()</code>，返回end之前的元素，<code>forward_list</code>没有。</li>
<li><code>c[n]</code>，如果<code>n&gt;c.size()</code>，无定义，只适用于<code>string</code>, <code>vector</code>, <code>deque</code>, <code>array</code>。</li>
<li><code>c.at(n)</code>，如果下标越界，抛出out of range异常，只适用于<code>string</code>, <code>vector</code>, <code>deque</code>, <code>array</code>。</li>
</ul>
<h3 id="forward-list的操作"><code>forward_list</code>的操作</h3>
<p><code>forward_list</code>提供了<code>insert_after</code>, <code>emplace_after</code>和<code>erase_after</code>。</p>
<h3 id="改变容器大小">改变容器大小</h3>
<p>将容器大小调整为n，n小于c.size()，将超过的舍去；n大于c.size()，使用值初始化或者指定一个元素t。</p>
<ul>
<li><code>c.resize(n)</code>，</li>
<li><code>c.resize(n, t)</code></li>
</ul>
<h3 id="迭代器失效">迭代器失效</h3>
<ol>
<li>容器添加元素之后</li>
<li>从一个容器中删除元素之后</li>
</ol>
<h2 id="vector的增长"><code>vector</code>的增长</h2>
<p>不同的实现中，vector的增长速度也不同，有的是2，有的是1.多。可以使用<code>c.capaticy</code>查看vector的容量。capacity和size的区别在于，size指的是它已经保存的元素的数目，而capacity是在不分配新的内存空间的前提下最多可以保存多少元素。</p>
<h2 id="容器适配器">容器适配器</h2>
<p>适配器接收一种已有的容器类型，让它的行为看起来像另一种不同的类型。标准库中定义了下面三个适配器：</p>
<ul>
<li><code>stack</code></li>
<li><code>queue</code></li>
<li><code>priority_queue</code></li>
</ul>
<p>每个适配器都有两个构造函数：</p>
<ul>
<li>默认构造函数创建一个空对象</li>
<li>一个构造函数接收容器参数，拷贝该容器初始化适配器。</li>
</ul>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-STL-container/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-STL-container/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ STL container</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:34:56" itemprop="dateCreated datePublished" datetime="2019-11-10T12:34:56+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-24 14:55:19" itemprop="dateModified" datetime="2019-12-24T14:55:19+08:00">2019-12-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是容器">什么是容器</h2>
<p>一个<strong>容器</strong>就是一些特定类型对象的集合。C++标准库中提供了两类容器，一类是顺序容器，一类是关联容器。<br>
关联容器和顺序容器有着根本上的不同：<br>
关联容器的元素是按照关键字保存和访问的；而顺序容器是按照他们在容器中的位置顺序保存和访问的，这种顺序不依赖于元素的值，而跟元素加入容器时的位置相对应。关联容器中的许多行为和顺序容器相同，但是他们的不同之处反映了关键字的作用。顺序容器和关联容器共享公共的接口，不同容器可以按照不同的方式对其进行扩展，这个公共接口使得容器学习起来更容器，基于某个容器学习的内容可以扩展到其他容器上。<br>
关联容器支持高效的关键字查找和访问，两个主要的关联容器是<code>map</code>和<code>set</code>，<code>map</code>中的元素是一些关键字－值(key-value)对，关键字索引，而值表示和索引相关的数据。而<code>set</code>中的每个元素只有一个关键字。</p>
<h2 id="顺序容器概述">顺序容器概述</h2>
<p>关于顺序容器更详细的内容可以查看<a href="https://mxxhcm.github.io/2019/11/10/C-sequential-container/">C++ sequential container</a>。</p>
<h3 id="顺序容器种类">顺序容器种类</h3>
<p>所有C++标准库中的顺序容器包括：</p>
<ul>
<li>vector: 可变大小数组，</li>
<li>list：双向链表，</li>
<li>forward_list：单向链表，</li>
<li>deque：双端队列</li>
<li>array：固定大小数组</li>
<li>string：与vector类似，但是专门用于字符操作，</li>
</ul>
<h3 id="定义顺序容器">定义顺序容器</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;forward_list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">array</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">list</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::forward_list;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">deque</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">string</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">array</span>&lt;<span class="built_in">string</span>, 1000&gt; c1;</span><br><span class="line">vecotr&lt;<span class="built_in">string</span>&gt; c2;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; c3;</span><br><span class="line">forward_list&lt;<span class="built_in">string</span>&gt; c4;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="built_in">string</span>&gt; c5;</span><br></pre></td></tr></table></figure>
<h3 id="存取时间复杂度和存储策略">存取时间复杂度和存储策略</h3>
<p>所有的顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在随机访问或者增删元素上的能力上做了不同的性能折中：</p>
<ul>
<li><code>string和</code>vector<code>：支持$O(1)$时间的随机访问；尾部增删是$O(1)$，在尾部之外的位置插入或者删除可能很慢$O(n)$。</code>string<code>和</code>vector`都存储在连续的的内存空间中，在中间增删需要移动增删位置之后所有的元素；在任何位置添加一个元素时，如果当前的存储空间不够，还需要分配新的存储空间，需要将所有的元素都移动到新的存储空间去。</li>
<li><code>list</code>和<code>forward_list</code>：<code>list</code>是双向链表，<code>forward_list</code>是单向链表，它们都不支持随机访问，在寻找某一个元素时，只能以$O(n)$的时间复杂度遍历整个链表，<code>list</code>支持双向顺序访问$O(n)$，<code>forward_list</code>只支持单向顺序访问$O(n)$；它们在任何位置插入或者删除的时间复杂度都是$O(1)$。<br>
和<code>vector</code>,<code>deque</code>,<code>array</code>相比，链表需要存放指针记录前(后)节点的信息。此外<code>forward_list</code>没有<code>size()</code>和<code>back()</code>成员，因为<code>forward_list</code>的设计目标是和手写的单向链表性能相似，<code>size</code>操作会增大计算开销，对于其他容器而言，<code>size</code>是一个$O(1)$的操作。</li>
<li><code>deque</code>：<code>deque</code>支持$O(1)$时间的随机访问；在中间位置增删都是$O(n)$的开销，但是在<code>deque</code>两端增删是$O(1)$的事件开销。</li>
<li><code>array</code>：$O(1)$时间复杂度的随机访问；不支持增删操作。<code>array</code>和内置数组一样，大小固定，不支持增删，但是更安全。</li>
</ul>
<h3 id="顺序容器的选择">顺序容器的选择</h3>
<ol>
<li>通常使用<code>vector</code>是最好的选择，除非有更好的理由。</li>
<li>程序有很多小的元素，而且空间额外开销很重要，不要用<code>list</code>或者<code>forward_list</code>。</li>
<li>要求支持随机访问元素，使用<code>vector</code>或者<code>deque</code>。</li>
<li>在容器中间插入或者删除，使用<code>list</code>或者<code>forward_list</code>。</li>
<li>程序需要在容器头尾增删，而不会在中间增删，使用<code>deque</code>。</li>
<li>如果即需要随机存取，又需要在容器中间增删，这个时候根据存取和增删的操作数量进行选择，哪种操作占据主导地位，就使用相对应的容器。</li>
<li>如果不确定到底应该使用<code>vector</code>还是<code>list</code>，那么就只使用它们都支持的操作，不使用下标运算，使用迭代器，避免随机访问。</li>
</ol>
<h2 id="关联容器概述">关联容器概述</h2>
<p>关于关联容器更详细的内容可以查看<a href="https://mxxhcm.github.io/2019/11/10/C-associative-container/">C++ associative container</a>。<br>
标准库共有8个关联容器，他们在三个维度上有差异</p>
<ol>
<li><code>set</code>还是<code>map</code>，map存放key-value，set只存放key，或者说key=value。</li>
<li>关键字是否可以重复，是否容器名字中包含multi</li>
<li>元素顺序无序还是有序，容器名字是否包含unordered</li>
</ol>
<h3 id="关联容器种类">关联容器种类</h3>
<p>具体如下：</p>
<ul>
<li><code>map</code>，关联数组，保存key-value</li>
<li><code>set</code>，只保存key，或者说key=value</li>
<li><code>unordered_map</code>，无序<code>map</code>，底层用hash实现</li>
<li><code>unordered_set</code>，无序<code>set</code>，底层用hash实现</li>
<li><code>multimap</code>，key可以重复出现的<code>map</code></li>
<li><code>multiset</code>，key字可以重复出现的<code>set</code></li>
<li><code>unordered_multimap</code>，key可以重复出现的无序<code>map</code>，底层用hash实现</li>
<li><code>unordered_multiset</code>，key可以重复出现的无序<code>set</code>，底层用hash实现</li>
</ul>
<p>关联容器不支持顺序容器和位置相关的操作，如<code>push_back</code>，<code>push_front</code>等，因为关联容器中元素是根据关键字存储的，这些操作对关联容器没有意义。此外，关联容器也不支持接收一个元素值和一个数量值的插入操作和构造函数。<br>
不过关联容器支持一些顺序容器不支持的操作。关联容器的迭代器都是双向的。</p>
<h3 id="定义关联容器">定义关联容器</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">multiset</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">multimap</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">unordered_set</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">unordered_map</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">unordered_multiset</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">unordered_multimap</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; c1;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt; c2;</span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="built_in">string</span>&gt; c3;</span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt; c4;</span><br><span class="line"></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; c5;</span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt; c6;</span><br><span class="line"><span class="built_in">unordered_multiset</span>&lt;<span class="built_in">string</span>&gt; c7;</span><br><span class="line"><span class="built_in">unordered_multimap</span>&lt;<span class="keyword">long</span>, <span class="built_in">string</span>&gt; c8;</span><br></pre></td></tr></table></figure>
<h2 id="顺序容器和关联容器的公共操作">顺序容器和关联容器的公共操作</h2>
<ol>
<li>
<p>每一个容器都定义在一个头文件中，文件名和类型相同（除了multiset和multimap以及unordered_multiset, unordered_multimap。</p>
</li>
<li>
<p><strong>容器类型成员</strong>。每个容器都定义了多个类型：</p>
<ul>
<li><code>iterator</code>，容器的迭代器类型</li>
<li><code>const_iterator</code>，无法修改元素的迭代器类型</li>
<li><code>reverse_iterator</code>，反向迭代器</li>
<li><code>const_reverse_iterator</code>，不能修改元素的反向迭代器</li>
<li><code>size_type</code>，无符号整数，足够保存容器的最大大小。</li>
<li><code>difference_type</code>，有符号整数，足够保存两个迭代器之间的距离</li>
<li><code>value_type</code>，元素类型</li>
<li><code>reference</code>，元素的左值类型</li>
<li><code>const_reference</code>，元素的<code>const</code>左值类型。</li>
</ul>
</li>
<li>
<p><strong>迭代器和迭代器范围。<strong>所有容器都支持迭代器，通过解引用迭代器访问容器中的元素。一个</strong>迭代器范围</strong>由一对迭代器构成，两个迭代器分别指向同一个容器中的元素或者是尾元素之后的位置，通常一个被称为begin，一个被称为end。如何获取迭代器：</p>
<ul>
<li><code>c.begin()</code>和<code>c.end()</code>，返回指向c的首元素和尾后元素的迭代器</li>
<li><code>c.rbegin()</code>和<code>c.rend()</code>，返回指向c的尾元素和首元素之前的反向迭代器</li>
<li><code>c.cbegin()</code>和<code>c.cend()</code>，返回指向c的首元素和尾后元素的const_iterator</li>
<li><code>c.crbegin()</code>和<code>c.crend()</code>，返回指向c的尾元素和首元素之前的const_reverse_iterator</li>
</ul>
<p>当<code>auto</code>和<code>begin</code>，<code>end</code>结合使用时，获得的迭代器类型依赖于容器的类型。只有当容器本身是const时，才能够得到<code>const_iterator</code>。<br>
而<code>auto</code>和<code>cbegin</code>和<code>cend</code>使用时，获得的迭代器类型和容器类型无关，一直都是<code>const_iterator</code>。<br>
关于迭代器的具体内容可以查看<a href></a>。</p>
</li>
<li>
<p><strong>容器定义和初始化。</strong></p>
<ul>
<li><code>C c;</code>，默认构造</li>
<li><code>C c1(c2);</code>或者<code>C c1=c2;</code>，拷贝构造，直接拷贝容器</li>
<li><code>C c(b, e);</code>，拷贝构造，通过迭代器范围进行拷贝，将迭代器b和e指定范围的元素拷贝到c，不适用于array。这种方式不要求容器类型相同，只要能将要拷贝的对象转化为要初始化的容器的元素类型即可。</li>
<li><code>C c{a, b, c...};</code>或者<code>C c={a, b, c...}</code>，列表初始化c，元素类型必须相同，同时显式的指定了容器的大小</li>
</ul>
<p>只有顺序容器（除了<code>array</code>）的构造函数才能接收大小参数。</p>
<ul>
<li><code>C seq(n);</code>，进行值初始化，不适用于<code>string</code></li>
<li><code>C seq(n, t);</code>，seq是包含n个初始值为t的元素</li>
</ul>
<p>总结一下：</p>
<ol>
<li>将一个容器初始化为另一个容器的拷贝时，两个容器的容器类型和元素类型必须相同</li>
<li>使用迭代器拷贝构造容器时，不需要容器类型和元素类型相同，只需要待拷贝对象能够转换成要初始化的元素对象即可。</li>
<li>对于顺序容器（除了array）来说，它还有另一个构造函数，它的参数是容器大小和一个可选的元素初始值。如果不提供元素初始值，标准库会创建一个值初始化器，内置类型，如int，取0，<code>string</code>等类类型，由类进行默认初始化。即当如果元素是内置类型，或者具有默认构造函数的类类型，那么可以只提供一个容器大小参数。如果没有默认构造函数，就必须指定显式的元素初始值。</li>
<li>标准库<code>array</code>具有固定大小，定义<code>array</code>时，除了指定元素类型，还要指定元素个数。一个默认构造的<code>array</code>是非空的，这些元素都被默认初始化。如果进行列表初始化，初始值如果小于<code>array</code>大小，剩余的元素执行值初始化。对于类类型来说，不论是默认初始化还是值初始化，都需要类有一个默认构造函数。</li>
</ol>
</li>
<li>
<p><strong>赋值, <code>assign</code>和<code>swap</code></strong>。</p>
<ul>
<li><code>c1 = c2</code>，将c1的元素用c2的元素替换，c1和c2类型必须相同</li>
<li><code>c1 = {a, b, c, ...}</code>，将c1中的元素替换为列表中元素，不适用于array</li>
<li><code>a.swap(b)</code>，交换a和b的元素</li>
<li><code>swap(a,b)</code>，和<code>a.swap(b)</code>相同。</li>
</ul>
<p>还有不适用于关联容器和<code>array</code>的<code>assign</code>操作，</p>
<ul>
<li><code>seq.assign(b, e);</code>，将seq中元素替换为迭代器b和e中的元素，迭代器b和e不能指向seq中的元素</li>
<li><code>seq.addign(il);</code>，将seq中的元素替换成初始化列表il中的元素</li>
<li><code>seq.assign(n, t);</code>，将deq中的元素替换成n个值为t的元素</li>
</ul>
<ol>
<li>赋值号左右两边的运算对象必须具有相同的类型，而assign不需要两个容器的类型相同，只需要元素类型相容即可。<code>array</code>允许直接赋值<code>array</code>，但是不支持<code>assign</code>操作，也不允许用花括号包围的值列表进行赋值，因为右面运算对象的大小可能和左面运算对象的大小不同（见C++ primer第五版302页），而<code>array</code>的大小是不可变的。</li>
<li>赋值操作会让指向左边容器内部的迭代器，引用和指针失效。而swap交换容器内容不会使得指向容器的迭代器，指针和引用失效（容器类型为array和string除外）。</li>
<li>swap交换<code>array</code>时，两个<code>array</code>的大小必须相同，类型相同。<code>swap</code>交换两个<code>array</code>会真正交换两个<code>array</code>的元素。</li>
<li>swap交换除了<code>string</code>之外的容器时，指向容器的迭代器，引用和指针都不会失效，即访问的还是未交换之前的对象，但是这些对象所属的容器变了。</li>
</ol>
</li>
<li>
<p><strong>大小。</strong></p>
<ul>
<li><code>size()</code>，容器当前容纳的元素个数，不支持<code>forward_list</code></li>
<li><code>max_size()</code>，容器所能容纳的最大元素个数</li>
<li><code>empty()</code>，容器是否为空</li>
</ul>
</li>
<li>
<p><strong>关系运算符。</strong></p>
<ol>
<li><code>==</code>和<code>!=</code>，所有的容器都支持的运算符。</li>
<li><code>&lt;=</code>,<code>&lt;</code>,<code>&gt;=</code>, <code>&gt;</code>，关系运算符（无序关联容器不支持），关系运算符两侧的容器类型必须一样，容器类的元素类型也必须一样。</li>
<li>容器的相等运算实际上是使用的元素的<code>==</code>运算实现的，而容器的关系运算实际上是使用元素的<code>&lt;</code>运算实现的。对于类类型来说，必须对相应的操作符重载，才能进行相应的关系运算，否则就无法进行。</li>
<li>两个容器比较大小的规则：<br>
两个容器大小相等，对应元素相等，这两个容器相等。<br>
两个容器大小不同，但是较小元素中每个元素都等于较大容器中的对应元素，较小容器小于较大容器。<br>
如果两个容器都不是另一个容器的前缀子序列，则他们的结果取决于第一个不相等的元素的比较结果。</li>
</ol>
</li>
<li>
<p>**增删元素（不适用于<code>array</code>）。**注意，在不同的容器中，操作的接口都不同</p>
<ul>
<li>c.insert(args)，将args中的元素拷贝进c</li>
<li>c.emplace(inits)，使用inits构造c中的一个元素</li>
<li>c.erase(args)，删除args指定的元素</li>
<li>c.clear()，删除c中所有元素，返回void</li>
</ul>
</li>
<li>
<p>顺序容器几乎可以保存任意类型的元素，但是某些容器对于元素类型有特殊的要求，我们可以为不支持特定操作的类型定义容器，但是使用只用那些没有特殊要求的容器操作了。<br>
顺序容器构造函数的一个版本接受容器大小参数，它使用元素类型的默认构造函数，但是有些类没有默认构造函数，这时候我们可以定义这种类型的容器，但是需要传入一个元素的初始化器。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;noDefault&gt; v1(<span class="number">10</span>, init); <span class="comment">//正确，</span></span><br><span class="line"><span class="built_in">vector</span>&lt;noDefault&gt; v2(<span class="number">10</span>);   <span class="comment">//错误，因为没有默认构造函数</span></span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/10/C-class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/10/C-class/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/10/index.html">C++ customed type class</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 12:31:11" itemprop="dateCreated datePublished" datetime="2019-11-10T12:31:11+08:00">2019-11-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-04 12:51:10" itemprop="dateModified" datetime="2020-02-04T12:51:10+08:00">2020-02-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概念">概念</h2>
<ol>
<li><strong>数据抽象和封装</strong>。类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。<strong>数据抽象</strong>是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作，类的实现则包括类的数据成员，负责接口实现的函数以及定义类所需要的各种私有函数。<strong>封装</strong>实现了类的接口和实现的分离，封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。</li>
<li>**成员函数是定义为类的一部分的函数,有时候也被称为方法。使用.运算符后跟要使用的成员函数,同时使用调用运算符<code>()</code>来访问一个函数。**<strong>成员函数</strong>的声明必须在类的内部，成员函数的定义既可以在类的内部也可以在类的外部。<strong>定义在类内部的的函数是隐式的内联函数</strong>。而作为接口部分的非成员函数，如<code>add</code>,<code>print</code>,<code>read</code>等都必须在类的外部。</li>
<li><strong>友元的声明只是指定了访问权限(可以访问类的私有成员,和第四条不冲突),而并非一个普通的函数声明,如果希望类的用户能够调用某个友元函数,必须在友元声明之外再次对函数进行一次声明.</strong></li>
<li>封装的好处
<ul>
<li>确保用户代码不会无意间破坏对象的状态,防止因为引入的原因造成数据被破坏,如果有程序缺陷破坏了对象的数据成员的状态,那么只有实现部分的代码可能产生这样的错误.降低了代码维护和错误修正的难度</li>
<li>被封装的类的具体实现细节可以随时改变,无序调整用于级别的代码.类的作者可以比较自由的修改数据.当实现部分改变时,只要类的接口不变,用户代码就不需要改变.如果数据是<code>public</code>的,所有使用了原来数据成员的代码都可能失效,需要先定位并重写这部分代码.<strong>注意当类的实现发生改变时无序更改用户代码,但是使用了该类的源文件必须重新编译.</strong></li>
</ul>
</li>
<li><strong>构造函数</strong>。类通过一个或几个特殊的成员函数控制其对象的初始化过程，这些函数叫做构造函数。</li>
<li>构造函数不能声明为const类型。在创建一个<code>const</code>对象时，直到构造函数完成初始化，对象才算真正取得了<code>const</code>属性。</li>
</ol>
<h2 id="类">类</h2>
<p>类的基本思想是数据抽象和封装。数据抽象是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作，类的实现则包括类的数据成员，负责接口实现的函数以及定义类所需要的各种私有函数。<br>
封装实现了类的接口和实现的分离，封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。</p>
<p>类想要实现数据抽象和封装，需要首先定义一个抽象数据类型，在抽象数据类型中，类的设计者负责考虑类的实现过程；使用该类的程序员只需要抽象的思考类型做了什么，不需要了解细节．</p>
<p>**类是基于对象的，类之间的关系（继承，组合，委托）是面向对象的。**C++ 是由C<ins>语言和C</ins> 标准库组成。</p>
<h2 id="类的定义">类的定义</h2>
<p>每个类都定义了一个唯一的类型。即使两个类的成员列表完全一致，它们也是不同的类型。对一个类来说，它的成员和其他任何类的对象都不是一回事。<br>
仅仅声明类而暂时不定义它，这种声明有时候也叫<strong>前向声明</strong>。在类声明之后定义之前，它属于不完全类型。我们知道它是一个类，但是不清楚它到底包含哪些类型。</p>
<p>类的组成包括成员函数，就是定义在类内部的函数；数据成员变量，定义在类内的数据变量；类的类型成员，就是<code>typedef</code>重命名的类型；访问控制等。</p>
<h2 id="访问控制和封装">访问控制和封装</h2>
<h3 id="访问说明符">访问说明符</h3>
<p>访问说明符用于加强类的封装性,让用户不能直接访问对象的内部。</p>
<ul>
<li><code>public</code>, 定义在public说明符后的成员在整个程序内可以被访问,public定义类的接口,向类的用户提供访问数据成员的功能。</li>
<li><code>private</code>,定义在private说明符后的成员可以被类的成员函数访问,但是不能被该类的独享访问,它封装了类的实现细节。</li>
</ul>
<p>C++中的<code>struct</code>和<code>class</code>很像,只不过<code>struct</code>默认访问权限是<code>public</code>,而<code>class</code>默认访问权限是<code>private</code>的。</p>
<h3 id="封装">封装</h3>
<p>封装的好处:</p>
<ol>
<li>确保用户代码不会无意间破坏对象的状态,防止因为引入的原因造成数据被破坏,如果有程序缺陷破坏了对象的数据成员的状态,那么只有实现部分的代码可能产生这样的错误.降低了代码维护和错误修正的难度</li>
<li>被封装的类的具体实现细节可以随时改变,无序调整用于级别的代码。类的作者可以比较自由的修改数据。当实现部分改变时,只要类的接口不变,用户代码就不需要改变。如果数据是<code>public</code>的,所有使用了原来数据成员的代码都可能失效,需要先定位并重写这部分代码。<strong>注意当类的实现发生改变时无序更改用户代码,但是使用了该类的源文件必须重新编译。</strong></li>
</ol>
<h2 id="类的作用域">类的作用域</h2>
<p>类本身是一个作用域，类的成员函数的定义在类的作用域之内。编译器在处理类的时候,先编译成员的声明,然后编译成员函数体。<br>
在类的外部定义成员函数时,成员函数的定义必须和它的声明匹配。</p>
<h2 id="类的定义-v2">类的定义</h2>
<h3 id="成员函数">成员函数</h3>
<p><strong>成员函数是定义为类的一部分的函数,有时候也被称为方法。使用.运算符后跟要使用的成员函数,同时使用调用运算符<code>()</code>来访问一个函数。</strong><br>
成员函数的声明必须在类的内部,成员函数的定义既可以在类的内部也可以在类的外部，<strong>定义在类内部的的函数是隐式的内联函数</strong>。而作为接口部分的非成员函数,如<code>add</code>,<code>print</code>,<code>read</code>等都必须在类的外部。</p>
<h3 id="构造函数">构造函数</h3>
<p>构造函数完成类对象的初始化过程。详细介绍可以查看<a href></a>。</p>
<h3 id="类数据成员的初值">类数据成员的初值</h3>
<p>使用<code>=</code>或者列表初始化的方式为类的数据成员变量。</p>
<h3 id="this指针"><code>this</code>指针</h3>
<p>当一个对象调用类的成员函数时,到底发生了什么?比如:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sales_data book;</span><br><span class="line">book.isbn();</span><br></pre></td></tr></table></figure></p>
<p>上面第二行代码其实相当于:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sales_data::isbn(&amp;book);</span><br></pre></td></tr></table></figure></p>
<p>成员函数通过一个名字为<code>this</code>的额外的隐式参数来访问调用它的那个对象,编译器负责把<code>book</code>的地址传递给<code>isbn</code>的隐式形参<code>this</code>。在函数内部可以直接使用调用该函数的对象的成员,不需要通过成员访问运算符来实现,因为<code>this</code>所指的就是这个对象,***任何对类成员的直接访问都被当成<code>this</code>的隐式使用。**当<code>isbn</code>使用<code>bookNo</code>时,隐式的使用<code>this</code>指向的成员,就像我们写了<code>this-&gt;bookNo</code>一样.<br>
虽然<code>this</code>形参是隐式定义的,但是定义任何名字为<code>this</code>的变量或者函数都是非法的.我们可以在成员函数体内部调用<code>this</code>,<code>this</code>的目的是总是指向当前这个对象,所以<code>this</code>是一个常量指针(顶层const),不允许更改它的指向。</p>
<h3 id="const成员函数"><code>const</code>成员函数</h3>
<p>默认情况下,<code>this</code>的类型是指向类类型的非常量版本的常量指针(顶层const).比如在<code>Sales_data</code>的成员函数中,<code>this</code>的类型是<code>Sales_data *const</code>,尽管<code>this</code>是隐式的,它仍然需要遵循初始化规则,即不能把它绑定到常量对象上，也就使得常量对象无法调用普通的成员函数（因为不能把常量对象绑定到普通指针上）。<br>
如果<code>isbn</code>是一个普通函数而且<code>this</code>是一个普通的指针参数，应该把<code>this</code>生命成<code>const Sales_data *const</code>。顶层const是它自己带的，底层const是为了能够使得常量对象也能够调用普通的成员函数。但是因为<code>this</code>是隐式参数，C++ 选择将const关键字放在函数的参数列表之后，这个const表示<code>this</code>是一个指向常量的指针,这样的函数称为常量成员函数。<br>
<strong>常量对象,常量的引用和指针只能调用常量成员函数.并且只能读取它的对象的数据成员,无法修改</strong></p>
<h3 id="返回this对象">返回<code>this</code>对象</h3>
<p>当我们定义的函数类似于某个内置运算符时,应该尽量让函数的行为和内置运算符类似.比如内置运算符把它的左侧运算对象当做左值返回.如果我们在写一个复合赋值运算的时候,就需要返回一个引用类型,具体的返回值应该是<code>this</code>指针指向的整个对象,即<code>*this</code>。如下所示:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Sales_data &amp;<span class="title">combine</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    units_sold += rhs.units_sold;</span><br><span class="line">    revenut += ths.revenue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数返回指向当前类对象的this指针时，返回值是否为引用类型，结果完全不一样。不加引用的话，是this指针的一个副本，所有后续操作都是在这个副本上进行的，而不是在<code>this</code>指针指向的对象上。</p>
<p><strong>从const成员函数返回<code>*this</code>。一个const成员函数如果以引用的形式返回<code>*this</code>，那么它的返回类型是常量引用。</strong></p>
<h3 id="内联成员函数">内联成员函数</h3>
<p>定义在类内部的函数隐式的被定义为内联的（即使不加inline关键字），定义在类内的构造函数也是内联函数。<strong>可以在类内把inline作为声明的一部分显式的声明成员函数，也能在类的外部用inline关键字修饰函数的定义。</strong><br>
内联成员函数最好和相应的类定义在同一个头文件中。<br>
通常将内联函数和<code>constexpr</code>函数定义在头文件中。<br>
内联函数允许多次定义，但是每次的定义必须一致。为什么？什么是内联函数，在每个调用点上将函数内联的展开。如果有两个文件foo.cpp和bar.cpp都需要调用一个相同的内联函数myinline，在编译这两个头文件的时候，需要将函数myinline进行展开，所以它们都需要定义myinline，但是在生成目标文件的时候，因为函数是强类型，就会出错，所以内联函数允许多次一致的定义。而最简单的方法就是将内联函数定义在头文件中，然后使用它的源文件包含它即可。</p>
<h3 id="重载-const-成员函数">重载(const)成员函数</h3>
<p>成员函数的重载和普通函数的重载很像，只不过成员函数是在类内。<br>
同样的，对于const成员函数的重载，也和const函数的重载很像，底层const可以重载，顶层const不能重载。</p>
<h3 id="可变数据成员">可变数据成员</h3>
<p>使用<code>mutable</code>关键字声明一个可变数据成员，即使它是常量对象的成员。因此，一个const成员函数（this指针是指向常量的指针）可以改变一个可变成员的值。可以使用mutable声明一个变量做特别的用途，比如统计类的某个（常量）成员函数被调用了多少次。</p>
<h2 id="友元">友元</h2>
<ol>
<li>友元提供了其他类或者函数(非类的成员函数)访问类的私有对象的功能。</li>
<li>友元的声明只需要在其他函数或者类前加上<code>friend</code>关键字即可。
<ul>
<li>类之间的友元。一个类可以把其他类定义成友元，友元类的成员函数可以访问这个类包括非公有成员在内的所有成员。</li>
<li>成员函数作为友元。可以把其他类中的某个函数设置成友元。但是这几个类之间的声明和定义需要满足一定的依赖关系。</li>
<li>函数重载和友元。如果一个类想要一组重载函数声明为它的友元，需要对重载的每一个函数都声明为友元。</li>
</ul>
</li>
<li><strong>友元声明只能出现在类定义的内部,并且不会受区域访问控制级别（public，private, protected）的约束。</strong></li>
<li><strong>友元的声明只是指定了访问权限(可以访问类的私有成员,和第三条不冲突)，而并非一个普通的函数声明，如果希望类的用户能够调用某个友元函数，必须在友元声明之外再次对函数进行一次声明。<br>
即使在类的内部定义函数，也必须在类的外部提供相应的声明从而使得函数变得可见。即使我们仅仅使用声明友元类的成员调用该友元函数，它也必须是被声明过的。友元声明的作用仅仅是影响访问权限，而非普通意义的声明。</strong></li>
<li>tips,一般来说,最好在类定义开始或者结束前的位置集中声明友元。</li>
<li>友元不具有传递性。</li>
<li>友元声明和作用域。类和非成员函数的声明不是必须在它们的友元声明之前。而友元类的成员函数的声明必须在它们的友元声明之前。</li>
</ol>
<h2 id="类的作用域-v2">类的作用域</h2>
<p>每个类都有自己的作用域，在类的作用域之外，普通的数据和函数成员只能通过对象，引用或者指针使用成员访问运算符进行访问，对于类类型成员则使用作用域运算符访问。<br>
一个类就是一个作用域，在类的外部，成员的名字被隐藏起来了，在类的外部定义成员函数时必须同时提供类名和函数名。一旦遇到了类名，定义的剩余部分就在类的作用域之内了，剩余部分包括参数列表和函数体，接下来我们就可以直接使用类的其他成员而无需再次授权。如果函数的返回类型不是在当前类的作用域内定义的，还需要指定返回类型是哪个类的成员。</p>
<h3 id="名字查找的过程：">名字查找的过程：</h3>
<ol>
<li>在名字所在的块中寻找其声明语句，只考虑在名字的使用前出现的声明。</li>
<li>如果没找到，继续查找外层作用域。</li>
<li>如果没找到匹配的声明，则程序报错。</li>
</ol>
<h3 id="类的定义-v3">类的定义</h3>
<p>类的定义分为两步处理，编译器处理完类中的全部声明后才会处理成员函数的定义：</p>
<ol>
<li>首先，编译成员（包括函数和数据成员）的声明。</li>
<li>直到类的声明全部完成后才编译函数体。</li>
</ol>
<h4 id="成员函数声明的名字查找">成员函数声明的名字查找</h4>
<p>在处理成员函数的声明时，函数声明中的返回值类型和参数列表中出现的名字，都必须在使用前确保可见。按照名字查找的过程进行查找这些名字。</p>
<h4 id="类型名字">类型名字</h4>
<p>类型名字不能被重新定义。</p>
<h4 id="成员函数定义的名字查找">成员函数定义的名字查找</h4>
<ol>
<li>首先在成员函数，该名字出现之前，查找该名字的使用。</li>
<li>如果在成员函数内部没有找到，在类的所有成员内查找。</li>
<li>如果类内没有找到，在成员函数定义之前的作用域内继续查找。</li>
</ol>
<h2 id="类的静态成员">类的静态成员</h2>
<h3 id="声明">声明</h3>
<ol>
<li>静态成员属于类本身，而不属于某个对象，可以通过在成员的声明前面加上<code>static</code>关键字表示这是一个静态成员。</li>
<li>类的静态成员存储在任何对象之外，对象中不包含任何与静态数据成员有关的数据。</li>
<li>类的静态成员函数也不和任意对象绑定在一起，因此它们也不包含<code>this</code>指针。因此，静态成员函数不能声明为<code>const</code>的，也不能在<code>static</code>对象内使用<code>this</code>指针。包含<code>this</code>指针的显示调用和其他非静态成员的调用。</li>
</ol>
<h3 id="静态成员的定义">静态成员的定义</h3>
<p>静态成员函数既可以定义在类的内部，也可以定义在类的外部。定义在外部的时候，不需要重复<code>static</code>关键字。<br>
而静态数据成员不属于类的任何一个对象，所以静态成员不能在构造函数中初始化。<br>
一般来说，不在类内初始化静态数据成员，而是在类的外部定义和初始化每个静态成员，一个静态数据成员只能定义一次（最好把静态成员的定义和其他函数的定义放在同一个文件中）。下面会说到不一般的情况。</p>
<h3 id="静态成员的类内初始化">静态成员的类内初始化</h3>
<p>不一般的情况是，可以为静态成员提供const类型的的类内初始值，在这种情况下，要求静态成员必须是字面值常量类型的常量表达式(<code>constexpr</code>)。</p>
<h3 id="使用">使用</h3>
<ol>
<li>静态成员不属于任何类的对象，但是可以通过类的对象，指针和引用访问静态成员（成员变量和成员函数）。成员函数也可以直接使用静态成员，不需要加上作用域运算符。</li>
</ol>
<h2 id="其他">其他</h2>
<p>头文件一旦改变，相关的源文件必须重新编译获取更新过的声明。<br>
预处理器变量无视C++中关于作用域的规则。加上头文件保护符，防止重复包含。头文件保护符必须唯一。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/9/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/page/11/">11</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/11/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">334</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  

  

</body>
</html>
