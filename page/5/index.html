<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/5/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/5/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-variable-declaration-and-definition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-variable-declaration-and-definition/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">C++ variable declaration and definition</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 21:22:49" itemprop="dateCreated datePublished" datetime="2019-11-13T21:22:49+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:15:59" itemprop="dateModified" datetime="2019-12-17T16:15:59+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="C-类型"><a href="#C-类型" class="headerlink" title="C++类型"></a>C++类型</h2><p>C++中，对象（变量）的类型通常有两种：</p>
<ol>
<li>基本内置类型，整形和浮点型。整形又包括整数，布尔型，字符串，浮点型又包括单精度浮点型和双精度浮点型，详细介绍可以查看<a href="https://mxxhcm.github.io/2019/11/05/C-fundamental-types-and-variables/">C++算术类型</a>。</li>
<li>复合类型，包括<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">指针</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-array/">数组</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-reference/">引用</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-class/">类</a>，结构，联合类型。</li>
</ol>
<h2 id="变量和对象"><a href="#变量和对象" class="headerlink" title="变量和对象"></a>变量和对象</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量是一个有名字的，可供程序操作的存储空间。C++ 中的每个变量都有数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能够参数的运算。对于C++ 程序员来说，变量和对象一般可以互用。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>什么是对象，具有某种数据类型的内存空间，并不区分是复合类型还是内置类型，也不区分是否有名字和是否只读。</p>
<h2 id="变量定义"><a href="#变量定义" class="headerlink" title="变量定义"></a>变量定义</h2><p>一条定义语句由一个基本数据类型和紧随其后的一个或者多个声明符组成。每个声明符声明了一个变量并且指定该变量为与基本数据类型有关的某种类型。<br>基本变量的声明语句由数据类型和变量名组成，声明符就是变量名。而复合类型的声明语句中声明符除了变量名，还会有类型修饰符，如<code>*</code>,<code>&amp;</code>和<code>[]</code>等等。比如引用的声明语句中将声明符写成<code>&amp;d</code>的形式，其中<code>d</code>是声明的变量名,<code>&amp;</code>是类型修饰符。指针是另外一种复合类型，通常将声明符写成<code>*d</code>的形式，其中<code>d</code>是变量名，<code>*</code>是类型修饰符。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p>在指针操作中，其中操作符<code>*</code>称为解引用，操作符<code>&amp;</code>称为取地址符。</p>
<h3 id="复合类型的定义"><a href="#复合类型的定义" class="headerlink" title="复合类型的定义"></a>复合类型的定义</h3><p>变量的定义包含一个基本数据类型和一组声明符。在一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是一条定义语句可能定义处不同类型的变量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure></p>
<p>在定义语句中，类型修饰符<code>*</code>和<code>&amp;</code>仅仅修饰紧随其后的变量。关于引用和指针的声明，一般有两种写法：</p>
<ol>
<li><p>将修饰符和变量名写在一起，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>把修饰符和类型名写在一块，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1;</span><br><span class="line"><span class="keyword">int</span>* p2;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这两种方法都对，C++ primer采用第一种。</p>
<h4 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h4><p>声明符中修饰符的个数没限制，可以写很多个。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival; <span class="comment">//pi指向一个int数</span></span><br><span class="line"><span class="keyword">int</span> **pi = &amp;pi; <span class="comment">//pi指向一个int的指针。</span></span><br></pre></td></tr></table></figure></p>
<h4 id="指针的引用"><a href="#指针的引用" class="headerlink" title="指针的引用"></a>指针的引用</h4><p>引用不是对象，所以指针不能指向引用。但是指针是对象，所以有指针的引用。复杂的指针或者引用的声明语句，从右往左读。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;    <span class="comment">//从右往左阅读，r是一个引用，是谁的引用，int*的引用。</span></span><br><span class="line"></span><br><span class="line">r = &amp;i; </span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">// i=0</span></span><br></pre></td></tr></table></figure></p>
<h2 id="变量初始化"><a href="#变量初始化" class="headerlink" title="变量初始化"></a>变量初始化</h2><p>初始化是在变量创建时给一个特定的值，而赋值是把对象的当前值擦除，使用一个新值代替。</p>
<h3 id="默认初始化"><a href="#默认初始化" class="headerlink" title="默认初始化"></a>默认初始化</h3><p>当变量没有指定初值，使用默认初始化的方式进行初始化。默认值由变量类型和变量位置决定。<br>对于内置类型的变量，如果没有显式初始化，它的位置由定义的位置决定。函数内部的内置类型不会被初始化，定义于任何函数外部的内置类型被初始化为0。未初始化的变量的值是未定义的。<br>对于自定义的类型来说，每个类决定初始化对象的方式，而且是否允许不经过初始化就定义对象也由自己决定。如果类允许这种行为，由类决定对象的初始值是什么；如果类要求每个对象显示初始化，在创建类对象没有进行明确的初始化操作时，会引发错误。</p>
<h2 id="声明和定义的区别"><a href="#声明和定义的区别" class="headerlink" title="声明和定义的区别"></a>声明和定义的区别</h2><ol>
<li>声明需要给出变量的类型和名字，但是不需要申请存储空间。</li>
<li>只进行声明的话使用<code>extern</code>关键字，不要显式的初始化变量。包含了显式初始化的声明就变成了定义。</li>
<li>变量只能定义一次，但是可以声明多次。可以方便的在多个文件中使用同一个变量。</li>
</ol>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-type-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-type-operation/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">C++ type operation</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:19:46" itemprop="dateCreated datePublished" datetime="2019-11-13T14:19:46+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:14:54" itemprop="dateModified" datetime="2019-12-17T15:14:54+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类型操作">类型操作</h2>
<h3 id="别名typedef和using">别名<code>typedef</code>和<code>using</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typdef dobuel wages;    <span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_imte;  <span class="comment">//别名声明</span></span><br></pre></td></tr></table></figure>
<h4 id="指针-常量和类型别名">指针，常量和类型别名</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//基本数据类型是char *，即指针类型</span></span><br><span class="line"><span class="keyword">const</span> pstring *p;</span><br></pre></td></tr></table></figure>
<p>不能简单的把<code>pstring</code>用<code>char *</code>替换，如果替换了变成下式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>;   <span class="comment">//基本数据类型是const char，</span></span><br></pre></td></tr></table></figure>
<p>很容易把<code>*</code>看成是声明符的一部分，即<code>*cstr</code>的一部分，但是实际上<code>*</code>是和<code>const char</code>在一起的。<code>const char *cstr</code>是<strong>指向<code>char</code>常量的指针</strong>，而<code>const pstring cstr</code>是指向<code>char</code>的<strong>常量指针</strong>。</p>
<h3 id="auto关键字"><code>auto</code>关键字</h3>
<p>编译器自动分析表达式的类型，<code>auto</code>定义的变量必须有初值。<br>
使用一条<code>auto</code>语句可以声明多个变量，多个变量的基本数据类型必须一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i= 0, *p = &amp;i; //正确</span><br><span class="line">auto i = 1, d = 3.14;   //错误</span><br></pre></td></tr></table></figure>
<h4 id="复合类型-常量和auto">复合类型，常量和<code>auto</code></h4>
<ol>
<li>编译器使用<code>auto</code>推断出来的值和初始值类型有时候不完全一样。比如使用引用其实使用的是引用对象的值。</li>
<li><code>auto</code>会忽略顶层<code>const</code>，保留底层<code>const</code>。如果希望<code>auto</code>推断出的是顶层<code>const</code>，需要显式的加一个<code>const</code>，即<code>const auto = ...</code>。</li>
<li>将引用的类型设为<code>auto</code>也可以保留初始值中的顶层<code>const</code>属性，</li>
<li>如果给初始值绑定一个引用，并且设为<code>auto</code>类型，这个对象就不是顶层<code>const</code>了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a是一个int,而不是int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;    <span class="comment">//b是一个int</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;    <span class="comment">//c是一个int, cr是ci别名，ci是顶层const</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;    <span class="comment">//d是int *</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">//e是一个指向const的指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">//f是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci;   <span class="comment">// g是int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">43</span>;<span class="comment">//这个j就不是顶层const了，类型是const int &amp;，它是底层const。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="decltype类型"><code>decltype</code>类型</h3>
<p><code>decltype</code>和<code>auto</code>的区别：</p>
<ol>
<li>它只返回表达式的类型。</li>
<li>它能识别顶层<code>const</code>和引用类型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;ri = i, *pi = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(ri);       <span class="comment">//是int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(ri+<span class="number">0</span>);    <span class="comment">//是int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) p = <span class="number">0</span>; <span class="comment">//const int,</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) q = <span class="number">0</span>; <span class="comment">//const int &amp;，顶层常量引用可以初始化成字面值</span></span><br><span class="line"><span class="keyword">decltype</span>(ci) x; <span class="comment">//错误，常量必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y; <span class="comment">//错误，引用必须初始化</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>引用从来都是作为它所指对象的同义词出现，只有在<code>decltype</code>处是例外。</p>
<h4 id="decltype和引用"><code>decltype</code>和引用</h4>
<ol>
<li>如果表达式的内容是解引用操作，使用<code>decltype</code>将会得到引用类型。</li>
<li><code>decltype((variable))</code>的结果永远是引用，而<code>decltype(variable)</code>的结果只有在真的是引用的时候才会返回引用。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) d;</span><br><span class="line"><span class="keyword">decltype</span>(i) e;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-const/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">C/C++ const</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:15:52" itemprop="dateCreated datePublished" datetime="2019-11-13T14:15:52+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:41:26" itemprop="dateModified" datetime="2019-12-17T16:41:26+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="const类型"><a href="#const类型" class="headerlink" title="const类型"></a><code>const</code>类型</h2><ol>
<li><code>const</code>修饰的变量一经初始化，不能改变其值，而且必须进行初始化。</li>
<li>可以使用任意对象（包含非<code>const</code>对象）初始化<code>const</code>对象。</li>
<li><code>const</code>对象默认只在当前文件中有效。如果需要在其他文件中使用，在声明和定义的文件中都需要加上<code>extern</code>关键字；而非<code>const</code>对象在定义时不需要使用<code>extern</code>关键字，只需要在其他文件的声明中加上<code>extern</code>即可。</li>
<li>编译器遇到<code>const</code>变量时，会将所有该变量出现的地方都换成相应的值。</li>
</ol>
<h2 id="引用和const"><a href="#引用和const" class="headerlink" title="引用和const"></a>引用和<code>const</code></h2><p>可以把应用绑定到<code>const</code>对象上，就像绑定到其他常量上，称为对常量的引用（reference to const)，和普通引用的不同在与，对常量的引用不能用作修改它绑定的对象：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;</span><br><span class="line"></span><br><span class="line">r1 = <span class="number">42</span>;    <span class="comment">//这行代码是错的，因为r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;   <span class="comment">//这行代码也是错的，因为r2是普通引用</span></span><br></pre></td></tr></table></figure></p>
<p>常量引用是对常量的引用的简称。严格来说，并不存在常量引用，因为引用不是一个对象，我们没办法让引用本身恒定不变。但是因为C++中，引用绑定的对象是不能更改的，所以从这层意义上理解，所有的引用又都称得上常量。引用的对象是常量还是非常量决定了引用能进行的操作，但是影响不到引用和对象的绑定关系。</p>
<h3 id="初始化和对常量的引用"><a href="#初始化和对常量的引用" class="headerlink" title="初始化和对常量的引用"></a>初始化和对常量的引用</h3><p>之前说过引用的类型对象必须和引用对象的类型一样。但是有两个例外，<strong>一个例外就是初始化常量引用时可以使用任意表达式作为初值。</strong>如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">43</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的例子我们也可以看出，对常量的引用可能引用一个非常量对象，我们不能通过<code>r</code>改变<code>i</code>的值，但是我们可以直接改变<code>i</code>的值，因为<code>r</code>和<code>i</code>是绑定的，所以<code>r</code>的值也改变了。</p>
<p>当把一个常量引用绑定到另一种类型上的时候，会发生什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14;</span><br><span class="line">const int &amp;ri = dval;</span><br></pre></td></tr></table></figure></p>
<p>上述代码将一个<code>dobule</code>类型的变量绑定到一个<code>const int</code>型引用上，为了让<code>ri</code>绑定一个整数，编译器将上述代码变成了以下形式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int temp = dval;</span><br><span class="line">const int &amp;ri = temp;</span><br></pre></td></tr></table></figure></p>
<p>将<code>ri</code>绑定到了一个临时对象<code>temp</code>上，但是我们想要<code>ri</code>操作的是<code>dval</code>而不是<code>temp</code>，所以这种行为被判定为非法。</p>
<h3 id="引用和左值，右值"><a href="#引用和左值，右值" class="headerlink" title="引用和左值，右值"></a>引用和左值，右值</h3><ol>
<li>非常量引用的初始值必须是左值。</li>
<li>常量引用的初始值可以是右值。比如<code>const int &amp;a =  7</code>;</li>
<li>常量引用的初始值可以为左值。</li>
</ol>
<h2 id="指针和const"><a href="#指针和const" class="headerlink" title="指针和const"></a>指针和<code>const</code></h2><p>指针也可以指向常量。类似于对常量的引用（常量引用），有指向常量的指针（pointer to const)。</p>
<ol>
<li>之前说过指针指向的类型对象必须和指针的类型一样。但是有两个例外，一个例外就是指向常量的指针可以使用非常量对象的地址进行初始化。</li>
<li>要想存放指向常量的地址，必须使用指向常量的指针。</li>
<li>指向常量的指针不能用于改变其所指对象的值，很容易明白，因为指向的是常量，而常量的值是不能修改的，所以指向常量的指针自然不能修改它指向的对象的值。</li>
<li>那么指向常量的指针的指向能否改变？当然可以了，要不然就不会有<code>const</code>指针了，即指针本就就是常量对象，指向不能改变的指针对象。</li>
</ol>
<p>可以认为指向常量的指针和对常量的引用都是他们自认为指向了常量对象，而常量对象不能被修改，所以就不能修改所指对象的值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;  <span class="comment">//报错，必须是指向常量的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;    <span class="comment">//</span></span><br><span class="line">*cptr = <span class="number">4</span>;  <span class="comment">//不能修改常量指针指向的常量的值</span></span><br></pre></td></tr></table></figure></p>
<h3 id="const指针"><a href="#const指针" class="headerlink" title="const指针"></a><code>const</code>指针</h3><p>引用不是对象，而指针是对象，因此就像其他对象一样，可以把指针本身定义为常量，叫做常量指针，常量指针必须初始化。<br><code>const</code>指针必须初始化，它指向变量的值能否改变只取决于它指向变量的类型。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;val;   <span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;  <span class="comment">//</span></span><br></pre></td></tr></table></figure></p>
<h2 id="顶层const"><a href="#顶层const" class="headerlink" title="顶层const"></a>顶层<code>const</code></h2><p>用顶层<code>const</code>表示指针本身是一个常量，用底层<code>const</code>表示指针指向的对象是一个常量。指针可以既是顶层<code>const</code>又是底层<code>const</code>。<br>更一般的，顶层<code>const</code>可以表示任何的对象是常量，这一点对任意类型都使用。而底层<code>const</code>则和指针，引用等复合类型有关。<br>可以把一个顶层<code>const</code>赋值给非顶层<code>const</code>对象；但是不能把底层<code>const</code>赋值给非底层<code>const</code>对象，这个多加几句，因为底层<code>const</code>一定是和复合类型指针和引用相关的，所以要把它赋值给一个非底层的<code>const</code>对象，这个待赋值的对象也一定是指针和引用，如果它是非底层<code>const</code>对象，那么就可以通过它修改它指向的对象了，而这个对象是<code>const</code>的，不能被修改。</p>
<p>对常量的引用（常量引用）可以和常量对量绑定；<br>对常量的引用（常量引用）可以和非常量对量绑定；<br>非常量引用不可以和常量对象绑定；<br>非常量引用可以和非常量对象绑定；</p>
<p>指向常量的指针可以指向常量对象；<br>指向常量的指针可以指向非常量对象；<br>常量指针可以指向非常量对象；<br>常量指针不可以指向常量对象；<br>普通指针不可以指向常量对象；<br>普通指针可以指向非常量对象；</p>
<p>常量指针（顶层const）可以用来初始化非常量对象。<br>对常量的引用和指向常量的指针（底层const）不可以用来初始化非常量对象。</p>
<h2 id="constexpr和常量表达式，constexpr函数"><a href="#constexpr和常量表达式，constexpr函数" class="headerlink" title="constexpr和常量表达式，constexpr函数"></a><code>constexpr</code>和常量表达式，<code>constexpr</code>函数</h2><ol>
<li><p>常量表达式，值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值和用常量表达式初始化的<code>const</code>对象也是常量表达式。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">23</span>;  <span class="comment">//不是常量表达式，因为他不是`const`对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_size();  <span class="comment">//sz是常量，但不是常量表达式，因为它的值需要等到运行时才能获得。</span></span><br></pre></td></tr></table></figure></p>
</li>
<li><p>常量表达式一定是常量，但是常量不一定是常量表达式。</p>
</li>
<li>声明为<code>constexpr</code>的变量由编译器验证它是否是常量表达式。</li>
<li>声明为<code>constexpr</code>的变量一定是个常量，而且必须用常量表达式初始化。</li>
<li>如果认定变量一定是个常量表达式，就把它声明成<code>constexpr</code>类型，即<code>constexpr</code>用于声明常量表达式。</li>
<li><code>constexpr</code>函数的形参和返回值都必须是字面值类型，并且函数体有且只有一条<code>return</code>语句。</li>
<li><code>constexpr</code>函数不一定返回常量表达式。</li>
</ol>
<h3 id="字面值类型"><a href="#字面值类型" class="headerlink" title="字面值类型"></a>字面值类型</h3><p>算术类型，引用和指针都属于字面值类型，<code>string</code>，IO库和类不属于字面值类型。算术类型包含整形和浮点型，整形中又包含整数，字符和布尔。<code>constexpr</code>只能用于字面值类型。<br>指针和引用能用定义成<code>constexpr</code>，但是初值受到严格限制，一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>，<code>0</code>或者某个固定地址的对象。一般来说，函数内部的变量(除了<code>static</code>变量)没有存在固定地址中，而所有函数之外的对象地址固定不变，能用来初始化<code>constexpr</code>指针。<code>constexpr</code>声明的指针是顶层<code>const</code>，即指针本身是个<code>const</code>，它指向的对象不能变，它指向的对象的值能变。</p>
<h2 id="const-cast"><a href="#const-cast" class="headerlink" title="const_cast"></a><code>const_cast</code></h2><ol>
<li><p><code>const_cast</code>只能改变运算对象的底层<code>const</code>，将常量对象转换成非常量对象，这种性质叫做去掉<code>const</code>性质。如果对象本身不是一个常量，使用强制类型转换获得写权限是一个合法的行为，如果对象是一个常量，使用<code>const_cast</code>执行写操作就会产生未定义的后果。<code>const_cast</code>还可以将一个非<code>const</code>对象变成<code>const</code>对象。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s1</span><span class="params">(<span class="string">"hello"</span>)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span> <span class="title">s2</span><span class="params">(<span class="string">"world"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *p1 = &amp;s1;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *p2 = &amp;s2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> *p3 = <span class="keyword">const_cast</span>&lt;<span class="built_in">string</span> *&gt;(p2);  <span class="comment">//去掉底层const，但是通过p3写它指向的东西是未定义行为。</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">string</span> *p4 = <span class="keyword">const_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span>*&gt;(p1);   <span class="comment">//将非底层const转换成底层const。</span></span><br></pre></td></tr></table></figure></p>
</li>
<li><p>只有<code>const_cast</code>能改变表达式的常量属性，使用其他类型的命名强制类型转换改变表达式的常量属性都会引发编译器的错误，注意不能使用<code>const_cast</code>改变表达式的类型。</p>
</li>
<li>通常用于有函数重载的上下文。</li>
</ol>
<h2 id="const形参和实参"><a href="#const形参和实参" class="headerlink" title="const形参和实参"></a><code>const</code>形参和实参</h2><p>当形参是<code>const</code>时，必须注意顶层<code>const</code>，顶层<code>const</code>作用于对象本身。当用实参初始化形参时，会忽略掉顶层<code>const</code>，即形参的顶层<code>const</code>被忽略掉了。当形参有顶层<code>const</code>时，传递给它常量或者非常量对象都是可以的。</p>
<h3 id="指针或者引用形参和const"><a href="#指针或者引用形参和const" class="headerlink" title="指针或者引用形参和const"></a>指针或者引用形参和<code>const</code></h3><p>形参的初始化方式和变量的初始化方式是一样的，所以指针或者引用形参和<code>const</code>结合时，按照<code>const</code>变量的初始化规则执行就行。</p>
<h3 id="尽量使用常量引用"><a href="#尽量使用常量引用" class="headerlink" title="尽量使用常量引用"></a>尽量使用常量引用</h3><p>把函数不会修改的形参定义成普通的引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。（比如，不能把<code>const</code>对象，字面值或者需要类型转换的对象传递给普通的引用传参）</p>
<h4 id="数组形参和const"><a href="#数组形参和const" class="headerlink" title="数组形参和const"></a>数组形参和<code>const</code></h4><p>当函数不需要对数组进行写操作时，数组形参应该是指向<code>const</code>的指针。只有当函数确实需要改变数组元素值的时候，才把形参定义成指向非常量的指针。</p>
<h2 id="重载和const"><a href="#重载和const" class="headerlink" title="重载和const"></a>重载和<code>const</code></h2><h3 id="重载和const形参"><a href="#重载和const形参" class="headerlink" title="重载和const形参"></a>重载和<code>const</code>形参</h3><p>顶层<code>const</code>不影响传入函数的对象</p>
<ol>
<li>一个拥有顶层<code>const</code>的形参无法和另一个没有顶层<code>const</code>的形参区分开来。</li>
<li>如果形参是某种类型的指针或引用，即形参是底层<code>const</code>，区分其指向的是常量对象还是非常量对象可以实现函数重载。</li>
</ol>
<h3 id="const-cast和重载"><a href="#const-cast和重载" class="headerlink" title="const_cast和重载"></a><code>const_cast</code>和重载</h3><p><code>const_cast</code>在重载函数的情景中有最有用。如下函数：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">stringCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>函数的形参是底层<code>const</code>，可以接收常量或者非常量的实参。但是返回的都是<code>const string</code>的引用，如果输入是两个<code>string</code>的引用，返回一个<code>const string</code>的引用显然是不合理的，这时候就可以使用<code>const_cast</code>了。对上述代码做一个改进：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span>&amp; <span class="title">stringCompare</span><span class="params">(<span class="built_in">string</span> &amp;s1, <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> &amp;r = stringCompare(<span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span> &amp;&gt;(s1), <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> <span class="built_in">string</span> &amp;&gt;(s2)a);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="built_in">string</span> &amp;&gt;(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.《C++ Primer》第五版<br>2.<a href="https://www.zhihu.com/question/36052573/answer/65756850" target="_blank" rel="noopener">https://www.zhihu.com/question/36052573/answer/65756850</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-compound-type-reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-compound-type-reference/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">C++ compound type reference</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:14:15" itemprop="dateCreated datePublished" datetime="2019-11-13T14:14:15+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:37:29" itemprop="dateModified" datetime="2019-12-17T16:37:29+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引用（左值引用）"><a href="#引用（左值引用）" class="headerlink" title="引用（左值引用）"></a>引用（左值引用）</h2><ol>
<li>引用不是一个对象，没有实际地址，不能定义指向引用的指针。</li>
<li>引用只是一个别名，必须和一个已经存在的对象绑定在一起，无法更改，必须初始化。</li>
<li>定义引用时，标识符必须以<code>&amp;</code>开头。</li>
<li>除了两种特殊情况外，所有引用的类型都必须和它绑定的对象严格匹配。</li>
<li>引用只能绑定在对象上，不能绑定在字面值或者某个表达式上。（const引用除外）</li>
</ol>
<h2 id="引用的两种特殊情况"><a href="#引用的两种特殊情况" class="headerlink" title="引用的两种特殊情况"></a>引用的两种特殊情况</h2><ol>
<li>初始化常量引用时允许用任意的表达式作为初始值，只要该表达式的结果能够转换成应用的类型即可。其次，允许一个常量引用绑定非常量的对象，字面值，甚至是一个表达式。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = dval;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>编译器把上述代码变成了：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> inst temp = dval;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;ri = temp;</span><br></pre></td></tr></table></figure></p>
<p>当ri不是常量时，就允许对ri赋值，这样就会改变ri所引用对象的值。但是ri其实是绑定到了一个临时变量temp上，程序员绑定临时变量的目的肯定是想改变dval的值，大家不会想着把引用绑定到临时变量上，然后改变它的值，所以C++就把这种行为归为非法（注：并不是说这种绑定是错误的）。<br>2.</p>
<h2 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h2><h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-compound-type-pointer/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">C/C++ compound type pointer</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:11:26" itemprop="dateCreated datePublished" datetime="2019-11-13T14:11:26+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-11 16:35:36" itemprop="dateModified" datetime="2019-12-11T16:35:36+08:00">2019-12-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="指针">指针</h2>
<ol>
<li>变量的值存储在计算机的内存中，每个变量都占据一个特定的位置，每一个内存位置都由地址唯一确定并引用。指针可以看成是地址的另一个名字<a href="3.1.3">2</a>。</li>
<li>指针变量也是一个变量，其中存放的是另一个变量的地址，因为指针是一个变量，所以指针变量本身也存放在内存中的某个位置<a href="3.1.3">2</a>。允许对指针赋值和拷贝，在指针的生命周期内可以先后指向几个不同的对象。</li>
<li>指针无须在定义时赋值，和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ol>
<h2 id="指针声明和定义">指针声明和定义</h2>
<p>指针也是一个复合类型，需要按照复合类型的声明和定义进行声明。</p>
<h3 id="指针定义">指针定义</h3>
<p>定义指针类型的方法将声明符写成<code>*d</code>的形式，其中<code>d</code>是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号<code>*</code>。即<code>*</code>是修饰声明符的，而不是修饰<code>int</code>的。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; <span class="comment">// 定义一个int*的指针p，p进行了默认初始化</span></span><br><span class="line"><span class="keyword">int</span> *a, b, *c;  <span class="comment">//定义了两个int*类型的指针a,c，一个int类型变量b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *message = <span class="string">"Hello world!"</span>; <span class="comment">//定义一个char*变量，指向数据段的字符串常量区中的字符串"Hello world!"的首字符的地址。</span></span><br><span class="line"><span class="comment">//下面两行代码和上面一行代码的作用是相同的，message是一个`char *`指针，指向字符串常量"Hello world!"的首字符的地址。</span></span><br><span class="line"><span class="keyword">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">message = <span class="string">"Hello world!"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="取地址符">取地址符</h3>
<p>指针存放某个对象的地址，要想获取改地址，需要使用取地址符<code>&amp;</code>。除了两种特殊情况外，所有指针类型都要和它所指的对象严格匹配。<br>
两种特殊情况：</p>
<ol>
<li>一个指向常量的指针可以指向个非常量对象。</li>
<li>…</li>
</ol>
<h3 id="指针的值-就是地址-有四种可能取值">指针的值，就是地址，有四种可能取值</h3>
<ol>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针，没有指向任何对象</li>
<li>无效指针，除了以上三种情况的任何值。</li>
</ol>
<p>使用无效指针和使用未初始化变量是同类错误，编译器都不负责进行检查。</p>
<h3 id="解引用指针-间接访问-操作符">解引用指针（间接访问）操作符</h3>
<p>C11中解引用操作符<code>*</code>的定义：</p>
<blockquote>
<p>The unary * operator denotes indirection. If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object. If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’. If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.102)</p>
</blockquote>
<p>C++11中解引用操作符<code>*</code>的定义：</p>
<blockquote>
<p>The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is “pointer to T,” the type of the result is “T.” [ Note: a pointer to an incomplete type (other than cv void) can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a prvalue, see 4.1. — end note ]</p>
</blockquote>
<p>解引用操作符<code>*</code>应用于指向对象或者指向函数的指针表达式，得到指针指向对象的左值表达式，给解引用的结果赋值其实就是给指针所指的对象赋值([1]2.3.2)。如果不解引用，指针变量中存放的内容就只是地址。<br>
<strong>对象（变量）和指针变量中存放的内容（即地址）的区别，对象可以直接进行赋值。指针变量中存放的是一个地址，地址本身就是一个数字，是一个右值，不能对其进行赋值，对这个地址进行解引用，得到指针指向的对象。</strong><br>
定义一个指针<code>p</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>; </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p><code>p</code>是<code>int*</code>类型，存放的是变量<code>a</code>的地址，<code>*</code>是间接访问，<code>*p</code>对指针进行解引用得到指针指向对象的左值表达式，其实就是<code>a</code>，<code>&amp;</code>表示取变量<code>a</code>的地址。</p>
<h3 id="未初始化和非法的指针">未初始化和非法的指针</h3>
<p>看一个错误的代码片段：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a; <span class="comment">//定义一个指针*p</span></span><br><span class="line">*a = <span class="number">12</span>;    <span class="comment">//把12存储在a指向的内存中，错误</span></span><br></pre></td></tr></table></figure></p>
<p>这个代码中犯了一个很严重的错误，我们在声明了变量<code>a</code>，但是没有对它进行显示初始化，所以编译器会对a进行默认初始化，默认初始化并不会为变量分配内存。如果程序执行这个赋值操作，假如a是一个非法地址，程序会出错，终止程序，在UNIX系统上，这个错误称为&quot;segmentation violation&quot;或者&quot;memory fault&quot;，它告诉我们程序正在访问一个非法的地址。如果a是一个合法的地址，这就会错误的修改a指向的内存中的值，造成一些难以预料到的错误。</p>
<h3 id="空指针">空指针</h3>
<p>有以下几种方法声明空指针：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1.</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 方法2.</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 方法3.</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;<span class="comment">//NULL定义在cstdlib中</span></span><br></pre></td></tr></table></figure></p>
<p>最好使用<code>nullptr</code>或者<code>0</code>，而避免使用<code>NULL</code>。</p>
<h3 id="void-指针"><code>void*</code>指针</h3>
<p><code>void *</code>指针可以存放任意类型的地址，但是我们并不知道它存放的是什么类型的对象。</p>
<h3 id="指针的指针">指针的指针</h3>
<p>因为指针也是一个变量，所以它自然也就有地址，也就存在指向指针的指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, *b, **c;</span><br><span class="line">b = &amp;a;</span><br><span class="line">c = &amp;b;   <span class="comment">//紧挨着c左边的那个*表示c是一个指针，然后再往左边的那个`*`是和`int`在一起的，表示指针`c`指向的变量的类型是`int *`类型的。</span></span><br><span class="line"><span class="comment">// a,*b, **c表示同样的东西，都是变量a的值。</span></span><br><span class="line"><span class="comment">// *c和b和&amp;a表示同样的东西，都是变量a的地址。</span></span><br><span class="line"><span class="comment">// a表示int类型的变量</span></span><br><span class="line"><span class="comment">// b是a的地址，*b表示对指针p解引用，*b就是a。</span></span><br><span class="line"><span class="comment">// c是b的地址，*c表示对指针c解引用，*c就是b，也就是a的地址，*(*c)也就是*b，也是a。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="指针的特点">指针的特点</h2>
<ol>
<li>
<p>存放的是对象的地址，要想获取变量的地址，需要使用取地址符<code>&amp;</code>，访问指针中地址指向的变量，使用解引用符号<code>*</code>，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp; val; <span class="comment">//指针p存放的是变量val的地址</span></span><br><span class="line"><span class="keyword">int</span> b = *p; <span class="comment">//b被初始化为32,p存放的是val的地址，*p获得该地址指向的变量val。</span></span><br><span class="line">*p = <span class="number">3</span>; <span class="comment">//将val赋值为3</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>赋值永远改变的是<code>=</code>左侧的对象，可以用来判断到底是改变了指针的值还是改变了指针所指的对象的值。</p>
</li>
<li>
<p>除了两种特殊情况外，所有指针的类型都必须和它指向的对象严格匹配。</p>
</li>
</ol>
<h2 id="指针和引用的不同点">指针和引用的不同点</h2>
<ol>
<li>指针本身就是一个对象，允许赋值和拷贝，在生命周期内可以指向几个不同的对象；而引用本身并非一个对象，一定定义了引用，它就和一个对象终生绑定在了一起。</li>
<li>指针定义时无须赋值；而引用必须在定义时赋值。</li>
</ol>
<h2 id="指针运算">指针运算</h2>
<p>指针加上一个整数的结果是另一个指针。注意，这里假设每种类型都是连续存储的。假设字符型占一个字节，<code>float</code>占四个字节，<code>double</code>占八个字节。<br>
如果将指针加上1：<br>
对于一个字符型，新的指针指向内存中的下一个字符，指针的值实际上增加了1。<br>
对于一个<code>float</code>型，它指向内存中的下一个<code>float</code>，指针的值实际上增加了4。<br>
对于一个<code>double</code>型，它指向内存中的下一个<code>double</code>，指针的值实际上增加了8。<br>
也就是说，对于一个给定类型的指针，将它加一，得到的新指针指向下一个同类型的变量，这也是声明指针类型的作用。</p>
<h3 id="指针的大小">指针的大小</h3>
<p>任何类型的指针本身所占的大小都是相等的，取决于计算机的地址大小，如果是<code>32</code>位的地址，指针的大小就是<code>4</code>个字节，如果是<code>64</code>位的地址，指针的大小就是<code>8</code>个字节。!!!这是错误的。。</p>
<blockquote>
<p>The size of a pointer depends on many factors - including the CPU architecture, compiler, Operating System etc.<br>
Usually the size is equal to the word size of the underlying processor architecture, and the size of total addressable memory (including virtual memory).<br>
So, for a 32bit computer, the pointer size can be 4 bytes; 64bit computers can have 8 bytes. Or, a 64bit computer running a 32bit OS will have 4 bytes. Still, under a specific architecture, all types of pointers (void*, int*, char*, long* etc) will have same size (except function pointers).<br>
That’s, pointers in C (or C++) doesn’t have a fixed size.</p>
</blockquote>
<h3 id="算术运算">算术运算</h3>
<p>C的算术运算只有两种形式。第一种是指针加减一个整数，第二种是两个指针相减。</p>
<h4 id="指针加减一个整数">指针加减一个整数</h4>
<p>指针加减一个整数的运算形式只能用于指向数组中某个元素的指针，将它加减一个整数得到的表达式也还是一个指针，它仍指向数组中某个元素。如果对指针进行加法或者减法运算之后，指针所指的位置是在数组第一个元素前面或者在最后一个元素后面，它的效果是未定义的。这种操作编译器不会进行检查，需要程序员自己进行检查。<br>
这种形式也适用于<code>malloc</code>函数动态分配的内存。</p>
<h4 id="指针减指针">指针减指针</h4>
<p>两个指针相减的结果类型是<code>ptrdiff_t</code>，是一种有符号整数类型。运算结果是两个指针在内存中的距离，以数组元素的长度为单位，而不是以字节为单位。两个指针必须指向同一个数组，结果可正可负。如果两个指针指向不同的数组，这个距离就没有意思。因为我们不知道两个数组分别存在哪个位置。</p>
<h3 id="关系运算">关系运算</h3>
<p><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code><br>
关系运算也需要指针指向同一个数组中的元素。为了和C++的迭代器兼容，最好使用<code>==</code>或者<code>!=</code>，因为迭代器不支持关系运算，而指针和迭代器都支持<code>==</code>和<code>!=</code>运算。</p>
<h2 id="c中的指针表达式和左值右值-2">C中的指针表达式和左值右值[2]</h2>
<h3 id="指针自增自减操作">指针自增自减操作</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = &amp;ch;</span><br></pre></td></tr></table></figure>
<ol>
<li>前置自增操作<code>++cp</code>，将<code>cp</code>的值加一，该操作先将<code>cp</code>的值加一，指向<code>ch</code>后面的一个位置，然后返回<code>cp</code>的一个拷贝。表达式<code>++cp</code>和<code>cp</code>加一后的对象一样。</li>
<li>后置自增操作<code>cp++</code>，将<code>cp</code>的值加一，该操作先返回对象<code>cp</code>的一个拷贝，然后将<code>cp</code>的值加一，指向<code>ch</code>后面的一个位置。表达式<code>cp++</code>和<code>cp</code>加一前的对象一样。</li>
<li>解引用前置自增操作<code>*++cp</code>，这个式子其实是对表达式<code>++cp</code>的解引用操作，也就是对<code>cp</code>加一后的拷贝的解引用操作，而不是对<code>cp</code>的操作。</li>
<li>解引用前置自增操作<code>*cp++</code>，这个式子其实是对表达式<code>cp++</code>的解引用操作，是对<code>cp</code>加一前的拷贝的解引用操作，而不是对<code>cp</code>的操作。</li>
</ol>
<h3 id="指针表达式和左值右值">指针表达式和左值右值</h3>
<p>关于左值和右值的介绍，可以查看<a href="http://localhost:4000/2019/11/14/C-CPP-lvalue-and-rvalue/" target="_blank" rel="noopener">C C++ lvalue and rvalue</a>。<br>
给出下列代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;cp = 4; //这个是错的，&amp;cp是一个地址，但是它本身只是一个数，它的本质和`10=4;`没有区别，使用解引用符号访问这个地址上的对象。</span></span><br><span class="line"><span class="comment">// 10 = 4; 错误，10既不是指针，也不是变量</span></span><br><span class="line"><span class="comment">//*10 = 4; 错误，10既不是指针，也不是变量</span></span><br><span class="line">*(<span class="keyword">int</span>*)<span class="number">10</span> = <span class="number">4</span>; <span class="comment">//10是一个int，首先把它转化成一个指针，表示一个地址，然后使用解引用进行赋值</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>ch</code>，作为左值时，表示的是<code>ch</code>在内存中的位置；<code>ch</code>作为右值时，值是<code>'a'</code>，</li>
<li><code>&amp;ch</code>，不能当左值，因为它没有存放在内存中；当右值时，值是变量<code>ch</code>的地址</li>
<li><code>cp</code>，作为左值，是一个指针变量；作为右值，值是变量<code>ch</code>的地址</li>
<li><code>&amp;cp</code>，无法作为左值；作为右值，值是指针变量<code>cp</code>的地址</li>
<li><code>*cp</code>，作为左值，和<code>ch</code>等价；作为右值，值是<code>'a'</code></li>
<li><code>*cp+1</code>，无法作为左值；作为右值，值是<code>'a'+1</code>。</li>
<li><code>*(cp+1)</code>，作为左值，是一个指针，指向<code>ch</code>后面的一个内存单位；作为右值，是<code>ch</code>后面一个内存单位的值。</li>
<li><code>++cp</code>，无法作为左值，右值和<code>*(cp+1)</code>一样。</li>
<li><code>cp++</code>，无法作为左值，右值和<code>*(cp+1)</code>一样。</li>
<li><code>*++cp</code>，作为左值，是一个指针，指向<code>ch</code>后面的一个位置；作为右值，是<code>ch</code>后面那个位置的值。</li>
<li><code>*cp++</code>，作为左值，是一个指针，指向<code>ch</code>；作为右值，<code>'a'</code>。</li>
<li><code>++*cp</code>，无法作为左值；作为右值，是<code>'b'</code>；</li>
<li><code>(*cp)++</code>，无法作为左值；作为右值，是<code>'a'</code>。</li>
<li><code>++*++cp</code>，无法作为左值；作为右值，是<code>'c'</code>。</li>
<li><code>++*cp++</code>，无法作为左值；作为右值，是<code>'c'</code></li>
</ol>
<h2 id="指针和数组">指针和数组</h2>
<ol>
<li>指针和数组的联系很紧密，在很多用到数组名字的时候，编译器都会自动的将它转换成一个指向数组首元素的指针。数组名字是个常量指针。</li>
<li>使用取地址符获取某个对象的指针，对数组元素使用取地址符就能得到指向该元素的指针。</li>
</ol>
<p>关于更多指针和数组之间的内容，点击查看<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-array/">数组</a>的介绍。</p>
<h2 id="函数指针">函数指针</h2>
<p>函数指针指向的是函数而不是对象。和其他指针一样，函数指针指向某种特定类型。函数的类型由它的返回值和形参共同决定，和函数名无关。例如：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lengthCompare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>这个函数的类型是<code>bool(const string &amp;, const string &amp;)</code>，要想声明一个指向该函数的指针，只需要使用指针代替函数名字即可：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;);</span><br></pre></td></tr></table></figure></p>
<p>从声明符中的变量名字开始，<code>pf</code>前面有个<code>*</code>，所以<code>pf</code>是个指针，右侧是形参列表，左侧是函数的返回值类型。因此，<code>pf</code>是一个指向函数的指针，函数的参数是两个<code>const string</code>的引用，返回值是<code>bool</code>类型，指针类型是<code>boo(*)(const string &amp;, const string &amp;)</code></p>
<p>函数指针可以作为形参，也可以作为返回值，还可以使用<code>decltype</code>和<code>typedef</code>简化函数指针。需要注意的是，<code>decltype</code>不会把函数转换成指针。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.《C和指针》<br>
3.<a href="https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard" target="_blank" rel="noopener">https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard</a><br>
4.<a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf</a><br>
5.<a href="https://www.quora.com/What-is-the-size-of-a-pointer-in-C%60" target="_blank" rel="noopener">https://www.quora.com/What-is-the-size-of-a-pointer-in-C`</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-compound-type-array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-compound-type-array/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">C/C++ compound type array</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:09:40" itemprop="dateCreated datePublished" datetime="2019-11-13T14:09:40+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:38:11" itemprop="dateModified" datetime="2019-12-17T16:38:11+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组和<code>vector</code>类似，但是数组是定长的，大小不变，而<code>vector</code>是可变的，可以把<code>vector</code>看成可变长度的数组。<br>如果不清楚元素的确切个数，使用vector。</p>
<h3 id="定义和初始化"><a href="#定义和初始化" class="headerlink" title="定义和初始化"></a>定义和初始化</h3><p>数组的维度必须是确定的，在编译时就知道，即是一个常量表达式（值不会改变并且在编译时就已知）。<br>默认情况下，数组的元素被默认初始化。和内置类型的变量一样，如果在数组内部定义了某种内置类型的数组，那么默认初始化得到的数组含有未定义的值。</p>
<h3 id="显式的初始化数组"><a href="#显式的初始化数组" class="headerlink" title="显式的初始化数组"></a>显式的初始化数组</h3><ol>
<li>可以忽略维度，编译器会根据初始值推测出来；</li>
<li>如果指明维度，初始值的数量不应该超出指定的大小；</li>
<li>如果维度比提供的初始值大，其它的元素被初始化成默认值（值初始化）。</li>
</ol>
<h3 id="数组不支持直接拷贝和直接赋值"><a href="#数组不支持直接拷贝和直接赋值" class="headerlink" title="数组不支持直接拷贝和直接赋值"></a>数组不支持直接拷贝和直接赋值</h3><p>不能将数组或的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。</p>
<h3 id="数组和vector"><a href="#数组和vector" class="headerlink" title="数组和vector"></a>数组和<code>vector</code></h3><p>不允许使用一个数组为另一个数组赋初值，也不允许使用<code>vector</code>初始化数组。但是支持使用数组来初始化<code>vector</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi(begin(arr), end(arr));</span><br></pre></td></tr></table></figure></p>
<h3 id="复杂数组的声明"><a href="#复杂数组的声明" class="headerlink" title="复杂数组的声明"></a>复杂数组的声明</h3><p>对于数组声明的理解，从变量名开始，先往右，再往左读。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];    <span class="comment">//数组arr，有10个元素，每个元素是int类型</span></span><br><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];  <span class="comment">//数组ptrs，有10个int*类型元素，</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>];  <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;   <span class="comment">//数组的指针Parray，指向一个有10个int类型的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;    <span class="comment">//数组的引用arrRef，引用一个10个int类型的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;<span class="built_in">array</span>)[<span class="number">10</span>] = ptrs;   <span class="comment">//数组的引用array，引用一个10个int*类型的数组</span></span><br></pre></td></tr></table></figure></p>
<h2 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h2><ol>
<li>范围for 语句。</li>
<li>下标运算符。下标的类型是<code>size_t</code>类型。它是一种机器相关的无符号类型，足够大能够表示内存中任意对象的大小。定义在<code>&lt;stddef.c&gt;</code>或者<code>&lt;cstddef&gt;</code>头文件中。</li>
</ol>
<h2 id="数组和指针"><a href="#数组和指针" class="headerlink" title="数组和指针"></a>数组和指针</h2><h3 id="数组名和指针"><a href="#数组名和指针" class="headerlink" title="数组名和指针"></a>数组名和指针</h3><ol>
<li>一般情况下，可以使用取地址符获取某个对象的指针。数组元素也是对象，使用下标运算符得到数组指定位置的对象，使用取地址符就能得到指向该元素的指针。([1]3.5.3)</li>
<li>数组的另一个特性是，在大多用到数组名字的时候，编译器都会自动的将它转换成一个指向数组首元素的指针，而且数组名是一个常量指针([1]3.5.3)。或者说数组作为右值时，编译器会自动将数组转化成数组首元素的地址([2)]。</li>
<li>在C中，只有两种操作不把数组名字当做常量指针，当数组名字用作<code>sizeof</code>和<code>&amp;</code>的操作对象时。当<code>sizeof</code>的输入是数组名时，返回的是数组的长度（字节为单位）。而<code>&amp;</code>对数组名取地址时，返回的是指向数组的指针。</li>
</ol>
<p>在<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">C++复合类型指针</a>中介绍了指针的算术运算。指针的算术运算有一个要求，就是指针必须指向数组中某一个元素。如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[sz] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line">ip = arr;   <span class="comment">//这个不是数组的赋值。事实上，这是指针的赋值。</span></span><br><span class="line"><span class="keyword">int</span> *ip2 = ip+<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = arr + sz;</span><br><span class="line"><span class="keyword">int</span> *p2 = arr + <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，给<code>arr</code>加上<code>sz</code>时，编译器自动的将它转换成指向数组<code>arr</code>中首元素的指针。执行加法操作，其实就是指针的算术运算，最后指向<code>arr</code>的第五个元素之后的位置。如果超出了这个位置，就会出错，编译器不会检查这种错误。</p>
<h3 id="下标引用"><a href="#下标引用" class="headerlink" title="下标引用"></a>下标引用</h3><ol>
<li>对于内置数组来说，执行下标运算，相当于先将数组转换为首元素的指针，然后执行数组的算术运算。如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = ia[<span class="number">2</span>];  <span class="comment">//这行代码其实相当于以下两行代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = ia;</span><br><span class="line">i = *(p+<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>除了优先级外，下标运算和间接访问（解引用）完全一样。</p>
<ol>
<li><p><strong>而且只要指针指向的是数组中的元素或者数组中尾元素的下一个位置，都可以执行下标操作。当指针指向数组尾后元素时，该位置不可访问！但是可以访问其他位置。</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>];</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>和标准库<code>string</code>，<code>vector</code>下标操作的不同之处在于，内置数组的下标操作中，，下标可以是负的，而标准<code>string</code>,<code>vector</code>中下标必须是无符号类型。</p>
</li>
</ol>
<h3 id="数组-指针"><a href="#数组-指针" class="headerlink" title="数组!=指针"></a>数组!=指针</h3><p>需要注意的是，数组和指针并不是等价的！考虑以下代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> *b;</span><br></pre></td></tr></table></figure></p>
<p><code>a</code>和<code>b</code>不能互换使用，即使它们都可以使用指针运算，可以进行间接访问和下标引用操作。它们并不一样。<br>定义一个数组时，编译器会根据声明指定的元素数量为数组保留内存空间，然后再创建数组名，它的值是一个常量，指向这段空间的起始位置。定义一个指针变量时，编译器只为指针本身保留内存空间。所以，进行了上述定义以后，<code>*a</code>合法，而<code>*b</code>不合法。</p>
<h3 id="C-中的数组和指针"><a href="#C-中的数组和指针" class="headerlink" title="C++中的数组和指针"></a>C++中的数组和指针</h3><ol>
<li>使用decltype关键字对数组进行解析时，不会将数组转换成指针，它会将识别出数组类型。使用<code>auto</code>分析数组类型时会推断出指针类型。</li>
<li>指针也是迭代器。通过数组名字或者数组首元素地址都可以得到指向数组第一个元素的指针。</li>
<li><code>begin</code>和<code>end</code>获取数组首元素指针和尾后指针。尾后指针不能执行解引用和递增操作。</li>
</ol>
<h2 id="C风格字符串"><a href="#C风格字符串" class="headerlink" title="C风格字符串"></a>C风格字符串</h2><p>C风格字符串不是一种类型，而是一种约定俗成的写法。按照约定，C风格字符串存放在数组中，并且以空字符<code>&#39;\0&#39;</code>结束。关于C风格字符串更多的内容可以查看<a href></a>。</p>
<h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><ol>
<li><p>使用列表初始化。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str2[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> str3[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>使用字符串字面值初始化。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line"><span class="comment">//编译器会隐式的在最后加一个"\0"，sizeof(str)会计算这个"\0", strlen(str)不会</span></span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这种方式是字符数组初始化的简便写法。</p>
<ol>
<li>指针和C风格字符串<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *messages= <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>对于以上三种方式来说，方式1和2是等价的，这种方式中的”helloworld”存放在栈中。而第三种有些特殊，在第三种方式中，”hello world”是一个字符串字面值常量，存放在数据区的字符串常量部分[6,7,8,9]。事实上，它是一个常量字符数组，是一个不可修改的左值[9]，把它作为右值时，会进行类型转换将左值转换成右值，即使用常量字符数组首字符的地址进行初始化。</p>
<h3 id="C风格字符串操作函数"><a href="#C风格字符串操作函数" class="headerlink" title="C风格字符串操作函数"></a>C风格字符串操作函数</h3><p>C语言标准库<code>&lt;string.h&gt;</code>或者C++版本的<code>&lt;string.h&gt;</code>提供了以下的字符串操作函数，它们的参数必须是指向以空字符结束的字符数组的指针。在函数内存不会验证这些字符串参数是否满足要求。</p>
<ul>
<li><code>strlen(p)</code>，返回p指向的字符串的长度，不包括空字符</li>
<li><code>strcmp(p1, p2)</code>，p1==p2，返回0,p1&gt;p2，返回正值，否则返回负值。</li>
<li><code>strcat(p1, p2)</code>，p2拼接到p1，返回p1</li>
<li><code>sctcpy(p1, p2)</code>，p2拷贝到p1，返回p1</li>
</ul>
<p>有一点需要注意的是，<code>p2</code>必须能够容纳下拼接后或者拷贝后的字符串，编译器不会进行检查，这需要由程序员自己进行检查。</p>
<h3 id="C风格字符串的比较"><a href="#C风格字符串的比较" class="headerlink" title="C风格字符串的比较"></a>C风格字符串的比较</h3><p>两个C风格字符串的比较，其实比较的是指针而不是字符串本身。如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str1[] = &quot;hello&quot;;</span><br><span class="line">char str2[] = &quot;world&quot;;</span><br><span class="line">if(str1 &lt; str2) //这行代码比较的不是两个字符串，而是两个指针。</span><br></pre></td></tr></table></figure></p>
<h3 id="string和C风格字符串的相互转换"><a href="#string和C风格字符串的相互转换" class="headerlink" title="string和C风格字符串的相互转换"></a><code>string</code>和C风格字符串的相互转换</h3><ol>
<li>允许使用以空字符结束的字符数组初始化<code>string</code>对象或者为<code>string</code>对象赋值。</li>
<li><code>string</code>对象的加法运算中允许使用空字符结束的字符数组作为其运算对象，不能两个都是。</li>
<li><code>string</code>对象的复合赋值运算中允许使用以空字符结束的字符数组作为其右侧运算对象。</li>
</ol>
<h4 id="string转换成C风格字符串"><a href="#string转换成C风格字符串" class="headerlink" title="string转换成C风格字符串"></a><code>string</code>转换成C风格字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world!&quot;);</span><br><span class="line">const char *str = s.c_str();</span><br></pre></td></tr></table></figure>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>多维数组指的是数组的数组。多维数组的定义方式如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];   <span class="comment">//大小为3的数组，每个元素是一个大小为4的数组</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>];    <span class="comment">//大小为10的数组，每个元素是大小为20的数组，每个数组的元素又是一个大小为30的数组。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="存储顺序"><a href="#存储顺序" class="headerlink" title="存储顺序"></a>存储顺序</h3><p>按照从右到左的维度顺序依次进行存储，实际上它们存储在了线性空间内。比如对于一个数组<code>int array[3][6]</code>，它在内存中的存储顺序其实是：<br>a[0][0], a[0][1], a[0][2], a[0][3], a[0][4], a[0][5], a[1][0], a[1][1], a[1][2], a[1][3], a[1][4], a[1][5], a[2][0], a[2][1], a[2][2], a[2][3], a[2][4], a[2][5]。</p>
<h3 id="多维数组的初始化"><a href="#多维数组的初始化" class="headerlink" title="多维数组的初始化"></a>多维数组的初始化</h3><p>使用花括号括起来的一组值初始化多维数组。</p>
<ol>
<li><p>指定所有元素的值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
<li><p>初始化一部分，其余的进行值初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>只对a[0]进行了初始化。</p>
<ol>
<li>初始化每一行的部分元素。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>只对每一行的第一个值进行了初始化。</p>
<h3 id="多维数组数组名和指针"><a href="#多维数组数组名和指针" class="headerlink" title="多维数组数组名和指针"></a>多维数组数组名和指针</h3><p>一维数组的数组名是一个指针，它的类型是指向元素类型的指针。多维数组也一样，多维数组的数组名也是一个指针，只不过它的类型是指向数组的指针。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>数组名<code>matrix</code>实际上是指向数组首元素的一个指针，数组首元素是一个<code>int [10]</code>类型的数组，所以<code>matrix</code>是一个指向<code>int [10]</code>类型数组的指针，解引用操作<code>*matrix</code>得到一个<code>int [10]</code>类型的数组，这个东西其实也是一个数组名，相当于一个指针，指向一个<code>int</code>类型。<code>*(*(matrix+1)+2)</code>其实就是<code>matrix[1][2]</code>。</p>
<h3 id="多维数组的下标"><a href="#多维数组的下标" class="headerlink" title="多维数组的下标"></a>多维数组的下标</h3><p>如果要访问多维数组中的某个元素，必须指定所有维度的下标。即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//要访问第2行的第16个元素，使用下标[1][15]。</span></span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">15</span>];</span><br></pre></td></tr></table></figure></p>
<p>但是，实际上，下标和间接引用是等价的，在多维数组中也一样。数组名<code>matrix</code>可以当成一个指针，<code>matrix +1</code>实际上指向第二个<code>int [10]</code>的数组，<code>*(matrix+1)</code>是一个<code>int [10]</code>的数组。</p>
<h3 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h3><p>在下面的代码中，<code>pa</code>是一个int指针，<code>p</code>是一个<code>int [10]</code>类型的指针，指向<code>matrix</code>的第一行的10个元素。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>], *pa = <span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>], (*p)[<span class="number">10</span>] = matrix;</span><br></pre></td></tr></table></figure></p>
<h2 id="指针数组"><a href="#指针数组" class="headerlink" title="指针数组"></a>指针数组</h2><p>我们可以创建指针的数组。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *api[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>创建了一个数组，数组有10个元素，每个元素都是一个<code>int*</code>类型的指针。可以创建一个<code>char*</code>类型的指针数组：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *keyword[] = &#123;</span><br><span class="line">    <span class="string">"do"</span>,</span><br><span class="line">    <span class="string">"while"</span>,</span><br><span class="line">    <span class="string">"if"</span>,</span><br><span class="line">    <span class="string">"for"</span>,</span><br><span class="line">    <span class="string">"return"</span>,</span><br><span class="line">    <span class="string">"switch"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以参考下面示意图：<br><img src="/2019/11/13/C-compound-type-array/char_pointer_array.jpg" alt="char_pointer_array"></p>
<h2 id="数组和左值"><a href="#数组和左值" class="headerlink" title="数组和左值"></a>数组和左值</h2><p>数组本身是一个不可修改的左值。</p>
<h2 id="字符串字面值和左值"><a href="#字符串字面值和左值" class="headerlink" title="字符串字面值和左值"></a>字符串字面值和左值</h2><p>字符串字面值常量是一个常量，不可修改的左值，它以数组的形式存储。</p>
<h2 id="为什么数组不支持赋值"><a href="#为什么数组不支持赋值" class="headerlink" title="为什么数组不支持赋值"></a>为什么数组不支持赋值</h2><ol>
<li>不支持数组的拷贝是为了避免不必要的复制开销，数组复制将会导致连续的内存读和写。</li>
<li>为什么用指针代替数组，不是因为他们太像了，而是避免赋值的开销，因为c里面只有值传递，如果对数组采用pass by value，会有很大的开销。</li>
</ol>
<h2 id="array-amp-array和-amp-array-0"><a href="#array-amp-array和-amp-array-0" class="headerlink" title="array,&amp;array和&amp;array[0]"></a><code>array</code>,<code>&amp;array</code>和<code>&amp;array[0]</code></h2><p><code>array</code>和<code>&amp;array[0]</code>是一样的，它们和&amp;array有什么区别呢？[3]<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"array=%p, &amp;array=%p\n"</span>, <span class="built_in">array</span>, &amp;<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"array+1=%p: &amp;array+1=%p\n"</span>, <span class="built_in">array</span>+<span class="number">1</span>, &amp;<span class="built_in">array</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>程序的输出如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array=0x7ffc50c541c0: &amp;array=0x7ffc50c541c0</span><br><span class="line">array+1=0x7ffc50c541c4: &amp;array+1=0x7ffc50c541d4</span><br></pre></td></tr></table></figure></p>
<p>根据上面程序的输出，<code>array</code>和<code>&amp;array</code>得到了一样的地址。但是它们并不是一样的！！！它们的地址相同，但是地址的类型不同。<br>对指针进行算术运算，将<code>array</code>和<code>&amp;array</code>都加一，我们却得到了不同的结果。事实上，<code>array</code>是指向数组第一个元素的指针，而<code>&amp;array</code>是指向整个<code>int [5]</code>数组的指针。因此，根据指针运算规则，对地址<code>array</code>和<code>&amp;array</code>进行算术运算，得到了不同的结果。</p>
<h2 id="数组和函数"><a href="#数组和函数" class="headerlink" title="数组和函数"></a>数组和函数</h2><h3 id="数组形参"><a href="#数组形参" class="headerlink" title="数组形参"></a>数组形参</h3><p>数组有两个特殊的性质：</p>
<ol>
<li>不允许拷贝，因为不能拷贝数组，所以不能以值传递的方式使用数组参数。</li>
<li>在使用数组时通常会将其转换成指针。因为数组会被转换成指针，所以为函数传递数组时，实际上传递的是指向数组首元素的指针，这样子可以节约开销。</li>
</ol>
<h3 id="管理数组转换的指针"><a href="#管理数组转换的指针" class="headerlink" title="管理数组转换的指针"></a>管理数组转换的指针</h3><p>当传递给函数一个数组时，实参自动的转成指向数组首元素的指针，数组的大小对于函数的调用没有什么影响。因为数组是以指针的形式传递给函数的，所以函数其实是不知道数组的大小的，调用者应该为此提供一些额外的信息。通常有三种方式：</p>
<ol>
<li>显示传递一个表示数组大小的形参</li>
<li>使用标记指定数组长度，要求数组本身包含一个结束标记，典型的例子是C风格字符串。</li>
<li>使用标准库规范，传递数组首元素和尾后元素的指针。可以使用<code>begin</code>和<code>end</code>函数获得数组的首元素和尾后元素的指针。</li>
</ol>
<h3 id="数组形参和const"><a href="#数组形参和const" class="headerlink" title="数组形参和const"></a>数组形参和<code>const</code></h3><p>当函数不需要对数组进行写操作时，数组形参应该是指向<code>const</code>的指针。只有当函数确实需要改变数组元素值的时候，才把形参定义成指向非常量的指针。</p>
<h3 id="数组引用形参"><a href="#数组引用形参" class="headerlink" title="数组引用形参"></a>数组引用形参</h3><p>C++允许将变量定义成数组的引用，形参也可以是数组的引用。此时，引用形参绑定到数组上。</p>
<h3 id="传递多维数组"><a href="#传递多维数组" class="headerlink" title="传递多维数组"></a>传递多维数组</h3><p>C++其实没有真正的多维数组，多维数组其实就是数组的数组。把多维数组传递给函数时，传递的是指向数组首元素的指针。而多维数组是数组的数组，首元素本身就是一个数组，多维数组转换成指向数组的指针。数组第二维以及后面维度都是数组类型的一部分，不能省略。</p>
<h2 id="函数返回值和数组"><a href="#函数返回值和数组" class="headerlink" title="函数返回值和数组"></a>函数返回值和数组</h2><p>因为数组不能被拷贝，所以函数不能返回数组。不过可以返回数组的指针或者引用。</p>
<h3 id="声明一个返回数组指针的函数"><a href="#声明一个返回数组指针的函数" class="headerlink" title="声明一个返回数组指针的函数"></a>声明一个返回数组指针的函数</h3><p>返回数组指针的函数形式如下所示：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type (*function(parameter_list)) [dimension]</span><br></pre></td></tr></table></figure></p>
<p>类似于其他数组的声明，Type表示元素的类型，dimension表示数组的大小，<code>(*function(parameter_list))</code>两端的括号必须在，否则函数的返回类型就是指针的数组。如下示例:<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p><code>func</code>带有参数，说明它是一个函数，前面带有解引用操作，说明可以对函数调用的结果执行解引用操作，括号右面说明这是一个维度为10的数组，括号左面是数组类型。</p>
<h3 id="使用尾置返回类型"><a href="#使用尾置返回类型" class="headerlink" title="使用尾置返回类型"></a>使用尾置返回类型</h3><p>可以使用尾置返回类型，任何函数的定义都能使用尾置返回，但是这种形式一般用于比较复杂的返回类型，比如数组的指针或者数组的引用。形式如下：<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">auto func() -&gt; int (*)[10];</span><br></pre></td></tr></table></figure></p>
<h3 id="使用decltype"><a href="#使用decltype" class="headerlink" title="使用decltype"></a>使用<code>decltype</code></h3><p>可以使用<code>decltype</code>声明返回值类型。比如返回一个指针时，<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> odd[] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> even[] = &#123;<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">decltype</span>(odd) *func(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (i%<span class="number">2</span>)? &amp;odd: &amp;even;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h2><p>1.《C++ Primer第五版》<br>2.<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer" target="_blank" rel="noopener">https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer</a><br>3.<a href="https://www.geeksforgeeks.org/whats-difference-between-array-and-array-for-int-array5/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/whats-difference-between-array-and-array-for-int-array5/</a><br>4.<a href="https://stackoverflow.com/questions/3437110/why-do-c-and-c-support-memberwise-assignment-of-arrays-within-structs-but-not/3439969" target="_blank" rel="noopener">https://stackoverflow.com/questions/3437110/why-do-c-and-c-support-memberwise-assignment-of-arrays-within-structs-but-not/3439969</a><br>5.<a href="https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type" target="_blank" rel="noopener">https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type</a><br>6.<a href="https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s" target="_blank" rel="noopener">https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s</a><br>7.<a href="https://stackoverflow.com/questions/2938895/difference-between-char-a-string-char-p-string" target="_blank" rel="noopener">https://stackoverflow.com/questions/2938895/difference-between-char-a-string-char-p-string</a><br>8.<a href="http://c-faq.com/decl/strlitinit.html" target="_blank" rel="noopener">http://c-faq.com/decl/strlitinit.html</a><br>9.<a href="https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-getline-vs-C-getline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-getline-vs-C-getline/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">C getline vs C++ getline</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 13:11:10" itemprop="dateCreated datePublished" datetime="2019-11-13T13:11:10+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:14:11" itemprop="dateModified" datetime="2019-12-17T15:14:11+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="getline-in-c">getline in C</h2>
<h3 id="原型">原型</h3>
<p>使用<code>man getline</code>可以看到UNIX提供的库函数<code>getline</code>的原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> getline(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream);</span><br><span class="line"><span class="keyword">ssize_t</span> getdelim(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, <span class="keyword">int</span> delim, FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="性质">性质</h3>
<ol>
<li><code>getline()</code>从stream中读入一整行，</li>
<li>如果<code>*lineptr</code>设置为NULL并且<code>*n=0</code>，<code>getline()</code>会分配一个buffer存储读入的line。这个buffer应该被用户程序释放，即使<code>geline()</code>失败了。</li>
<li>如果<code>*lineptr</code>包含一个指针，大小是<code>*n</code>字节。当buffer不能存下读入的line时，<code>getline()</code>会使用<code>realloc(3)</code>对buffer进行resize，更新<code>*lineptr</code>和<code>*n</code>。</li>
<li>只要成功调用，<code>*lineptr</code>和<code>*n</code>分别表示的是buffer的地址和分配的内存大小。</li>
<li><code>getdelim()</code>和<code>getline()</code>一样，只不过可以指定一个delimiter而不是使用newline作为delimiter。任何delimiter都会存进<code>*lineptr</code>中。</li>
<li>为什么<code>getline</code>需要的是<code>char**</code>而不是<code>char*</code>，因为<code>getline</code>在lineptr指向的空间不足时，重新分配内存，如果使用的是<code>char*</code>的话，当<code>getline</code>重新分配内存后，我们就失去了对<code>line</code>的访问，而使用一个<code>char**</code>类型的字符串，使用一个<code>char**</code>类型，即指针的指针记录每次分配的<code>char*</code>。[3]。</li>
</ol>
<h2 id="getline-in-c-v2">getline in C++</h2>
<h3 id="cin-getline">cin.getline</h3>
<p><code>cin.getline()</code>是操作C strings，即字符数组的。不会将<code>'\n'</code>读入。</p>
<h3 id="std-getline">std::getline</h3>
<ol>
<li><code>std::getline()</code>是操作C++ strings的，即<code>std::string</code>。</li>
<li><code>std::getline()</code>从input stream中读一个string，遇到delimiter就停止，默认的delimiter是<code>'\n'</code>。即使输入开始就是delimiter也会停止。</li>
<li><code>std::getline()</code>会把delimiter也读进来，然后把读到的内容存到<code>string</code>对象中去，存入的内容不包含delimiter。</li>
</ol>
<h2 id="代码示例">代码示例</h2>
<h3 id="getline">getline</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    FILE *stream = <span class="built_in">stdin</span>;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread = getline(&amp;line, &amp;len, stream)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Retrieved line of length %zu:\n"</span>, nread);</span><br><span class="line">        fwrite(line, nread, <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getdelim">getdelim</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    FILE *stream = <span class="built_in">stdin</span>;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">int</span> delim = <span class="string">','</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread = getdelim(&amp;line, &amp;len, delim, stream)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Retrieved line of length %zu:\n"</span>, nread);</span><br><span class="line">        fwrite(line, nread, <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/4872361/why-are-there-two-different-getline-functions-if-indeed-there-are" target="_blank" rel="noopener">https://stackoverflow.com/questions/4872361/why-are-there-two-different-getline-functions-if-indeed-there-are</a><br>
2.<a href="https://www.reddit.com/r/learnprogramming/comments/4fx64h/is_there_a_difference_between_cingetline_and/" target="_blank" rel="noopener">https://www.reddit.com/r/learnprogramming/comments/4fx64h/is_there_a_difference_between_cingetline_and/</a><br>
3.<a href="https://stackoverflow.com/questions/5744393/why-is-the-first-argument-of-getline-a-pointer-to-pointer-char-instead-of-c/36098042" target="_blank" rel="noopener">https://stackoverflow.com/questions/5744393/why-is-the-first-argument-of-getline-a-pointer-to-pointer-char-instead-of-c/36098042</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/12/C-exit-and-return/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/12/C-exit-and-return/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">C/C++ exit and return</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-12 13:51:20" itemprop="dateCreated datePublished" datetime="2019-11-12T13:51:20+08:00">2019-11-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:01:53" itemprop="dateModified" datetime="2019-12-17T15:01:53+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进程终止">进程终止</h2>
<p>总共有八种方式可以让进程终止，包括五种正常终止和三种异常终止，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回，相当于调用<code>exit</code>。</li>
<li>调用<code>exit</code>，ISO C定义的，它的操作包括调用各个exit handler，处理所有标准I/O流。</li>
<li>调用<code>_exit</code>或者<code>_Exit</code>，ISO C定义了<code>_Exit</code>，而POSIX.1说明了<code>_exit</code>。它的目的是提供一种无需运行exit handler或者信号处理程序而终止的方法。是否对标准I/O流进行flush，取决于实现。在UNIX中，<code>_Exit</code>和<code>_exit</code>是同义的，并不flush I/O流。</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程以哪种方式终止，最后都会执行内核中的同一段代码，这段代码为相关进程关闭所有打开的文件描述符，释放它使用的内存。<br>
为了让终止进程能够通知父进程它是如何终止的。对于3个终止函数(<code>exit</code>, <code>_exit</code>, <code>_Exit</code>)，将它们的<code>exit status</code>作为参数传递给函数。在异常终止的情况下，内核产生一个指示其异常终止原因的terminaiton status（终止状态）。在任意终止情况下，这个终止进程的父进程都能用<code>wait</code>或者<code>waitpid</code>函数获得它的终止状态。<br>
<strong>如果父进程在子进程之前终止</strong>，那么对于父进程终止的所有进程，它们的父进程都变成<code>init</code>进程，终止状态返回到<code>init</code>进程。具体是怎么操作：对于一个即将终止的进程，内核检查所有活动进程，判断其中是否有待终止进程的子进程，如果有的话，将这些进程的父进程的ID改为<code>init</code>进程的ID 1。<br>
<strong>如果子进程在父进程之前终止</strong>，那么父进程是无法获取它的终止状态的。内核为每一个终止进程保留了一部分信息，当终止进程的父进程调用<code>wait</code>或者<code>waitpid</code>时，可以获取这些信息，这些信息包含终止进程PID，进程的终止状态，进程占用的CPU时间总量。内核可以释放这些进程的内存，关闭打开的文件。如果一个进程终止了，但是它的父进程没有等待它，它被称为一个zombie（僵尸）进程。如果一个长期运行的进程，<code>fork</code>了很多子进程，除非父进程等到取得子进程的终止状态，要不它们就会变成僵尸进程。<strong>当父进程结束时，僵尸进程就会结束？？？</strong><br>
<code>init</code>的子进程，不会变成僵尸进程，因为<code>init</code>进程被编写成无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数获得其终止状态。</p>
<h3 id="exit和-exit函数"><code>exit</code>和<code>_Exit</code>函数</h3>
<h4 id="c11标准定义">C11标准定义</h4>
<p><code>exit</code>定义在<code>&lt;stdlib.h&gt;</code>头文件中</p>
<blockquote>
<p>void exit( int exit_code ); (until C11)<br>
_Noreturn void exit( int exit_code );(since C11)<br>
Causes normal program termination to occur.<br>
Several cleanup steps are performed:</p>
</blockquote>
<ul>
<li>functions passed to atexit are called, in reverse order of registration（调用atexit注册的函数）</li>
<li>all C streams are flushed and closed （冲洗C的缓冲区，不是不关闭流吗？？？）</li>
<li>files created by tmpfile are removed  (删除临时文件）</li>
<li>control is returned to the host environment. If exit_code is zero or EXIT_SUCCESS, an implementation-defined status, indicating successful termination is returned. If exit_code is EXIT_FAILURE, an implementation-defined status, indicating unsuccessful termination is returned. In other cases implementation-defined status value is returned.（将控制权返还给操作系统。）</li>
</ul>
<p><code>-Exit</code>定义在<code>&lt;stdlib.h&gt;</code>头文件中</p>
<blockquote>
<p>void _Exit( int exit_code ); (since C99) (until C11)<br>
_Noreturn void _Exit( int exit_code );(since C11)<br>
Causes normal program termination to occur without completely cleaning the resources.<br>
Functions passed to at_quick_exit() or atexit() are not called. Whether open streams with unwritten buffered data are flushed, open streams are closed, or temporary files are removed is implementation-defined. （不调用atexit注册的函数，是否冲洗缓冲区，关闭打开的stream和删除临时文件是由实现定义的，UNIX都不做这些操作）<br>
If exit_code is 0 or EXIT_SUCCESS, an implementation-defined status indicating successful termination is returned to the host environment. If exit_code is EXIT_FAILURE, an implementation-defined status, indicating unsuccessful termination, is returned. In other cases an implementation-defined status value is returned.</p>
</blockquote>
<h4 id="性质">性质</h4>
<ol>
<li><code>exit</code>和<code>_Exit</code>是ISO C的内容，而<code>_exit</code>是POSIX.1的内容。</li>
<li>它们都用于正常终止一个程序，<code>_Exit</code>和<code>_exit</code>立刻进入内核，<code>_Exit</code>和<code>_exit</code>是否冲洗缓冲区是由实现定义的，UNIX上选择不冲洗。而<code>exit</code>先执行一些清理操作，然后返回内核，<code>exit</code>函数首先调用<code>atexit</code>函数登记的终止处理程序，然后冲洗标准I/O流，现代的<code>exit</code>实现都不会关闭标准I/O流，之前的一些实现还会关闭标准I/O流，这在调用<code>vfork</code>的时候可能会出现问题，还会删除临时文件。</li>
<li>三个退出函数都需要一个整形的参数，被称为exit status。</li>
<li>如果满足以下条件：
<ul>
<li>调用这三个函数不带终止状态</li>
<li><code>main</code>执行了一个不带返回值的<code>return</code>语句</li>
<li><code>main</code>没有声明返回类型为整形，进程的终止状态是未定义的。<br>
那么这个进程的终止状态是未定义的。</li>
</ul>
</li>
<li><code>main</code>返回返回一个整型值和用该值调用<code>exit</code>是等价的。对于某些C编译器和UNIX lint(1)程序来说，会产生警告信息，因为这些编译器并不了解<code>main</code>中的<code>return</code>和<code>exit</code>的作用是相同的。避开这种警告信息的一种方法是在<code>main</code>中使用<code>return</code>而不是<code>exit</code>，这样做的结果是UNIX grep命令无法找出程序中所有的<code>exit</code>调用。另一个方法是将<code>main</code>声明为<code>void</code>而不是<code>int</code>，然后调用<code>exit</code>，但是这不并不是标准，ISO C和POSIX.1定义<code>main</code>的返回值应当是带符号整形。</li>
</ol>
<h4 id="函数原型">函数原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h3 id="atexit"><code>atexit</code></h3>
<h4 id="c11标准定义-v2">C11标准定义</h4>
<blockquote>
<p>Registers the function pointed to by func to be called on normal program termination (via exit() or returning from main()). The functions will be called in reverse order they were registered, i.e. the function registered last will be executed first.<br>
The same function may be registered more than once.<br>
atexit is thread-safe: calling the function from several threads does not induce a data race.<br>
The implementation is guaranteed to support the registration of at least 32 functions. The exact limit is implementation-defined.</p>
</blockquote>
<h4 id="性质-v2">性质</h4>
<p>每个进程可以通过<code>atexit</code> register至多32个由<code>exit</code>自动调用的函数，这些函数被称为exit handler（终止处理程序）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>atexit</code>的参数是一个函数地址，不会有返回值</li>
<li><code>exit</code>调用<code>atexit</code> register的程序的顺序和使用<code>atexit</code>进行register的顺序相反。</li>
<li>ISO C和POSIX.1标准规定，<code>exit</code>首先调用各个exit handler，然后使用<code>fclose</code>关闭所有标准I/O流。</li>
<li>POSIX.1对ISO C进行了扩展，如果程序调用了任何<code>exec</code>函数，清除exit handler。</li>
<li>内核执行一个程序的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一办法是显式或者隐式的（通过<code>exit</code>）调用<code>_exit</code>和<code>_Exit</code>。</li>
</ol>
<h2 id="return"><code>return</code></h2>
<h2 id="return和exit"><code>return</code>和<code>exit</code></h2>
<ol>
<li><code>return</code>是C/C++语言的关键字，是语言级别的；而<code>exit()</code>是一个函数，它是对系统调用<code>_exit()</code>的封装，是系统调用层次的。</li>
<li><code>return</code>结束一个函数的执行；而<code>exit()</code>结束一个进程，删除进程使用的内存空间，并且将应用程序的一个状态返回给OS，这个状态标识了进程的运行信息。</li>
<li><code>exit(0)</code>表示正常运行程序并退出程序，<code>exit(1)</code>表示非正常运行导致退出程序；<code>return 0</code>和<code>retrun 1</code>能够起类似的作用。</li>
<li>对于我们自定的函数，可以return给操作系统，交给相关的处理程序调用exit或者程序自身直接调用exit。</li>
</ol>
<h3 id="c-中的区别">C++中的区别</h3>
<p>在C++中，退出程序时，<code>exit</code>并不会调用局部非静态对象的析构函数，而<code>return</code>会调用局部非静态对象的析构函数。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main" target="_blank" rel="noopener">https://stackoverflow.com/questions/461449/return-statement-vs-exit-in-main</a><br>
2.<a href="https://www.geeksforgeeks.org/return-statement-vs-exit-in-main/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/return-statement-vs-exit-in-main/</a><br>
3.<a href="https://www.zhihu.com/question/26591968/answer/33839473" target="_blank" rel="noopener">https://www.zhihu.com/question/26591968/answer/33839473</a><br>
4.<a href="https://www.zhihu.com/question/26591968/answer/33330774" target="_blank" rel="noopener">https://www.zhihu.com/question/26591968/answer/33330774</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/12/UNIX-system-call-vs-library-call/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/12/UNIX-system-call-vs-library-call/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">UNIX system call vs library call</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-12 13:01:01" itemprop="dateCreated datePublished" datetime="2019-11-12T13:01:01+08:00">2019-11-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:49:18" itemprop="dateModified" datetime="2019-12-17T15:49:18+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="系统调用-system-call-和库函数-library-function">系统调用(system call)和库函数(library function)</h2>
<h3 id="系统调用">系统调用</h3>
<p>所有的操作系统都提供多种服务的入口点，通过这些入口点向内核请求服务，这些入口点被称为系统调用(system call)。系统调用处于kernel mode，一些任务只能在kernel mode运行。比如和硬件的交互，系统调用使得用户mode的进程可以通过系统调用进入kernel mode，从而实现和硬件的交互。。<br>
系统调用接口可以在man的第二部分查看，它是用C语言定义的，与具体系统如何调用一个系统调用的实现技术无关。这些和早期的操作系统按照传统方式用机器的汇编语言定义内核入口点。<br>
UNIX使用的方法是为每个系统调用在标准C库中设置一个同名函数。用户进程使用标准C调用相应的函数，这些函数又根据系统调用调用相应的内核服务。</p>
<h3 id="库函数">库函数</h3>
<p>库函数可以在man手册的第三部分查看，第三部分定义了程序员可以使用的通用库函数。库函数可以调用系统调用，也可以不调用系统调用，比如<code>read</code>函数会调用系统调用，而<code>atoi</code>等并不使用任何系统调用。</p>
<h3 id="系统调用和库函数之间的关系">系统调用和库函数之间的关系</h3>
<ol>
<li>从实现角度来看，系统调用和库函数有着根本的区别，系统调用处于内核mode，库函数属于用户mode。</li>
<li>从用户应用角度考虑，可以把系统调用看做C函数，使用系统调用还是库函数不重要，它们都是为应用程序提供服务的。</li>
<li>C函数只是系统调用和库函数的一种实现，系统调用和库函数都可以以其他方式实现。</li>
<li>系统调用通常只是提供一种最小接口，而库函数实现更复杂的功能。</li>
<li>库函数可以被替换，但是系统调用通常是不能替换的。</li>
<li>库函数可以调用系统调用，也可以不调用系统调用。</li>
<li>应用程序既可以调用库函数也可以调用系统调用。</li>
<li>进程控制系统调用(fork, exec和wait)等通常由应用程序直接调用。为了简化一些常见情况，UNIX也提供了一些库函数，如system和popen。</li>
<li>库函数链接到用户程序，在user space执行，而syste call没有链接到用户程序，在kernel space执行</li>
<li>库函数的执行时间被计算为user level time，而system call的执行事件算作system time的一部分。</li>
<li>库函数可以简单的进行debug，而系统调用不能debug，因为它们被kernel执行。</li>
</ol>
<p>对于第4条，可以考虑以下例子：<br>
sbrk(2)是分配存储空间的UNIX系统调用，它按照指定字节数增加或者减少进程地址空间。如何管理进程的地址空间由进程决定。<br>
malloc(3)是公用函数库中的一个存储分配空间函数，它负责进行进程的存储地址管理。<br>
我们可以自己实现一个malloc，但是它很有可能还要使用sbrk(2)。内核中的系统调用ssbrk是系统层面的空间分配，而库函数malloc是在用户层面进行操作。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://www.thegeekstuff.com/2012/07/system-calls-library-functions/" target="_blank" rel="noopener">https://www.thegeekstuff.com/2012/07/system-calls-library-functions/</a><br>
3.<a href="https://stackoverflow.com/questions/29816791/what-is-the-difference-between-system-call-and-library-call" target="_blank" rel="noopener">https://stackoverflow.com/questions/29816791/what-is-the-difference-between-system-call-and-library-call</a><br>
4.<a href="https://unix.stackexchange.com/questions/6931/what-is-the-difference-between-a-library-call-and-a-system-call-in-linux" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/6931/what-is-the-difference-between-a-library-call-and-a-system-call-in-linux</a><br>
5.<a href="https://unix.stackexchange.com/questions/57232/difference-between-system-calls-and-library-functions" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/57232/difference-between-system-calls-and-library-functions</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/12/C-main-argc-argv/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/12/C-main-argc-argv/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/5/index.html">C/C++ main argc argv</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-12 00:43:21" itemprop="dateCreated datePublished" datetime="2019-11-12T00:43:21+08:00">2019-11-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:09:33" itemprop="dateModified" datetime="2019-12-17T15:09:33+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="main函数">main函数</h2>
<p><code>main</code>函数是C语言和C++ 程序的入口，C和C++ 的标准要求它们的实现必须支持以下两种形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;...&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span>&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>任何C和C++ 库实现都必须实现以上两种形式的<code>main</code>，除此以外，可以根据标准进行其他扩展实现，但是这样子可能在一个平台上能运行的程序在另一个平台上不能运行，即除了标准的两种<code>main</code>，其他扩展都是不可移植的。<br>
需要注意的一点是，C和C++ 标准对于<code>main</code>的扩展有要求，C++ 标准要求所有的<code>main</code>都必须返回<code>int</code>类型，只有它们的参数可以改变。而C要自由一些，可以有<code>void main(char, dobule)</code>的实现，但是在C++ 标准中这是不支持的。<code>int main(int ,char*, char**)</code>在C和C++ 标准中都是允许的。</p>
<h2 id="main函数示例">main函数示例</h2>
<p>假设有一个名为prog的可执行文件，其中包含一个<code>main</code>函数，可以通过命令行选项向程序传递参数：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">prog -d -o file data0</span><br></pre></td></tr></table></figure>
<p>这些参数通过两个形参<code>argc</code>和<code>argv</code>传递给<code>main</code>函数。形参<code>argv</code>是一个数组，数组元素是字符串指针，即<code>argv</code>是一个C风格字符串指针数组。而<code>argc</code>表示的是字符串数组的长度。<br>
当一个实参传递给<code>main</code>函数之后，<code>argv</code>的第一个元素指向程序的名字或者一个空字符串，接下来的元素依次存放命令行提供的实参。最后一个指针指向的元素应该保证为0。<br>
注意，当使用<code>argv</code>中的实参时，注意<code>argv[0]</code>保存的是程序名字或者空字符串，可选的实参从<code>argv[1]</code>开始。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.<a href="https://stackoverflow.com/questions/9554513/c-main-vs-c-main" target="_blank" rel="noopener">https://stackoverflow.com/questions/9554513/c-main-vs-c-main</a><br>
3.《你必须知道的495个C语言问题》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/4/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><span class="space">&hellip;</span><a class="page-number" href="/page/30/">30</a><a class="extend next" rel="next" href="/page/6/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">300</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">22</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">68</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
