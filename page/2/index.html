<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/2/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/29/Network-常见面试题目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/29/Network-常见面试题目/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">Network 常见面试题目</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-29 21:44:42" itemprop="dateCreated datePublished" datetime="2020-02-29T21:44:42+08:00">2020-02-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-21 11:05:25" itemprop="dateModified" datetime="2020-04-21T11:05:25+08:00">2020-04-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="套接字">套接字</h2>
<p>套接字是一个同一台主机内应用层和网络层之间的接口。由于套接字是在网络上建立网络应用程序的可编程接口，所以也把套接字称为应用程序和网络之间的应用编程接口。</p>
<p>一个UDP套接字是由目的IP地址和目的端口号标识的二元组。两个UDP报文段，只要目的IP地址和目的端口号一样，不论源IP地址和端口号是否一样，都被定向到相同的目的进程。<br>
一个TCP套接字是由源IP地址，源端口号，目的IP地址，目的端口号构成的四元组。所有的这四元组都被用来进行多路分解。</p>
<h2 id="常见应用层协议">常见应用层协议</h2>
<p>DNS<br>
FTP<br>
HTTP<br>
SMTP</p>
<h2 id="http">HTTP</h2>
<h3 id="http请求报文段">HTTP请求报文段</h3>
<p>HTTP包含一行请求行和多行首部行。<br>
请求行有三个字段：方法字段，URL字段，HTTP协议版本字段。<br>
方法字段有GET，POST，HEAD，PUT和DELETE。</p>
<ol>
<li>Host，目标主机。</li>
<li>Connection，浏览器告诉服务器不希望使用持久连接。</li>
<li>User-agent，浏览器。</li>
<li>Accept-language</li>
</ol>
<h3 id="http响应报文段">HTTP响应报文段</h3>
<p>一个状态行和6个首部行，然后是报文实体。<br>
状态行：<br>
协议版本，状态码和相应状态信息。<br>
6个首部行：</p>
<ol>
<li>Connection，不适用持久链接。</li>
<li>Date，服务器产生发送报文的时间。</li>
<li>Server，服务器类型。</li>
<li>Last-Modified，对象创建或者修改的最后日期。</li>
<li>Content-Length，发送内容的长度。</li>
<li>Content Type，发送内容的类型。</li>
</ol>
<h3 id="http状态码-3-4-5">HTTP状态码[3,4, 5]</h3>
<p>1xx信息<br>
2xx成功<br>
200 OK 请求成功<br>
201 Created 当服务器按照客户端的的请求创建了一个新的资源时，发送此响应代码。<br>
204 No Content。服务端拒绝对PUT，POST或者DELETE请求返回任何状态信息。返回空文件替换缓存。而304是使用上次的缓存。<br>
3xx 重定向，客户端需要做一些额外的工作才能得到所需要的资源，他们通过用于GET请求。<br>
301 Moved Permanently 服务器知道客户端请求的资源，但是不喜欢客户端使用当前URL。<br>
302 Found。临时性重定向。不是永久性移动，而是临时性移动。比如说用户把uri保存为书签，出现301时，书签会被更新，出现302时不会。。<br>
303 See Other。请求已经被处理，但是服务器返回的不是文档，是一个URI。和302功能一样，但是303明确表示客户端应该使用GET方法获取资源。<br>
304 Not modified。客户端有数据主题，不需要重复发送。<br>
307 Temporary Redict。临时性重定向，和302有着相同的意思。但是不会将POST修改成GET。<br>
301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，删除请求体，再次发送请求。尽管301,302是禁止将POST改成GET的，但是大家都会这么做。<br>
4xx表示客户端错误<br>
400 Bad Request，服务器收到了请求，但是不知道什么意思。<br>
401 请求要求用户的身份认证，而客户端认证失败。<br>
403 客户端的请求正确，但是服务端拒绝此请求，暗示了请求的资源确实存在。<br>
404 Not Found，服务器无法把客户端请求的URI转换为一个资源。<br>
405 客户端中请求的方法被禁止<br>
5xx表示服务器错误<br>
500 Internal Server Error对于大多数web框架，如果在执行请求处理代码时遇到了异常，就发送此代码。<br>
502 bad gateway<br>
503 Service Unavaiable，服务器当前不能处理处理客户端的请求，可能一会就好了。<br>
505 HTTP Version Not Support</p>
<h3 id="get和post区别">GET和POST区别</h3>
<ol>
<li>GET是安全的，POST是不安全的。</li>
<li>GET是幂等的，POST是不幂等的。</li>
<li>GET是可缓存的，POST通常是不可缓存的。</li>
</ol>
<p>GET一般是请求服务器的指定资源，是安全，幂等，可缓存的。而post一般是根据请求的payload对指定的资源机械能给你处理，POST是不安全的，不幂等的，不可缓存的。</p>
<p>其他：</p>
<ol>
<li>GET会把请求的数据会放在URL后面，而POST把请求的数据放在body中。注意，GET的body也可以存放request body，这是针对于接口来说的。</li>
<li>GET请求提交的url数据最多是1024字节是浏览器或者服务器限制的，而post则没有限制。</li>
<li>GET和POST都不安全，HTTP本身是明文协议，无论是url,header还是body，都是在网络中明文传播的。只不过url中的数据是可以在浏览器中直接看到的，而header和body中的数据更麻烦一些，需要使用抓包软件查看。</li>
<li>但是GET的效率要比post高。</li>
</ol>
<h3 id="https和http-2">HTTPS和HTTP[2]</h3>
<p>HTTP协议是明文协议，TCP和UDP也没有加密。于是就有了SSL，利用非对称密码体系对发送的数据进行加密。<br>
HTTPS是在TCP连接之后由客户端发起的。其实使用到了对称加密技术和非对称加密技术。</p>
<ol>
<li>客户端发送一个Client Hello给服务器，包含一个随机数，以及客户端支持的加密条件和SSL版本。</li>
<li>服务端回应一个Server Hello给客户端，服务器选定一组加密套件，然后和第二个随机数，以及服务器的证书（包含服务器的公钥和名字）一块发送给客户端。服务器是由CA机构发送到，一个大家都信任的机构。</li>
<li>客户端验证服务端的证书的真实性。（使用CA的数字证书，服务端的证书含有CA对服务器信息的签名，然后客户端使用CA证书中的公钥对服务端的数字证书进行验证签名，验证签名即使用相同的摘要算法对服务器的信息进行摘要，然后和CA证书的签名对比。）<br>
验证成功之后，生成第三个随机数，使用服务端的公钥对这个随机数加密生成PreMaster Key，然后发送给服务端。</li>
<li>服务端用自己的私钥解密生成PreMaster Key。这个时候，两边都拥有三个随机数，使用相同的算法生成一个秘钥。之后的通信都使用这个秘钥进行。</li>
</ol>
<h3 id="输入www-baidu-com发生的一切">输入www.baidu.com发生的一切</h3>
<ol>
<li>用户输入网址。</li>
<li>DNS解析。一般情况下，本机是会知道DNS服务器的IP地址的。递归查询和迭代查询获得目的主机的IP地址。一般是在同一个局域网内，通过ARP请求，查询对应的DNS服务器的MAC地址，然后把请求包发给它。[8]</li>
<li>TCP连接。三次握手。</li>
<li>发送请求。</li>
<li>接收HTTP相应报文</li>
<li>浏览器渲染。</li>
</ol>
<h3 id="cookie">Cookie</h3>
<p>Cookie用户和服务器的交互。因为HTTP是无状态的，简化了服务器的设计。当想要识别用户的时候，可能限制用户的访问或者想把用户和内容关联起来。HTTP使用了cookie：<br>
cookie有四个部分：</p>
<ol>
<li>HTTP响应报文中有一个cookie首部行。</li>
<li>HTTP请求报文中有一个cookie首部行。</li>
<li>用户端系统有保留一个cookie文件。</li>
<li>Web站点后台有一个cookie数据库。</li>
</ol>
<h3 id="web缓存">Web缓存</h3>
<p>Web缓存器也叫代理服务器，它有自己的磁盘存储空间，并在自己的磁盘存储空间中保存最近请求过的对象拷贝。<br>
然后可以配置浏览器，将用户的所有HTTP请求首先指向Web缓存器，一旦配置了浏览器，每个浏览器对象的请求首先被定向到Web缓存器。</p>
<ol>
<li>浏览器建立一个到Web缓存器的TCP连接，并发送一个HTTP请求。</li>
<li>Web缓存器检查缓存是命中。</li>
<li>命中的话，Web缓存器向发送一个条件GET，查询Last-modified。</li>
<li>没有命中的话，Web缓存器请求该对象，并将其缓存。</li>
<li>Web缓存器向客户机浏览器发送报文。</li>
</ol>
<h2 id="tcp和udp的选择">TCP和UDP的选择</h2>
<p>DNS通常采用UDP，因为TCP需要建立连接，会引入建立TCP连接的时延，这样子会慢得多。如果没有收到响应，就会向另一台DNS服务器发送查询，或者通知调用的程序它不能获得响应。[9]<br>
而HTTP使用TCP而不是UDP，因为web网页需要的是可靠性。</p>
<h2 id="udp">UDP</h2>
<p>UDP相对于TCP的优势：</p>
<ol>
<li>应用层能更好的控制要发送的数据和发送时间。</li>
<li>无需连接建立。</li>
<li>无连接状态。</li>
<li>分组首部开销小。TCP报文段有20字节的首部开销，而UDP只有8字节的开销。</li>
</ol>
<h3 id="udp报文段结构">UDP报文段结构</h3>
<p>UDP报文段的首部共8个字节，64位，每个字段8位，共4个字段，：</p>
<ol>
<li>16位源端口号</li>
<li>16位目的端口号</li>
<li>16位长度字段，长度字段包含了首部在内的UDP报文段的长度（以字节为单位）。</li>
<li>16位检验和</li>
</ol>
<h3 id="udp校验和">UDP校验和</h3>
<ol>
<li>UDP校验和提供了差错检测功能，但是不能进行差错恢复。为什么UDP校验和work？</li>
<li>为什么要进行差错校验？链路中可能出错，内存中也可能出错。UDP必须在端到端基础上在运输层提供差错校验。</li>
<li>出错后如何处理。一些实现是丢弃受损的报文段，一些是将受损的报文段交给应用程序并告警。</li>
</ol>
<h2 id="可靠数据传输原理">可靠数据传输原理</h2>
<h3 id="停止等待协议">停止等待协议</h3>
<p>为了解决分组可能出错的情况，引入<strong>自动重传请求</strong>。自动重传请求协议需要另外三种协议：差错检验，接收方反馈和重传。<br>
当一个分组到达时可能出错，接收方进行进行<strong>差错校验</strong>，如果出错，发送一个NAK给发送方。如果没有失败，发送一个ACK给接收方。<br>
直到发送方确定接收方已经收到当前分组之后（收到一个ACK），才会继续发送新数据，这就是<strong>停止等待协议</strong>。如果收到一个NAK，就会重传当前分组。（<strong>接收方反馈</strong>）<br>
但是ACK和NAK也可能出错或者丢失，通过引入<strong>重传</strong>解决这个问题。<br>
到底什么时候重传呢？等待一个RTT太久了，可以使用一个定时器设置一个时间，超过这个时间就重传。<br>
这样子在接收方引入了冗余分组的问题。冗余分组的问题在于不知道接收方发送的ACK或者NAK是否被发送方接收，或者是分组没有丢失，等到了一段时间又到了。接收方不知道接收到的分组到底是哪一个，是重发的分组还是新的分组。可以通过引入分组序号解决这个问题。在停止等待协议中，一个比特的分组序号就够了。<strong>所以也叫比特交替协议</strong>。</p>
<h3 id="流水线可靠数据传输协议">流水线可靠数据传输协议</h3>
<p>停止等待协议的效率太低了。流水线可靠数据传输协议不是一次只发一个分组，而是一次发送多个分组，就好像一条流水线一样。这就产生了几个问题：</p>
<ol>
<li>必须增加序号范围，原来只要一个比特就够了，现在需要多个。</li>
<li>协议的发送方和接收方也必须能够缓存多个分组。</li>
<li>流水线中如果分组丢失了，有两种方式进行差错恢复，回退N步（GBN）和选择重传（SR）。</li>
</ol>
<h3 id="回退n步">回退N步</h3>
<p>GBN的发送方要处理是三个工作，准备N个分组，处理接收方返回的ACK，以及超时重传。<br>
GBN的接收方要处理的工作，只有接收到的分组的序号和上一次相同，会返回给发送方一个ACK，GBN采用<strong>累计确认</strong>（对序号n的分组的确认表明接收方已经正确接收到n以及n之前的分组了）。所有其他情况，都会丢弃分组。比如失序分组，接收方应该接收序号为n的分组，但是收到了序号为n+1的分组，就会丢弃，而不是缓存。</p>
<p>GBN维护一个大小为N的窗口。对于发送方，维护一个大小为N的窗口，如果这N个分组的ACK都没有收到，就不会发送新的数据，等待接收方返回ACK。发送方还有超时设置，（发送方发送的分组丢了，或者接收方返回的ACK丢了），都会重传。</p>
<h3 id="选择重传">选择重传</h3>
<p>GBN有时候会效率太低，因为一个分组丢失，可能导致重传整个N个分组。选择重传可以用来解决这种问题。</p>
<h2 id="tcp">TCP</h2>
<h3 id="tcp累计确认和gbn-选择重传之间的关系">TCP累计确认和GBN，选择重传之间的关系</h3>
<p>GBN是滑动窗口协议，虽然也提供累计确认，但是它不会缓存失序报文，会把它们全部丢弃。假设序号为n的报文段丢失了，然后需要发送方重传n之后的所有报文。而TCP的发送方至多只会重传一个报文段，如果TCP接收方接收到了<br>
选择重传对失序报文进行缓存，但是没有提供累计确认。</p>
<h3 id="可靠数据传输">可靠数据传输</h3>
<p>TCP发送方有三个与发送和重传有关的主要事件：</p>
<ol>
<li>数据处理。TCP从发送缓存重拿数据，加上TCP首部，传递给IP层。然后传递给网络，TCP接收方的接收缓存获取数据。</li>
<li>超时。<br>
通过重传引发超时的报文响应超时时间。如果多次超时的话，就倍增超时时间间隔。<br>
冗余ACK触发<strong>快速重传</strong>（为什么发送方收到三个冗余ACK就立即快重传）。冗余ACK是对按序接收到的最后一个字节数据进行重复确认。</li>
<li>ACK处理。如果收到的ACK是窗口的最小未确认序号，那么修改窗口的最小未确认序号。</li>
</ol>
<h3 id="三次握手">三次握手</h3>
<ol>
<li>A向B发送一个SYN报文段，并且包含自己的初始序列号。</li>
<li>B向A发送一个SYNACK报文段，并且包含自己的初始序列号。同时分配连接缓存，变量等。</li>
<li>A向B发送一个ACK报文段，不是SYN报文段。</li>
</ol>
<h3 id="为什么要随机初始化一个报文段序号">为什么要随机初始化一个报文段序号</h3>
<p>减少上次TCP连接中的报文段被当做两台主机之间新的TCP连接中的报文段。</p>
<h3 id="为什么是三次握手而不是两次或者四次">为什么是三次握手而不是两次或者四次</h3>
<p>其实是四次挥手，只不过第二次和第三次可以合并起来了。三次挥手的目的是确立TCP双方都能获得对方的初始序号。<br>
为什么不是两次？如果A向B发送一个请求，B回应一个请求。而B的回应丢了，A就无法和B进行通信。如果设计成A重传，那么可能会建立很多个连接。如果设计成B重传，为什么要B重传？不是两次握手吗？他怎么知道要重传。这些都是如果设计成两次握手需要考虑的问题。<br>
对于三次握手来说，如果</p>
<ol>
<li>A发给B的丢了，A超时重传。</li>
<li>B发给A的丢了，B超时重传。B分配缓存，变量等。</li>
<li>A又发给B的丢了，这时候B已经认为建立了连接。<br>
如果双方都没有数据，那么会触发第二步的超时重传。<br>
如果A要发送数据，那么A会直接把数据发给B，就肯定建立连接了。<br>
如果B要发送数据，也会触发第二步的超时重传。</li>
</ol>
<h3 id="四次挥手">四次挥手</h3>
<ol>
<li>A发给B FIN报文段。A执行主动关闭。</li>
<li>B发给A ACK。B进行WAIT-TIME。等待B终止连接，这个时候B可以给A发送数据，但是A不能给B发送数据。B执行被动关闭，B处于CLOSE_WAIT状态。</li>
<li>B发给A FIN报文段。A收到报文段之后处于TIME_WAIT状态。</li>
<li>A发给B ACK。这个时候A要等待30s或者1分钟，两分钟。因为需要确认B那边收到了ACK，否则的话，B就无法关闭。</li>
</ol>
<h3 id="流量控制">流量控制</h3>
<p>TCP通过让发送方维护一个16位的接收窗口（是接收方的）的变量来提供流量控制。不正式的说，接收窗口用于告诉发送方，接收方还有多少可用的缓存空间。TCP是全双工的，两端都维护一个接收窗口。<br>
接收方将自己的缓冲区大小填入TCP首部的窗口长度字段。这个字段是多少：缓冲区的大小 - （缓冲区中的最后一个字节编号 - 从缓冲区中读出的最后一个字节）。<br>
如果接收方窗口大小为0怎么办？这时发送方不给接收方发报文，而接收方也不发，只有在有数据或者ACK要发的时候，接收方才会给发送方发报文。随着接收方应用程序从缓冲区取走数据，发送方也不能继续发数据。这个时候怎么办？规定：当接收方的接收窗口大小为0时，发送方会不断发送含有一个数据字节的报文段。</p>
<p>为什么要有流量控制，为了防止快速的发送设备发出的数据过多，导致慢速的接收设备处理不过来，而发生大量数据的丢失。</p>
<h3 id="拥塞控制">拥塞控制</h3>
<p>分组重传是网络拥塞的征兆，却不能解决网络拥塞问题。<br>
什么时候知道出现了拥塞：</p>
<ol>
<li>超时</li>
<li>收到3个冗余ACK。</li>
</ol>
<p>为什么要有拥塞控制：</p>
<p>慢启动。<br>
快恢复。收到三个ACK以后的方式叫做快恢复。<br>
快重传。</p>
<p>开始时，指数方式增加，收到超时ACK时开始线性增乘性减。<br>
但是如果发生超时，执行慢开始，即将拥塞窗口变为1MSS，然后指数速度增加，直到遇到超时事件的一半窗口值，开始线性增加。通过设置一个阈值来实现。</p>
<h3 id="timewait过多-6">TIMEWAIT过多[6]</h3>
<p>修改内核设置：</p>
<ol>
<li>开启内核中TCP重用。</li>
<li>开启内核中TCP中快速回收。</li>
<li>修改TIMEOUT</li>
</ol>
<h3 id="clost-wait太多-7">CLOST_WAIT太多[7]</h3>
<p>比如说一个爬虫服务器，爬取其他服务器上的内容，如果没有相应的内容，对方会断开连接，这时候爬虫服务器上的程序是被动断开，如果没有执行close引发第三次挥手，就会有很多CLOSE_WAIT。</p>
<h3 id="long-fat-network">long fat network</h3>
<p>高带宽和长时延网络情况，被称为长肥网络。带宽和时延的乘积表示网络通道的容量，也就是能够在网络中缓冲的数据量，显然增加带宽和时延都增加在网络中缓冲的数据量。但是随着它们乘积的不断变大，TCP的局限就开始显露出来。常规的窗口大小是16位的，能接收和发送的最大大小为65535，而BDP远大于这个值。TCP就不得不发送一会数据就等待ACK，极端情况下有点像停止等待协议。<br>
缺点</p>
<ol>
<li>窗口小，序号少，无法充分利用带宽。窗口扩展项。</li>
<li>时延长。快重传。</li>
<li>序号用的很快。PAWS算法。</li>
<li>RTT比较难测量。引入时间戳。</li>
</ol>
<h2 id="tcp和udp的区别">TCP和UDP的区别</h2>
<ol>
<li>TCP面向连接，UDP无连接。</li>
<li>TCP提供可靠数据传输，UDP提供不可靠数据传输。</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，而UDP是不可靠信道。</li>
<li>TCP面向字节流，把数据看成一个无结构但是有序的字节流。UDP面向报文段。</li>
<li>TCP有流量控制，拥塞控制，UDP无。</li>
<li>TCP很慢，而UDP很快。</li>
<li>TCP首部20个字节，UDP是8个字节。</li>
</ol>
<h2 id="dos攻击">Dos攻击</h2>
<p>Dos（拒绝服务）攻击是一种宽泛类型的攻击，可以分为三类：</p>
<ul>
<li>弱点攻击</li>
<li>带宽洪泛。攻击者向目的主机发送大量的分组，导致目标的介入链路变得非常拥塞，使得合法的分组无法到达服务器。</li>
<li>连接洪泛。创建大量的全开或者半开TCP连接。</li>
</ul>
<p>DDos攻击，分布式拒绝服务攻击。</p>
<h3 id="syn洪泛攻击">SYN洪泛攻击</h3>
<p>攻击者发送大量的SYN报文段，而不完成TCP握手的第三步，服务器不断地为这些半开连接服务器分配资源，导致服务器资源被迅速消耗。<br>
怎么预防？SYN cookies，当服务器收到一个TCP连接时，不生成一个TCP半开连接，只生成一个初始序列号（精心计算的序列号，被称为cookie），然后发送这种序列号的SYNACK报文段。<br>
如果客户机是合法的，客户机返回一个ACK，服务器收到ACK。然后利用这个ACK计算一个，这个ACK是否对应客户机发送的SYN报文段，如果是，生成一个全开的连接。</p>
<h3 id="dns攻击">DNS攻击</h3>
<p>DDos带宽洪泛攻击。攻击者向多个DNS根服务器发送大量的分组，使得大多数合法的DNS请求得不到回答。比如发送大量的ICMP报文。<br>
怎么预防？分组过滤器，过滤ICMP报文。还有就是本地DNS服务器缓存了顶级域名服务器的地址。使得请求绕过了DNS根服务器。</p>
<h2 id="传输层协议">传输层协议</h2>
<p>TCP协议。<br>
UDP协议。<br>
运输层协议是在端系统而不是网络路由器中实现的。<br>
端口号。<br>
socket？</p>
<h2 id="网络层协议">网络层协议</h2>
<p>IP协议，IP协议为主机之间提供了逻辑通信，它的服务模型是尽力而为交互服务。<br>
ICMP协议。<strong>互联网控制消息协议</strong>。最典型的应用是差错报告。ICMP报文有一个类型字段和一个编码字段，并且包含由该ICMP报文首次生成的IP数据报的首部和前8字节内容，以便于发送方能够确定引发该差错的数据报。<br>
ping程序发送一个ICMP类型为8编码为0的报文到指定主机（表示回显请求），看到该回显请求的目的主机发送一个类型0编码为0的报文回显回答。<br>
traceroute原理。traceroute利用ICMP报文实现，源主机中的该程序向目的主机发送一系列普通的IP数据报，每一个数据报都携带了一个具有不可达UDP端口号的UDP报文段，第i个报文段的TTL(time to live，确保数据报不会永远在网络中循环，每过一个路由器，字段值减一)是i。同时，源主机为每个数据报启动定时器，当第i个数据报到达第i个路由器时，TTL为0。根据IP协议的规则，路由器会向源主机发送一个ICMP告警报文（类型为11，编码为0）。该告警报文含有路由器的名字和IP地址，该ICMP报文到达源主机时，源主机从定时器得到RTT，从ICMP报文得到路由器名字和IP地址。那么什么时候停止发送数据报？当其中一个报文到达目的主机的时候，由于数据报包含了一个不可达的端口，所以目的主机会发送类型为3，编码为3的目的端口不可达的ICMP报文。<br>
IGMP协议。网际组管理协议。用于多播。<br>
ARP协议，地址解析协议。是算在链路层还是网络层？把IPv4地址转换成硬件地址。<br>
RARP协议，反向地址解析协议。把硬件地址映射成IPv4地址。<br>
路由器属于网络层设备，它只检查网络层字段。<br>
IP地址。</p>
<p>MTU（最大传输单元），以太网的MTU是1500字节。IPV4要求最小MTU是68字节（20字节首部长度和40字节选项，以及8字节的偏移）。IPV6要求的最小MTU是1280字节。两个主机路径上的最小MTU称为路径MTU。路径MTU可以不对称。<br>
当IP数据报的大小超过链路MTU时，执行分片。<br>
最小重组缓冲区是IPV4(6)的任何实现都必须保证支持的最小数据报大小，IPV4是576字节，IPV6是1500字节。超过这个大小，就不一定能被接收方识别。所以，使用UDP的网络应用的报文段一般都不超过这个大小。<br>
MSS（最大报文段）是用来通过对方，自己这面能够接收的最大TCP报文段大小，也就是最小重组缓冲区的实际值。MSS的大小通常设置为MTU减去IP和TCP首部的长度。</p>
<p>如果</p>
<h2 id="数据链路层">数据链路层</h2>
<p>成帧，透明传输，差错检测。<br>
MAC地址。<br>
交换机，网桥。<br>
MAC地址。</p>
<h2 id="物理层">物理层</h2>
<p>集线器，中继器。</p>
<h2 id="tcp-粘包-问题">TCP“粘包”问题</h2>
<p>粘包问题实际上不是TCP的，它是开发者在设计应用数据传输时的数据结构没有设计好好，可能两个不同的应用层数据在同一个TCP报文段中发给了接收方。<br>
怎么解决，需要在传输层的数据流中给出边界，然后对传输层的数据流进行解析得到相应的数据。不应该依赖于socket的缓冲区作为数据报的边界。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《计算机网络自顶向下》<br>
2.<a href="https://segmentfault.com/a/1190000016855991" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016855991</a><br>
3.<a href="https://www.cnblogs.com/xflonga/p/9368993.html" target="_blank" rel="noopener">https://www.cnblogs.com/xflonga/p/9368993.html</a><br>
4.<a href="https://www.cnblogs.com/aliwa/p/8495014.html" target="_blank" rel="noopener">https://www.cnblogs.com/aliwa/p/8495014.html</a><br>
5.<a href="https://blog.csdn.net/qq_39816673/article/details/89611936" target="_blank" rel="noopener">https://blog.csdn.net/qq_39816673/article/details/89611936</a><br>
6.<a href="https://www.cnblogs.com/dadonggg/p/8778318.html" target="_blank" rel="noopener">https://www.cnblogs.com/dadonggg/p/8778318.html</a><br>
7.<a href="http://www.httpclient.cn/archives/106.html" target="_blank" rel="noopener">http://www.httpclient.cn/archives/106.html</a><br>
8.<a href="https://www.cnblogs.com/lolau/p/8137541.html" target="_blank" rel="noopener">https://www.cnblogs.com/lolau/p/8137541.html</a><br>
9.为什么DNS使用UDP而不是TCP？ - 车小胖的回答 - 知乎<br>
<a href="https://www.zhihu.com/question/310145373/answer/583869215" target="_blank" rel="noopener">https://www.zhihu.com/question/310145373/answer/583869215</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/29/OS-常见面试题目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/29/OS-常见面试题目/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">OS 常见面试题目</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-29 21:43:49" itemprop="dateCreated datePublished" datetime="2020-02-29T21:43:49+08:00">2020-02-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-28 22:44:18" itemprop="dateModified" datetime="2020-03-28T22:44:18+08:00">2020-03-28</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="字节对齐">字节对齐</h2>
<p>许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值K的整数倍，这种对齐能够简化处理器和内存系统之间接口的硬件设计。<br>
比如说一个处理器总是从内存中读取8个字节，那么地址就为8的倍数。<br>
一般是K字节基本对象的地址必须是K的倍数。这就是为什么空类的大小是一个字节！！！因为空类中补充了一个char类型的数据，它不需要对齐！！！</p>
<h2 id="中断和异常">中断和异常</h2>
<p>异常和异常是控制流终中的突变，用来相应处理器状态中的某些变化。什么是控制流？控制指令执行的序列。<br>
中断提供了一种方式，使处理器转而去做正常控制流之外的代码。</p>
<p>中断和异常通常被定义为改变处理器执行指令顺序的事件。<br>
中断是异步的，通常是其他硬件（比如IO）设备依照CPU时钟信号随机产生的。<br>
异常是同步的，指令执行时由CPU控制单元产生的，可能是除零。（异常）<br>
Intel x86把同步和异步中断分别称为异常和中断。</p>
<h2 id="用户态进入内核态">用户态进入内核态</h2>
<ol>
<li>系统调用。</li>
<li>异常。</li>
<li>中断。</li>
</ol>
<h2 id="mutex和信号量-读写锁的区别-5">mutex和信号量，读写锁的区别[5]</h2>
<p>mutex和信号量它们都可以用来实现同步操作，而信号量可以大于1，而mutex不能大于1。还有就是信号量可以由不同的进程释放，而mutex只能由获得锁的进程释放。<br>
mutex和读写锁的区别，读写锁的并行性更高，而mutex要不就是加锁，要不就是不加锁。而读写锁可以是读锁，可以是写锁，还可以是不加锁。<br>
自旋锁和mutex的区别，自旋锁在没有获取锁之前，是忙等状态，它只能被持有一小段时间，否则就会影响性能。自旋锁一般用在非抢占式内核中，它们会阻塞中断。<br>
条件量可以和mutex结合使用。<br>
屏障。<br>
可以用mutex实现读写锁。。。具体的思路是，当有人读时，就要阻塞写锁，但是可以加写锁。有人写时，就要阻塞读锁。</p>
<h2 id="动态链接和静态链接的区别">动态链接和静态链接的区别</h2>
<p>静态链接在编译的时候就把用到的目标模块复制到可执行文件中。<br>
而动态链接在编译的时候，只是链接器复制了一些重定位和符号表信息，使得它们在运行时可以解析对动态链接库中代码和数据的引用。加载器加载程序时，会先加载动态链接器，然后动态链接器通过执行重定位和完成链接。</p>
<h2 id="netstat">netstat</h2>
<p>netstat监控网络连接，路由表等，网络接口等。<br>
netstat默认打印所有打开的socket连接。<br>
-a, --all展示所有的listening和没有listening的sockets。<br>
-l, --listening，展示所有listening的socket，默认情况下是忽略的。<br>
-p, --program，每一个socket属于哪一个程序和pid。<br>
-n, --numeric，数值展示host，port和用户名。<br>
-t, --tcp<br>
-u, --udp<br>
-r打印路由表。<br>
-i打印网络接口。</p>
<h2 id="lsof">lsof</h2>
<p>列出打开的文件。</p>
<h2 id="ip">ip</h2>
<p>ip address，查看ip地址。<br>
ip link，查看网络设备。</p>
<h2 id="原子操作">原子操作</h2>
<p>原子操作指的是由多步组成的操作，要么执行完所有步骤，要不一步也不执行。</p>
<h2 id="程序和线程">程序和线程</h2>
<p>程序是一个存储在硬盘上的可执行文件。<br>
程序的执行实例被称为进程，它是操作系统对一个正在运行的程序的一个抽象。</p>
<h2 id="进程和线程的区别">进程和线程的区别</h2>
<ol>
<li>进程是资源分配和调度的最小单位，而线程是CPU调度的最小单位。引入线程后，系统并发性更高。</li>
<li>进程拥有独立的地址空间，若干代码段，数据段，文件，主存以及至少一个线程。</li>
<li>一个进程内的多个线程共享该进程的所有资源，线程自己拥有很少的资源，比如线程ID，寄存器，线程私有数据，线程栈。</li>
<li>进程调度需要上下文切换，开销大。</li>
<li>同一进程内的线程切换，仅交换线程拥有的一小部分资源，效率高。不同进程的线程切换会引发进程调度。</li>
<li>线程中通常要进行同步操作，当多个线程共享线相同的内存时，需要使用同步操作确保他们看到一致的视图。</li>
<li>进程之间交换信息要使用进程间通信。</li>
<li>一个进程结束后所有线程都将终止。</li>
<li>而一个线程结束通常不会影响其他线程（如果调用了exit就会终止所有线程。）</li>
</ol>
<h2 id="进程都有哪些资源">进程都有哪些资源</h2>
<p>寄存器<br>
堆<br>
栈<br>
数据段<br>
代码段<br>
文件描述符<br>
锁<br>
信号</p>
<h2 id="进程都有哪些区域">进程都有哪些区域</h2>
<p>可执行代码<br>
初始化数据<br>
未初始化数据<br>
堆<br>
栈</p>
<h2 id="进程创建">进程创建</h2>
<p>怎么创建一个进程。调用fork复制进程的数据空间，代码段，堆和栈的副本。现在的fork利用写时复制，这些区域由父进程和子进程共享，内核将它们的访问权限修改为只读，如果父进程和子进程中的任何一个试图修改这些区域，内核只为修改的那篇区域（通常是一页）制作一个副本，原来的页仍是受到保护的，当其他进程试图写入时，内核会检查写进程是不是这个页的唯一属主，如果是，他把这个页标记为对这个进程是可写的。通过使用一个引用计数记录共享相应页的进程数目。</p>
<p>task_struct包含PID，mm_struct（页表），可执行文件的名字，程序计数器等。<br>
调用fork函数时，内核为新进程创建一个各种各样的数据结构，并给他分配一个唯一的PID，为了给这个进程创建虚拟内存，它创建了当前进程的mm_struct，area_struct和页表的副本。他将两个进程中的每个页面都标记为只读，并将两个进程中的area_struct都标记为私有的copy on write。<br>
当fork在新进程返回时，新进程的虚拟内存和调用fork之间进程的虚拟内存相同。当这两个进程中的任意一个进程写操作的时候，COW就会创建新页面。因此，也就为每个进程保持了私有地址空间。</p>
<h2 id="fork和vfork区别-clone">fork和vfork区别，clone</h2>
<ol>
<li>fork采用copy-on-write[4]，而vfork在调用exec之前和父进程共享数据。</li>
<li>fork不对子进程的执行顺序做任何要求，而vfork要求子进程先运行，父进程挂起，知道子进程调用了exec或者exit之后，父进程恢复运行。</li>
<li>clone可以指定要复制的内容。</li>
</ol>
<h2 id="进程执行">进程执行</h2>
<p>进程，是一个程序的执行实例。<br>
每个进程都由一个进程描述符表示，这个描述符包含有关进程当前状态的信息。当内核暂停一个进程的执行时，它在进程描述符中保存好几个寄存器的内容：</p>
<ul>
<li>程序计数器和栈指针寄存器</li>
<li>通过寄存器</li>
<li>包含CPU状态信息的处理器控制寄存器</li>
<li>内存管理寄存器。</li>
</ul>
<p>进程描述符用一个结构体task_struct表示。这个结构体中包含tty_struct，fs_struct，files_struct, mm_struct和signal_struct以及其他更多。</p>
<h2 id="进程状态">进程状态</h2>
<p>进程描述符中的状态域描述了进程当前可能所处的状态，有五种：</p>
<ol>
<li>运行状态</li>
<li>中断</li>
<li>不可中断</li>
<li>停止</li>
<li>僵死状态。</li>
</ol>
<h2 id="进程切换">进程切换</h2>
<p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行，这种行为被称为进程切换。linux中进程切换的主要内容：</p>
<ol>
<li>地址空间。（快表和页表）。</li>
<li>硬件上下文，寄存器，程序计数器。</li>
</ol>
<h2 id="进程结束">进程结束</h2>
<p>使用exit，使用return ，使用Exit，进程的最后一个线程调用pthread_exit。<br>
调用abort，进程接收到某些信号，最后一个线程对cancel做出请求。</p>
<h2 id="进程通信">进程通信</h2>
<p>独立进程访问同一个对象的方法。使用共享内存，然后使用信号量，记录锁，或者读写锁进行进行保护。<br>
如何传递一个字符串？使用FIFO？</p>
<h2 id="线程都有哪些资源">线程都有哪些资源</h2>
<p>私有的：程序计数器，栈空间和寄存器。</p>
<h2 id="线程创建">线程创建</h2>
<p>pthread_create。</p>
<h2 id="线程结束">线程结束</h2>
<p>pthread_exit<br>
cancel<br>
从启动例程返回。</p>
<h2 id="线程同步">线程同步</h2>
<p>互斥量<br>
读写锁<br>
条件变量<br>
屏障</p>
<h2 id="协程">协程</h2>
<p>一个进程</p>
<h2 id="死锁">死锁</h2>
<h3 id="什么是死锁">什么是死锁</h3>
<p>两个或多个进（线）程在运行过程中相互请求其他进（线）程拥有且不释放的资源，造成所有的进程或者线程都无法继续前进。</p>
<h3 id="产生死锁的原因">产生死锁的原因</h3>
<ol>
<li>资源竞争。资源类型：可抢占资源，不可抢占资源。</li>
<li>加锁的顺序不合适。</li>
</ol>
<h3 id="产生死锁的必要条件">产生死锁的必要条件</h3>
<ol>
<li>互斥条件：每个资源是不可共享的。</li>
<li>请求和保持：进程因请求某个资源而阻塞时，保持已经获得的资源不放。</li>
<li>不剥夺：进程获得的资源没有使用完前，不能被其他进程强行剥夺，只能由获得资源的进程自己释放。</li>
<li>循环等待：A等待B，B等待A。</li>
</ol>
<h3 id="解决死锁的方法">解决死锁的方法</h3>
<ol>
<li>忽略死锁问题，假设系统永远不死锁。</li>
<li>保证系统永远不进入死锁状态。
<ul>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
</li>
<li>允许系统进入死锁状态，并且可以从死锁恢复。
<ul>
<li>死锁检测</li>
<li>死锁恢复</li>
</ul>
</li>
</ol>
<h4 id="忽略死锁">忽略死锁</h4>
<p>鸵鸟算法，假设死锁永不发生。死锁在计算机中很少出现，预防死锁的代码调高。</p>
<h4 id="死锁预防-静态资源分配">死锁预防（静态资源分配）</h4>
<p>对应死锁产生的后三个必要条件。资源的互斥条件不能改变。</p>
<ol>
<li>破坏请求和保持条件：资源一次性分配，只要有有一个资源得不到分配，就不给这个进程分资源。资源利用率低，但是容易实现。</li>
<li>破坏不可剥夺条件：超时放弃已有的锁。</li>
<li>破坏循环等待条件：对所有资源进行排序，以确定的顺序获得锁。</li>
</ol>
<h4 id="死锁避免-动态资源分配">死锁避免（动态资源分配）</h4>
<p>允许进程动态的申请资源，一次申请部分资源。系统在进行资源分配之前，先计算资源分配的安全性，如果此次分配不会导致系统进入不安全状态（可能死锁），就将资源分配给进程。<br>
银行家算法。<br>
n表示进程数据，m表示资源类型。<br>
可用资源向量。<br>
最大需求矩阵。<br>
分配矩阵。<br>
需求矩阵。<br>
当一个进程申请资源时，首先判断它的请求是不是小于avaiable，如果小于，就需要等到。否则，假设将资源分配给这个进程，然后修改相应的数据结构。执行安全性算法。<br>
安全性算法是：</p>
<h4 id="死锁检测">死锁检测</h4>
<p>系统进行资源分配后，计算资源的安全性，如果此次分配会导致死锁，就采取恢复措施，否则继续。</p>
<h4 id="死锁恢复">死锁恢复</h4>
<ol>
<li>剥夺资源使系统恢复。</li>
<li>撤销进程使得系统恢复。</li>
</ol>
<h2 id="页式内存管理">页式内存管理</h2>
<h3 id="原理">原理</h3>
<h4 id="页框和页面">页框和页面</h4>
<p>页框也叫物理块。将物理存储空间划分成大小相等的若干块。大小为2的整数幂，在512字节到8192字节之间。<br>
页面。将进程的逻辑地址空间划分成与物理块大小相同的若干片。<br>
为进程分配内存时，以块为单位将进程的若干页分别装入多个可以不相邻的物理块中。</p>
<h4 id="地址空间">地址空间</h4>
<p>假设进程使用的逻辑空间是线性的，逻辑地址空间的大小是0到2的m次方(m是地址空间的位数）。每个进程使用相同的逻辑空间。!!!注意，页式内存管理的逻辑地址空间和段页式内存管理的逻辑地址空间是不一样。<br>
假设每个页面的大小是2的n次方。逻辑地址空间中的地址是addr，<br>
页号§：addr / 2的n次方。（总共有2的m次方/2的n次方个页）<br>
页内偏移(d)：add % 2的n次方。</p>
<h4 id="页表">页表</h4>
<ol>
<li>记录进程的逻辑页和主存中物理块的对应关系，实现从页号到物理块的地址映射。</li>
<li>进程地址空间中的每一页在页表中有一个条目（page table entry, PTE)，指出该逻辑在主存中的物理块号。</li>
<li>页表存放在主存中，页表的主存地址与页表的长度在PCB中。</li>
<li>控制寄存器用来存放：
<ul>
<li>页表基址寄存器：指向页表。</li>
<li>页表长度寄存器：页表长度。</li>
</ul>
</li>
</ol>
<h3 id="地址转化">地址转化</h3>
<ol>
<li>将页表的初始地址和页表长度送入控制寄存器。</li>
<li>比较PC上的页号是否大于控制寄存器中的页表长度。</li>
<li>将页号和控制寄存器中的页表起始地址相加，得到页号在页表中的位置。（就相当于一个数据，判断当前要访问的元素下标是否越界，不越界的话，取得地址）。</li>
</ol>
<p>上述过程是通过硬件完成的。<br>
获得页表在主存中的位置后，将该主存块号乘上页面大小加上PC上的偏移量，得到在主存中的物理地址。</p>
<h3 id="快表和联想寄存器">快表和联想寄存器</h3>
<p>在地址变换单元中设置的专用缓冲存储器。用来存放页表的一部分。快表的组成：<br>
页号，块号，访问位，状态位。<br>
在查询时，先使用快表进行查询，没有找到时，继续使用主存进行正常的地址变换，直到形成访问主存的绝对地址。<br>
然后将相应的逻辑页号和物理块号，写入快表中状态为为0的一行中。如果没有这样的，就把它写入访问位为0的某一行，同时置状态位和访问位为1。</p>
<h3 id="多级页表">多级页表</h3>
<p>如果一个进程可以访问32位大小的逻辑空间，页的大小为4KB（2的12次方）。那么一个页表需要包含2的32次方/2的12次方=2的20次方个表项，假设一个表项4B，那么需要4MB连续物理空间存储页表。<br>
解决方法，再分页，即多级页表。</p>
<h3 id="页式管理的主存分配">页式管理的主存分配</h3>
<p>页表是每个进程一张。</p>
<h2 id="段式内存管理">段式内存管理</h2>
<h3 id="原理-v2">原理</h3>
<h4 id="为什么引入段式管理？">为什么引入段式管理？</h4>
<ol>
<li>方便编程。</li>
<li>信息共享。</li>
<li>信息保护。</li>
<li>动态增长。</li>
<li>动态链接。</li>
</ol>
<h4 id="分段">分段</h4>
<p>按照程序自身的逻辑关系将地址空间划分成若干部分。每个段都有自己的名字。每个段都从0开始编制。</p>
<p>每个逻辑地址都分为段号和段内偏移。<br>
段式存储分配以段为单位进行，为作业的每一个分段分配一个连续的主存空间，各段之间可以不连续。</p>
<h3 id="段表">段表</h3>
<ol>
<li>用于记录进程分段和物理存储空间的对应关系，实现从逻辑分段到物理内存的地址映射。</li>
<li>每个逻辑分段对应一个table entry，指出该逻辑分段在主存中的<strong>起始地址</strong>和<strong>段的长度</strong>。（注意页表中存放的是页号和块号）。</li>
<li>段表存放于主存。段表的主存起始和段表长度保存在进程控制块中。</li>
<li>控制寄存器。
<ul>
<li>段表基址寄存器：指向段表。</li>
<li>段表长度寄存器：段表长度。</li>
</ul>
</li>
</ol>
<h3 id="段式管理的主存分配">段式管理的主存分配</h3>
<p>存在外碎片。<br>
分段方法：<br>
首次适应法。<br>
最佳适应法。<br>
最坏适应法。</p>
<h3 id="段式和页式管理的比较">段式和页式管理的比较</h3>
<ol>
<li>段是信息的逻辑单位，它是根据用户需要进行划分的。</li>
<li>页是信息的物理单位，为了管理主存方便，对用户是透明的。</li>
<li>段的大小不固定，由它的功能确定的。</li>
<li>页的大小固定，由系统决定。</li>
<li>段式管理向用户提供的是二维地址空间。</li>
<li>而页式管理用户提供的是一维地址空间，确定其页号和页内偏移是由机器硬件实现的。</li>
<li>页式管理产生内碎片</li>
<li>段式管理产生外碎片。</li>
</ol>
<h2 id="页面置换算法">页面置换算法</h2>
<ol>
<li>最佳算法。从主存中移除永远不再需要的页面，如果没有这样的页面，选择接下来最长时间不再使用的那个。（需要我们有未卜先知的能力）。</li>
<li>先进先出。总是替换最先进来的那个。</li>
<li>最近最少未使用。每次将当前访问的数据放在最前面，当发生未命中的时候，替换最近未使用的那个。</li>
<li>时钟算法（最近未用）。给每一帧附一个附加位。某一帧第一次被使用的时候，使用位设置为1，下一次如果扫描到它，而不是使用它的话，就把1置换成0。如果现在是0，要使用它，就把它置换为1。</li>
</ol>
<h2 id="进程调度算法">进程调度算法</h2>
<ol>
<li>先来先服务（FCFS)。非抢占式的，易于实现，效率不高，性能不好，有利于长作业，但是不利于短作业。</li>
<li>短作业优先（SJF）。可以剥夺，也可以不剥夺。<br>
每次从作业队列中挑选服务时间最短的作业进行处理。非抢占式的，有限照顾短作业，具有很好的性能，降低平均等待时间，提高吞吐量。但是不利于长作业，长作业出现饥饿状态。不能用于实时系统。<br>
不剥夺的话，就是最短剩余时间优先。首先按照作业时间最短的作业运行，如果运行时有新的作业到达，并且它的服务时间比当前作业的剩余服务时间短，就发生抢占。抢占式的，因为频繁抢占和进程切换，系统开销大，算法实现代价高，一般用于实时系统。</li>
<li>高响应比。优先运行运行时间短，等待时间长的进程。非抢占式的，每次选择响应比最高的作业运行。可以避免饥饿。</li>
<li>优先级调度算法。可以剥夺，也可以非剥夺。为每个进程指定一个优先级。</li>
<li>时间片轮转法。用于分时系统的进程调度，采用剥夺方式。不利于IO频繁的作业。</li>
<li>多级队列调度算法。</li>
</ol>
<p>window和linux都采用基于抢占的优先级调度算法。</p>
<h2 id="io数据传输的控制方式">IO数据传输的控制方式</h2>
<ol>
<li>程序查询方式。</li>
<li>程序中断方式。</li>
<li>直接存储器访问。</li>
<li>通道方式。</li>
</ol>
<h2 id="磁盘调度算法">磁盘调度算法</h2>
<ol>
<li>先来先服务。容易实现，公平合理。但是完全不考虑队列中各个请求情况，使得磁头频繁移动。</li>
<li>最短寻道时间优先（SSTF）。在移动磁头时，总是选择移动磁头距离最小的磁道。可能会导致饥饿问题。</li>
<li>扫描法SCAN和循环扫描法CSCAN。<br>
SCAN磁头不断的从一端移动到另一端，到头返回。（电梯算法）<br>
CSCAN，从一端移动到另一端时，立即返回它开始的地方。</li>
<li>查询法LOOK和循环查询法C-LOOK。<br>
SCAN和CSCAN都是将磁头从一端移动到另一端。<br>
而LOOK和CLOOK是移动到最远的请求上的那个磁道，如果前进方向上没有请求，就反向移动。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread" target="_blank" rel="noopener">https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread</a><br>
3.<a href="https://www.geeksforgeeks.org/difference-between-process-and-thread/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/difference-between-process-and-thread/</a><br>
4.<a href="https://www.cnblogs.com/Rofael/archive/2013/04/13/3019153.html" target="_blank" rel="noopener">https://www.cnblogs.com/Rofael/archive/2013/04/13/3019153.html</a><br>
5.<a href="https://blog.csdn.net/tt_love9527/article/details/82107549" target="_blank" rel="noopener">https://blog.csdn.net/tt_love9527/article/details/82107549</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/29/C-常见面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/29/C-常见面试题/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C 常见面试题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-29 21:43:10" itemprop="dateCreated datePublished" datetime="2020-02-29T21:43:10+08:00">2020-02-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-04-23 15:21:34" itemprop="dateModified" datetime="2020-04-23T15:21:34+08:00">2020-04-23</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="什么是面向对象">什么是面向对象</h2>
<p>在C语言中，数据和函数是分开来的，语言本身并不支持数据和函数之间的关联性，这种程序就称为程序性的。它们被一组算法驱动，处理共同的外部数据。<br>
而C++将数据和函数封装起来，用户只能通过类设计者提供的接口访问类内封装的数据。<br>
面对对象的三大特点：封装，继承和多态。<br>
<strong>数据抽象和封装</strong>。类的基本思想是<strong>数据抽象</strong>和<strong>封装</strong>。<strong>数据抽象</strong>是一种依赖于接口和实现分离的编程技术。类的接口包括用户所能执行的操作，类的实现则包括类的数据成员，负责接口实现的函数以及定义类所需要的各种私有函数。<strong>封装</strong>实现了类的接口和实现的分离，封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分。<br>
<strong>继承</strong>的三种方式：public，private和protected继承。<br>
<strong>多态</strong>，多态分为动态多态和静态多态。静态多态是通过模板实现的，动态多态是通过虚函数和RTTI实现的。<br>
<strong>动态绑定和静态绑定。</strong></p>
<h2 id="指针和引用的区别">指针和引用的区别</h2>
<ol>
<li>1 从定义上来说，可以定义指针的指针，但是不能（直接）定义引用的引用（模板参数推导的时候可以）。定义。</li>
<li>2 const引用可以指向字面值常量，而指针不能（除了字符数组）。</li>
<li>3 指针本身可以是const的，而引用不能。底层const和顶层const。</li>
<li>指针可以为空，引用不能。初始化。</li>
<li>指针可以被重新赋值。而引用一旦被绑定就不能修改。赋值。</li>
<li>指针必须被解引用才能使用，而引用不需要。访问。</li>
<li>指针变量可以进行运算，而引用不能。运算。</li>
<li>指针本身是一个变量，有它自己的内存地址，以及在栈上的大小。而引用的内存地址和它绑定的对象一样，看起来是一样的，但是实际上是不一样的（编译器做了一些操作），可以把引用当做它引用对象的别名。</li>
</ol>
<h2 id="inline-10-11">inline[10,11]</h2>
<ol>
<li>
<p>inline函数对于封装提供了一种必要的支持，可以有效的存取封装于class中的nonpulibc数据。避免函数调用的开销，比如说参数入栈，出栈。</p>
</li>
<li>
<p>它是C程序中宏函数的一个安全替代品。宏函数是由预处理器对宏进行替换，而内联函数是通过编译器控制的。内联函数是函数，会进行参数检查。只不过在调用的时候像宏一样展开，减少函数调用。</p>
</li>
<li>
<p>如果一个inline函数被调用太多次的话，会产生太多的扩展代码，使得程序变得的道别大。</p>
</li>
<li>
<p>inline函数有多个局部变量或者参数带有副作用，都会产生临时性对象。</p>
</li>
<li>
<p>inline中调用inline可能会使得复杂度太大，而没有办法内联。</p>
</li>
<li>
<p>用inline声明的函数并不一定会inline，取决于编译器。编译器通过计算各种操作的复杂度，计算是否需要内联。</p>
</li>
<li>
<p>inline只适合函数体代码简单的函数使用，不能有循环等语句。适用于规模小，流程直接，频繁调用。</p>
</li>
<li>
<p>建议inline函数的定义放在头文件中。</p>
</li>
<li>
<p>类内定义的函数是隐式的inline函数。</p>
</li>
<li>
<p>inline关键字应该和实现放在一块，只在声明中说明没有用。</p>
</li>
<li>
<p>慎用内联。</p>
</li>
</ol>
<h2 id="static关键字-4">static关键字[4]</h2>
<ol>
<li>隐藏全局变量和函数的作用域。这一个已经被标准抛弃了。</li>
<li>修饰局部变量，改变变量的生命周期。</li>
<li>修饰类的数据成员和成员函数。</li>
</ol>
<h2 id="const关键字">const关键字</h2>
<ol>
<li>顶层const和底层const。主要是常量指针和常量引用。</li>
<li>const修饰形参和const修饰返回值。</li>
<li>和类相关。<br>
修饰成员变量，必须使用初始化列表赋值。<br>
const修饰成员函数。<br>
修饰类对象，必须调用const类型的函数。<br>
const可以用来区分重载。</li>
</ol>
<h2 id="c语言结构体中的空数组-20">C语言结构体中的空数组[20]</h2>
<p>声明一个不占用空间的指针，redis的sds就用到了这种方法。</p>
<h2 id="include-和-区别">include &quot;&quot;和<code>&lt;&gt;</code>区别</h2>
<p>它们的查找路径不同，<code>&lt;&gt;</code>先查找系统目录，&quot;“先查找当前目录。<br>
”&quot;查找到的会隐藏&lt;&gt;查找到的。</p>
<h2 id="const和宏常量的区别">const和宏常量的区别</h2>
<p>const常量有数据类型，而宏常量没有。编译器可以对前者进行安全检查，对后者只能进行字符替换。</p>
<h2 id="内存泄露">内存泄露</h2>
<ol>
<li>忘记delete</li>
<li>array delete</li>
<li>虚析构函数</li>
<li>指针数组，没有对每个指针进行释放。</li>
</ol>
<h2 id="指针函数和函数指针">指针函数和函数指针</h2>
<p>指针函数是一个函数，返回类型是一个指针而已。<br>
函数指针是一个指针，是一个指向函数的指针。</p>
<h2 id="数组和指针">数组和指针</h2>
<ol>
<li>数组是一块连续存放的空间，指针是一个地址，指针变量是一个变量。</li>
<li>初始化。</li>
<li>大小。</li>
<li>指针数组和数组指针。</li>
<li>作为函数参数。</li>
</ol>
<h2 id="vector扩容">vector扩容</h2>
<h3 id="为什么不是常数">为什么不是常数</h3>
<p>成倍增长可以保持常数时间复杂度的插入操作。<br>
常数增长的插入时间复杂度是O(n)。<br>
为什么？假设要插入n个元素，成倍增长的倍数是p，常数增长的大小是q。<br>
成倍增长总共的复制开销：<br>
$$ \sum_{i=1}^{log_p^n } p^i $$<br>
常数增长总共的复制开销：<br>
$$\sum_{i=1}^{n/q} qi $$</p>
<h3 id="为什么是1-5或者2">为什么是1.5或者2</h3>
<p>为什么是1.5？可以复用之间的空间。<br>
为什么是2？实现简单。</p>
<h2 id="strlen和sizeof的区别">strlen和sizeof的区别</h2>
<ol>
<li>sizeof是运算符。它的值在编译时就已经确定了，所以不能用来获得动态分配的内存空间的大小。</li>
<li>strlen是函数，在运行时计算的。</li>
<li>静态数组传递给strlen就会退化成指针，在传递给sizeof的时候还是数组。strlen是数组中内容的长度，而sizeof是静态数组声明时的大小。</li>
<li>动态数组(malloc)分配的，strlen能获得数组中内容的大小，而sizeof只能获得指针的大小。</li>
<li>strlen不会计算空字符，而sizeof会。</li>
</ol>
<h2 id="override和overload">override和overload</h2>
<p>只有虚函数能被ovrride。<br>
override是用来实现多态的，函数的参数类型和声明和可以父类中完全一样。<br>
而overload中，函数的参数列表必须不同。它的作用我觉得可能是方便记忆，方便理解。实现同一个功能的函数具有同样的名字。</p>
<h2 id="空类的大小为1字节">空类的大小为1字节</h2>
<p>标准规定空类的大小为1，因为两个不同的对象需要不同的地址表示。标准规定完整对象的大小大于0。</p>
<h2 id="虚函数和虚函数表-12">虚函数和虚函数表[12]</h2>
<p>当某个类中声明了虚函数时，编译器会为该类创建一个虚函数表，存放虚函数的地址，这个是在编译时期完成的。然后编译器会在该类的对象中添加一个虚指针指向这样一个虚函数表。<br>
当有其他类继承这个类时，编译器为这个类也创建一个虚函数表。如果派生类重写了基类的虚函数，那么编译器会更新虚函数表中的函数地址为派生类的虚函数地址。<br>
当发生虚函数调用时，编译器会根据指针指向的对象，找到该对象的虚函数表，然后调用相应的虚函数。</p>
<h2 id="虚析构函数">虚析构函数</h2>
<p>一个基类总是需要虚析构函数。</p>
<h2 id="虚继承">虚继承</h2>
<p>为什么要有虚继承？<br>
派生类可能多次继承同一个类。默认情况下，派生类会含有继承链上每个类对应的子部分，如果某个类在派生过程中出现了多次，派生类中将包含该类的多个子对象。比如iostream之类的类，肯定不行。<br>
声明成虚继承的继承体系中，无论虚基类在继承体系中出现了多少次，派生类中都只含有一个共享的虚基类子对象。</p>
<h2 id="多态">多态</h2>
<p>C++的多态分为两种，一种是静态多态，通过函数重载和模板实现。<br>
一种是动态多态，虚函数实现。</p>
<p>C实现C++的多态[5,6, 29]。</p>
<h2 id="rtti-13">RTTI[13]</h2>
<p>C++ 缺乏安全的向下转型（将派生类指针转换成基类指针），只有类型真的可以被转型的时候，才会执行向下转型。</p>
<p>RTTI提供了一个安全的向下转型，但是只对那些多态类型有效（使用继承和动态绑定）。为什么？因为那些ADT和非多态类型不需要这些东西，所以，很自然的就想到，在虚函数表上进行操作，通过在虚函数表中增加一个slot（通常是第一个slot），它是通过编译器在编译器指定的，和虚函数一起。</p>
<p>dynamic_cast可以用来实现向下转型，，如果向下转型是安全的，就可以执行，而如果是不安全的，就返回0。<br>
dynamic_cast可以在执行期决定真正的类型。代价是什么呢，一个就是编译时在虚函数表中增加的一项，另一个就是运行期间，获取type_info对象的地址，这个地址和指向对象的类型有关，然后获得它的类型。<br>
对于引用和指针的异常处理不同：<br>
对于指针，如果返回0，表示这个指针是空指针。<br>
对于引用，如果引用不是一种真的派生类，就会抛出bad_cast异常。</p>
<p>type_info对象对于内置类型和非多态的类型也适用。不过这种type_info对象是编译器取得的（在需要的时候），而不是运行期。</p>
<h2 id="cast"><code>cast</code></h2>
<h3 id="static-cast"><code>static_cast</code></h3>
<p>和C中提供的强制类型转换一样。</p>
<h3 id="const-cast"><code>const_cast</code></h3>
<p>只能改变运算对象的底层const，可能去掉也可以添加底层const。</p>
<h3 id="reinterprect-cast"><code>reinterprect_cast</code></h3>
<p>为运算对象的bit mode提供新的解释。比如可以把一个整数解释成字符串。</p>
<h3 id="dynamic-cast"><code>dynamic_cast</code></h3>
<p><code>dynamic_cast</code>实现安全的动态转换。<br>
它可以可以安全实现的执行downcast，但是需要是含有虚函数的类。</p>
<h2 id="智能指针">智能指针</h2>
<h3 id="shared-ptr实现">shared_ptr实现</h3>
<p>引用计数放在指针成员中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>():pd(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>(T *data): pd(data), <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)</span><br><span class="line">    &#123; &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;T&gt; &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        pd = rhs.pd; </span><br><span class="line">        count = rhs.count;</span><br><span class="line"></span><br><span class="line">        ++*rhs.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;T&gt; &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count &amp;&amp; --*count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> pd;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pd = rhs.pd;</span><br><span class="line">        count = rhs.count;</span><br><span class="line">        <span class="keyword">if</span>(rhs.count)</span><br><span class="line">            ++*count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count &amp;&amp; --*count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> pd; </span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *p;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    T *pd;</span><br><span class="line">    <span class="keyword">size_t</span> *count;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="unique-ptr实现">unique_ptr实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unique_ptr</span>():p(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    explicit unique_ptr(T *data): p(data)</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝赋值</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">unique_ptr</span> &amp;rhs) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构</span></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T *q = p;</span><br><span class="line"></span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> q; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">reset</span><span class="params">(T *data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        p = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *p;&#125;</span><br><span class="line">    <span class="comment">//指针本身是个常量</span></span><br><span class="line">    <span class="comment">// const 修饰this指针，常量指针，指向不能改变，指针指向的值可以改变。为什么这里返回值不是常量。这个指针可不可以指向常量对象，可以。</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *p&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *p;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="shared-ptr和unique-ptr">shared_ptr和unique_ptr</h3>
<ol>
<li>它们管理保存指针的策略，前者可以共享指针，而后者则独占指针。</li>
<li>它们允许用户重载deleter的方式。只要在创建或者reset指针时给shared_ptr提供一个deleter即可。但是，deleter是unique_ptr对象的一部分。<br>
shared_ptr的deleter是运行时绑定，所以需要使用指针，开销大，但是用户重载更方便。它的执行方式可能如下：<code>del?del(p): delete p</code>。<br>
而unique_ptr的deleter是编译时绑定，避免了间接调用deleter的运行时开销。</li>
<li>shared_ptr不能动态管理数组，而unique_ptr可以动态管理数组。</li>
</ol>
<h3 id="智能指针和数组">智能指针和数组</h3>
<ol>
<li>shared_ptr不支持管理动态数组。需要提供自定义的delete（只要是一个可调用对象就行）。</li>
<li>unique_ptr支持动态管理数组，需要在类型后面加上一对方括号。当unique_ptr销毁时，会自动使用delete[]。不能使用成员访问运算符（点和箭头），但是可以使用下标访问运算符。</li>
</ol>
<h3 id="weak-ptr">weak_ptr</h3>
<p><code>weak_ptr</code>可以解决循环引用问题，比如双向链表中的循环引用。[9]</p>
<h2 id="类模板和函数模板的区别">类模板和函数模板的区别</h2>
<p>类模板用来生成类，函数模板的参数是由编译器推导的，而类模板的参数必须指定。</p>
<h2 id="模板特化和偏特化">模板特化和偏特化</h2>
<p>模板特化的本质是模板实例化，定义特化版本时，我们实际上是接替了编译器的工作。<br>
函数模板只能全特化。<br>
类模板可以全特化也可以偏特化。偏特化既有类型的偏特化，也有个数的偏特化。</p>
<h2 id="为什么模板的声明和实现要写在一起而类的实现和声明要分开-7">为什么模板的声明和实现要写在一起而类的实现和声明要分开[7]</h2>
<p>C++ 采用分离式编译。可以不用将所有的代码写在一个文件中，可以将他们分解为更小，更好管理的模块，可以独立的修改和编译这些模板。当我们改变这些模板时，只需要重新的编译它，并重新链接，不必重新编译其他文件。这一功能主要是通过链接器实现的。更多的内容可以查看CSAPP上介绍的。<br>
对于普通对象和函数而言，类的声明写在头文件中，实现写在cpp文件中。cpp文件是可以单独被编译的。<br>
但是模板函数的声明并不能直接被直接编译成二进制代码，在遇到template时编译器不会为它分配任何空间。因为只有在真正使用模板的时候，才会知道模板参数的值。编译器和链接器的某一个部分，可以去掉模板的多重定义。</p>
<h2 id="哈希表">哈希表</h2>
<p>哈希表冲突严重的话会退化成单链表。这个时候哈希表的各种操作的时间复杂度都提升了一个量级，会占用大量CPU时间，降低系统响应时间，可以用来做DDos攻击。<br>
解决冲突的方法：</p>
<h2 id="内存管理">内存管理</h2>
<h3 id="new">new</h3>
<p>new一个空数组是和合法的，但是不能解引用！！！可以把它当做尾后迭代器来使用。</p>
<h3 id="malloc-calloc和realloc">malloc, calloc和realloc</h3>
<ol>
<li>malloc分配指定字节的数组，初值不定。</li>
<li>calloc分配nobj个size字节的对象，每一位都初始化为0。</li>
<li>realloc在以前分配的区域的基础上扩大为新的容量。如果原来的区域后面有足够大的空间，就在那里，否则复制到一个新的空间中。</li>
</ol>
<h3 id="placement-new">placement new</h3>
<p>重载operator new函数。placement new可以为分配函数提供额外的信息。<br>
Placement new允许我们将对象构造在已经分配好的内存上，分配好的内存不一定是operator new分配的内存，甚至可以是静态内存。<br>
allocator的内存分配和构造函数的调用是分开进行的，通过两个函数allocate和construct。<br>
对应于new，可以使用operator new进行空间分配，使用placement new调用构造函数。</p>
<h3 id="stl-allocator">stl allocator</h3>
<p>管理的是malloc分配的虚拟内存，比如STL的alloc分配器。<br>
大于128B的，直接malloc。<br>
小于等于128B的，维护16个链表，每个都是8的倍数。</p>
<h3 id="用户空间内存分配-22">用户空间内存分配[22]</h3>
<h4 id="malloc实现-21">malloc实现[21]</h4>
<p>管理的是虚拟内存。<br>
除了mmap外的几种方式，一般分配大内存的话都是mmap，小内存的话都是通过bin实现的。</p>
<h4 id="mmap">mmap</h4>
<h4 id="ptmalloc实现">ptmalloc实现</h4>
<h4 id="tcmalloc实现">tcmalloc实现</h4>
<h4 id="jemalloc实现">jemalloc实现</h4>
<h3 id="内核空间内存分配-22">内核空间内存分配[22]</h3>
<p>伙伴算法用于大块连续物理内存的分配。<br>
slab和kmalloc用于小块连续物理内存的分配。<br>
vmalloc用于连续虚拟内存的分配。<br>
注意，这三种方法都是内核空间的内存分配。</p>
<h4 id="伙伴算法-24">伙伴算法[24]</h4>
<h5 id="什么是伙伴算法">什么是伙伴算法</h5>
<p>伙伴算法，把所有的空闲页框分成11个链表，每个链表分别管理2的0到10次方大小的连续页框。伙伴算法只能分配2的幂次页的空间。通常一个页框是4K大小，所以伙伴算法维持的最大连续内存4M大小，最小是4K大小。</p>
<h5 id="伙伴的回收">伙伴的回收</h5>
<p>什么是伙伴，由同一个块分裂开来的两个块。所有大小为2的k的块，它的地址一定是2^k次方的整数倍。将它的地址除以2的k+1次方，然后再加减2的k次方，就可以得到它的伙伴的地址。<br>
比如大小为16的块，可能是0-16，16-32，32-48，48-64。它们的地址都是16的倍数，0-16和16-32互为伙伴，而32-48和48-64互为伙伴。但是16-32和32-48不是伙伴！！！因为它们不是从同一个块分裂来的。。。。</p>
<h5 id="优点和缺点-25">优点和缺点[25]</h5>
<p>优点</p>
<ol>
<li>解决了外部碎片问题。</li>
<li>解决了连续页框的分配问题。</li>
<li>针对于大内存。</li>
</ol>
<p>缺点：</p>
<ol>
<li>合并的要求太严格了。</li>
<li>内碎片问题。</li>
<li>合并和拆分的开销，如果刚合并又要拆分等等。</li>
</ol>
<h4 id="slab-26">slab[26]</h4>
<p>slab机制通常由三类对象构成：kmem_cache，slab和slab对象构成。[27]<br>
一个kmem_cache通常有1个或者多个slab，一个slab通常是1个或者多个连续物理页，然后它被分成多个slab对象。这个cache管理的就是相应大小的slab对象。</p>
<h4 id="kmalloc实现-23">kmalloc实现[23]</h4>
<p>分配的是小的连续的物理内存，基于slab实现的。<br>
slab又是基于伙伴系统的。</p>
<h4 id="vmalloc实现">vmalloc实现</h4>
<p>分配的是连续的虚拟内存，物理内存不一定连续。</p>
<h2 id="对齐">对齐</h2>
<p>gcc 默认对齐是4字节对齐。在结构体中要注意。<br>
malloc是16字节对齐。</p>
<h2 id="cmake-make和makefile">cmake, make和makefile</h2>
<ol start="0">
<li><strong>cmake根据CMakeLists.txt生成makefile，make执行makefile。</strong></li>
<li>makefile是文件，包含了怎么样进行编译和链接。makefile可以手动写，但是它不跨平台（即不同平台的makefile不同），而且工程大很麻烦。</li>
<li>CMakeLists.txt是我们自己写的。cmake指向CMakeLists.txt所在的目录，cmake可以根据CMakeList.txt跨平台自动生成makefile。</li>
<li>make用来执行makefile，调用makefile中用户指定的命令进行编译和链接。</li>
</ol>
<h2 id="void">void *</h2>
<p>可以接收任意类型的赋值，无需强制类型转换。<br>
经过类型转换可以赋值给任意类型的变量。</p>
<h2 id="lambda表达式">lambda表达式</h2>
<p>为什么要有lambda表达式？</p>
<ol>
<li>总共有四种可调用对象，函数，函数指针，重载了函数运算符的类和lambda表达式。</li>
<li>lambda表达式的声明。<br>
auto f = [local variable](int x){return a;};</li>
<li>对于那种只在一两个地方使用的简单操作，lambda表达式是有用的。当在多个地方使用的话，通过应该使用一个函数，或者需要很多语句的话，也是函数比较好。</li>
<li>capture list中引用和值的作用。</li>
<li>可以和STL中的算法进行交互。</li>
</ol>
<h3 id="lambda的底层实现">lambda的底层实现</h3>
<h2 id="面向对象的几大原则">面向对象的几大原则</h2>
<ol>
<li>单一职责原则。解耦，增强内聚，即高内聚低耦合。</li>
<li>开放封闭原则。对扩展开放，对修改关闭。</li>
<li>里氏替换原则。子类可以替换父类。</li>
<li>依赖倒置原则。依赖于抽象而不是依赖细节。</li>
<li>接口分离原则。不需要让客户程序依赖它们不需要的方法。一个接口应该只提供一种对外的功能。</li>
<li>合成复用原则。</li>
<li>迪米特原则。</li>
</ol>
<h2 id="设计模式">设计模式</h2>
<ol>
<li>单例模式</li>
<li>reactor模式。是事件驱动模式，它由一个或者多个并发输入源，有一个service handler和多个request handler。这个service handler会同步的将输入多路复用给相应的request handler。<br>
比如说redis的</li>
</ol>
<h2 id="数据结构相关">数据结构相关</h2>
<h3 id="堆">堆</h3>
<p><strong>二叉堆是完全二叉树，一般可以用数组实现</strong>。最大堆就是每个根节点的值大于其子节点的值，最小堆就是每个根节点的值小于其子节点的值。</p>
<h4 id="sgi-stl-heap相关的算法">SGI STL heap相关的算法</h4>
<ul>
<li>push_heap，将新的节点插在最后一个位置。</li>
<li>pop_heap，弹出最大堆的堆顶元素。（或者就是heapify）</li>
<li>sort_heap，就是排序。</li>
<li>make_heap，创建一个最大堆。</li>
</ul>
<h4 id="优先队列">优先队列</h4>
<p>底层实现是二叉堆，总是弹出key最大的元素。</p>
<h3 id="哈希和哈希表">哈希和哈希表</h3>
<h4 id="什么是哈希">什么是哈希</h4>
<p>哈希：把任意长度的输入，变成固定长度的输出，这个映射的规则就是对应的哈希算法，原始数据映射后的输出叫做哈希值。哈希值存在的目的是加速key-value的查找速度。<br>
哈希常见的几种实现方式：顺序，链式，散列，索引。哈希表是其中的一种。<br>
注意把哈希和哈希表区分开来。</p>
<h4 id="碰撞-冲突">碰撞（冲突）</h4>
<p>什么是碰撞？输入不同的数据得到相同的输出，哈希一定会发生碰撞。</p>
<h4 id="hash">hash</h4>
<h5 id="好的hash要求">好的hash要求</h5>
<ol>
<li>抗碰撞。不同的输入得到相同输出的概率要小。</li>
<li>抗篡改。输入数据的小的变化会得到完全不同的值，输入相同的数据会得到相同的值。（雪崩效应）。</li>
<li>速度要好。哈希算法的效率要高</li>
<li>根据输出不能反推输入。</li>
</ol>
<h5 id="hash的应用">hash的应用</h5>
<ol>
<li>保存密码，保存用户密码的哈希值。（这也是很多地方只能重置密码的原因，因为它们也不知道你的密码。。。）</li>
<li>数据校验。</li>
<li>负载均衡。在服务器扩容时，使用一致性哈希。</li>
</ol>
<h4 id="hashtable">hashtable</h4>
<p>哈希表是用哈希算法实现的表，提供了对任何有名字项的存取和删除操作，也可以查看是一种字典，提供常数时间的读写操作。<br>
哈希表的扩容(rehash)，元素个数比bucket个数多，再打散，把bucket个数增加两倍（接近两倍的质数）。</p>
<h4 id="hashtable碰撞的解决方法">hashtable碰撞的解决方法</h4>
<p>负载系数：元素个数除以表格大小，除了开链法，都要在0,1之间。<br>
<strong>线性探测</strong>：插入的时候，找到一个不可用的位置（被其他值占了），继续找下下一个位置，直到找到一个空位置。查找的时候，如果找到一个和当前搜索的目标不同的值，就继续往下找。删除的话，采用惰性删除，只删除记号，实际操作等到rehash时再进行。<br>
最坏情况下，哈希表退化成链表。<br>
<strong>二次探测</strong>：发生冲突是，而是使用H+n^2的平方寻找可用的位置。</p>
<ol>
<li>对于二次探测，假设表格大小为质数，负载因子为0.5，保持负载因子在0.5以下，超过0.5就rehash，可以保证插入每一个元素的探测次数不多于2。</li>
<li>二次探测本身所需的计算量其实和一次探测差不多。</li>
<li>rehash的时候，必须重新计算表中的每一个元素。</li>
</ol>
<p><strong>开链(seperate chaining)</strong>：在每一个表格中维护一个链表。表格的负载系数会大于1。</p>
<h4 id="hashtable的桶">hashtable的桶</h4>
<p>SGI使用开链法，表格（桶的集合）使用vector（为了动态扩容），而链表使用自定义的结构体。</p>
<ol start="0">
<li>SGI使用bkt_num()获得每个元素应该存放在哪个bucket中，这个函数负责调用hash function取得一个可以执行取模运算的值。为什么不直接使用hash_function，因为有些元素类型无法直接拿来对hashtable的大小进行模运算，这时候需要做一些转换。<br>
开链法没有要求表格的大小为质数，但是SGI依然这么做了，并且准备了28个质数的表，并且提供一个函数去获取最接近并大于某个数的质数。</li>
<li>在创建一个hashtable对象时，首先要进行实例化，指明hashtable的各个模板参数，然后提供参数给构造函数（没有默认构造函数数）。其中有一个参数大小为n，表明要创建的hashtable的桶的个数（它会自动寻找一个接近n的质数）。</li>
<li>插入元素的时候，每插入一个就会判断是否需要resize。这个是一个很常用的操作，插入操作，首先判断需不要扩容，比如vector等。</li>
<li>扩容的原则：元素数量大于bucket的数量就resize。</li>
<li>复制和删除，删除的时候需要对bucket中每一个链表都删除。而复制的时候需要先把原有的给删除掉，然后保留和复制对象至少一样的空间。</li>
<li>hashtable的示例，在新版本的STL中，不能直接使用hashtable，unordered_set和unordered_map都是对hashtable的封装，调用构造函数时传入一个n是桶的数量，这个n必须指定（STL会自动改成比n大的最小质数）。</li>
</ol>
<h4 id="hash函数">hash函数</h4>
<p>STL定义了很多仿函数，都是模板。hash也是一个仿函数，返回size_t类型。对于char, int,等类型，通常就返回原值，而对字符串和string等设计了相应的转换函数，对于浮点数，怎么办，没有说，STL源码剖析的版本没有实现，但是cppreference上说有，应该是新增加的。</p>
<h4 id="其他">其他</h4>
<p>unordered类容器和非ordered类容器最大的区别就是一个是默认有序，一个是默认无序。</p>
<h3 id="树">树</h3>
<p><strong>二叉搜索树</strong>：任何节点的键值一定大于它的左子树中的所有节点，小于右子树中每一个节点的键值。<br>
关联式容器的内部结构是<strong>平衡二叉树</strong>，平衡二叉树有AVL树，红黑树，AA树等。平衡的大概意思就是没有一个节点过深。</p>
<h4 id="avl树">AVL树</h4>
<p>确保整颗树的深度是logn，任何节点的左右子树高度最多相差1。<br>
AVL利用单旋和双旋，可以将所有不平衡的情况转换为平衡的情况。<br>
对于深度最深的节点X，造成节点X不平衡只有四种情况：<br>
插入点在X的左子节点的左子树。<br>
插入点在X的左子节点的右子树。<br>
插入点在X的右子节点的左子树。<br>
插入点在X的右子节点的右子树。<br>
双旋第一步做完，第二步就是单旋了。</p>
<h4 id="红黑树-17">红黑树[17]</h4>
<p>红黑树需要满足以下规则：</p>
<ol>
<li>所有节点非红即黑。</li>
<li>根节点为黑色。</li>
<li>如果节点为红，子节点必须为黑。</li>
<li>任一节点到叶子节点的任何路径，所包含的黑色节点必须相同。</li>
</ol>
<p>为什么有了AVL还要有红黑树。AVL的条件太苛刻了，基本上每次插入和删除都需要重新调整。这样子在插入和删除比较频繁的情况下代价太大了。就提出了AVL树，查找的时间复杂度也是logn的，但是它的平衡条件要比AVL树宽松一些，插入和删除时也不会像AVL那样频繁破坏规则。<br>
查找的代价：最长路径长度不超过最短路径长度的2倍。<br>
插入代价：插入节点最多只需要两次操作，和AVL一样，变色的时间复杂度是O(logN)。<br>
删除代价：删除一个节点最多只需要旋转3次，但是变色操作的时间复杂度在O(logN)。</p>
<p>插入有四种情况：</p>
<ol>
<li>父节点为黑色，直接插入一个红色节点就好了。</li>
<li>父节点为红色，这个时候，取决于叔节点的颜色。
<ul>
<li>叔节点为红色，这个时候还取决祖父节点的父节点的颜色。如果那个节点是黑，把新增加的节点和父节点（叔节点）交换一下就好了。如果那个节点是红色，还需要更改祖父节点的颜色。</li>
<li>叔节点为黑色，</li>
<li>叔节点为黑色，</li>
</ul>
</li>
</ol>
<p>一个有n个节点的红黑树的高度至多为2log(n+1)。</p>
<h2 id="b树-18">B树[18]</h2>
<p>B树是对二叉树的推广，B树一般有一个阶数m，m阶代表每个树节点最多有m个查找路径，其实就是有多少个分叉，有m个分叉，最多就能存储m-1个数据。m=2时，就是二叉树，二叉树每个节点能分两叉，只能存1个数据。</p>
<ol>
<li>如果根节点不是叶子节点，必须有两个叶节点，一个数据，也就是两个分叉。</li>
<li>每个非叶子节点的子节点数大于等于m/2的上界，小于m；每个节点的关键字个数必须大于m/2-1（这里除法是有小数的）的上界小于m-1，就是对应的分叉数-1。</li>
<li>所有的叶子节点都位于同一层，不包含关键字信息。</li>
</ol>
<h2 id="b-树-18">B+树[18]</h2>
<p>B+树和B树的区别：</p>
<ol>
<li>每个节点有n个子节点，n个关键字，而B树n个子节点有n-1个关键字。</li>
<li>还有就是根节点和叶子节点关键字和子节点的个数范围。</li>
<li>叶子节点包含全部关键字，所有非叶子节点都只起到了索引的作用。非叶子节点上有关键字，但是只用来索引，没有对应记录的存储地址。</li>
<li>非叶子节点中出现的关键字是会重复出现在叶子节点中的。</li>
</ol>
<p>B+树的好处，扫库的时候直接顺序查找就好了，而B树需要中序遍历。B+树还支持区间查询，而B树不支持。<br>
通常在B+树中有两个头指针，一个指向根节点，一个指向关键字最小的叶节点。所以支持顺序查找，也支持多路查找。</p>
<h2 id="gcc和gdb-14">gcc和gdb[14]</h2>
<p>gcc 常用选项：<br>
-O编译器优化，Og最低等级的优化，On，数字越大优化等级越高。<br>
-Wall发出所有警告<br>
-g产生调试信息<br>
-o指定输出文件。<br>
-E只进行预处理<br>
-S编译，就是产生汇编代码<br>
-c之汇编，不链接，就是产生目标代码<br>
-static禁止使用动态链接库，只链接静态库，编译后可独立执行，不需要动态库，但是得到的可执行目标文件比较大。<br>
-L dir在库文件的搜索列表添加dir目录<br>
-I dir在头文件的搜索列表添加dir目录<br>
-shared</p>
<p>使用gdb调试时，需要使用使用gcc -g选项添加调试信息。</p>
<ul>
<li>gdb program，</li>
<li>gdb program core，用gdb查看core dump文件</li>
<li>gdb program pid，用gdb查看已经开始运行的进程。</li>
</ul>
<p>使用quit或者q退出。</p>
<p>gdb调试选项<br>
help<br>
run，开始调试程序<br>
break，设置断点。<br>
info break，查看断点信息。<br>
watch，为一个表达式设置一个检视点，可以加上-l选项，当监视的变量改变时，就会自动打印。<br>
catch,<br>
list，打印源码展示出指定的函数或者行。<br>
print，打印出表达式的值。<br>
display，每次程序停止的时候打印出<br>
bt，显示程序的调用栈信息。<br>
framen，简要查看第n帧的信息。<br>
info frame，详细查看当前帧的信息<br>
info registers，查看寄存器<br>
info args，查看当前帧的参数。<br>
info locals，查看当前帧中的局部变量。<br>
continue<br>
step</p>
<h2 id="移动-move-语义和右值引用-16">移动(move)语义和右值引用[16]</h2>
<p>移动语义，是为了避免无用的复制开销。右值引用的出现，让移动语义变得可能。将指针指向的内存直接拿过来使用。<br>
Move semantics is a new way of moving resources around in an optimal way by avoiding unnecessary copies of temporary objects, based on rvalue references. In my opinion, the best way to understand what move semantics is about is to build a wrapper class around a dynamic resource (i.e. a dynamically allocated pointer) and keep track of it as it moves in and out functions. Keep in mind however that move semantics does not apply only to classes!</p>
<h2 id="布隆过滤器">布隆过滤器</h2>
<p>布隆过滤器，它可以用来判断一个东西一定不存在或者可能存在。</p>
<h2 id="c-的异常安全性-28">C++ 的异常安全性[28]</h2>
<ol>
<li>基本承诺。不破坏数据和资源泄露。比如说锁，使用析构函数。</li>
<li>强烈保证。如果异常被抛出，对象的状态保持不变。</li>
<li>不抛出异常保证。不抛出异常，比如vector的移动构造函数。</li>
</ol>
<h2 id="可执行文件的执行过程">可执行文件的执行过程</h2>
<p>[30]</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in" target="_blank" rel="noopener">https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in</a><br>
2.<a href="https://blog.csdn.net/dengheCSDN/article/details/78985684" target="_blank" rel="noopener">https://blog.csdn.net/dengheCSDN/article/details/78985684</a><br>
3.<a href="https://www.cnblogs.com/carekee/articles/1630789.html" target="_blank" rel="noopener">https://www.cnblogs.com/carekee/articles/1630789.html</a><br>
4.<a href="https://stackoverflow.com/a/943303/8939281" target="_blank" rel="noopener">https://stackoverflow.com/a/943303/8939281</a><br>
5.<a href="https://stackoverflow.com/questions/524033/how-can-i-simulate-oo-style-polymorphism-in-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/524033/how-can-i-simulate-oo-style-polymorphism-in-c</a><br>
6.<a href="https://blog.csdn.net/dumpling5232/article/details/52632060" target="_blank" rel="noopener">https://blog.csdn.net/dumpling5232/article/details/52632060</a><br>
7.<a href="https://blog.csdn.net/uestclr/article/details/51372780" target="_blank" rel="noopener">https://blog.csdn.net/uestclr/article/details/51372780</a><br>
8.<a href="https://stackoverflow.com/questions/10068653/separate-compilation-in-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/10068653/separate-compilation-in-c</a><br>
9.<a href="https://blog.csdn.net/qq_34992845/article/details/69218843" target="_blank" rel="noopener">https://blog.csdn.net/qq_34992845/article/details/69218843</a><br>
10.<a href="https://www.cnblogs.com/fnlingnzb-learner/p/6423917.html" target="_blank" rel="noopener">https://www.cnblogs.com/fnlingnzb-learner/p/6423917.html</a><br>
11.<a href="https://isocpp.org/wiki/faq/inline-functions" target="_blank" rel="noopener">https://isocpp.org/wiki/faq/inline-functions</a><br>
12.<a href="https://isocpp.org/wiki/faq/virtual-functions" target="_blank" rel="noopener">https://isocpp.org/wiki/faq/virtual-functions</a><br>
13.<a href="https://www.cnblogs.com/findumars/p/6358194.html" target="_blank" rel="noopener">https://www.cnblogs.com/findumars/p/6358194.html</a><br>
14.<a href="https://blog.csdn.net/kikajack/article/details/92829582" target="_blank" rel="noopener">https://blog.csdn.net/kikajack/article/details/92829582</a><br>
15.<a href="https://en.cppreference.com/w/cpp/utility/hash" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/hash</a><br>
16.<a href="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners" target="_blank" rel="noopener">https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners</a><br>
17.<a href="https://blog.csdn.net/hackbuteer1/article/details/7740956" target="_blank" rel="noopener">https://blog.csdn.net/hackbuteer1/article/details/7740956</a><br>
18.<a href="https://blog.csdn.net/Raven_csdn/article/details/88816877" target="_blank" rel="noopener">https://blog.csdn.net/Raven_csdn/article/details/88816877</a><br>
19.<a href="https://www.cnblogs.com/raorao1994/p/9045756.html" target="_blank" rel="noopener">https://www.cnblogs.com/raorao1994/p/9045756.html</a><br>
20.<a href="https://www.cnblogs.com/guozhiming2003/archive/2010/03/09/1681951.html" target="_blank" rel="noopener">https://www.cnblogs.com/guozhiming2003/archive/2010/03/09/1681951.html</a><br>
21.<a href="https://cloud.tencent.com/developer/article/1173720" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1173720</a><br>
22.<a href="https://www.cnblogs.com/arnoldlu/p/8251333.html" target="_blank" rel="noopener">https://www.cnblogs.com/arnoldlu/p/8251333.html</a><br>
23.<a href="https://www.cnblogs.com/arnoldlu/p/8215414.html" target="_blank" rel="noopener">https://www.cnblogs.com/arnoldlu/p/8215414.html</a><br>
24.<a href="https://www.cnblogs.com/xkfz007/archive/2012/11/08/2760148.html" target="_blank" rel="noopener">https://www.cnblogs.com/xkfz007/archive/2012/11/08/2760148.html</a><br>
25.<a href="https://www.cnblogs.com/cherishui/p/4246133.html" target="_blank" rel="noopener">https://www.cnblogs.com/cherishui/p/4246133.html</a><br>
26.<a href="https://www.kernel.org/doc/gorman/html/understand/understand011.html" target="_blank" rel="noopener">https://www.kernel.org/doc/gorman/html/understand/understand011.html</a><br>
27.<a href="https://blog.csdn.net/qq_26626709/article/details/52742484" target="_blank" rel="noopener">https://blog.csdn.net/qq_26626709/article/details/52742484</a><br>
28.<a href="https://blog.csdn.net/bonchoix/article/details/8046727" target="_blank" rel="noopener">https://blog.csdn.net/bonchoix/article/details/8046727</a><br>
29.<a href="https://www.cnblogs.com/qingergege/p/9594432.html" target="_blank" rel="noopener">https://www.cnblogs.com/qingergege/p/9594432.html</a><br>
30.<a href="https://blog.csdn.net/zmx1026/article/details/46471439" target="_blank" rel="noopener">https://blog.csdn.net/zmx1026/article/details/46471439</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/29/UNIX-daemon/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/29/UNIX-daemon/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">UNIX daemon</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-29 16:08:36" itemprop="dateCreated datePublished" datetime="2020-02-29T16:08:36+08:00">2020-02-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-10 20:42:56" itemprop="dateModified" datetime="2020-03-10T20:42:56+08:00">2020-03-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="守护进程">守护进程</h2>
<p>守护进程常常在系统引导装入时启动，仅在系统关闭时才终止。<br>
守护进程没有控制终端，终端名设置为问号。</p>
<h2 id="将一个进程初始化成守护进程">将一个进程初始化成守护进程</h2>
<ol>
<li>调用umask设置mask。</li>
<li>创建一个没有控制终端的进程。</li>
<li>更改进程当前工作目录。</li>
<li>关闭继承的文件描述符。</li>
<li>守护进程一般不和标准输入，标准输出以及标准错误绑定。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/22/network-tcp-udp-message/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/22/network-tcp-udp-message/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">network tcp udp message</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-22 10:47:38" itemprop="dateCreated datePublished" datetime="2020-02-22T10:47:38+08:00">2020-02-22</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/21/C-virtual-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/21/C-virtual-function/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C virtual function</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-21 23:53:01" itemprop="dateCreated datePublished" datetime="2020-02-21T23:53:01+08:00">2020-02-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-22 00:59:57" itemprop="dateModified" datetime="2020-02-22T00:59:57+08:00">2020-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="虚函数">虚函数</h2>
<h2 id="纯虚函数">纯虚函数</h2>
<h2 id="什么函数不能是虚函数">什么函数不能是虚函数</h2>
<ol>
<li>非成员函数</li>
<li>友元函数</li>
<li>构造函数</li>
<li>静态函数</li>
<li>内联函数</li>
</ol>
<h2 id="虚函数的作用">虚函数的作用</h2>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://www.cnblogs.com/mfrbuaa/p/5118361.html" target="_blank" rel="noopener">https://www.cnblogs.com/mfrbuaa/p/5118361.html</a><br>
2.<a href="https://stackoverflow.com/questions/2391679/why-do-we-need-virtual-functions-in-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/2391679/why-do-we-need-virtual-functions-in-c</a><br>
3.<a href="https://stackoverflow.com/questions/8824359/why-use-virtual-functions" target="_blank" rel="noopener">https://stackoverflow.com/questions/8824359/why-use-virtual-functions</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/21/C-inline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/21/C-inline/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C inline</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-21 23:33:55" itemprop="dateCreated datePublished" datetime="2020-02-21T23:33:55+08:00">2020-02-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-25 15:06:02" itemprop="dateModified" datetime="2020-02-25T15:06:02+08:00">2020-02-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="none"></h2>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://isocpp.org/wiki/faq/inline-functions" target="_blank" rel="noopener">https://isocpp.org/wiki/faq/inline-functions</a><br>
2.<a href="https://stackoverflow.com/questions/5971736/c-inline-function" target="_blank" rel="noopener">https://stackoverflow.com/questions/5971736/c-inline-function</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/21/C-final-and-override/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/21/C-final-and-override/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C final and override</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-21 23:28:03" itemprop="dateCreated datePublished" datetime="2020-02-21T23:28:03+08:00">2020-02-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-22 01:06:13" itemprop="dateModified" datetime="2020-02-22T01:06:13+08:00">2020-02-22</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="final"><code>final</code></h2>
<h2 id="override"><code>override</code></h2>
<h2 id="作用-使用场合-不用的后果">作用，使用场合，不用的后果。</h2>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》<br>
2.ttps://stackoverflow.com/questions/8824587/what-is-the-purpose-of-the-final-keyword-in-c11-for-functions<br>
3.<a href="https://en.cppreference.com/w/cpp/language/final" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/final</a><br>
4.<a href="https://stackoverflow.com/questions/99297/how-are-virtual-functions-and-vtable-implemented" target="_blank" rel="noopener">https://stackoverflow.com/questions/99297/how-are-virtual-functions-and-vtable-implemented</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/20/UNIX-system-function/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/20/UNIX-system-function/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">UNIX system function</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-20 16:42:45 / 修改时间：22:27:16" itemprop="dateCreated datePublished" datetime="2020-02-20T16:42:45+08:00">2020-02-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="system">system</h2>
<p>ISO C定义了<code>system</code>函数，它用来执行一个shell命令，对系统的依赖性很强。<code>system</code>库函数调用<code>fork</code>创建一个子进程使用<code>execl</code>执行参数<code>system</code>指定的shell命令。相当于:<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>, <span class="string">"-c"</span>, command, (<span class="keyword">char</span> *) <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>POSIX.1包括了<code>system</code>接口，扩展了ISO C定义，描述了<code>system</code>在POSIX.1环境中的运行行为。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *command)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="属性">属性</h2>
<p><code>system</code>在其实现中调用了<code>fork</code>, <code>exec</code>和<code>waitpid</code>，可能有以下的返回值：</p>
<ol>
<li>如果<code>command</code>是一个空指针，当前系统是有可用的shell时，<code>system</code>返回非0值，否则返回0。在UNIX的各个实现中，一定提供了shell，当<code>command</code>是空指针时，总是返回非零值。</li>
<li><code>fork</code>失败或者<code>waitpid</code>返回处<code>EINTR</code>之外的出错，返回-1，设置errno。</li>
<li>如果<code>exec</code>失败，表示不能执行shell，返回值如同shell执行了exit(127)一样</li>
<li>所有三个函数都成功，<code>system</code>的返回值和在shell中执行相应命令的的termination status一样。</li>
</ol>
<h2 id="可能实现">可能实现</h2>
<p>其中一种<code>system</code>的可能实现如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">system</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmdstring)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> status;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(cmdstring == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        status = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        execl(<span class="string">"/bin/sh"</span>, <span class="string">"sh"</span>,  <span class="string">"-c"</span>, cmdstring, (<span class="keyword">char</span>*)<span class="number">0</span>);</span><br><span class="line">        _exit(<span class="number">127</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(waitpid(pid, &amp;status, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(errno != EINTR)</span><br><span class="line">            &#123;</span><br><span class="line">                status = <span class="number">-1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>system</code>而不是直接使用<code>fork</code>和<code>exec</code>的好处是：<code>system</code>进行了各种所需要的各种出错处理和信号处理。但是早期的系统中，没有<code>waitpid</code>函数，于是父进程使用下列语句等待子进程结束：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>((lastpid = wait(&amp;status) != pid &amp;&amp; lastpid !=<span class="number">-1</span>)</span><br><span class="line">    ;</span><br></pre></td></tr></table></figure></p>
<p>如果在调用<code>system</code>之前产生了其它子进程，如果这些子进程在<code>system</code>产生的子进程之前结束，那么上面的代码会将这些提前结束的子进程的进程ID和termination都给丢弃。<br>
<strong>system函数还有可能会出现漏洞。如果设置了set UID或者set GID位的程序执行<code>system</code>，那么这个进程的高级别权限可能会保持下来（现代的系统都解决了这个问题）。如果一个进程正在以特殊的权限(set UID和set GID)运行，它又想生成另一个进程执行另一个程序，它应该直接使用<code>fork</code>和<code>exec</code>，而且在<code>fork</code>之后，<code>exec</code>之前要改回普通权限，set UID和set GID程序绝不应该调用<code>system</code>函数。</strong></p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/20/UNIX-interpreter-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/20/UNIX-interpreter-file/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">UNIX interpreter file</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-20 16:41:39 / 修改时间：22:00:11" itemprop="dateCreated datePublished" datetime="2020-02-20T16:41:39+08:00">2020-02-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="解释器文件">解释器文件</h2>
<p>所有的UNIX系统都支持解释器文件。这种文件是文本文件，起始形式是：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#! pathname [optional-argument]</span><br></pre></td></tr></table></figure></p>
<p>在感叹号和pathname之间的空格是可以选的。常见的解释器文件以下列行开始：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>! /bin/bash</span><br></pre></td></tr></table></figure></p>
<p>pathname通常是绝对路径名，识别这种文件是<code>exec</code>系统调用处理的一部分。内核使调用<code>exec</code>函数的进程实际执行的并不是该<strong>解释器文件</strong>，而是在该解释器文件第一行中pathname指定的文件，即解释器。<br>
<strong>解释器文件是文本文件，它以!#开头，而解释器是二进制文件，由解释器中的文件第一行的pathname指定。</strong></p>
<h2 id="解释器文件的好处">解释器文件的好处</h2>
<p>是否一定需要解释器文件呢？不完全如此，但是它们确实使得用户得到效率方面的好处，代价是内核的额外开销，因为识别解释器文件的是内核。由于下列原因，解释器文件是有用的：</p>
<ol>
<li>有些程序是用某种脚本语言写的脚本，解释器文件可以将这一事实隐藏起来。</li>
<li>解释器脚本在效率方面提供了好处。</li>
<li>解释器脚本使我们可以使用除了/bin/sh以外的其他shell编写shell脚本。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>《APUE》第三版</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">335</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
        
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  

  

</body>
</html>
