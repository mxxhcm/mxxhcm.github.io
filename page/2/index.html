<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/2/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/2/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/18/UNIX-file-I-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/18/UNIX-file-I-O/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">UNIX file I/O</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 19:19:20" itemprop="dateCreated datePublished" datetime="2019-11-18T19:19:20+08:00">2019-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-24 10:10:01" itemprop="dateModified" datetime="2019-11-24T10:10:01+08:00">2019-11-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="注意事项">注意事项</h2>
<ol>
<li><code>creat</code>以只写方式打开文件，不能进行读操作。</li>
<li>为什么有了<code>open</code>要有<code>creat</code>，早期的<code>open</code>只支持0,1,2三个flag，不能打开不存在的文件，需要有单独的系统调用创建文件。而有了新的<code>open</code>以后就不需要<code>creat</code>了。</li>
<li><code>open</code>和<code>dup</code>返回的文件描述符一定是最小的未使用的文件描述符。</li>
<li>以<code>O_APPEND</code>打开的文件，如果进行<code>write</code>的话，即使使用<code>lseek</code>定位到非文件结尾处，最后也是在文件结尾处进行写。因为使用<code>O_APPEND</code>的<code>write</code>是由两个系统调用函数<code>lseek</code>和“普通的”<code>write</code>构成的一个操作。而<code>read</code>操作可以使用<code>lseek</code>进行定位。</li>
<li>所有的磁盘I/O都要经过内核的block buffers块缓存区，也称为内核的(buffer cache)缓冲区高速缓存。有一个例外就是对原始磁盘设备的I/O，先不考虑这种情况。<code>read</code>和<code>write</code>的数据都要被内核进行缓冲，术语unbuffered I/O指的是在用户的进程中不会对这两个函数进行自动缓冲，每次<code>read</code>和<code>write</code>都会进行一次系统调用。</li>
</ol>
<h2 id="文件i-o">文件I/O</h2>
<p>UNIX系统中的大多数文件I/O只用到了5个函数：<code>open</code>,<code>read</code>,<code>write</code>, <code>lseek</code>和<code>close</code>。不同的缓冲长度对<code>read</code>和<code>write</code>的速度影响。<br>
本章介绍的函数通常被称为不带缓冲的I/O，不带缓冲的I/O指的是每个<code>read</code>和<code>write</code>都调用内核中的一个系统调用，它们不是ISO C的组成部分，但是，它们都是POSIX.1和SUS的组成部分。<br>
只要涉及在多个进程之间共享资源，原子操作的概念就非常重要。本章还进行一步讨论在多个进程之间如何共享文件，以及所涉及的内核有关数据结构。相应的函数有：<code>dup</code>, <code>fcntl</code>,<code>sync</code>, <code>fsync</code>和<code>ioctl</code>等。</p>
<h2 id="文件描述符">文件描述符</h2>
<p>对于内核而言，所有打开的文件都是通过文件描述符引用。文件描述符是一个非负整数。当打开或者创建一个新文件时，内核向进程返回一个文件描述符。当读，写一个文件时，使用<code>open</code>或者<code>creat</code>返回的文件描述符标识该文件，将其作为参数传递给<code>read</code>或者<code>write</code>。<br>
UNIX系统shell把文件描述符0和进程的标准输入关联，文件描述符1和标准输出关联，文件描述符2和标准错误关联。为了提高系统的可读性，通常把它们换成符号常量<code>STDIN_FILENO</code>,<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>，它们都在头文件<code>&lt;unistd.h&gt;</code>中定义。<br>
文件描述符的变化范围是0到<code>OPEN_MAX-1</code>，早起的UNIX系统实现采用的上限值是19，现在的很多系统将它增加到63。（对于Linux, FreeBSD等的很多版本，文件描述符的变化范围几乎是无限的，只受到硬件资源的约束）</p>
<h2 id="open-openat和creat-close"><code>open</code>,<code>openat</code>和<code>creat</code>, <code>close</code></h2>
<p>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>pathname</code>是路径名，可以是相对路径也可以是绝对路径，<code>flags</code>的选项有很多，它们定义在<code>&lt;fcntl.h&gt;</code>头文件中。flag参数必须在<code>O_RDONLY</code>,<code>O_WRONLY</code>和<code>O_RDWR</code>之中选且只能选一个。然后还有很多其他的可选flag，常见的有：<code>O_APPEND</code>，<code>O_CREAT</code>，<code>O_EXCL</code>, <code>O_DIRECTORY</code>等，使用<code>man 2 open</code>就可以查看。</p>
<h3 id="openat-vs-open"><code>openat</code> vs <code>open</code></h3>
<p><code>open</code>和<code>openat</code>返回的一定是最小的没有使用的文件描述符。可以利用这一点可以在标准输入，标准输出，或者标准错误上打开新的文件。一个应用程序可以先关闭标准输出，然后打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符1上打开。<br>
<code>dirfd</code>参数是<code>open</code>和<code>openat</code>的区别，它们之间的关系有以下三种：</p>
<ol>
<li><code>pathname</code>指定的是绝对路径名，<code>dirfd</code>参数被忽略，<code>open</code>和<code>openat</code>一样。</li>
<li><code>pathname</code>指定的是相对路径名，<code>dirfd</code>制定了相对路径名在文件系统中的开始地址，<code>dirfd</code>参数通过打开相对路径名的目录来获取。</li>
<li><code>pathname</code>指定了相对路径名，<code>dirfd</code>的参数是特殊值<code>AT_FDCWD</code>，这种情况下，路径名是在当前工作目录中获取，<code>openat</code>和<code>open</code>在操作上类似。</li>
</ol>
<h3 id="openat作用"><code>openat</code>作用</h3>
<p>为什么增加<code>openat</code>函数，它的目的是解决两个问题：</p>
<ol>
<li>让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。同一进程中的所有线程共享相同的当前工作目录。</li>
<li>避免time-of-check-to-time-of-use错误。它的基本思想是，如果有两个基于文件的系统调用，第二个调用的结果依赖于第一个调用的结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间，文件可能改变了，这就造成了第一个调用的结果不再有效，使得程序的最终结果是错误的。</li>
</ol>
<h3 id="文件名和路径名过长">文件名和路径名过长</h3>
<p>当文件名和路径名过长时，是截断为系统允许的最长量还是返回出错信息？这个是由系统的历史形成的。通常BSD和Linux总是会返回出错，而System V和Solaris等不一定。<br>
具体的可以根据POSIX.1定义的常量<code>_POSIX_NO_TRUC</code>决定是截断还是出错。根据文件系统的类型，这个值可以变换。可以使用<code>fpathconf</code>或者<code>pathconf</code>查询目录具体支持哪种行为。<br>
如果<code>_POSIX_NO_TRUC</code>有效，当路径名超过<code>PATH_MAX</code>或者路径名中的任一文件名超过<code>NAME_MAX</code>时，返回出错，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。</p>
<h3 id="create和open"><code>create</code>和<code>open</code></h3>
<p><code>create</code>其实相当于指定了<code>open</code>的flags为<code>O_WRONLY|O_CREAT|O_TRUNC</code>。<br>
为什么有了<code>open</code>还要有<code>creat</code>，在早期的UNIX版本中，<code>flags</code>只能为0,1或者2。无法打开一个不存在的文件。因此需要另一个系统调用<code>creat</code>创建新文件。现在的<code>open</code>系统调用提供了<code>O_CREAT</code>和<code>O_TRUNC</code>选项，也就不需要<code>creat</code>了。</p>
<p><code>creat</code>的不足：<code>creat</code>以<strong>只写方式</strong>打开所创建的文件，即创建新文件之后，只能对新文件进行写操作，不能进行读操作。如果要创建一个临时文件，先写文件，然后再读文件。在<code>open</code>的老版本时，即不能打开不存在的文件时，需要先使用<code>creat</code>创建新文件，然后关闭该文件，然后使用<code>open</code>读文件。现在的话，可以使用以下方式实现创建新文件并进行读写：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_RDWR|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<h3 id="close函数"><code>close</code>函数</h3>
<p>调用<code>close</code>关闭一个已经打开的文件。函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建文件">创建文件</h3>
<ol>
<li>
<p>创建一个只写文件（如果文件存在，将文件清零）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">creat(filename, mode);</span><br><span class="line">open(filename, O_WRONLY|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>创建一个读写文件（如果文件存在，将文件清零）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_RDWR|O_CREAT|O_TRUNC);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>检测并创建一个只写文件（ 如果文件存在，错处，返回-1）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_WRONLY|O_CREAT|O_EXCL, mode);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>检测并创建一个读写文件（ 如果文件存在，错处，返回-1）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_RDWR|O_CREAT|O_EXCL, mode);</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<h2 id="lseek-read-write"><code>lseek</code>, <code>read</code>, <code>write</code></h2>
<p>它们的原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<h3 id="当前文件偏移量">当前文件偏移量</h3>
<ol>
<li>每一个打开文件都有一个和它相关联的当前文件偏移量(current file offset)。它通常是一个非负整数，用来度量从文件开始处的字节数。</li>
<li>通常情况下，读写操作都是从current file offset开始的，并且使偏移量增加读写的字节数。</li>
<li>除了指定<code>O_APPEND</code>选项外，打开一个文件时，默认的current file offset都是0。</li>
<li><code>whence</code>有三个取值，<code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code>。<code>lseek</code>成功执行，返回的offset等于<code>whence+offset</code>，对于<code>SEEK_CUR</code>和<code>SEEK_END</code>来说，参数<code>offset</code>可正可负，只要保证返回的current file offset非负即可。</li>
<li><code>lseek</code>中的<code>l</code>表示<code>long</code>。</li>
<li>current file offset可以大于文件长度，这种情况会在文件中构成一个空洞。空洞不要求占据磁盘上的存储区。</li>
</ol>
<h3 id="read"><code>read</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p><code>read</code>函数从文件描述符标示的文件中读取至多<code>count</code>个字节到<code>buf</code>指定的位置。如果操作成功的话，返回读到的字节数，如果已经到了文件结尾，返回0。出错的话，返回-1，设置errno。<br>
在以下几种情况下，读到的字节数可能少于<code>count</code>：</p>
<ol>
<li>读普通文件时，在读满<code>count</code>个之前就已经到了文件尾端。</li>
<li>某个信号造成中断时，而已经读取了部分数据时。</li>
<li>从终端设备读时，通常一次最多读一行。</li>
<li>从网络读时，网络中的缓冲机制。</li>
<li>从管道或者FIFO读取时，管道包含的字节数少于<code>count</code>。</li>
<li>从面向记录的设备读时，一次最多返回一个记录。</li>
<li>第二个参数<code>void*</code>表示通用指针。</li>
<li>返回值<code>ssize_t</code>是有符号类型，因为它需要返回正整数字节，0和-1。</li>
<li>第三个参数<code>size_t</code>是一个无符号类型。</li>
</ol>
<h3 id="write"><code>write</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p>它的返回值通常和<code>count</code>一样，否则就是出错了。出错的常量原因有：</p>
<ol>
<li>磁盘满了，</li>
<li>超过了一个给定进程的文件长度限制。</li>
<li>如果<code>lseek</code>返回的当前文件偏移量不在文件结尾，<code>write</code>会覆盖掉相应位置的数据。</li>
</ol>
<p>对于普通文件，写操作从文件的当前偏移量开始，如果打开文件时指定了<code>O_APPEND</code>选项，那么文件偏移量设置在文件结尾处。在一次写成功之后，文件偏移量增加实际写的字节数。</p>
<h3 id="创建含有空洞的文件">创建含有空洞的文件</h3>
<p>当<code>lseek</code>使得当前文件偏移量超过了现有文件长度，再继续进行<code>write</code>之后，当前文件偏移量和文件长度之间的内容就是空洞，它一般不占用磁盘空间，但是使用<code>ls</code>时，会把它计算成字节长度。</p>
<h2 id="i-o的效率">I/O的效率</h2>
<p>进程终止时，UNIX系统内核会关闭所有打开的文件描述符，但是并不会关闭标准输入和输出。<br>
在选取<code>read</code>和<code>write</code>的buffer大小时，也有一定技巧。大多数文件系统都使用了预读(read ahead)技术。当进行顺序读取时，系统试图读入比应用所要求的更多数据，并且假设应用很快就会读这些数据。<br>
在使用<code>ext4</code>文件系统时，它的磁盘块长度是4096，所以当BUFFER大于等于4096时，读写时间几乎不变。</p>
<h2 id="文件共享">文件共享</h2>
<h3 id="i-o数据结构">I/O数据结构</h3>
<p>UNIX支持在不同进程之间共享打开文件。这需要使用到内核用于I/O的数据结构。内核使用三种数据结构表示打开文件：进程表记录项，文件表项和节点表项。</p>
<ol>
<li>进程表记录项。每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，每隔描述符占用一项，其中内容有：文件描述符标志和指向文件表项的指针。</li>
<li>文件表项。内核为所有打开文件维持一张文件表。每个表项包含：文件状态标志，当前文件偏移量和指向该文件节点表项的指针</li>
<li>节点表项。每个打开设备都有一个节点结构。包含文件的所有者，文件长度，指向文件实际数据块在磁盘上所在的指针等。</li>
</ol>
<p>如果两个进程打开了同一个文件，每个进程都会获得各自相应文件的一个文件表项，这两个文件表项中的节点表项指针指向同一个节点表项。也有可能多个进程的文件描述符指向同一个文件表项。<br>
自己的总结，每一个文件都有一个节点表项，记录文件长度和数据存储地址，而文件表项记录的是在节点表项的哪个位置进行什么操作，进程表记录项记录了每个进程打开了几个文件，每个文件的文件表项在哪里。</p>
<h3 id="write和lseek对当前文件偏移量的影响"><code>write</code>和<code>lseek</code>对当前文件偏移量的影响</h3>
<ol>
<li><code>write</code>在写入完成后，在文件表项的当前文件偏移量上加上写入的字节数，如果当前文件偏移量超过了当前文件长度，更新节点表项中的文件长度，相当于文件长度增加了。</li>
<li><code>lseek</code>只修改文件表项中的当前文件偏移量，不进行任何I/O操作。</li>
<li><code>lseel</code>定位到文件尾端的时候，文件表项中当前文件偏移量被设置为节点表项中的当前文件长度。</li>
<li>使用<code>O_APPEND</code>打开文件的时候，文件表项中的文件状态标志也会被修改，对于使用<code>O_APPEND</code>操作打开的文件，进行<code>write</code>操作相当于先将当前文件偏移量设置为节点表项中的文件长度，然后再<code>write</code>，即使先使用<code>lseek</code>将当前文件偏移量设置为<code>SEEK_SET</code>也不行，也是进行追加。所以在每次append之前不用先进行<code>lseek</code>，<code>lseek</code>了也白做。但是<code>read</code>可以使用<code>lseek</code>正常进行。</li>
</ol>
<h2 id="原子操作">原子操作</h2>
<p>如果一个操作是原子操作，那么这个操作的所有步骤要么不执行，要不全部执行。</p>
<h3 id="追加文件">追加文件</h3>
<p>指定<code>open</code>的<code>O_APPEND</code>选项实现追加操作，<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileno=open(filename, O_RDWR|O_APPEND);</span><br><span class="line">write(file, buf, BUFSIZE);</span><br></pre></td></tr></table></figure></p>
<p>追加文件是一个原子操作，如果不是原子操作的话，就相当于：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fileno = open(filename, O_RDWR);</span><br><span class="line">lseek(fileno, <span class="number">0</span>, SEEK_END);</span><br><span class="line">write(fileno, buf, BUFSIZE);</span><br></pre></td></tr></table></figure></p>
<p>如果是单进程，上面两段代码是等价的，但是如果是多进程的话，下面代码就可能会出错。进程A lseek，进程B lseek，进程A write，进程B write。进程B的操作会覆盖进程A的操作。<br>
所以这也就解释了使用选项<code>O_APPEND</code>后的操作，因为这个append的<code>write</code>是由两个系统调用组成的原子操作，先<code>lseek</code>，再普通的<code>write</code>。所以在调用<code>write</code>之前不用<code>lseek</code>，就算你<code>lseek</code>了也是白<code>lseek</code>。</p>
<h3 id="读写原子操作">读写原子操作</h3>
<p>读写的原子操作原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>pread</code>相当于调用<code>lseek</code>和<code>read</code>的原子操作，但是<code>pread</code>不改变当前文件偏移量。<br>
调用<code>write</code>相当于调用<code>lseek</code>和<code>write</code>的原子操作，但是<code>pwrite</code>不改变当前文件偏移量。</p>
<h3 id="创建文件原子操作">创建文件原子操作</h3>
<p>检查文件是否存在和创建文件是一个原子操作。如果这个操作不是原子操作，比如说是由<code>open</code>和<code>creat</code>两个函数调用组成的一个操作，它们不是一个原子操作。当前进程确定一个文件不存在，决定创建该文件。在<code>open</code>和<code>creat</code>调用之间，另一个进程创建了这个文件，并写入了数据。当前进程会再次创建这个文件，覆盖掉另一个进程写入的数据。</p>
<h2 id="dup和dup2复制文件描述符"><code>dup</code>和<code>dup2</code>复制文件描述符</h2>
<p>UNIX系统提供了两个原子操作<code>dup</code>和<code>dup2</code>对一个指定的文件描述符进行复制。如果得到的新文件描述符和fd不同，那么这两个文件描述符共享同一个文件表项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dup返回的文件描述符一定是当前可用文件描述符中的最小值。和open一个文件类似。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过fd2指定返回的新的文件描述符。</span></span><br><span class="line"><span class="comment">// 如果fd2和fd相等，返回fd2</span></span><br><span class="line"><span class="comment">// 如果fd2和fd不等，关闭fd2，然后返回fd2。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(inf fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>非原子操作的文件描述符复制可以通过<code>fcntl</code>实现。</p>
<h2 id="sync-fsync和fdatasync"><code>sync</code>,<code>fsync</code>和<code>fdatasync</code></h2>
<p>UNIX系统在内核中设置了缓冲区高速缓存或者页高速缓存，大多数磁盘的I/O都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些写入磁盘，这方方式叫做<strong>延迟写</strong>。<br>
等到内核需要使用缓冲区存放其他磁盘块数据时，它会把所有延迟写数据写入磁盘。为了保证磁盘上实际文件系统和缓冲区中内容的一致性，UNIX提供了三个函数，它们的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.将所有修改过的块缓冲区排入队列，然后就返回，并不等待实际写磁盘操作结束。</span></span><br><span class="line"><span class="comment">// 通常情况下，update系统守护进程一般每隔30秒调用一次`sync`函数，这就保证了定期将内核块缓冲区的内容写入磁盘。命令sync(1)也会调用`sync`函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.只对文件描述符`fd`指定的一个文件起作用，等到写磁盘操作结束才返回。更新文件的数据和属性。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.只对文件描述符`fd`指定的一个文件起作用，等到写磁盘操作结束才返回。只更新文件的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="fcntl"><code>fcntl</code></h2>
<p>fcntl是文件控制函数，它的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>fcntl有很多种功能，这一节先介绍以下五种：</p>
<ol>
<li>复制一个已有的描述符，设置<code>cmd</code>为<code>F_DUPFD</code>或者<code>F_DUPFD_CLOEXEC</code>。</li>
<li>获取和设置文件描述符标志，设置<code>cmd</code>为<code>F_GETFD</code>或者<code>F_SETFD</code>。当前只有一个文件描述符标志，就是<code>FD_CLOEXEC</code>。</li>
<li>获取和设置文件状态标志，设置<code>cmd</code>为<code>F_GETFL</code>或者<code>F_SETFL</code>。<br>
获取文件状态标志时，介绍<code>open</code>时给出了许多文件状态标志。对于五个互斥的权限，需使用<code>O_ACCMODE</code>取得访问方式位，然后与相应的权限比对。对于其他的权限，将返回值和相应的标志进行与操作，判断是否设置了相应位。<br>
设置文件状态标志位时，可以更改的几个权限有，<code>O_APPEND</code>, <code>O_NONBLOCK</code>, <code>O_SYNC</code>, <code>O_DSYNC</code>, <code>O_RSYNC</code>, <code>O_FSYNC</code>, <code>O_ASYNC</code>。</li>
<li>获取和设置异步I/O所有权，设置<code>cmd</code>为<code>F_GETOWN</code>或者<code>F_SETOWN</code>。</li>
<li>获取和设置记录锁，设置<code>cmd</code>为<code>F_GETLK</code>，或者<code>F_SETLK</code>或者<code>F_SETLKW</code>。</li>
</ol>
<p>在修改文件描述符标志或者文件状态标志时，必须要先获得现在的标志值，然后对它进行修改，获得新的标志值，然后进行设置。不能单单设置一个标志值，否则会关闭以前设置的标志位。</p>
<h2 id="ioctl"><code>ioctl</code></h2>
<p>这个有点看不懂。</p>
<h2 id="dev-fd"><code>/dev/fd</code></h2>
<p>UNIX提供了<code>/dev/fd</code>目录，其中包含了名为0, 1, 2的文件。打开<code>/dev/fd/0</code>,<code>/dev/fd/1</code>, <code>/dev/fd/2</code>相当于复制描述符n。即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/df/0"</span>, mode);</span><br><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>上述两行代码是相等的。文件描述符0和fd共享同一个文件表项。在Linux中，文件描述符被映射成指向底层物理文件的符号链接。比如打开<code>/dev/fd/0</code>时，实际上打开的是与标准输入关联的文件。返回的新文件描述符的mode和<code>/dev/fd</code>文件描述符的mode并不相关。所以，即使我们使用<code>O_RDWR</code> mode打开<code>/dev/fd/0</code>，也不能对<code>fd</code>进行写操作。<br>
Linux下提供了<code>/dev/stdin</code>，<code>/dev/stdout</code>, <code>/dev/stderr</code>，它们和<code>/dev/fd/0</code>等都是一样的。在shell中，可以使用dev/fd作为参数，把标准输入和输出当做一个文件，可以像处理其他文件一样进行操作。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/18/how-C-program-works/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/18/how-C-program-works/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">How C program works</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 14:27:10" itemprop="dateCreated datePublished" datetime="2019-11-18T14:27:10+08:00">2019-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-19 22:36:20" itemprop="dateModified" datetime="2019-11-19T22:36:20+08:00">2019-11-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="none"></h2>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://mapan1984.github.io/program/2018/03/10/C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/#c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">https://mapan1984.github.io/program/2018/03/10/C-编译过程与库文件的作用/#c语言编译过程</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/14/C-lvalue-and-rvalue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/14/C-lvalue-and-rvalue/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C and C++ lvalue and rvalue</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-14 17:22:02" itemprop="dateCreated datePublished" datetime="2019-11-14T17:22:02+08:00">2019-11-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-17 20:19:24" itemprop="dateModified" datetime="2019-11-17T20:19:24+08:00">2019-11-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对象-object-和值-value">对象(object)和值(value)</h2>
<h3 id="c11标准">C11标准</h3>
<p>C11标准的定义如下([14]3.15, 3.19)：</p>
<blockquote>
<p>3.15 object<br>
region of data storage in the execution environment, the contents of which can represent values<br>
NOTE When referenced, an object may be interpreted as having a particular type; see 6.3.2.1.<br>
3.19 value<br>
precise meaning of the contents of an object when interpreted as having a specific type</p>
</blockquote>
<p>object是一块内存空间，它的内容可以表示值。当被使用时，一个对象可以解释为一种特定的类型。value是以具体类型解析object中的内容。</p>
<h3 id="c-11标准">C++11标准</h3>
<p>C++11标准的定义如下([17]1.8)：</p>
<blockquote>
<p>An object is a region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. — end note ]<br>
An object can have a name.<br>
An object has a storage duration which influences its lifetime.<br>
An object has a type.<br>
The term object type refers to the type with which the object is created.</p>
</blockquote>
<p>C++ 中的obejct也是一个内存空间。object可以有名字，可以有类型（内置类型还是复合类型都行），有一个duration。也就是C++ Primer第五版中说的对象是具有某种数据类型的内存空间，可以有名，可以没有名字。</p>
<h2 id="c语言中的lvalue和rvalue">C语言中的lvalue和rvalue</h2>
<h3 id="左值和右值的定义">左值和右值的定义</h3>
<p>首先看一下标准中的定义：<br>
C11中左值的定义：</p>
<blockquote>
<p>An lvalue is an expression (with an object type other than void) that potentially designates an object;64) if an lvalue does not designate an object when it is evaluated, the behavior is undefined. When an object is said to have a particular type, the type is specified by the lvalue used to designate the object. A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a constqualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a constqualified type.</p>
</blockquote>
<p>C++11中左值的定义([17]3.10)：</p>
<blockquote>
<p>An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example, the result of calling a function whose return type is an lvalue reference is an lvalue. — end example ]</p>
</blockquote>
<p>C中早期的定义：<br>
左值是一个表达式，可以出现在赋值操作的左边或者右边，而右值只能出现在左边。<br>
后来C标准和C++ 标准中定义的左值基本一样，可以总结为：<br>
左值指定了一个函数或者对象（变量）。它存放在内存中的某个位置，并且允许使用取值地址符<code>&amp;</code>获取这块内存的地址。如果<code>E</code>是指针类型的表达式，那么<code>*E</code>是<code>E</code>指向的函数或者对象的左值表达式。左值分为可修改左值和不可修改左值，像常量，数组名，等属于不可修改左值，而其它的左值都是可修改左值。如果一个表达式不是左值，那么它就被定义为右值。<br>
怎么样判断左值，满足以下两点中任何一点就是一个左值：</p>
<ol>
<li>是否有名字</li>
<li>是否能够取到它的地址</li>
</ol>
<p>C++ Primer中给出的一个方法：当一个对象被用作右值的时候，用的是对象的值。当一个对象被用作左值的时候，用的是对象在内存中的位置。<br>
示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = &amp;ch; <span class="comment">//ch可以当做左值，也可以当做右值</span></span><br><span class="line">&amp;ch = <span class="number">3</span>;  <span class="comment">//错误，因为&amp;ch我们只能取得它的值，并不能获取它在内存中的地址，即它只是一个右值，不能当做左值。</span></span><br></pre></td></tr></table></figure>
<p><strong>对象（变量）和指针变量中存放的内容（即地址）的区别，对象可以直接进行赋值。指针变量中存放的是一个地址，地址本身就是一个数字，是一个右值，不能对其进行赋值，对这个地址进行解引用，得到指针指向对象的左值表达式。</strong></p>
<h3 id="左值和右值的转换">左值和右值的转换</h3>
<h4 id="左值到右值的隐式类型转换-13">左值到右值的隐式类型转换[13]</h4>
<ol>
<li>C语言存在左值到右值的默认类型转换，当运算符需要右值操作对象时，而给出的是左值操作对象时，编译器会默认将左值转换成右值。</li>
<li>数组到指针的转换。在需要右值操作对象的时候，编译器换将数组名转换为其首元素的地址，类型为指向元素的指针。</li>
<li>函数到指针的转换。</li>
</ol>
<p>一般情况下，对象之间的运算，对象是以右值的形式参与的。比如<code>+</code>运算符需要两个右值运算数：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中,<code>a</code>和<code>b</code>都是左值，在<code>int c = a+b;</code>中，它们经历了隐式的类型转换，将左值转换为了右值。<br>
除了数组，函数，不完整的类型，所有的左值都可以转换为右值，但是右值不能转换为左值。</p>
<h4 id="右值产生左值">右值产生左值</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a[<span class="number">0</span>]; <span class="comment">//a和&amp;a[0]都是数组首元素的值</span></span><br><span class="line">*(p+<span class="number">1</span>) = <span class="number">-1</span>;    <span class="comment">//p+1是右值，但是*(p+1)是左值</span></span><br></pre></td></tr></table></figure>
<h4 id="左值产生右值">左值产生右值</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;var;  <span class="comment">//var是左值，但是&amp;var是右值。</span></span><br></pre></td></tr></table></figure>
<p>单目运算符<code>&amp;</code>需要一个左值作为它的运算对象，当且仅当<code>n</code>是一个变量时，<code>&amp;n</code>是一个有效的表达式，<code>&amp;12</code>是错误的。</p>
<h3 id="可修改左值和不可修改左值">可修改左值和不可修改左值</h3>
<ol>
<li>
<p>左值指向的位置的内容，如果可以被修改，那么这个左值是一个可修改左值，否则就是不可修改左值。</p>
</li>
<li>
<p>如果一个表达式指向内存中的一个位置，并且它的类型是算术类型，<code>struct</code>，<code>union</code>或者pointer，那么它就是一个可修改左值。</p>
</li>
<li>
<p>可修改左值不能含有数组类型，不完整的类型，<code>const</code>修饰的类型，它们都是不可修改左值。如果<code>struct</code>或者<code>union</code>要是可修改左值，那么它们不能有<code>const</code>成员。</p>
</li>
<li>
<p>为什么可修改左值不能是<code>array</code>，我们不能对数组赋值，但是可以通过下标操作对数组进行赋值，所以数组名字不能是一个可修改的左值。或者说数组名字其实是数组首元素的地址。这里的数组赋值说的是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">b = a;  <span class="comment">//想要做的操作是把数组a赋值给数组b，这是错误的。</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>为什么没有说函数不能是可修改左值，函数名指定的是一个函数不是一个对象，所以函数名不能是左值，自然也不能是一个可修改左值。</p>
</li>
<li>
<p>数组和指针都是左值，但是数组是不可修改左值，而指针是可修改左值（非const）。数组作为作为右值表示的是数组首元素的地址，数组作为左值，表示的是数组类型，是不能修改的左值。而指针变量可以作为左值，因为我们可以取得它的地址，指针变量作为右值是指针变量存储的值，即它指向变量的地址。</p>
</li>
</ol>
<h3 id="左值类型">左值类型</h3>
<p>C语言中的左值有以几种：</p>
<ol>
<li>任意类型变量的名字</li>
<li>下标运算符<code>[]</code></li>
<li>指针的成员访问操作<code>-&gt;</code>和<code>.</code></li>
<li>单目运算符解引用<code>*</code>的表达式，不能指向一个数组</li>
<li>指针的解引用操作，不能是一个函数指针</li>
<li>数组，<code>const</code>对象，是一个不可修改左值，比如<code>const int a = 0;</code>，<code>a</code>是一个不可修改左值</li>
<li>字符串字面值常量是一个不可修改左值[12]，因为C中没有字符串类型，字符串常量都是以字符数组类型存储的，而在C中，除了左值以外没有任何方式可以让数组存在于表达式中。</li>
</ol>
<h2 id="c-和c中lvalue的区别">C++和C中lvalue的区别</h2>
<p>《C++ Primer》中说C++和C中的左值和右值不一样，我怎么觉得都一样呢。（好吧，自己还是道行太浅了）。<br>
举例来说：</p>
<ol>
<li>比如说<code>++i</code>和<code>--i</code>操作，在C中，它是一个右值，而在C++ 中，它是左值，而<code>i++</code>和<code>i--</code>在C和C++ 中都是右值[9]。</li>
<li>在C语言中，三目运算符（?:）的结果一定是右值，而在C++中，如果:旁边的两个操作数是左值，那么结果也是左值[10]。</li>
</ol>
<h3 id="c-中的左值运算">C++中的左值运算</h3>
<ol>
<li>赋值运算需要一个非常量左值作为左侧运算对象，得到的结果也仍然是一个左值。</li>
<li>取地址符用作一个左值运算对象，返回一个指向该运算对象的地址，这个值是一个右值。</li>
<li>内置解引用运算符，下标运算符，迭代器解引用运算符，<code>string</code>和<code>vector</code>的求值结果都是左值。</li>
<li>内置类型和迭代器的递增递运算符作用于左值运算对象，其前置版本所得的结果也是左值，即<code>++iter</code>, <code>++i</code>等。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C和指针》<br>
2.《C++ Primer》<br>
3.<a href="https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/</a><br>
4.<a href="https://segmentfault.com/a/1190000003793498" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003793498</a><br>
5.<a href="https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type" target="_blank" rel="noopener">https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type</a><br>
6.<a href="https://www.quora.com/What-is-lvalue-and-rvalue-in-C" target="_blank" rel="noopener">https://www.quora.com/What-is-lvalue-and-rvalue-in-C</a><br>
7.<a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c" target="_blank" rel="noopener">https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c</a><br>
8.<a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c" target="_blank" rel="noopener">https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c</a><br>
9.<a href="https://www.zhihu.com/question/29936562/answer/46129706" target="_blank" rel="noopener">https://www.zhihu.com/question/29936562/answer/46129706</a><br>
10.<a href="https://www.zhihu.com/question/313519801/answer/642403872" target="_blank" rel="noopener">https://www.zhihu.com/question/313519801/answer/642403872</a><br>
11.<a href="https://www.zhihu.com/question/36052573/answer/65743965" target="_blank" rel="noopener">https://www.zhihu.com/question/36052573/answer/65743965</a><br>
12.<a href="https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value</a><br>
13.<a href="https://www.zhihu.com/question/25814721/answer/31648501" target="_blank" rel="noopener">https://www.zhihu.com/question/25814721/answer/31648501</a><br>
14.<a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues" target="_blank" rel="noopener">https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues</a><br>
15.<a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf</a><br>
16.<a href="https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard" target="_blank" rel="noopener">https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard</a><br>
17.<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-variable-declaration-and-definition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-variable-declaration-and-definition/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C++ variable declaration and definition</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 21:22:49" itemprop="dateCreated datePublished" datetime="2019-11-13T21:22:49+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-16 13:00:16" itemprop="dateModified" datetime="2019-11-16T13:00:16+08:00">2019-11-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="c-类型">C++类型</h2>
<p>C++中，对象（变量）的类型通常有两种：</p>
<ol>
<li>基本内置类型，整形和浮点型。整形又包括整数，布尔型，字符串，浮点型又包括单精度浮点型和双精度浮点型，详细介绍可以查看<a href="https://mxxhcm.github.io/2019/11/05/C-fundamental-types-and-variables/">C++算术类型</a>。</li>
<li>复合类型，包括<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">指针</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-array/">数组</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-reference/">引用</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-class/">类</a>，结构，联合类型。</li>
</ol>
<h2 id="变量和对象">变量和对象</h2>
<h3 id="变量">变量</h3>
<p>变量是一个有名字的，可供程序操作的存储空间。C++ 中的每个变量都有数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能够参数的运算。对于C++ 程序员来说，变量和对象一般可以互用。</p>
<h3 id="对象">对象</h3>
<p>什么是对象，具有某种数据类型的内存空间，并不区分是复合类型还是内置类型，也不区分是否有名字和是否只读。</p>
<h2 id="变量定义">变量定义</h2>
<p>一条定义语句由一个基本数据类型和紧随其后的一个或者多个声明符组成。每个声明符声明了一个变量并且指定该变量为与基本数据类型有关的某种类型。<br>
基本变量的声明语句由数据类型和变量名组成，声明符就是变量名。而复合类型的声明语句中声明符除了变量名，还会有类型修饰符，如<code>*</code>,<code>&amp;</code>和<code>[]</code>等等。比如引用的声明语句中将声明符写成<code>&amp;d</code>的形式，其中<code>d</code>是声明的变量名,<code>&amp;</code>是类型修饰符。指针是另外一种复合类型，通常将声明符写成<code>*d</code>的形式，其中<code>d</code>是变量名，<code>*</code>是类型修饰符。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p>在指针操作中，其中操作符<code>*</code>称为解引用，操作符<code>&amp;</code>称为取地址符。</p>
<h3 id="复合类型的定义">复合类型的定义</h3>
<p>变量的定义包含一个基本数据类型和一组声明符。在一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是一条定义语句可能定义处不同类型的变量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure></p>
<p>在定义语句中，类型修饰符<code>*</code>和<code>&amp;</code>仅仅修饰紧随其后的变量。关于引用和指针的声明，一般有两种写法：</p>
<ol>
<li>
<p>将修饰符和变量名写在一起，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>把修饰符和类型名写在一块，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1;</span><br><span class="line"><span class="keyword">int</span>* p2;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这两种方法都对，C++ primer采用第一种。</p>
<h4 id="指向指针的指针">指向指针的指针</h4>
<p>声明符中修饰符的个数没限制，可以写很多个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival; <span class="comment">//pi指向一个int数</span></span><br><span class="line"><span class="keyword">int</span> **pi = &amp;pi; <span class="comment">//pi指向一个int的指针。</span></span><br></pre></td></tr></table></figure>
<h4 id="指针的引用">指针的引用</h4>
<p>引用不是对象，所以指针不能指向引用。但是指针是对象，所以有指针的引用。复杂的指针或者引用的声明语句，从右往左读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;    <span class="comment">//从右往左阅读，r是一个引用，是谁的引用，int*的引用。</span></span><br><span class="line"></span><br><span class="line">r = &amp;i; </span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">// i=0</span></span><br></pre></td></tr></table></figure>
<h2 id="变量初始化">变量初始化</h2>
<p>初始化是在变量创建时给一个特定的值，而赋值是把对象的当前值擦除，使用一个新值代替。</p>
<h3 id="默认初始化">默认初始化</h3>
<p>当变量没有指定初值，使用默认初始化的方式进行初始化。默认值由变量类型和变量位置决定。<br>
对于内置类型的变量，如果没有显式初始化，它的位置由定义的位置决定。函数内部的内置类型不会被初始化，定义于任何函数外部的内置类型被初始化为0。未初始化的变量的值是未定义的。<br>
对于自定义的类型来说，每个类决定初始化对象的方式，而且是否允许不经过初始化就定义对象也由自己决定。如果类允许这种行为，由类决定对象的初始值是什么；如果类要求每个对象显示初始化，在创建类对象没有进行明确的初始化操作时，会引发错误。</p>
<h2 id="声明和定义的区别">声明和定义的区别</h2>
<ol>
<li>声明需要给出变量的类型和名字，但是不需要申请存储空间。</li>
<li>只进行声明的话使用<code>extern</code>关键字，不要显式的初始化变量。包含了显式初始化的声明就变成了定义。</li>
<li>变量只能定义一次，但是可以声明多次。可以方便的在多个文件中使用同一个变量。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-type-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-type-operation/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C++ type operation</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:19:46 / 修改时间：14:20:42" itemprop="dateCreated datePublished" datetime="2019-11-13T14:19:46+08:00">2019-11-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类型操作">类型操作</h2>
<h3 id="别名typedef和using">别名<code>typedef</code>和<code>using</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typdef dobuel wages;    <span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_imte;  <span class="comment">//别名声明</span></span><br></pre></td></tr></table></figure>
<h4 id="指针-常量和类型别名">指针，常量和类型别名</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//基本数据类型是char *，即指针类型</span></span><br><span class="line"><span class="keyword">const</span> pstring *p;</span><br></pre></td></tr></table></figure>
<p>不能简单的把<code>pstring</code>用<code>char *</code>替换，如果替换了变成下式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>;   <span class="comment">//基本数据类型是const char，</span></span><br></pre></td></tr></table></figure>
<p>很容易把<code>*</code>看成是声明符的一部分，即<code>*cstr</code>的一部分，但是实际上<code>*</code>是和<code>const char</code>在一起的。<code>const char *cstr</code>是<strong>指向<code>char</code>常量的指针</strong>，而<code>const pstring cstr</code>是指向<code>char</code>的<strong>常量指针</strong>。</p>
<h3 id="auto关键字"><code>auto</code>关键字</h3>
<p>编译器自动分析表达式的类型，<code>auto</code>定义的变量必须有初值。<br>
使用一条<code>auto</code>语句可以声明多个变量，多个变量的基本数据类型必须一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i= 0, *p = &amp;i; //正确</span><br><span class="line">auto i = 1, d = 3.14;   //错误</span><br></pre></td></tr></table></figure>
<h4 id="复合类型-常量和auto">复合类型，常量和<code>auto</code></h4>
<ol>
<li>编译器使用<code>auto</code>推断出来的值和初始值类型有时候不完全一样。比如使用引用其实使用的是引用对象的值。</li>
<li><code>auto</code>会忽略顶层<code>const</code>，保留底层<code>const</code>。如果希望<code>auto</code>推断出的是顶层<code>const</code>，需要显式的加一个<code>const</code>，即<code>const auto = ...</code>。</li>
<li>将引用的类型设为<code>auto</code>也可以保留初始值中的顶层<code>const</code>属性，</li>
<li>如果给初始值绑定一个引用，并且设为<code>auto</code>类型，这个对象就不是顶层<code>const</code>了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a是一个int,而不是int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;    <span class="comment">//b是一个int</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;    <span class="comment">//c是一个int, cr是ci别名，ci是顶层const</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;    <span class="comment">//d是int *</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">//e是一个指向const的指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">//f是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci;   <span class="comment">// g是int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">43</span>;<span class="comment">//这个j就不是顶层const了，类型是const int &amp;，它是底层const。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="decltype类型"><code>decltype</code>类型</h3>
<p><code>decltype</code>和<code>auto</code>的区别：</p>
<ol>
<li>它只返回表达式的类型。</li>
<li>它能识别顶层<code>const</code>和引用类型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;ri = i, *pi = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(ri);       <span class="comment">//是int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(ri+<span class="number">0</span>);    <span class="comment">//是int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) p = <span class="number">0</span>; <span class="comment">//const int,</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) q = <span class="number">0</span>; <span class="comment">//const int &amp;，顶层常量引用可以初始化成字面值</span></span><br><span class="line"><span class="keyword">decltype</span>(ci) x; <span class="comment">//错误，常量必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y; <span class="comment">//错误，引用必须初始化</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>引用从来都是作为它所指对象的同义词出现，只有在<code>decltype</code>处是例外。</p>
<h4 id="decltype和引用"><code>decltype</code>和引用</h4>
<ol>
<li>如果表达式的内容是解引用操作，使用<code>decltype</code>将会得到引用类型。</li>
<li><code>decltype((variable))</code>的结果永远是引用，而<code>decltype(variable)</code>的结果只有在真的是引用的时候才会返回引用。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) d;</span><br><span class="line"><span class="keyword">decltype</span>(i) e;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-const/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C/C++ const</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:15:52" itemprop="dateCreated datePublished" datetime="2019-11-13T14:15:52+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-15 08:59:01" itemprop="dateModified" datetime="2019-11-15T08:59:01+08:00">2019-11-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="const类型"><code>const</code>类型</h2>
<ol>
<li><code>const</code>修饰的变量一经初始化，不能改变其值，而且必须进行初始化。</li>
<li>可以使用任意对象（包含非<code>const</code>对象）初始化<code>const</code>对象。</li>
<li><code>const</code>对象默认只在当前文件中有效。如果需要在其他文件中使用，在声明和定义的文件中都需要加上<code>extern</code>关键字；而非<code>const</code>对象在定义时不需要使用<code>extern</code>关键字，只需要在其他文件的声明中加上<code>extern</code>即可。</li>
<li>编译器遇到<code>const</code>变量时，会将所有该变量出现的地方都换成相应的值。</li>
</ol>
<h2 id="引用和const">引用和<code>const</code></h2>
<p>可以把应用绑定到<code>const</code>对象上，就像绑定到其他常量上，称为对常量的引用（reference to const)，和普通引用的不同在与，对常量的引用不能用作修改它绑定的对象：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;</span><br><span class="line"></span><br><span class="line">r1 = <span class="number">42</span>;    <span class="comment">//这行代码是错的，因为r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;   <span class="comment">//这行代码也是错的，因为r2是普通引用</span></span><br></pre></td></tr></table></figure></p>
<p>常量引用是对常量的引用的简称。严格来说，并不存在常量引用，因为引用不是一个对象，我们没办法让引用本身恒定不变。但是因为C++中，引用绑定的对象是不能更改的，所以从这层意义上理解，所有的引用又都称得上常量。引用的对象是常量还是非常量决定了引用能进行的操作，但是影响不到引用和对象的绑定关系。</p>
<h3 id="初始化和对常量的引用">初始化和对常量的引用</h3>
<p>之前说过引用的类型对象必须和引用对象的类型一样。但是有两个例外，**一个例外就是初始化常量引用时可以使用任意表达式作为初值。**如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">43</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的例子我们也可以看出，对常量的引用可能引用一个非常量对象，我们不能通过<code>r</code>改变<code>i</code>的值，但是我们可以直接改变<code>i</code>的值，因为<code>r</code>和<code>i</code>是绑定的，所以<code>r</code>的值也改变了。</p>
<p>当把一个常量引用绑定到另一种类型上的时候，会发生什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14;</span><br><span class="line">const int &amp;ri = dval;</span><br></pre></td></tr></table></figure></p>
<p>上述代码将一个<code>dobule</code>类型的变量绑定到一个<code>const int</code>型引用上，为了让<code>ri</code>绑定一个整数，编译器将上述代码变成了以下形式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int temp = dval;</span><br><span class="line">const int &amp;ri = temp;</span><br></pre></td></tr></table></figure></p>
<p>将<code>ri</code>绑定到了一个临时对象<code>temp</code>上，但是我们想要<code>ri</code>操作的是<code>dval</code>而不是<code>temp</code>，所以这种行为被判定为非法。</p>
<h3 id="引用和左值-右值">引用和左值，右值</h3>
<ol>
<li>非常量引用的初始值必须是左值。</li>
<li>常量引用的初始值可以是右值。比如<code>const int &amp;a = 7</code>;</li>
<li>常量引用的初始值可以为左值。</li>
</ol>
<h2 id="指针和const">指针和<code>const</code></h2>
<p>指针也可以指向常量。类似于对常量的引用（常量引用），有指向常量的指针（pointer to const)。</p>
<ol>
<li>之前说过指针指向的类型对象必须和指针的类型一样。但是有两个例外，一个例外就是指向常量的指针可以使用非常量对象的地址进行初始化。</li>
<li>要想存放指向常量的地址，必须使用指向常量的指针。</li>
<li>指向常量的指针不能用于改变其所指对象的值，很容易明白，因为指向的是常量，而常量的值是不能修改的，所以指向常量的指针自然不能修改它指向的对象的值。</li>
<li>那么指向常量的指针的指向能否改变？当然可以了，要不然就不会有<code>const</code>指针了，即指针本就就是常量对象，指向不能改变的指针对象。</li>
</ol>
<p>可以认为指向常量的指针和对常量的引用都是他们自认为指向了常量对象，而常量对象不能被修改，所以就不能修改所指对象的值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;  <span class="comment">//报错，必须是指向常量的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;    <span class="comment">//</span></span><br><span class="line">*cptr = <span class="number">4</span>;  <span class="comment">//不能修改常量指针指向的常量的值</span></span><br></pre></td></tr></table></figure></p>
<h3 id="const指针"><code>const</code>指针</h3>
<p>引用不是对象，而指针是对象，因此就像其他对象一样，可以把指针本身定义为常量，叫做常量指针，常量指针必须初始化。<br>
<code>const</code>指针必须初始化，它指向变量的值能否改变只取决于它指向变量的类型。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;val;   <span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;  <span class="comment">//</span></span><br></pre></td></tr></table></figure></p>
<h2 id="顶层const">顶层<code>const</code></h2>
<p>用顶层<code>const</code>表示指针本身是一个常量，用底层<code>const</code>表示指针指向的对象是一个常量。指针可以既是顶层<code>const</code>又是底层<code>const</code>。<br>
更一般的，顶层<code>const</code>可以表示任何的对象是常量，这一点对任意类型都使用。而底层<code>const</code>则和指针，引用等复合类型有关。<br>
可以把一个顶层<code>const</code>赋值给非顶层<code>const</code>对象；但是不能把底层<code>const</code>赋值给非底层<code>const</code>对象，这个多加几句，因为底层<code>const</code>一定是和复合类型指针和引用相关的，所以要把它赋值给一个非底层的<code>const</code>对象，这个待赋值的对象也一定是指针和引用，如果它是非底层<code>const</code>对象，那么就可以通过它修改它指向的对象了，而这个对象是<code>const</code>的，不能被修改。</p>
<p>对常量的引用（常量引用）可以和常量对量绑定；<br>
对常量的引用（常量引用）可以和非常量对量绑定；<br>
非常量引用不可以和常量对象绑定；<br>
非常量引用可以和非常量对象绑定；</p>
<p>指向常量的指针可以指向常量对象；<br>
指向常量的指针可以指向非常量对象；<br>
常量指针可以指向非常量对象；<br>
常量指针不可以指向常量对象；<br>
普通指针不可以指向常量对象；<br>
普通指针可以指向非常量对象；</p>
<p>常量指针（顶层const）可以用来初始化非常量对象。<br>
对常量的引用和指向常量的指针（底层const）不可以用来初始化非常量对象。</p>
<h2 id="constexpr和常量表达式"><code>constexpr</code>和常量表达式</h2>
<p>常量表达式，值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值和用常量表达式初始化的<code>const</code>对象也是常量表达式。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">23</span>;  <span class="comment">//不是常量表达式，因为他不是`const`对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_size();  <span class="comment">//sz是常量，但不是常量表达式，因为它的值需要等到运行时才能获得。</span></span><br></pre></td></tr></table></figure></p>
<p>常量表达式一定是常量，但是常量不一定是常量表达式。<br>
声明为<code>constexpr</code>的变量由编译器验证它是否是常量表达式。<br>
声明为<code>constexpr</code>的变量一定是个常量，而且必须用常量表达式初始化。<br>
如果认定变量一定是个常量表达式，就把它声明成<code>constexpr</code>类型，即<code>constexpr</code>用于声明常量表达式。</p>
<h3 id="字面值类型">字面值类型</h3>
<p>算术类型，引用和指针都属于字面值类型，<code>string</code>，IO库和类不属于字面值类型。算术类型包含整形和浮点型，整形中又包含整数，字符和布尔。<code>constexpr</code>只能用于字面值类型。<br>
指针和引用能用定义成<code>constexpr</code>，但是初值受到严格限制，一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>，<code>0</code>或者某个固定地址的对象。一般来说，函数内部的变量(除了<code>static</code>变量)没有存在固定地址中，而所有函数之外的对象地址固定不变，能用来初始化<code>constexpr</code>指针。<code>constexpr</code>声明的指针是顶层<code>const</code>，即指针本身是个<code>const</code>，它指向的对象不能变，它指向的对象的值能变。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版<br>
2.<a href="https://www.zhihu.com/question/36052573/answer/65756850" target="_blank" rel="noopener">https://www.zhihu.com/question/36052573/answer/65756850</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-compound-type-reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-compound-type-reference/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C++ compound type reference</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:14:15 / 修改时间：14:15:33" itemprop="dateCreated datePublished" datetime="2019-11-13T14:14:15+08:00">2019-11-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引用-左值引用">引用（左值引用）</h2>
<ol>
<li>引用不是一个对象，没有实际地址，不能定义指向引用的指针。</li>
<li>引用只是一个别名，必须和一个已经存在的对象绑定在一起，无法更改，必须初始化。</li>
<li>定义引用时，标识符必须以<code>&amp;</code>开头。</li>
<li>除了两种特殊情况外，所有引用的类型都必须和它绑定的对象严格匹配。</li>
<li>引用只能绑定在对象上，不能绑定在字面值或者某个表达式上。（const引用除外）</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<ol>
<li></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-compound-type-pointer/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C/C++ compound type pointer</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:11:26" itemprop="dateCreated datePublished" datetime="2019-11-13T14:11:26+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-17 20:59:19" itemprop="dateModified" datetime="2019-11-17T20:59:19+08:00">2019-11-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="指针">指针</h2>
<ol>
<li>变量的值存储在计算机的内存中，每个变量都占据一个特定的位置，每一个内存位置都由地址唯一确定并引用。指针可以看成是地址的另一个名字<a href="3.1.3">2</a>。</li>
<li>指针变量也是一个变量，其中存放的是另一个变量的地址，因为指针是一个变量，所以指针变量本身也存放在内存中的某个位置<a href="3.1.3">2</a>。允许对指针赋值和拷贝，在指针的生命周期内可以先后指向几个不同的对象。</li>
<li>指针无须在定义时赋值，和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ol>
<h2 id="指针声明和定义">指针声明和定义</h2>
<p>指针也是一个复合类型，需要按照复合类型的声明和定义进行声明。</p>
<h3 id="指针定义">指针定义</h3>
<p>定义指针类型的方法将声明符写成<code>*d</code>的形式，其中<code>d</code>是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号<code>*</code>。即<code>*</code>是修饰声明符的，而不是修饰<code>int</code>的。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; <span class="comment">// 定义一个int*的指针p，p进行了默认初始化</span></span><br><span class="line"><span class="keyword">int</span> *a, b, *c;  <span class="comment">//定义了两个int*类型的指针a,c，一个int类型变量b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *message = <span class="string">"Hello world!"</span>; <span class="comment">//定义一个char*变量，指向数据段的字符串常量区中的字符串"Hello world!"的首字符的地址。</span></span><br><span class="line"><span class="comment">//下面两行代码和上面一行代码的作用是相同的，message是一个`char *`指针，指向字符串常量"Hello world!"的首字符的地址。</span></span><br><span class="line"><span class="keyword">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">message = <span class="string">"Hello world!"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="取地址符">取地址符</h3>
<p>指针存放某个对象的地址，要想获取改地址，需要使用取地址符<code>&amp;</code>。除了两种特殊情况外，所有指针类型都要和它所指的对象严格匹配。<br>
两种特殊情况：</p>
<ol>
<li>一个指向常量的指针可以指向个非常量对象。</li>
<li>…</li>
</ol>
<h3 id="指针的值-就是地址-有四种可能取值">指针的值，就是地址，有四种可能取值</h3>
<ol>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针，没有指向任何对象</li>
<li>无效指针，除了以上三种情况的任何值。</li>
</ol>
<p>使用无效指针和使用未初始化变量是同类错误，编译器都不负责进行检查。</p>
<h3 id="解引用指针-间接访问-操作符">解引用指针（间接访问）操作符</h3>
<p>C11中解引用操作符<code>*</code>的定义：</p>
<blockquote>
<p>The unary * operator denotes indirection. If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object. If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’. If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.102)</p>
</blockquote>
<p>C++11中解引用操作符<code>*</code>的定义：</p>
<blockquote>
<p>The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is “pointer to T,” the type of the result is “T.” [ Note: a pointer to an incomplete type (other than cv void) can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a prvalue, see 4.1. — end note ]</p>
</blockquote>
<p>解引用操作符<code>*</code>应用于指向对象或者指向函数的指针表达式，得到指针指向对象的左值表达式，给解引用的结果赋值其实就是给指针所指的对象赋值([1]2.3.2)。如果不解引用，指针变量中存放的内容就只是地址。<br>
<strong>对象（变量）和指针变量中存放的内容（即地址）的区别，对象可以直接进行赋值。指针变量中存放的是一个地址，地址本身就是一个数字，是一个右值，不能对其进行赋值，对这个地址进行解引用，得到指针指向的对象。</strong><br>
定义一个指针<code>p</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>; </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p><code>p</code>是<code>int*</code>类型，存放的是变量<code>a</code>的地址，<code>*</code>是间接访问，<code>*p</code>对指针进行解引用得到指针指向对象的左值表达式，其实就是<code>a</code>，<code>&amp;</code>表示取变量<code>a</code>的地址。</p>
<h3 id="未初始化和非法的指针">未初始化和非法的指针</h3>
<p>看一个错误的代码片段：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a; <span class="comment">//定义一个指针*p</span></span><br><span class="line">*a = <span class="number">12</span>;    <span class="comment">//把12存储在a指向的内存中，错误</span></span><br></pre></td></tr></table></figure></p>
<p>这个代码中犯了一个很严重的错误，我们在声明了变量<code>a</code>，但是没有对它进行显示初始化，所以编译器会对a进行默认初始化，默认初始化并不会为变量分配内存。如果程序执行这个赋值操作，假如a是一个非法地址，程序会出错，终止程序，在UNIX系统上，这个错误称为&quot;segmentation violation&quot;或者&quot;memory fault&quot;，它告诉我们程序正在访问一个非法的地址。如果a是一个合法的地址，这就会错误的修改a指向的内存中的值，造成一些难以预料到的错误。</p>
<h3 id="空指针">空指针</h3>
<p>有以下几种方法声明空指针：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1.</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 方法2.</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 方法3.</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;<span class="comment">//NULL定义在cstdlib中</span></span><br></pre></td></tr></table></figure></p>
<p>最好使用<code>nullptr</code>或者<code>0</code>，而避免使用<code>NULL</code>。</p>
<h3 id="void-指针"><code>void*</code>指针</h3>
<p><code>void *</code>指针可以存放任意类型的地址，但是我们并不知道它存放的是什么类型的对象。</p>
<h3 id="指针的指针">指针的指针</h3>
<p>因为指针也是一个变量，所以它自然也就有地址，也就存在指向指针的指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, *b, **c;</span><br><span class="line">b = &amp;a;</span><br><span class="line">c = &amp;b;   <span class="comment">//紧挨着c左边的那个*表示c是一个指针，然后再往左边的那个`*`是和`int`在一起的，表示指针`c`指向的变量的类型是`int *`类型的。</span></span><br><span class="line"><span class="comment">// a,*b, **c表示同样的东西，都是变量a的值。</span></span><br><span class="line"><span class="comment">// *c和b和&amp;a表示同样的东西，都是变量a的地址。</span></span><br><span class="line"><span class="comment">// a表示int类型的变量</span></span><br><span class="line"><span class="comment">// b是a的地址，*b表示对指针p解引用，*b就是a。</span></span><br><span class="line"><span class="comment">// c是b的地址，*c表示对指针c解引用，*c就是b，也就是a的地址，*(*c)也就是*b，也是a。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="指针的特点">指针的特点</h2>
<ol>
<li>
<p>存放的是对象的地址，要想获取变量的地址，需要使用取地址符<code>&amp;</code>，访问指针中地址指向的变量，使用解引用符号<code>*</code>，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp; val; <span class="comment">//指针p存放的是变量val的地址</span></span><br><span class="line"><span class="keyword">int</span> b = *p; <span class="comment">//b被初始化为32,p存放的是val的地址，*p获得该地址指向的变量val。</span></span><br><span class="line">*p = <span class="number">3</span>; <span class="comment">//将val赋值为3</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>赋值永远改变的是<code>=</code>左侧的对象，可以用来判断到底是改变了指针的值还是改变了指针所指的对象的值。</p>
</li>
<li>
<p>除了两种特殊情况外，所有指针的类型都必须和它指向的对象严格匹配。</p>
</li>
</ol>
<h2 id="指针和引用的不同点">指针和引用的不同点</h2>
<ol>
<li>指针本身就是一个对象，允许赋值和拷贝，在生命周期内可以指向几个不同的对象；而引用本身并非一个对象，一定定义了引用，它就和一个对象终生绑定在了一起。</li>
<li>指针定义时无须赋值；而引用必须在定义时赋值。</li>
</ol>
<h2 id="指针运算">指针运算</h2>
<p>指针加上一个整数的结果是另一个指针。注意，这里假设每种类型都是连续存储的。假设字符型占一个字节，<code>float</code>占四个字节，<code>double</code>占八个字节。<br>
如果将指针加上1：<br>
对于一个字符型，新的指针指向内存中的下一个字符，指针的值实际上增加了1。<br>
对于一个<code>float</code>型，它指向内存中的下一个<code>float</code>，指针的值实际上增加了4。<br>
对于一个<code>double</code>型，它指向内存中的下一个<code>double</code>，指针的值实际上增加了8。<br>
也就是说，对于一个给定类型的指针，将它加一，得到的新指针指向下一个同类型的变量，这也是声明指针类型的作用。</p>
<h3 id="指针的大小">指针的大小</h3>
<p>任何类型的指针本身所占的大小都是相等的，取决于计算机的地址大小，如果是<code>32</code>位的地址，指针的大小就是<code>4</code>个字节，如果是<code>64</code>位的地址，指针的大小就是<code>8</code>个字节。</p>
<h3 id="算术运算">算术运算</h3>
<p>C的算术运算只有两种形式。第一种是指针加减一个整数，第二种是两个指针相减。</p>
<h4 id="指针加减一个整数">指针加减一个整数</h4>
<p>指针加减一个整数的运算形式只能用于指向数组中某个元素的指针，将它加减一个整数得到的表达式也还是一个指针，它仍指向数组中某个元素。如果对指针进行加法或者减法运算之后，指针所指的位置是在数组第一个元素前面或者在最后一个元素后面，它的效果是未定义的。这种操作编译器不会进行检查，需要程序员自己进行检查。<br>
这种形式也适用于<code>malloc</code>函数动态分配的内存。</p>
<h4 id="指针减指针">指针减指针</h4>
<p>两个指针相减的结果类型是<code>ptrdiff_t</code>，是一种有符号整数类型。运算结果是两个指针在内存中的距离，以数组元素的长度为单位，而不是以字节为单位。两个指针必须指向同一个数组，结果可正可负。如果两个指针指向不同的数组，这个距离就没有意思。因为我们不知道两个数组分别存在哪个位置。</p>
<h3 id="关系运算">关系运算</h3>
<p><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code><br>
关系运算也需要指针指向同一个数组中的元素。为了和C++的迭代器兼容，最好使用<code>==</code>或者<code>!=</code>，因为迭代器不支持关系运算，而指针和迭代器都支持<code>==</code>和<code>!=</code>运算。</p>
<h2 id="c中的指针表达式和左值右值-2">C中的指针表达式和左值右值[2]</h2>
<h3 id="指针自增自减操作">指针自增自减操作</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = &amp;ch;</span><br></pre></td></tr></table></figure>
<ol>
<li>前置自增操作<code>++cp</code>，将<code>cp</code>的值加一，该操作先将<code>cp</code>的值加一，指向<code>ch</code>后面的一个位置，然后返回<code>cp</code>的一个拷贝。表达式<code>++cp</code>和<code>cp</code>加一后的对象一样。</li>
<li>后置自增操作<code>cp++</code>，将<code>cp</code>的值加一，该操作先返回对象<code>cp</code>的一个拷贝，然后将<code>cp</code>的值加一，指向<code>ch</code>后面的一个位置。表达式<code>cp++</code>和<code>cp</code>加一前的对象一样。</li>
<li>解引用前置自增操作<code>*++cp</code>，这个式子其实是对表达式<code>++cp</code>的解引用操作，也就是对<code>cp</code>加一后的拷贝的解引用操作，而不是对<code>cp</code>的操作。</li>
<li>解引用前置自增操作<code>*cp++</code>，这个式子其实是对表达式<code>cp++</code>的解引用操作，是对<code>cp</code>加一前的拷贝的解引用操作，而不是对<code>cp</code>的操作。</li>
</ol>
<h3 id="指针表达式和左值右值">指针表达式和左值右值</h3>
<p>关于左值和右值的介绍，可以查看<a href="http://localhost:4000/2019/11/14/C-CPP-lvalue-and-rvalue/" target="_blank" rel="noopener">C C++ lvalue and rvalue</a>。<br>
给出下列代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;cp = 4; //这个是错的，&amp;cp是一个地址，但是它本身只是一个数，它的本质和`10=4;`没有区别，使用解引用符号访问这个地址上的对象。</span></span><br><span class="line"><span class="comment">// 10 = 4; 错误，10既不是指针，也不是变量</span></span><br><span class="line"><span class="comment">//*10 = 4; 错误，10既不是指针，也不是变量</span></span><br><span class="line">*(<span class="keyword">int</span>*)<span class="number">10</span> = <span class="number">4</span>; <span class="comment">//10是一个int，首先把它转化成一个指针，表示一个地址，然后使用解引用进行赋值</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>ch</code>，作为左值时，表示的是<code>ch</code>在内存中的位置；<code>ch</code>作为右值时，值是<code>'a'</code>，</li>
<li><code>&amp;ch</code>，不能当左值，因为它没有存放在内存中；当右值时，值是变量<code>ch</code>的地址</li>
<li><code>cp</code>，作为左值，是一个指针变量；作为右值，值是变量<code>ch</code>的地址</li>
<li><code>&amp;cp</code>，无法作为左值；作为右值，值是指针变量<code>cp</code>的地址</li>
<li><code>*cp</code>，作为左值，和<code>ch</code>等价；作为右值，值是<code>'a'</code></li>
<li><code>*cp+1</code>，无法作为左值；作为右值，值是<code>'a'+1</code>。</li>
<li><code>*(cp+1)</code>，作为左值，是一个指针，指向<code>ch</code>后面的一个内存单位；作为右值，是<code>ch</code>后面一个内存单位的值。</li>
<li><code>++cp</code>，无法作为左值，右值和<code>*(cp+1)</code>一样。</li>
<li><code>cp++</code>，无法作为左值，右值和<code>*(cp+1)</code>一样。</li>
<li><code>*++cp</code>，作为左值，是一个指针，指向<code>ch</code>后面的一个位置；作为右值，是<code>ch</code>后面那个位置的值。</li>
<li><code>*cp++</code>，作为左值，是一个指针，指向<code>ch</code>；作为右值，<code>'a'</code>。</li>
<li><code>++*cp</code>，无法作为左值；作为右值，是<code>'b'</code>；</li>
<li><code>(*cp)++</code>，无法作为左值；作为右值，是<code>'a'</code>。</li>
<li><code>++*++cp</code>，无法作为左值；作为右值，是<code>'c'</code>。</li>
<li><code>++*cp++</code>，无法作为左值；作为右值，是<code>'c'</code></li>
</ol>
<h2 id="指针和数组">指针和数组</h2>
<ol>
<li>指针和数组的联系很紧密，在很多用到数组名字的时候，编译器都会自动的将它转换成一个指向数组首元素的指针。数组名字是个常量指针。</li>
<li>使用取地址符获取某个对象的指针，对数组元素使用取地址符就能得到指向该元素的指针。</li>
</ol>
<p>关于更多指针和数组之间的内容，点击查看<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-array/">数组</a>的介绍。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.《C和指针》<br>
3.<a href="https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard" target="_blank" rel="noopener">https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard</a><br>
4.<a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-compound-type-array/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-compound-type-array/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C/C++ compound type array</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:09:40" itemprop="dateCreated datePublished" datetime="2019-11-13T14:09:40+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-16 18:32:15" itemprop="dateModified" datetime="2019-11-16T18:32:15+08:00">2019-11-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="数组">数组</h2>
<p>数组和<code>vector</code>类似，但是数组是定长的，大小不变，而<code>vector</code>是可变的，可以把<code>vector</code>看成可变长度的数组。<br>
如果不清楚元素的确切个数，使用vector。</p>
<h3 id="定义和初始化">定义和初始化</h3>
<p>数组的维度必须是确定的，在编译时就知道，即是一个常量表达式（值不会改变并且在编译时就已知）。<br>
默认情况下，数组的元素被默认初始化。和内置类型的变量一样，如果在数组内部定义了某种内置类型的数组，那么默认初始化得到的数组含有未定义的值。</p>
<h3 id="显式的初始化数组">显式的初始化数组</h3>
<ol>
<li>可以忽略维度，编译器会根据初始值推测出来；</li>
<li>如果指明维度，初始值的数量不应该超出指定的大小；</li>
<li>如果维度比提供的初始值大，其它的元素被初始化成默认值（值初始化）。</li>
</ol>
<h3 id="数组不支持直接拷贝和直接赋值">数组不支持直接拷贝和直接赋值</h3>
<p>不能将数组或的内容拷贝给其他数组作为初始值，也不能用数组为其他数组赋值。</p>
<h3 id="数组和vector">数组和<code>vector</code></h3>
<p>不允许使用一个数组为另一个数组赋初值，也不允许使用<code>vector</code>初始化数组。但是支持使用数组来初始化<code>vector</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vi(begin(arr), end(arr));</span><br></pre></td></tr></table></figure></p>
<h3 id="复杂数组的声明">复杂数组的声明</h3>
<p>对于数组声明的理解，从变量名开始，先往右，再往左读。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>];    <span class="comment">//数组arr，有10个元素，每个元素是int类型</span></span><br><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];  <span class="comment">//数组ptrs，有10个int*类型元素，</span></span><br><span class="line"><span class="keyword">int</span> &amp;refs[<span class="number">10</span>];  <span class="comment">//错误</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;   <span class="comment">//数组的指针Parray，指向一个有10个int类型的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;    <span class="comment">//数组的引用arrRef，引用一个10个int类型的数组</span></span><br><span class="line"><span class="keyword">int</span> *(&amp;<span class="built_in">array</span>)[<span class="number">10</span>] = ptrs;   <span class="comment">//数组的引用array，引用一个10个int*类型的数组</span></span><br></pre></td></tr></table></figure></p>
<h2 id="访问数组元素">访问数组元素</h2>
<ol>
<li>范围for 语句。</li>
<li>下标运算符。下标的类型是<code>size_t</code>类型。它是一种机器相关的无符号类型，足够大能够表示内存中任意对象的大小。定义在<code>&lt;stddef.c&gt;</code>或者<code>&lt;cstddef&gt;</code>头文件中。</li>
</ol>
<h2 id="数组和指针">数组和指针</h2>
<h3 id="数组名和指针">数组名和指针</h3>
<ol>
<li>一般情况下，可以使用取地址符获取某个对象的指针。数组元素也是对象，使用下标运算符得到数组指定位置的对象，使用取地址符就能得到指向该元素的指针。([1]3.5.3)</li>
<li>数组的另一个特性是，在大多用到数组名字的时候，编译器都会自动的将它转换成一个指向数组首元素的指针，而且数组名是一个常量指针([1]3.5.3)。或者说数组作为右值时，编译器会自动将数组转化成数组首元素的地址([2)]。</li>
<li>在C中，只有两种操作不把数组名字当做常量指针，当数组名字用作<code>sizeof</code>和<code>&amp;</code>的操作对象时。当<code>sizeof</code>的输入是数组名时，返回的是数组的长度（字节为单位）。而<code>&amp;</code>对数组名取地址时，返回的是指向数组的指针。</li>
</ol>
<p>在<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">C++复合类型指针</a>中介绍了指针的算术运算。指针的算术运算有一个要求，就是指针必须指向数组中某一个元素。如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">size_t</span> sz = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">int</span> arr[sz] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *ip;</span><br><span class="line">ip = arr;   <span class="comment">//这个不是数组的赋值。事实上，这是指针的赋值。</span></span><br><span class="line"><span class="keyword">int</span> *ip2 = ip+<span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = arr + sz;</span><br><span class="line"><span class="keyword">int</span> *p2 = arr + <span class="number">10</span>;</span><br></pre></td></tr></table></figure></p>
<p>上述代码中，给<code>arr</code>加上<code>sz</code>时，编译器自动的将它转换成指向数组<code>arr</code>中首元素的指针。执行加法操作，其实就是指针的算术运算，最后指向<code>arr</code>的第五个元素之后的位置。如果超出了这个位置，就会出错，编译器不会检查这种错误。</p>
<h3 id="下标引用">下标引用</h3>
<ol>
<li>对于内置数组来说，执行下标运算，相当于先将数组转换为首元素的指针，然后执行数组的算术运算。如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i = ia[<span class="number">2</span>];  <span class="comment">//这行代码其实相当于以下两行代码</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = ia;</span><br><span class="line">i = *(p+<span class="number">2</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<p>除了优先级外，下标运算和间接访问（解引用）完全一样。</p>
<ol start="2">
<li>
<p><strong>而且只要指针指向的是数组中的元素或者数组中尾元素的下一个位置，都可以执行下标操作。当指针指向数组尾后元素时，该位置不可访问！但是可以访问其他位置。</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p = &amp;ia[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> j = p[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> k = p[<span class="number">-2</span>];</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>和标准库<code>string</code>，<code>vector</code>下标操作的不同之处在于，内置数组的下标操作中，，下标可以是负的，而标准<code>string</code>,<code>vector</code>中下标必须是无符号类型。</p>
</li>
</ol>
<h3 id="数组-指针">数组!=指针</h3>
<p>需要注意的是，数组和指针并不是等价的！考虑以下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> *b;</span><br></pre></td></tr></table></figure>
<p><code>a</code>和<code>b</code>不能互换使用，即使它们都可以使用指针运算，可以进行间接访问和下标引用操作。它们并不一样。<br>
定义一个数组时，编译器会根据声明指定的元素数量为数组保留内存空间，然后再创建数组名，它的值是一个常量，指向这段空间的起始位置。定义一个指针变量时，编译器只为指针本身保留内存空间。所以，进行了上述定义以后，<code>*a</code>合法，而<code>*b</code>不合法。</p>
<h3 id="c-中的数组和指针">C++中的数组和指针</h3>
<ol>
<li>使用decltype关键字对数组进行解析时，不会将数组转换成指针，它会将识别出数组类型。使用<code>auto</code>分析数组类型时会推断出指针类型。</li>
<li>指针也是迭代器。通过数组名字或者数组首元素地址都可以得到指向数组第一个元素的指针。</li>
<li><code>begin</code>和<code>end</code>获取数组首元素指针和尾后指针。尾后指针不能执行解引用和递增操作。</li>
</ol>
<h2 id="c风格字符串">C风格字符串</h2>
<p>C风格字符串不是一种类型，而是一种约定俗成的写法。按照约定，C风格字符串存放在数组中，并且以空字符<code>'\0'</code>结束。</p>
<h3 id="字符数组">字符数组</h3>
<ol>
<li>
<p>使用列表初始化。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str2[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> str3[] = &#123;<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'\0'</span>&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>使用字符串字面值初始化。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str1[] = <span class="string">"helloworld"</span>;</span><br><span class="line"><span class="comment">//编译器会隐式的在最后加一个"\0"，sizeof(str)会计算这个"\0", strlen(str)不会</span></span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这种方式是字符数组初始化的简便写法。</p>
<ol start="3">
<li>指针和C风格字符串<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *messages= <span class="string">"hello world"</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>对于以上三种方式来说，方式1和2是等价的，这种方式中的&quot;helloworld&quot;存放在栈中。而第三种有些特殊，在第三种方式中，&quot;hello world&quot;是一个字符串字面值常量，存放在数据区的字符串常量部分[6,7,8,9]。事实上，它是一个常量字符数组，是一个不可修改的左值[9]，把它作为右值时，会进行类型转换将左值转换成右值，即使用常量字符数组首字符的地址进行初始化。</p>
<h3 id="c风格字符串操作函数">C风格字符串操作函数</h3>
<p>C语言标准库<code>&lt;string.h&gt;</code>或者C++版本的<code>&lt;string.h&gt;</code>提供了以下的字符串操作函数，它们的参数必须是指向以空字符结束的字符数组的指针。在函数内存不会验证这些字符串参数是否满足要求。</p>
<ul>
<li><code>strlen(p)</code>，返回p指向的字符串的长度，不包括空字符</li>
<li><code>strcmp(p1, p2)</code>，p1==p2，返回0,p1&gt;p2，返回正值，否则返回负值。</li>
<li><code>strcat(p1, p2)</code>，p2拼接到p1，返回p1</li>
<li><code>sctcpy(p1, p2)</code>，p2拷贝到p1，返回p1</li>
</ul>
<p>有一点需要注意的是，<code>p2</code>必须能够容纳下拼接后或者拷贝后的字符串，编译器不会进行检查，这需要由程序员自己进行检查。</p>
<h3 id="c风格字符串的比较">C风格字符串的比较</h3>
<p>两个C风格字符串的比较，其实比较的是指针而不是字符串本身。如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">char str1[] = &quot;hello&quot;;</span><br><span class="line">char str2[] = &quot;world&quot;;</span><br><span class="line">if(str1 &lt; str2) //这行代码比较的不是两个字符串，而是两个指针。</span><br></pre></td></tr></table></figure></p>
<h3 id="string和c风格字符串的相互转换"><code>string</code>和C风格字符串的相互转换</h3>
<ol>
<li>允许使用以空字符结束的字符数组初始化<code>string</code>对象或者为<code>string</code>对象赋值。</li>
<li><code>string</code>对象的加法运算中允许使用空字符结束的字符数组作为其运算对象，不能两个都是。</li>
<li><code>string</code>对象的复合赋值运算中允许使用以空字符结束的字符数组作为其右侧运算对象。</li>
</ol>
<h4 id="string转换成c风格字符串"><code>string</code>转换成C风格字符串</h4>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string s(&quot;hello world!&quot;);</span><br><span class="line">const char *str = s.c_str();</span><br></pre></td></tr></table></figure>
<h2 id="多维数组">多维数组</h2>
<p>多维数组指的是数组的数组。多维数组的定义方式如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];   <span class="comment">//大小为3的数组，每个元素是一个大小为4的数组</span></span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>][<span class="number">20</span>][<span class="number">30</span>];    <span class="comment">//大小为10的数组，每个元素是大小为20的数组，每个数组的元素又是一个大小为30的数组。</span></span><br></pre></td></tr></table></figure></p>
<h3 id="存储顺序">存储顺序</h3>
<p>按照从右到左的维度顺序依次进行存储，实际上它们存储在了线性空间内。比如对于一个数组<code>int array[3][6]</code>，它在内存中的存储顺序其实是：<br>
a[0][0], a[0][1], a[0][2], a[0][3], a[0][4], a[0][5], a[1][0], a[1][1], a[1][2], a[1][3], a[1][4], a[1][5], a[2][0], a[2][1], a[2][2], a[2][3], a[2][4], a[2][5]。</p>
<h3 id="多维数组的初始化">多维数组的初始化</h3>
<p>使用花括号括起来的一组值初始化多维数组。</p>
<ol>
<li>
<p>指定所有元素的值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>初始化一部分，其余的进行值初始化<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>只对a[0]进行了初始化。</p>
<ol start="3">
<li>初始化每一行的部分元素。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">3</span>][<span class="number">4</span>] = &#123;&#123;<span class="number">0</span>&#125;, &#123;<span class="number">1</span>&#125;, &#123;<span class="number">2</span>&#125;, &#123;<span class="number">3</span>&#125;&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<p>只对每一行的第一个值进行了初始化。</p>
<h3 id="多维数组数组名和指针">多维数组数组名和指针</h3>
<p>一维数组的数组名是一个指针，它的类型是指向元素类型的指针。多维数组也一样，多维数组的数组名也是一个指针，只不过它的类型是指向数组的指针。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>数组名<code>matrix</code>实际上是指向数组首元素的一个指针，数组首元素是一个<code>int [10]</code>类型的数组，所以<code>matrix</code>是一个指向<code>int [10]</code>类型数组的指针，解引用操作<code>*matrix</code>得到一个<code>int [10]</code>类型的数组，这个东西其实也是一个数组名，相当于一个指针，指向一个<code>int</code>类型。<code>*(*(matrix+1)+2)</code>其实就是<code>matrix[1][2]</code>。</p>
<h3 id="多维数组的下标">多维数组的下标</h3>
<p>如果要访问多维数组中的某个元素，必须指定所有维度的下标。即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>];</span><br><span class="line"><span class="comment">//要访问第2行的第16个元素，使用下标[1][15]。</span></span><br><span class="line">matrix[<span class="number">1</span>][<span class="number">15</span>];</span><br></pre></td></tr></table></figure></p>
<p>但是，实际上，下标和间接引用是等价的，在多维数组中也一样。数组名<code>matrix</code>可以当成一个指针，<code>matrix +1</code>实际上指向第二个<code>int [10]</code>的数组，<code>*(matrix+1)</code>是一个<code>int [10]</code>的数组。</p>
<h3 id="指向数组的指针">指向数组的指针</h3>
<p>在下面的代码中，<code>pa</code>是一个int指针，<code>p</code>是一个<code>int [10]</code>类型的指针，指向<code>matrix</code>的第一行的10个元素。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>], *pa = <span class="built_in">vector</span>;</span><br><span class="line"><span class="keyword">int</span> matrix[<span class="number">3</span>][<span class="number">10</span>], (*p)[<span class="number">10</span>] = matrix;</span><br></pre></td></tr></table></figure></p>
<h2 id="指针数组">指针数组</h2>
<p>我们可以创建指针的数组。例如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *api[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>创建了一个数组，数组有10个元素，每个元素都是一个<code>int*</code>类型的指针。可以创建一个<code>char*</code>类型的指针数组：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *keyword[] = &#123;</span><br><span class="line">    <span class="string">"do"</span>,</span><br><span class="line">    <span class="string">"while"</span>,</span><br><span class="line">    <span class="string">"if"</span>,</span><br><span class="line">    <span class="string">"for"</span>,</span><br><span class="line">    <span class="string">"return"</span>,</span><br><span class="line">    <span class="string">"switch"</span>,</span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组和左值">数组和左值</h2>
<p>数组本身是一个不可修改的左值。</p>
<h2 id="字符串字面值和左值">字符串字面值和左值</h2>
<p>字符串字面值常量是一个常量，不可修改的左值，它以数组的形式存储。</p>
<h2 id="为什么数组不支持赋值">为什么数组不支持赋值</h2>
<ol>
<li>不支持数组的拷贝是为了避免不必要的复制开销，数组复制将会导致连续的内存读和写。</li>
<li>为什么用指针代替数组，不是因为他们太像了，而是避免赋值的开销，因为c里面只有值传递，如果对数组采用pass by value，会有很大的开销。</li>
</ol>
<h2 id="array-array和-array-0"><code>array</code>,<code>&amp;array</code>和<code>&amp;array[0]</code></h2>
<p><code>array</code>和<code>&amp;array[0]</code>是一样的，它们和&amp;array有什么区别呢？[3]</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"array=%p, &amp;array=%p\n"</span>, <span class="built_in">array</span>, &amp;<span class="built_in">array</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"array+1=%p: &amp;array+1=%p\n"</span>, <span class="built_in">array</span>+<span class="number">1</span>, &amp;<span class="built_in">array</span>+<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>程序的输出如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">array=0x7ffc50c541c0: &amp;array=0x7ffc50c541c0</span><br><span class="line">array+1=0x7ffc50c541c4: &amp;array+1=0x7ffc50c541d4</span><br></pre></td></tr></table></figure>
<p>根据上面程序的输出，<code>array</code>和<code>&amp;array</code>得到了一样的地址。但是它们并不是一样的！！！它们的地址相同，但是地址的类型不同。<br>
对指针进行算术运算，将<code>array</code>和<code>&amp;array</code>都加一，我们却得到了不同的结果。事实上，<code>array</code>是指向数组第一个元素的指针，而<code>&amp;array</code>是指向整个<code>int [5]</code>数组的指针。因此，根据指针运算规则，对地址<code>array</code>和<code>&amp;array</code>进行算术运算，得到了不同的结果。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.<a href="https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer" target="_blank" rel="noopener">https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer</a><br>
3.<a href="https://www.geeksforgeeks.org/whats-difference-between-array-and-array-for-int-array5/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/whats-difference-between-array-and-array-for-int-array5/</a><br>
4.<a href="https://stackoverflow.com/questions/3437110/why-do-c-and-c-support-memberwise-assignment-of-arrays-within-structs-but-not/3439969" target="_blank" rel="noopener">https://stackoverflow.com/questions/3437110/why-do-c-and-c-support-memberwise-assignment-of-arrays-within-structs-but-not/3439969</a><br>
5.<a href="https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type" target="_blank" rel="noopener">https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type</a><br>
6.<a href="https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s" target="_blank" rel="noopener">https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s</a><br>
7.<a href="https://stackoverflow.com/questions/2938895/difference-between-char-a-string-char-p-string" target="_blank" rel="noopener">https://stackoverflow.com/questions/2938895/difference-between-char-a-string-char-p-string</a><br>
8.<a href="http://c-faq.com/decl/strlitinit.html" target="_blank" rel="noopener">http://c-faq.com/decl/strlitinit.html</a><br>
9.<a href="https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-getline-vs-C-getline/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-getline-vs-C-getline/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/2/index.html">C getline vs C++ getline</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 13:11:10" itemprop="dateCreated datePublished" datetime="2019-11-13T13:11:10+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-17 22:24:40" itemprop="dateModified" datetime="2019-11-17T22:24:40+08:00">2019-11-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="getline-in-c">getline in C</h2>
<h3 id="原型">原型</h3>
<p>使用<code>man getline</code>可以看到UNIX提供的库函数<code>getline</code>的原型。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> getline(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream);</span><br><span class="line"><span class="keyword">ssize_t</span> getdelim(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, <span class="keyword">int</span> delim, FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="性质">性质</h3>
<ol>
<li><code>getline()</code>从stream中读入一整行，</li>
<li>如果<code>*lineptr</code>设置为NULL并且<code>*n=0</code>，<code>getline()</code>会分配一个buffer存储读入的line。这个buffer应该被用户程序释放，即使<code>geline()</code>失败了。</li>
<li>如果<code>*lineptr</code>包含一个指针，大小是<code>*n</code>字节。当buffer不能存下读入的line时，<code>getline()</code>会使用<code>realloc(3)</code>对buffer进行resize，更新<code>*lineptr</code>和<code>*n</code>。</li>
<li>只要成功调用，<code>*lineptr</code>和<code>*n</code>分别表示的是buffer的地址和分配的内存大小。</li>
<li><code>getdelim()</code>和<code>getline()</code>一样，只不过可以指定一个delimiter而不是使用newline作为delimiter。任何delimiter都会存进<code>*lineptr</code>中。</li>
<li>为什么<code>getline</code>需要的是<code>char**</code>而不是<code>char*</code>，因为<code>getline</code>在lineptr指向的空间不足时，重新分配内存，如果使用的是<code>char*</code>的话，当<code>getline</code>重新分配内存后，我们就失去了对<code>line</code>的访问，而使用一个<code>char**</code>类型的字符串，使用一个<code>char**</code>类型，即指针的指针记录每次分配的<code>char*</code>。[3]。</li>
</ol>
<h2 id="getline-in-c-v2">getline in C++</h2>
<h3 id="cin-getline">cin.getline</h3>
<p><code>cin.getline()</code>是操作C strings，即字符数组的。不会将<code>'\n'</code>读入。</p>
<h3 id="std-getline">std::getline</h3>
<ol>
<li><code>std::getline()</code>是操作C++ strings的，即<code>std::string</code>。</li>
<li><code>std::getline()</code>从input stream中读一个string，遇到delimiter就停止，默认的delimiter是<code>'\n'</code>。即使输入开始就是delimiter也会停止。</li>
<li><code>std::getline()</code>会把delimiter也读进来，然后把读到的内容存到<code>string</code>对象中去，存入的内容不包含delimiter。</li>
</ol>
<h2 id="代码示例">代码示例</h2>
<h3 id="getline">getline</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    FILE *stream = <span class="built_in">stdin</span>;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread = getline(&amp;line, &amp;len, stream)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Retrieved line of length %zu:\n"</span>, nread);</span><br><span class="line">        fwrite(line, nread, <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="getdelim">getdelim</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    FILE *stream = <span class="built_in">stdin</span>;</span><br><span class="line">    <span class="keyword">char</span> *line = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">size_t</span> len = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> nread;</span><br><span class="line">    <span class="keyword">int</span> delim = <span class="string">','</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ((nread = getdelim(&amp;line, &amp;len, delim, stream)) != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Retrieved line of length %zu:\n"</span>, nread);</span><br><span class="line">        fwrite(line, nread, <span class="number">1</span>, <span class="built_in">stdout</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(line);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/4872361/why-are-there-two-different-getline-functions-if-indeed-there-are" target="_blank" rel="noopener">https://stackoverflow.com/questions/4872361/why-are-there-two-different-getline-functions-if-indeed-there-are</a><br>
2.<a href="https://www.reddit.com/r/learnprogramming/comments/4fx64h/is_there_a_difference_between_cingetline_and/" target="_blank" rel="noopener">https://www.reddit.com/r/learnprogramming/comments/4fx64h/is_there_a_difference_between_cingetline_and/</a><br>
3.<a href="https://stackoverflow.com/questions/5744393/why-is-the-first-argument-of-getline-a-pointer-to-pointer-char-instead-of-c/36098042" target="_blank" rel="noopener">https://stackoverflow.com/questions/5744393/why-is-the-first-argument-of-getline-a-pointer-to-pointer-char-instead-of-c/36098042</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/29/">29</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">282</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">383</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
