<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/7/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/7/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/26/C-strlen-vs-sizeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/C-strlen-vs-sizeof/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">C/C++ strlen vs sizeof</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 10:07:37" itemprop="dateCreated datePublished" datetime="2019-11-26T10:07:37+08:00">2019-11-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:33:22" itemprop="dateModified" datetime="2019-12-17T15:33:22+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><code>strlen</code>不计算字符串数组的null字节，而<code>sizeof</code>会计算null字节所占的字节。</li>
<li><code>strlen</code>是一个函数，使用时需进行一次系统调用。而<code>sizeof</code>会在编译时计算。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版8.3节</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-struct/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX struct</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 17:34:51" itemprop="dateCreated datePublished" datetime="2019-11-25T17:34:51+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-08 13:52:58" itemprop="dateModified" datetime="2019-12-08T13:52:58+08:00">2019-12-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>struct FILE<br>
{</p>
<p>};</p>
<p>struct DIR<br>
{</p>
<p>};</p>
<h2 id="结构体">结构体</h2>
<p>POSIX定义了<br>
struct dirent<br>
{</p>
<p>};</p>
<p>struct pwd<br>
{</p>
<p>};</p>
<p>struct spwd<br>
{</p>
<p>};</p>
<p>struct grp<br>
{</p>
<p>};</p>
<p>struct timespec<br>
{</p>
<p>};</p>
<p>struct sm{</p>
<p>};</p>
<h2 id="进程资源限制">进程资源限制</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct rlimit&#123;</span><br><span class="line">    rlim_t rlim_cur;</span><br><span class="line">    rlim_t rlim_max;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版<br>
2.<a href="https://en.cppreference.com/w/c/chrono/timespec" target="_blank" rel="noopener">https://en.cppreference.com/w/c/chrono/timespec</a><br>
3.<a href="https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html" target="_blank" rel="noopener">https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-Process-Control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-Process-Control/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX Process Control</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 10:31:02" itemprop="dateCreated datePublished" datetime="2019-11-25T10:31:02+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-20 16:45:20" itemprop="dateModified" datetime="2020-02-20T16:45:20+08:00">2020-02-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一节主要介绍UNIX系统的进程控制，包括进程创建，进程执行和进程控制。以及进程属性的各种的ID-real UID, real GID和effective UID, effective GID和save UID， set UID和set GID，以及它们如何收到进程控制原语的影响。</p>
<h2 id="进程标识-pid">进程标识(pid)</h2>
<p>每一个进程都有一个非负整数表示它的唯一进程ID。进程ID标识符总是唯一的，但是可以复用。<br>
关于和进程ID相关的内容，可以查看<a href></a>。</p>
<h2 id="fork"><code>fork</code></h2>
<p><code>fork</code>创建一个子进程。函数原型：</p>
<h3 id="fork原型"><code>fork</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="fork性质"><code>fork</code>性质</h3>
<ol>
<li><strong>进程ID</strong>。<code>fork</code>调用一次，返回两次，分别是0和子进程ID，用以区别父进程和子进程。对于父进程，返回子进程ID，对于子进程，返回0。因为父进程可能有多个子进程，并且没有提供获得一个进程所有子进程ID的函数，而fork只有一个父进程，可以通过<code>getppid</code>获得它的父进程的ID。所以这样子进行区分。</li>
<li>子进程和父进程分别继续执行调用<code>fork</code>之后的指令。子进程是父进程的副本。子进程获得父本的数据段，堆和栈的完全副本。这是子进程的副本，和父进程不一样，它们并不共享数据的内存空间，但是它们共享text segment。</li>
<li>现代的操作系统实现，使用写时复制代替了父进程数据段，堆和栈的完全副本。这些区域是由父进程和子进程共享的，但是它们的访问权限是只读。如果父进程或者子进程想要对这些区域进行修改的话，内核会为修改区域的那块内存制作一个副本，用于进程修改。</li>
<li>父进程和子进程因为不共享数据，堆和栈，每个进程都有自己的变量，不会相互影响。</li>
<li><strong>执行顺序</strong>。<code>fork</code>后父进程和子进程的执行顺序是不确定的，这跟内核的调度算法有关。如果要求父进程和子进程之间进行同步，需要它们之间进行某种形式的进程通信。</li>
<li><strong>文件共享</strong>。对于父进程打开的文件，<code>fork</code>相当于将父进程的文件描述符都复制到了子进程中，相当于对父进程的每一个文件描述符，都调用了<code>dup</code>函数。父进程和子进程每个相同的打开文件描述符共享同一个文件表项。一般来说，在<code>fork</code>之后处理文件描述符有以下两种情况：
<ul>
<li>父进程等待子进程完成。父进程不需要对它的文件描述符做任何处理。</li>
<li>父进程和子进程分别执行不同的程序段。父进程和子进程各自关闭它们不需要的文件描述符。</li>
</ul>
</li>
<li><strong><code>fork</code>后子进程继承的信息</strong>。
<ul>
<li>real UID, real GID, effective UID, effective GID</li>
<li>set UID和 set GID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>Session ID</li>
<li>控制终端</li>
<li>cwd</li>
<li>root dir</li>
<li>umask</li>
<li>signal mask</li>
<li>文件描述符标志</li>
<li>环境</li>
<li>共享的内存段</li>
<li>内存映像</li>
<li>Resource limits</li>
</ul>
</li>
<li><strong>父进程和子进程的区别。</strong>
<ul>
<li><code>fork</code>的返回值不同</li>
<li>pid不同</li>
<li>它们有不同的ppid</li>
<li>子进程的很多时间设置为0</li>
<li>父进程设置的文件锁子进程不继承。</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号被设置为空集。</li>
</ul>
</li>
<li><strong><code>fork</code>的两种用法</strong>。
<ul>
<li>父进程和子进程分别执行不同的代码。比如网络服务中，父进程负责等待客户端请求，子进程负责处理父进程接收到的请求。</li>
<li>一个进程要执行不同的程序。对shell比较常见，通常执行完<code>fork</code>返回后立即调用<code>exec</code>。</li>
</ul>
</li>
</ol>
<h2 id="vfork"><code>vfork</code></h2>
<p>创建一个子进程，并且阻塞父进程，函数原型如下：</p>
<h3 id="vfork原型"><code>vfork</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="vfork属性"><code>vfork</code>属性</h3>
<ol>
<li><code>vfork</code>和<code>fork</code>都创建一个新进程，但是<code>vfork</code>并不会将父进程的地址空间完全复制到子进程中。因为子进程会立即调用<code>exec</code>或者<code>exit</code>，就不会引用该地址空间。但是如果在调用<code>exec</code>或者<code>exit</code>之前，它会在父进程的空间中运行，这种做法会提高效率。但是如果子进程修改除了<code>vfork</code>的返回值，或者在没有调用<code>exit</code>或者<code>exec</code>之前调用其他函数，这种行为是未定义的。</li>
<li><code>vfork</code>保证子进程先运行，在子进程没有调用<code>exec</code>或者<code>exit</code>时，内核会使父进程休眠，在子进程调用<code>exec</code>或者<code>exit</code>这两个中的任何一个后，父进程才会恢复运行。如果子进程需要父进程进一步操作的时候，就会产生死锁。</li>
</ol>
<h2 id="exit函数"><code>exit</code>函数</h2>
<p>关于<code>exit</code>函数的介绍，可以查看<a href>C/C++ exit and return</a>。<br>
总共有八种方式可以让进程终止，包括五种正常和三种异常，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回，相当于调用<code>exit</code>。</li>
<li>调用<code>exit</code>，ISO C定义的，它的操作包括调用各个exit handler，处理所有标准I/O流。<code>exit</code>会冲洗标准I/O流，如果这是函数库所采取的唯一的动作，那么不会出现什么问题。而如果<code>exit</code>除了冲洗标准I/O流，还会关闭I/O流，那么在<code>vfork</code>时就会出问题了。当然，现在的<code>exit</code>实现都不会关闭流了，这个操作一般都交给内核实现。</li>
<li>调用<code>_exit</code>或者<code>_Exit</code>，ISO C定义了<code>_Exit</code>，而POSIX.1说明了<code>_exit</code>。它的目的是提供一种无需运行exit handler或者信号处理程序而终止的方法。是否对标准I/O流进行flush，取决于实现。在UNIX中，<code>_Exit</code>和<code>_exit</code>是同义的，并不冲洗I/O流。</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程以哪种方式终止，最后都会执行内核中的同一段代码，这段代码为相关进程关闭所有打开的文件描述符，释放它使用的内存。<br>
为了让终止进程能够通知父进程它是如何终止的。对于3个终止函数，将它的<code>exit status</code>作为参数传递给函数。在异常终止的情况下，内核产生一个指示其异常终止原因的terminaiton status（终止状态）。在任意终止情况下，这个终止进程的父进程都能用<code>wait</code>或者<code>waitpid</code>函数获得它的终止状态。<br>
<strong>如果父进程在子进程之前终止</strong>，所有终止进程的子进程的父进程都变成<code>init</code>进程，<code>init</code>进程负责获得终止状态。对于一个即将终止的进程，内核检查所有活动进程，判断其中是否有待终止进程的子进程，如果有的话，将这些进程的父进程的ID改为<code>init</code>进程的PID 1。<br>
<strong>如果子进程在父进程之前终止</strong>。内核为每一个终止进程保留了一部分信息，当终止进程的父进程调用<code>wait</code>或者<code>waitpid</code>时，可以获取这些信息，这些信息包含终止进程PID，进程的终止状态，进程占用的CPU时间总量。内核可以释放这些进程的内存，关闭打开的文件。如果一个进程终止了，但是它的父进程没有等待它，它被称为一个zombie（僵尸）进程，这些信息不会被释放。如果一个长期运行的进程，<code>fork</code>了很多子进程，除非父进程调用wait得到子进程的终止状态，否则它们就会变成僵尸进程。<br>
<code>init</code>的子进程，不会变成僵尸进程，因为<code>init</code>进程被编写成无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数获得其终止状态。</p>
<h2 id="wait和waitpid"><code>wait</code>和<code>waitpid</code></h2>
<p>当一个进程终止的话（无论正常还是异常），内核就会向它的父进程发送<code>SIGCHLD</code>信号。而子进程终止是个异步事件，可以在父进程运行的任何时候发生。对于这种信号，父进程可以忽略它，或者调用一个信号处理函数。<br>
调用了<code>wait</code>或者<code>waitpid</code>的进程，可能会处于以下几种状态之一：</p>
<ol>
<li>所有子进程都还在运行，则阻塞。</li>
<li>一个子进程已经终止，正在等待父进程获取其终止状态，那么取得该子进程的终止状态立即返回。</li>
<li>如果它没有任何子进程，立即出错返回。</li>
</ol>
<p>如果进程由于接收到<code>SIGCHLD</code>而调用<code>wait</code>，我们期望<code>wait</code>会立即返回。如果在随机的时间点调用<code>wait</code>，进程可能会阻塞。</p>
<h3 id="wait和waitpid原型"><code>wait</code>和<code>waitpid</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *wstatus);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<h3 id="wait和waitpid性质"><code>wait</code>和<code>waitpid</code>性质</h3>
<ol>
<li>在一个子进程终止前，<code>wait</code>使其调用者阻塞，直到任意一个子进程终止。<code>wait</code>返回终止子进程的进程ID。如果<code>wait</code>要等待一个特定的进程，将返回的pid和要等待的pid相比，如果不相等，将这个pid和termination status保存起来，再次调用<code>wait</code>，直到等到目标pid。下一次想要等待一个特定进程的时候，现场看已经终止的进程列表中是否已有它 ，没有的haunted继续调用<code>wait</code>。</li>
<li>ISO中定义了<code>waitpid</code>中option的四个可能值：0，<code>WNOHANG</code>, <code>WUNTRACED</code>和<code>WCONTINUED</code>。POSXI扩展了许多其他选项。其中0表示阻塞调用，<code>WNOHANG</code>表示如果没有子进程结束就立刻退出，<code>WUNTRACED</code>表示如果一个子进程停止了也返回，<code>WCONTINUED</code>表示一个子进程恢复运行了也会返回。</li>
<li>指定option为0时，设置<code>waitpid</code>阻塞等待指定的进程pid。当<code>pid</code>为-1时，<code>waitpid</code>和<code>wait</code>一样。当<code>pid</code>大于或者小于0时，等待相应的pid（绝对值）。当pid等于0时，等待gid等于调用进程组id的任意一个子进程。</li>
<li>指定option为<code>WNOHANG</code>，设置<code>waitpid</code>不阻塞，表示如果没有子进程结束，就立刻返回。在Linux上，<code>WNOHANG</code>是1。</li>
<li>指定option为<code>WUNTRACED</code>和<code>WCONTINUED</code>，设置<code>waitpid</code>支持job control。</li>
<li>对于<code>wait</code>，只有当调用进程没有子进程时，才出错。对于<code>waitpid</code>，指定的进程或者进程组不存在，或者参数pid不是调用进程的子进程时，都会出错。</li>
<li><code>wstatus</code>是一个整形指针。如果它不为空指针，终止进程的终止状态就存放在它所指的单元内。</li>
<li><code>wstatus</code>指向的整形变量的意义是由实现定义的，其中的某一些位表示exit status，即正常退出。另外一些位表示signal number，表示不正常退出，一位表示是否产生core file，等等。POSIX.1指定了termination status可以用<code>&lt;sys/wait.h&gt;</code>中定义的宏查看。四个互斥宏可以用来取得进程终止的原因：
<ul>
<li><code>WIFEXITED(status)</code>，如果status是一个正常终止子进程返回的，为true。执行<code>WEXITSTATUS(statue)</code>获取子进程传递给<code>exit</code>或者<code>_exit</code>的参数的低八位。</li>
<li><code>WIFSIGNALED(status)</code>，如果status是一个异常终止子进程返回的，为true。执行<code>WTERMSIG(status)</code>获取使得子进程终止的signal。</li>
<li><code>WIFSTOPPED(status)</code>，如果status是一个当前暂停的子进程返回的，为true。执行<code>WSTOPSIG(status)</code>获取使得子进程暂停的signal。</li>
<li><code>WIFCONTINUED(status)</code>，。</li>
</ul>
</li>
<li><code>fork</code>两次可以让原始进程不用自己调用<code>wait</code>，也可以避免产生僵尸进程。</li>
</ol>
<h2 id="waitid"><code>waitid</code></h2>
<h3 id="waitid原型"><code>waitid</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="waitid性质"><code>waitid</code>性质</h3>
<ol>
<li><code>waitid</code>是SUS指定的，不是ISO C的部分。</li>
<li><code>waitid</code>和<code>waitpid</code>类似，但是它使用两个单独的参数表示要等到的子进程所属的类型，用<code>idtype</code>表明<code>id</code>的类型，用<code>id</code>表示pid或者进程组id。<code>idtype</code>的取值如下：
<ul>
<li><code>P_PID</code>，等待特定进程，id指定要等待的子进程的pid</li>
<li><code>P_PGID</code>，等待特定进程组中的任一子进程，id是包含要等待子进程的组ID</li>
<li><code>P_ALL</code>，等待任意子进程，忽略id。</li>
</ul>
</li>
<li><code>options</code>参数是以下标志的按位或运算。
<ul>
<li><code>WCONTINUED</code></li>
<li><code>WEXITED</code></li>
<li><code>WNOHANG</code></li>
<li><code>WNOWAIT</code></li>
<li><code>WSTOPPED</code></li>
</ul>
</li>
<li><code>siginfo_t</code>结构体包含了子进程状态改变有关signal的详细信息。</li>
</ol>
<h2 id="wait3和wait4"><code>wait3</code>和<code>wait4</code></h2>
<p>大多数UNIX系统都支持<code>wait3</code>和<code>wait4</code>，它们是从BSD延续下来的。它们的功能比POSIX.1函数<code>wait</code>, <code>waitpid</code>和<code>waitid</code>要多一个。可以通过附加参数允许内核返回终止进程以及其所有子进程使用的资源概况。包含用户CPU时间总量，系统CPU时间总量，缺页次数，接收到的signal次数。<br>
它们的原型如下：</p>
<h3 id="wait3和wait4原型"><code>wait3</code>和<code>wait4</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options, struct rusage *rusage);</span><br><span class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options, struct rusage *rusage);</span><br></pre></td></tr></table></figure>
<h2 id="race-condition">race condition</h2>
<p>如果多个进程都企图对共享数据进行某种处理，而且最后的结果取决于进程运行的顺序时，我们认为发生了race condition。<br>
如果一个进程希望等待子进程终止，可以调用<code>wait</code>函数中的一个。如果一个子进程想要等待父进程终止，可以使用下列形式的循环，称为轮询（polling)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式浪费了很多CPU时间。为了避免这些问题，可以使用signal或者进程间通信解决这些问题。</p>
<h2 id="exec"><code>exec</code></h2>
<p>通常使用<code>fork</code>创建新的子进程之后，子进程往往会调用一种<code>exec</code>函数执行另一个程序。当进程调用<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序从其<code>main</code>函数开始执行。调用<code>exec</code>并不会创建新进程，所以前后的进程ID不变。<code>exec</code>使用磁盘上的一个新程序替换了当前进程的text segment, data segment, heap和stack。<code>exec</code>函数只有在出错的时候才返回-1，并且设置<code>errno</code>。<br>
总共有七种不同的<code>exec</code>函数，它们被统称为<code>exec</code>函数。它们的原型如下：</p>
<h3 id="exec函数原型"><code>exec</code>函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> fexecve(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[]);</span></span></span><br></pre></td></tr></table></figure>
<h3 id="exec函数属性"><code>exec</code>函数属性</h3>
<ol>
<li><strong>传入参数的区别。</strong> <code>path</code>是路径名作为参数，<code>file</code>是文件名作为参数。如果<code>path</code>中包含<code>'/'</code>，将它看成路径名。否则按照PATH环境变量，在它指定的目录中搜寻可执行文件。如果函数<code>execlp</code>和<code>execvp</code>在PATH指定的目录中找到的文件不是link editor产生的可执行文件，就会把它当做一个shell脚本，调用<code>/bin/sh</code>，把这个文件当做shell的输入。</li>
<li><strong>argmuent list的区别。</strong> l表示的是列表，v表示的是向量。<code>execl</code>, <code>execlp</code>和<code>execle</code>要求将新程序的每个命令行参数都说明为一个单独的参数，这种参数表以空指针结尾。而<code>execv</code>,<code>execvp</code>, <code>execve</code>和<code>fexecve</code>，需要先构造一个指向各个参数的指针数组，然后将该数组的地址作为这四个函数的参数。</li>
<li><strong>environment list的区别。</strong> 以e结尾的函数，<code>execve</code>, <code>execvpe</code>,<code>execle</code>, <code>fexecve</code>等可以传递一个指向environment字符串指针数组的指针，这个是自己指定的环境。其他几个不带e的函数使用进程中的environ变量为新程序复制现有的环境。</li>
<li>调用<code>exec</code>后，进程ID没有改变，但是新程序从调用进程继承了以下属性：
<ul>
<li>pid和ppid</li>
<li>real UID, real GID,</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>Session ID</li>
<li>控制终端</li>
<li>闹钟余留时间</li>
<li>cwd</li>
<li>root dir</li>
<li>umask</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li>时间</li>
</ul>
</li>
<li>在<code>exec</code>前后，real UID和real GID不变，effective ID取决于是否设置set UID和set GID。如果新程序的set UID已经设置，则effective ID变成程序文件所有者的ID，否则不变。</li>
<li>这几个函数中，只有<code>execve</code>是系统调用，其他几个都只是库函数，最终都要调用<code>execve</code>。</li>
</ol>
<h2 id="解释器文件">解释器文件</h2>
<p>关于解释器文件，可以查看<a href></a>。</p>
<h2 id="system"><code>system</code></h2>
<p>关于system的介绍，可以查看<a href></a>。</p>
<h2 id="进程会计">进程会计</h2>
<p>大多数UNIX系统都提供了一个选项进行进程会计处理。启动该选项之后，每当进程结束时内核就会写一个会记记录。典型的会计记录是一个二进制数据，一般包括命令名，所有的CPU时间总量，UID和GID，启动时间等。所有的标准都没有定义进程会记，所以实现上就千差万别。<br>
<code>acct</code>函数启用和关闭进程会计。<br>
会记记录结构定义在头文件<code>&lt;sys/acct.h&gt;</code>的<code>struct acct</code>中，其中<code>ac_flag</code>标志记录了进程执行期间的某些事件：</p>
<ul>
<li><code>AFORK</code>，进程是<code>fork</code>产生的，但是未调用<code>exec</code></li>
<li><code>ASU</code>，进程使用superuser权限</li>
<li><code>ACORE</code>，进程转储到core</li>
<li><code>AXSIG</code>，进程由一个signal杀死</li>
<li><code>AEXPND</code>，扩展的会计条目</li>
<li><code>ANVER</code>，新纪录格式</li>
</ul>
<p>在LINUX上，<code>ac_flag</code>是枚举类型，所以不能使用<code>#ifdef</code>判断是否支持<code>ACCORE</code>等flag，可以使用<code>if !defied HAS_ACCORE</code>进行判断。</p>
<p>会计记录所需的各个数据（各CPU时间，传输的字符数等）都由内核保存在process table中，并在一个新进程被创建时初始化，进程终止时写一个会计记录。这产生了两个后果：</p>
<ol>
<li>对于那些不会终止的进程，比如<code>init</code>进程，我们无法获得它的会计记录。内核守护进程也不会终止，所以也不会产生会计记录。</li>
<li>在会计文件中记录的顺序对应于进程终止的顺序，而不是它们启动的顺序。</li>
</ol>
<p>会记记录对应于进程而不是程序。在<code>fork</code>之后，内核为子进程初始化一个记录，而不是在一个新程序被执行初始化时。<code>exec</code>并不会创建一个新的记录，但是相应记录中的名字会改变，<code>AFORK</code>标志没了。</p>
<h2 id="获得当前登录用户名">获得当前登录用户名</h2>
<p>可以使用<code>getlogin</code>获得当前登录用户的用户名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="进程调度">进程调度</h2>
<p>调度策略和调度优先级是由内核确定的。</p>
<h3 id="nice-getpriority-setpriority原型"><code>nice</code>, <code>getpriority</code>, <code>setpriority</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> inc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> prio)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="nice-getpriority-setpriority属性"><code>nice</code>, <code>getpriority</code>, <code>setpriority</code>属性</h3>
<ol>
<li><code>nice</code>函数将输入的参数加到当前的<code>nice</code>值上。<code>nice</code>值越大，优先级越低，否则越高。</li>
<li>在单核的机器中，同时运行一个父进程和一个子进程，它们的<code>nice</code>值不同的话，CPU占用比也可能会不同，这取决于进程调度程序如何使用<code>nice</code>值。在多核的机器上可能看不到这样的结果。</li>
</ol>
<h2 id="进程时间">进程时间</h2>
<p>可以使用<code>times</code>获得某进程和它的子进程的CPU时间以及墙上时钟时间，<code>times</code>通过<code>struct tms</code>传递信息。它的内容如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_utime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_stime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_cutime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_cstime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>它包含进程的用户CPU时间，系统CPU时间和子进程的用户CPU时间和系统CPU时间。但是不包含墙上时钟时间，墙上时钟时间是通过函数的返回值得到的，而且得到的时间是相对于过去某个时间点得到的，所以不能使用它的绝对值，要使用相对值。比如第一次调用<code>times</code>，记录返回值，等到下一次调用<code>times</code>时，用新的值减去刚才保存的值，得到墙上时间时间。<br>
<strong>所有时间（结构体和返回值）的单位都是滴答数。</strong><br>
函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> times(struct tms *buf);</span><br></pre></td></tr></table></figure></p>
<p>shell的<code>time(1)</code>可以使用<code>times(2)</code>实现，看程序。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-Process-Environment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-Process-Environment/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX Process Environment</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 10:22:51" itemprop="dateCreated datePublished" datetime="2019-11-25T10:22:51+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-02 10:54:56" itemprop="dateModified" datetime="2019-12-02T10:54:56+08:00">2019-12-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一部分介绍的是进程运行的环境。主要包括进程执行时，<code>main</code>函数是如何被调用的，命令行参数如何传递给进程的，进程的存储空间结构，如何分配存储空间，环境变量的使用，以及进程是怎么终止的。</p>
<h2 id="main函数和argc-argv"><code>main</code>函数和<code>argc</code>, <code>argv</code></h2>
<p>C语言总是从<code>main</code>函数开始执行，C语言中<code>main</code>有两个原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>argc</code>是命令行参数的个数，<code>argv</code>是一个指针数组，ISO C和POSIX.1都要求<code>argv[argc]</code>设置为<code>NULL</code>，所以可以用它作为参数处理的循环终止条件。关于更多指针的信息可以查看<a href></a>。<br>
当内核执行C程序（使用一个<code>exec</code>函数）时，在调用<code>main</code>函数之前设置一个特殊的启动例程。可执行程序文件将这个启动例程指定为程序的起始地址，这是由link editor设置的，它会被C编译器调用。启动例程从内核命令获得命令行参数和环境变量值，然后为调用<code>main</code>函数做好准备。</p>
<p>关于更多C和C++中<code>main</code>的介绍，可以查看<a href="https://mxxhcm.github.io/2019/11/12/C-CPP-main-argc-argv/">C/C++ main argc argv</a>。</p>
<h2 id="全局变量environ">全局变量<code>environ</code></h2>
<p>每个C程序都会接收到一个environment list，和<code>argv</code>一样，它是一个指针数组。每个指针指向一个以<code>null</code>结束的C字符串的地址，这个指针数组的地址存放在全局变量<code>environ</code>中：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br></pre></td></tr></table></figure></p>
<p>在历史上，UNIX大多支持三个参数的<code>main</code>函数，第三个参数就是environment list：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但是ISO C规定<code>main</code>只能有两个参数，POSIX.1也就规定使用全局变量<code>environ</code>而不是第三个参数。如果要查看所有的环境变量时，使用<code>environ</code>，而访问某个特定的环境变量时，使用<code>getenv</code>和<code>setenv</code>。</p>
<h2 id="进程终止">进程终止</h2>
<p>总共有八种方式可以让进程终止，包括五种正常和三种异常，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回</li>
<li>调用<code>exit</code></li>
<li>调用<code>_exit</code>或者<code>_Exit</code></li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h3 id="exit函数"><code>exit</code>函数</h3>
<h4 id="函数原型">函数原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h4 id="性质">性质</h4>
<ol>
<li><code>exit</code>和<code>_Exit</code>是ISO C的内容，而<code>_exit</code>是POSIX.1的内容</li>
<li>它们都用于正常终止一个程序，<code>_Exit</code>和<code>_exit</code>立刻进入内核，而<code>exit</code>先执行一些清理操作，然后返回内核。<code>exit</code>函数总是执行一个标准I/O库的关闭操作，对于所有打开的流调用<code>fclose</code>函数，所有带有未写缓冲的标准I/O流被flush。</li>
<li>三个退出函数都需要一个整形的参数，被称为exit status。</li>
<li>如果满足以下条件：
<ul>
<li>调用这三个函数不带终止状态</li>
<li><code>main</code>执行了一个不带返回值的<code>return</code>语句</li>
<li><code>main</code>没有声明返回类型为整形，进程的终止状态是未定义的。<br>
那么这个进程的终止状态是未定义的。</li>
</ul>
</li>
<li><code>main</code>返回返回一个整型值和用该值调用<code>exit</code>是等价的。对于某些C编译器和UNIX lint(1)程序来说，会产生警告信息，因为这些编译器并不了解<code>main</code>中的<code>return</code>和<code>exit</code>的作用是相同的。避开这种警告信息的一种方法是在<code>main</code>中使用<code>return</code>而不是<code>exit</code>，这样做的结果是UNIX grep命令无法找出程序中所有的<code>exit</code>调用。另一个方法是将<code>main</code>声明为<code>void</code>而不是<code>int</code>，然后调用<code>exit</code>，但是这不并不是标准，ISO C和POSIX.1定义<code>main</code>的返回值应当是带符号整形。</li>
</ol>
<p>关于更多<code>exit</code>函数的内容，可以查看<a href></a>。<br>
关于<code>exit</code>和<code>return</code>的内容，更多可以查看<a href>C/C++ exit and return</a>。</p>
<h3 id="atexit"><code>atexit</code></h3>
<p>每个进程可以通过<code>atexit</code> register至多32个由<code>exit</code>自动调用的函数，这些函数被称为exit handler（终止处理程序）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>atexit</code>的参数是一个函数地址，不会有返回值</li>
<li><code>exit</code>调用<code>atexit</code> register的程序的顺序和使用<code>atexit</code>进行register的顺序相反。</li>
<li>ISO C和POSIX.1标准规定，<code>exit</code>首先调用各个exit handler，然后使用<code>fclose</code>关闭所有标准I/O流。</li>
<li>POSIX.1对ISO C进行了扩展，如果程序调用了任何<code>exec</code>函数，清除exit handler。</li>
<li>内核执行一个程序的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一办法是显式或者隐式的（通过<code>exit</code>）调用<code>_exit</code>和<code>_Exit</code>。</li>
</ol>
<h2 id="c程序的存储空间布局">C程序的存储空间布局</h2>
<p>更多关于C程序存储空间布局可以查看<a href="https://mxxhcm.github.io/2019/10/19/C-program-memory-layout/">C/C++ program memory layout</a>。</p>
<h2 id="共享库">共享库</h2>
<p>共享库使得可执行文件中不再需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，使用动态链接的方法将程序和共享库函数链接，这减少了每个可执行文件的长度，但是增加了一些时间运行开销。这种时间开销发生在程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个优点是可以使用库函数的新版本代替老版本而无需对使用该库的程序重新链接和编辑。</p>
<h2 id="内存空间分配">内存空间分配</h2>
<p>ISO C说明了三个用于memory allocation的函数，<code>malloc</code>, <code>calloc</code>和<code>realloc</code>，它们的原型如下，更多关于C中<code>malloc</code>的内容可以查看<a href>C/C++ malloc(alloc) free new and delete</a>。</p>
<h3 id="malloc-calloc和realloc原型"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reallocarray</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-calloc和realloc属性"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>属性</h3>
<ol>
<li><code>malloc</code>，分配指定字节的内存空间，初始值不定。</li>
<li><code>calloc</code>，为指定长度的固定数量的对象分配空间，每一个bit都被初始化为0。</li>
<li><code>realloc</code>，增加或者减少已经分配的内存空间的大小。当这个大小增加时，可能需要将之前分配的空间中的数据移到另一个足够大的区域以便于增加大小，新增加的区域内的值是不确定的。</li>
<li>这三个函数返回的指针一定是对齐的，保证它可以用于任何对象。比如<code>double</code>的要求最严格，需要从8的倍数的地址单元开始，这三个函数返回的地址一定满足这个要求。</li>
<li>它们的返回类型都是<code>void*</code>，需要使用强制类型转换。</li>
<li><code>realloc</code>函数可以增加或者减少之前分配的内存空间的大小。比如分配了一个固定大小的数组，后来发小它不够用了，可以使用<code>realloc</code>对它进行扩充，如果原有的存储后有足够的大小进行扩充，则可以在原存储区的位置上向高地址进行扩充，无需移动原有数组，返回和传入相同的指针。如果原来的内存空间后没有足够的空间，就重新分配一个足够大的内存空间，再将原有数据的内容复制过去，然后释放原来的内存空间，返回新的指针。</li>
<li><code>realloc</code>传入的参数是存储区的新长度。如果传入的<code>ptr</code>参数是<code>NULL</code>指针，那就退化成了<code>malloc</code>。</li>
<li><code>free</code>可以释放<code>ptr</code>指向的内存空间，释放的空间通常送入可用内存池，之后可以通过这三个函数重新分配。</li>
<li><code>malloc</code>和<code>free</code>底层通常使用<code>sbrk</code>系统调用实现，这个系统调用扩充或者减小进程的堆，虽然<code>sbrk</code>可以扩充或者缩小进程的堆，但是一般<code>malloc</code>和<code>free</code>的实现不会减少进程的内存空间，释放的内存空间保存在<code>malloc</code>池中，而不是交给内核。</li>
<li>大多数实现分配的空间要比请求的空间大一些，因为需要存储一些管理信息，如block的大小，指向下一个block的指针等等。因此，如果对超过一个分配区域的内存进行读写的话，会造成很严重的错误。</li>
<li><code>free</code>一个已经释放了的块，<code>free</code>的不是<code>alloc</code>函数的返回值，没有进行<code>free</code>等等，都有可能造成很严重的后果。</li>
</ol>
<h2 id="环境变量">环境变量</h2>
<p>环境变量的形式是：<br>
<code>name = value</code><br>
UNIX内核并不使用环境变量，通常都是应用程序使用这些环境变量。比如shell使用了大量的环境变量。</p>
<h3 id="标准定义">标准定义</h3>
<p>ISO C定义了<code>getenv</code>函数可以获取环境变量。但是ISO C没有定义任何环境变量，SUS环境变量包括POSIX.1和XSI环境变量。<br>
除了获取环境变量，有时候我们也需要设置环境变量。ISO C没有定义获取环境变量的函数。SUS除了定义了ISO C，还定义了<code>putenv</code>, <code>setenv</code>和<code>unsetenv</code>对环境变量进行操作。</p>
<h3 id="putenv-setenv和unsetenv原型"><code>putenv</code>,<code>setenv</code>和<code>unsetenv</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="putenv-setenv和unsetenv性质"><code>putenv</code>,<code>setenv</code>和<code>unsetenv</code>性质</h3>
<ol>
<li><code>putenv</code>，创建或者重置一个<code>name</code>。</li>
<li><code>setenv</code>，如果<code>name</code>不存在，创建<code>name</code>；如果<code>name</code>存在，<code>rewrite</code>不为零，重写，<code>rewrite</code>为零，不进行重写。</li>
<li><code>unsetenv</code>，移除<code>name</code>的定义。如果<code>name</code>不存在，不会出错。</li>
<li>环境变量的修改和增加可能会遇到一些问题。因为环境变量存放在进程地址空间的最上面的一个不可扩展的空间。<br>
<strong>如果修改一个存在的<code>name</code></strong>：<br>
当新的<code>value</code>的长度小于等于原来的<code>value</code>长度时，直接覆盖就行；<br>
当新的<code>value</code>的长度大于原来的<code>value</code>长度时，只需要给新的<code>name-value</code>字符串分配空间就行了。使用<code>malloc</code>为新的字符串分配空间，然后将该字符串复制到新的空间，让environment list中<code>name</code>的指针指向新分配的存放字符串的空间即可。</li>
</ol>
<p><strong>如果增加一个新的<code>name</code>，不仅需要给新的<code>name-value</code>分配空间，指针数组的元素也增加了，还需要给指针数组分配新的空间</strong>。首先给新的<code>name-value</code>字符串分配空间，调用<code>malloc</code>先为字符串分配空间，然后将该字符串复制到这个空间：<br>
如果这是第一次增加一个<code>name</code>，必须调用<code>malloc</code>为指针数组增加空间。将原来的指针数组复制到新分配的空间中，然后将新字符串的指针放在指针数组的尾部，然后存放一个空指针。最后让全局变量<code>char **environ</code>指向这个指针数组。如果原来的指针数组存放在栈顶之上，需要将它复制到堆中。需要注意的是，这个指针数组中的未修改的环境变量的指针还是指向栈顶的字符串上。<br>
如果这不是第一个添加<code>name</code>，只需要使用<code>realloc</code>重新多分配一个指针数组的空间即可，然后将它指向新字符串的地址即可。</p>
<h2 id="setjmp和longjmp"><code>setjmp</code>和<code>longjmp</code></h2>
<h3 id="setjmp和longjmp原型"><code>setjmp</code>和<code>longjmp</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="setjmp和longjmp属性"><code>setjmp</code>和<code>longjmp</code>属性</h3>
<ol>
<li>自动变量存储在每个函数的栈帧中。</li>
<li><code>setjmp</code>和<code>longjmp</code>实在栈上跳过若干调用栈，返回到当前函数调用路径上的某个函数中。</li>
</ol>
<h2 id="getrlimit和setrlimit"><code>getrlimit</code>和<code>setrlimit</code></h2>
<p>每个进程能使用的资源都是有限的，可以使用<code>getrlimt</code>和<code>setrlimit</code>进行修改。它们都是XSI扩展，不是ISO C的定义。有些资源可以设置为<code>RLIM_INFINITY</code>，表示无限。</p>
<h3 id="getrlimit和setrlimit性质"><code>getrlimit</code>和<code>setrlimit</code>性质</h3>
<ol>
<li>任何一个进程都可以将<code>rlim_cur</code>改为小于等于<code>rlim_max</code>。</li>
<li>任何一个进程都可以将<code>rlim_max</code>改小，但是不能小于<code>rlim_cur</code>，且这个更改是不可逆的。</li>
<li>只有root用户可以更改<code>rlim_max</code>。</li>
</ol>
<p>它们的原型原型如下：</p>
<h3 id="getrlimit和setrlimit原型"><code>getrlimit</code>和<code>setrlimit</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="resource种类">resource种类</h4>
<ul>
<li>RLIMIT_AS</li>
<li>RLIMIT_VMEM</li>
<li>RLIMIT_DATA</li>
<li>RLIMIT_SWAP</li>
<li>RLIMIT_STACK</li>
<li>RLIMIT_NPROC</li>
<li>RLIMIT_FSIZE</li>
<li>RLIMIT_NOFILE</li>
<li>RLIMIT_NICE</li>
<li>…</li>
</ul>
<h4 id="结构体">结构体</h4>
<p>结构体<code>struct rlimt</code>的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;    <span class="comment">// soft limit</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;    <span class="comment">// hard limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>《APUE》第三版</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/24/UNIX-system-data-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/24/UNIX-system-data-file/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX system data file</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 14:17:20" itemprop="dateCreated datePublished" datetime="2019-11-24T14:17:20+08:00">2019-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-20 11:57:53" itemprop="dateModified" datetime="2020-02-20T11:57:53+08:00">2020-02-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="系统文件">系统文件</h2>
<table>
<thead>
<tr>
<th style="text-align:center">文件名</th>
<th style="text-align:center">结构</th>
<th style="text-align:center">查看结构内容</th>
<th style="text-align:center">头文件</th>
<th style="text-align:center">查询函数</th>
<th style="text-align:center">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/etc/passwd</td>
<td style="text-align:center">passwd</td>
<td style="text-align:center">man 5 passwd</td>
<td style="text-align:center">pwd.h</td>
<td style="text-align:center">getpwnam, getpwuid</td>
<td style="text-align:center">可以使用vipw直接修改。</td>
</tr>
<tr>
<td style="text-align:center">/etc/shadow</td>
<td style="text-align:center">shadow</td>
<td style="text-align:center">man 5 shadow</td>
<td style="text-align:center">shadow.h</td>
<td style="text-align:center">getspnam</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/group</td>
<td style="text-align:center">group</td>
<td style="text-align:center">man 5 group</td>
<td style="text-align:center">grp.h</td>
<td style="text-align:center">getgrnam, getgrgid</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/hosts</td>
<td style="text-align:center">hostent</td>
<td style="text-align:center">man 5 hosts</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getnameinfo, getaddrinfo</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/networks</td>
<td style="text-align:center">netent</td>
<td style="text-align:center">man 5 networks</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getnetbyname, getnetbyaddr</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/protocols</td>
<td style="text-align:center">protoent</td>
<td style="text-align:center">man 5 protocols</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getprotobyname, getprotobynumber</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/services</td>
<td style="text-align:center">servent</td>
<td style="text-align:center">man 5 services</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getservbyname, getservbyprot</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/var/run/utmp/,/var/log/wtmp/</td>
<td style="text-align:center">utmp</td>
<td style="text-align:center">man 5 utmp</td>
<td style="text-align:center">utmp.h</td>
<td style="text-align:center">getutid, getutline</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="其他操作">其他操作</h2>
<ol>
<li>查看整个口令文件：<code>struct pwd *getpwdent(void);</code><br>
<code>void setpwent(void);</code><br>
<code>void endpwent(void);</code></li>
<li>查看整个shadow文件:<code>struct pwd* getspent(void);</code><br>
<code>void setspent(void);</code><br>
<code>void endspent(void);</code></li>
<li>查看整个group文件：<code>struct pwd* getgrent(void);</code><br>
<code>void setgrent(void);</code><br>
<code>void endgrent(void);</code></li>
</ol>
<p>一般来说，对于第一节中列出的所有文件，都存在三个函数：<code>get</code>，<code>set</code>和<code>end</code>，它们的功能类型。<br>
第一次调用<code>get</code>函数，返回第一项，接下来顺序的返回文件中的每一项。<br>
<code>set</code>函数定位到数据库的开始位置。<br>
<code>end</code>函数关闭相应的数据库。</p>
<h2 id="附属组id">附属组ID</h2>
<p>使用newgrp(1)加GID在当前seeion内更改组ID，不加参数更改回原来的组(/etc/passwd)中的组。<br>
附属组ID的引入可以使得一个用户至多拥有16个另外的组（常用值是16）。<br>
有三个函数可以操作附属组ID：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前用户的至多size个gid，如果size=0，返回总共的附属组ID的个数，如果size!=0，返回实际写入数组中的组ID的个数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">gid_t</span> <span class="built_in">list</span>[])</span></span>;</span><br><span class="line"><span class="comment">// 为调用进程设置附属组ID。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">gid_t</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">// 为user初始化GID。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *user, <span class="keyword">gid_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="登录账户记录">登录账户记录</h2>
<p>utmp文件记录当前登录到系统的各个用户。<br>
wtmp文件记录各个登录和注销事件。<br>
同样，可以使用<code>struct utmp* getutent(void);</code><br>
<code>void setutent(void);</code><br>
<code>void endtuent(void);</code><br>
这三个访问。<br>
<code>who(1)</code>读取utmp文件。<br>
<code>last(1)</code>读取wtmp文件。</p>
<h2 id="系统标识">系统标识</h2>
<p>使用utsname(1)获得主机和操作系统相关的消息，通过定义在<code>&lt;sys/utsname.h&gt;</code>中的uname实现。<br>
使用hostname(1)获取和设置主机名，通过定义在<code>&lt;unistd.h&gt;</code>中的gethostname和sethostname实现。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/24/linux-glibc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/24/linux-glibc/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">linux glibc</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 11:57:59" itemprop="dateCreated datePublished" datetime="2019-11-24T11:57:59+08:00">2019-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 17:01:53" itemprop="dateModified" datetime="2019-12-17T17:01:53+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="查看当前linux系统的glibc版本">查看当前linux系统的glibc版本</h2>
<blockquote>
<p>ldd --version</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldd (Ubuntu GLIBC 2.27-3ubuntu1) 2.27</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure>
<p>我的笔记本上的glibc是2.27版本。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://www.linuxquestions.org/questions/linux-software-2/how-to-check-glibc-version-263103/" target="_blank" rel="noopener">https://www.linuxquestions.org/questions/linux-software-2/how-to-check-glibc-version-263103/</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/22/C-standard-IO-library/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/22/C-standard-IO-library/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">C (ISO C) Standard I/O library</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-22 23:28:22" itemprop="dateCreated datePublished" datetime="2019-11-22T23:28:22+08:00">2019-11-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-18 23:02:58" itemprop="dateModified" datetime="2019-12-18T23:02:58+08:00">2019-12-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="总结">总结</h2>
<ol>
<li><code>fgets</code>, <code>sprintf</code>, <code>snprintf</code>会在缓冲区数组的结尾加上一个null字节，但是使用的时候不会包含这个字节。</li>
<li><code>fgets</code>和<code>getline</code>都会读入回车，并且将它存入缓冲区，<code>getchar</code>, <code>getc</code>和<code>fgetc</code>也会读入回车，并且将它存起来。</li>
<li>每个标准I/O流都有一个和它相关联的文件描述符，可以对一个流调用<code>fileno</code>获得它的文件描述符。<code>fileno</code>不是ISO C的部分，因为文件描述符不属于ISO C。</li>
<li>标准I/O库的一个不足是效率不高。这和它复制的数据量有关。每当使用一次<code>fgets</code>和<code>fputs</code>时，通常需要复制两次数据，一次是在用户程序的行缓冲区和标准I/O缓冲区之间，一次是在内核和标准I/O缓冲区之间。<br>
使用<code>fgets</code>需要用户指定<code>fgets</code>使用的缓冲区，或者使用<code>getline</code>，如果传入的指针指向NULL，<code>getline</code>会负责分配缓冲区大小。<br>
<code>read</code>和<code>write</code>需要设置缓冲区，这是系统调用级别的，大小可以任意指定，通常使用<code>sturct stat.st_blksize</code>的大小，用户如果直接调用<code>read</code>和<code>write</code>的话，需要自己设置缓冲区。而标准I/O库可以自己选择是否进行缓冲，如果缓冲的话，标准I/O库可以负责进行缓冲区大小选择和分配，也可以用户自己进行指定缓冲类型：行缓冲和全缓冲，用户也可以自己通过<code>setbuf</code>和<code>setvbuf</code>更改缓冲区大小和地址。而在<code>setbuf</code>中，如果<code>buf</code>是<code>NULL</code>的话，是关闭缓冲区，如果不为空的话，必须是<code>BUFSIZ</code>大小。在<code>setvbuf</code>中，通过<code>mode</code>指定缓冲区的类型，<code>buf</code>是<code>NULL</code>的话，库函数负责分配缓冲区。否则<code>buf</code>是多大就用多大的缓冲区。<br>
而在内核中，还存在buffer cache和page cache，用于“延迟写”，减少和磁盘的交互。</li>
</ol>
<h2 id="概述">概述</h2>
<h3 id="特殊符号的ascii">特殊符号的ASCII</h3>
<p>'\n’是10。<br>
EOF是-1。</p>
<h3 id="标准i-o和文件i-o">标准I/O和文件I/O</h3>
<p>文件I/O是围绕文件描述符进行的，使用<code>open</code>打开一个文件时，返回一个文件描述符，然后使用文件描述符进行后续I/O操作。文件I/O是UNIX相关的实现，其他系统可能有不同的实现，是不跨平台的。<br>
标准I/O是围绕stream进行I/O操作的。当标准I/O库打开或者创建一个文件时，一个流已经和文件相关联。标准I/O库处理很多细节，比如缓冲区分配，使用优化的长度块执行I/O等，使用户不用担心选择多大的block进行I/O会更快。标准I/O库是ISO C标准定义的，不仅仅UNIX系统有实现，凡是支持ISO C标准的操作系统都应该实现，是支持跨平台的。标准I/O在UNIX上需要使用文件I/O实现，在windows等其他系统上就需要其他的实现。</p>
<h3 id="stream和file对象">stream和<code>FILE</code>对象</h3>
<blockquote>
<p>12.1 Streams<br>
For historical reasons, the type of the C data structure that represents a stream is called FILE rather than “stream”. Since most of the library functions deal with objects of type FILE *, sometimes the term file pointer is also used to mean “stream”. This leads to unfortunate confusion over terminology in many books on C.</p>
</blockquote>
<p>标准I/O的操作是围绕stream进行的，当打开一个stream时，它返回一个指向FILE类型的指针（通常叫做文件指针）。FILE是一个结构体，包含了标准I/O管理这个stream需要的所有信息，包含用于实际I/O的文件描述符，指向这个流缓冲区的指针，缓冲区的长度，当前缓冲区中的字符等。为了引用一个stream，需要将FILE指针作为参数传递给每个标准I/O函数。</p>
<h3 id="stream的定向">stream的定向</h3>
<p>对于ASCII字符集，一个字符用一个字节表示。对于国际字符集，一个字符用多个字节表示。标准I/O FILE stream可以用于单字节也可以用于多字节字符集。stream的orientation决定了读写的字符是单字节还是多字节，最开始创建stream时，它的orientation没有被确定，使用什么字符的I/O就会将stream的orientation定义为什么。<br>
有两个函数可以改变stream的orientation，它们是<code>freopen</code>和<code>fwide</code>，原型如下：</p>
<h3 id="freopen和fwide原型"><code>freopen</code>和<code>fwide</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *stream, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="freopen和fwide性质"><code>freopen</code>和<code>fwide</code>性质</h3>
<ol>
<li><code>fwide</code>用于设置stream的orientation。如果<code>mode</code>为负，是单字节定向的。如果<code>mode</code>为正，是多字节定向的。如果<code>mode</code>为0，<code>fwide</code>确定当前stream的oritentation并返回。</li>
<li><code>fwide</code>不能改变已经定向的stream的orientation。</li>
<li><code>fwide</code>没有出错返回</li>
</ol>
<h3 id="标准输入-标准输出和标准错误">标准输入，标准输出和标准错误</h3>
<p>通常对一个进程预定义了三个stream，它们可以自动的被进程使用。它们是标准输入，标准输出和标准错误，这些stream引用的文件和文件描述符<code>STDIN_FILENO</code>,<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>所引用的文件一样。<br>
这三个stream定义在头文件<code>&lt;stdio.h&gt;</code>中，通过预定义文件指针<code>stdin</code>, <code>stdou</code>和<code>stderr</code>使用。</p>
<h2 id="三种缓冲类型">三种缓冲类型</h2>
<p>标准I/O库提供缓冲的目的是尽可能减少<code>read</code>和<code>write</code>的调用次数，标准I/O库对每个流自动的进行缓冲管理，使得应用程序不用考虑缓冲区的管理。<br>
标准I/O提供了三种类型的缓冲：</p>
<h3 id="全缓冲">全缓冲</h3>
<p>填满标准I/O的缓冲区之后，进行实际的I/O操作。对于存储在磁盘上的文件通常是由标准I/O实施全缓冲的。在一个流上第一次执行I/O操作时，相关的标准I/O函数调用<code>malloc</code>获得需要的缓冲区。</p>
<h3 id="行缓冲">行缓冲</h3>
<p>在行缓冲中，当输入和输出遇到换行符时，标准I/O库执行I/O操作。但是需要注意的是行缓冲区的长度是固定的，当行缓冲区满时即使没有遇到换行符也进行I/O操作。当涉及终端的I/O时，通常使用行缓冲。使用标准I/O的<code>fputc</code>允许我们一次输出一个字符，但是只有在写了一行之后才能进行实际I/O操作。<br>
此外，任何时候只要通过标准I/O库要求从一个不带缓冲的流或者一个行缓冲的流中得到输入数据，那么就会flush所有行缓冲输出流。从行缓冲的流中得到输入数据的一个例子就是从终端按下回车，刚才输入的数据就会立刻从输出流中输出。</p>
<h3 id="不带缓冲">不带缓冲</h3>
<p>标准I/O库不对字符进行缓冲存储。如果将字符传入不带缓冲的输出流中，字符会立即输出到输出流关联的文件或者设备。</p>
<h3 id="fflush函数"><code>fflush</code>函数</h3>
<p>标准I/O库使用flush将输出流缓冲区的内容写到和输出流相关联的文件，缓冲区可以使用标准I/O例程自动的flush，比如当缓冲区填满时，或者缓冲区不满时可以手动调用<code>fflush</code>函数进行flush。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flussh</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>任何时候，都可以手动强制冲洗一个流，当<code>fp</code>是<code>NULL</code>时，冲洗所有的输出流。<br>
注意<code>fflush</code>和<code>fsync</code>的区别，<code>fflush</code>是将位于主存中的缓冲区的内存冲洗到内核。而内核也有一个缓冲区，叫做buffer cache或者page cache，内核接收到数据会首先将它们写入buffer cache或者page cache中，然后排入队列，晚些时候再写，这种方式叫做延迟写。<code>fsync</code>是将buff cache中的内容立即写入磁盘而不等待。</p>
<h3 id="iso-c缓冲标准和unix具体实现">ISO C缓冲标准和UNIX具体实现</h3>
<p>ISO C要求：</p>
<ol>
<li>当且仅当标准输入和标准输出不指向交互设备时，它们才是全缓冲的。</li>
<li>标准错误不会是全缓冲的。</li>
</ol>
<p>UNIX具体实现：</p>
<ol>
<li>标准错误不带缓冲</li>
<li>指向终端设备的流，都是行缓冲的，否则是全缓冲的。</li>
</ol>
<h3 id="修改默认缓冲">修改默认缓冲</h3>
<p>可以通过<code>setbuf</code>和<code>setvbuf</code>更改流的缓冲类型。</p>
<h3 id="setbuf和setvfuf原型"><code>setbuf</code>和<code>setvfuf</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="setbuf和setvfuf性质"><code>setbuf</code>和<code>setvfuf</code>性质</h3>
<ol>
<li>这些函数需要在流被打开后调用，因为他们需要文件指针作为参数，而且应该在对流执行任何操作之前调用。</li>
<li>可以使用<code>setbuf</code>函数打开和关闭缓冲机制。将<code>buf</code>设置为<code>NULL</code>，就是关闭缓冲。如果<code>buf</code>不为<code>NULL</code>，它必须指向一个长度为<code>BUFSIZ</code>的缓冲区，通常在这之后就是全缓冲的，如果和终端设备关联，可能会是行缓冲的。</li>
<li><code>setvbuf</code>可以通过<code>mode</code>指定缓冲的类型，<code>_IOFBF</code>是全缓冲，<code>_IOLBF</code>是行缓冲，<code>_IONBF</code>是不缓冲。指定不缓冲，忽略<code>buf</code>和<code>size</code>参数。如果指定全缓冲或者行缓冲，<code>buf</code>和<code>size</code>可以通过<code>buf</code>和<code>size</code>指定缓冲区的位置和大小。如果指定带缓冲，而<code>buf</code>是<code>NULL</code>，系统会自动分配<code>BUFSIZE</code>大小的缓冲区。</li>
<li>一般而言，应该由操作系统选择缓冲区的长度，并且自动分配缓冲区，这种情况下，关闭流，标准I/O库会自动释放缓冲区。</li>
</ol>
<h2 id="打开一个stream">打开一个stream</h2>
<p>可以使用<code>fopen</code>, <code>freopen</code>和<code>fdopen</code>函数打开一个standard I/O stream。它们的原型如下：</p>
<h3 id="fopen-freopen和fdopen原型"><code>fopen</code>, <code>freopen</code>和<code>fdopen</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="fopen-freopen和fdopen性质"><code>fopen</code>, <code>freopen</code>和<code>fdopen</code>性质</h3>
<ol>
<li><code>fopen</code>打开路径名为<code>pathname</code>的一个文件</li>
<li><code>fdopen</code>使用一个已有的文件描述符，并将一个标准I/O stream和该文件描述符结合。<strong>这个函数通常用于由创建管道和网络通信通道函数返回的文件描述符，因为这些特殊文件不能使用标准I/O函数<code>fopen</code>打开，所以需要使用设备专用函数获得一个文件描述符，然后使用<code>fdopen</code>将文件描述符和一个I/O stream结合。</strong></li>
<li><code>freopen</code>函数在一个指定的stream打开一个指定的文件，如果这个stream已经打开，先关闭这个stream；如果这个stream已经进行了定向，使用<code>freopen</code>清楚该定向。<strong>这个函数一般用于将一个指定的文件打开为一个预定义的stream：stdin, stdout和stderr。</strong></li>
<li><code>fopen</code>和<code>freopen</code>是ISO C的部分，因为ISO C不包含文件描述符，所以只有POSIX.1有<code>fdopen</code>。</li>
<li><code>mode</code>有15种取值：<code>r</code>, <code>w</code>, <code>a</code>, <code>rb</code>, <code>wb</code>, <code>ab</code>,<code>r+</code>,<code>r+b</code>, <code>rb+</code>,<code>w+</code>,<code>w+b</code>,<code>wb+</code>, <code>a+</code>, <code>a+b</code>, <code>ab+</code>。对于标准I/O来说，使用<code>b</code>可以区分二进制和文本文件。但是对于UNIX来说，二进制和文本文件没有区别，有没有<code>b</code>无所谓。</li>
<li>当用追加写时，如果有多个进程用追加写方式打开同一个文件，每个进程的数据都会正确的写入文件中。</li>
<li><code>fdopen</code>不会截断也不会创建文件。对于<code>fdopen</code>来说，因为需要文件描述符，所以文件必须是打开的，当<code>mode</code>是<code>w</code>,<code>wb</code>时，并不会截断文件，<code>a</code>和<code>ab</code>也不能用于创建文件，因为文件描述符必须引用一个存在的文件。而如果使用<code>a+</code>, <code>ab+</code>, <code>w+</code>, <code>wb+</code>等，这个时候文件已经存在了，不会创建，也不会截断，需要写或者追加就行了，就不会有前半句说的问题了。</li>
<li>使用<code>a</code>和<code>w</code>相关的<code>mode</code>创建文件时，没有办法指定文件的权限位。而POSIX.1要求使用如下的权限创建文件：<br>
<code>S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IOTH|S_IWOTH</code><br>
可以在使用<code>fopen</code>等函数之前，使用<code>umask</code>指定文件的权限位。</li>
<li>如果流引用终端设备，是行缓冲的，否则是全缓冲的。</li>
</ol>
<h3 id="fclose函数和性质"><code>fclose</code>函数和性质</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在文件被关闭之前，flush输出数据。缓冲区中的输入数据被丢弃。如果标准I/O库为这个stream自动分配了缓冲区，释放该缓冲区。<br>
当一个进程正常终止时，所有带未写缓冲数据的标准I/O都被flush，所有打开的标准I/O都被关闭。</p>
<h2 id="读写stream">读写stream</h2>
<p>对于一个打开的stream，可以使用3种不同的类型的非格式化I/O以及格式化I/O，对其进行读写操作。<br>
3种非格式化I/O包括：</p>
<ol>
<li>单字符的I/O。如果流是带缓冲的，标准I/O会负责处理缓冲。</li>
<li>单行的I/O。<strong>这里需要注意一下，单行I/O指定的buffer和标准I/O的buffer不一样。</strong></li>
<li>直接I/O（direct I/O）。</li>
</ol>
<h2 id="ferror和feof-clearerr函数和属性"><code>ferror</code>和<code>feof</code>, <code>clearerr</code>函数和属性</h2>
<p>不管是出错还是到达文件结束，<code>getc</code>,<code>fgetc</code>和<code>ungetc</code>等许多函数都返回同样的值<code>EOF</code>，<code>EOF</code>是-1，可以使用<code>ferro</code>和<code>feof</code>判断到底是出错还是到达文件尾端。大多数实现中是为每个流在<code>FILE</code>对象中维护了出错标志和文件结束标志，可以使用<code>clearerr</code>清除相应的标志。函数的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="单字符i-o">单字符I/O</h2>
<p><code>getc</code>, <code>fgetc</code>和<code>getchar</code>函数可以用于一个读一个字符。它们的原型如下：</p>
<h3 id="getc-fgetc和getchar-ungetc原型"><code>getc</code>, <code>fgetc</code>和<code>getchar</code>, <code>ungetc</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="getc-fgetc和getchar-ungetc性质"><code>getc</code>, <code>fgetc</code>和<code>getchar</code>, <code>ungetc</code>性质</h3>
<p><code>getc</code>和<code>fgetc</code>功能一样，只不过<code>getc</code>可以被实现为宏，而<code>fgetc</code>不能被实现为宏。所以：</p>
<ol>
<li><code>getc</code>的参数不应该是具有副作用的表达式，因为它可能会被计算多次。</li>
<li><code>fgetc</code>一定是函数，所以可以得到它的地址。可以当做参数传递给其他函数。</li>
<li><code>fgetc</code>的调用时间通常要比<code>getc</code>长，因为调用函数的时间通常比调用宏的时间长。</li>
</ol>
<h3 id="ungetchar函数和属性"><code>ungetchar</code>函数和属性</h3>
<ol>
<li>从流中读取的数据可以送回流中。</li>
<li>ISO C规定可以支持任何次数的回送，但是一次只能送一个字符。</li>
<li>回送的字符可以不是上次读到的字符。</li>
<li>回送的字符不能是<code>EOF</code>，但是读到文件尾端时，还可以回送一个字符，因为一次成功的<code>ungetc</code>调用会清除<code>EOF</code>标志。</li>
<li>用<code>ungetc</code>只能将字符写入到标准I/O库的流缓冲区中，并没有将它们写到底层设备或者文件中。</li>
</ol>
<p>函数的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="输出函数putc-fputc和putchar">输出函数<code>putc</code>, <code>fputc</code>和<code>putchar</code></h3>
<p>它们的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;     <span class="comment">//相当于putc(c, stdout);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="单行i-o">单行I/O</h2>
<p><code>fgets</code>和<code>gets</code>,<code>getline</code>提供了单行输入的功能，单行I/O需要指定一个缓冲区，这个缓冲区是用户自己定义的，是应用程序级别的，它和标准I/O的buffer不一样，我们可以通过<code>setbuf</code>和<code>setvbuf</code>设置标准I/O的buffer，这是标准I/O即库函数层级的，而<code>read</code>和<code>write</code>等使用的buffer又是一类buffer，这是系统调用层级的，我们也可以自己指定。<br>
它们的原型如下：</p>
<h3 id="fgets和gets-getline原型"><code>fgets</code>和<code>gets</code>,<code>getline</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> getline(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream);</span><br><span class="line"><span class="keyword">ssize_t</span> getdelim(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, <span class="keyword">int</span> delim, FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="fgets和gets-getline性质"><code>fgets</code>和<code>gets</code>,<code>getline</code>性质</h3>
<ol>
<li><code>gets</code>从标准输入读，而<code>fgets</code>从指定的流中读</li>
<li><code>gets</code>不会读入<code>'\n'</code>，而<code>fgets</code>, <code>getline</code>都会读入<code>'\n'</code>;</li>
<li><code>fgets</code>需要指定缓冲的长度，遇到<code>&quot;\n&quot;</code>停止，但是不能超过<code>n-1</code>个字符，读入的字符送入缓冲区。缓冲区以<code>NULL</code>字节结尾，如果这一行包含最后一个换行符超过了<code>n-1</code>个字符，<code>fgets</code>只返回一个不完整的行，但是这一行还是以<code>NULL</code>结束，下一次调用继续从该行读。</li>
<li><code>gets</code>不推荐使用，因为没有指定缓冲区的长度，可能会造成缓冲区溢出，很危险。</li>
</ol>
<h3 id="fputs和puts原型"><code>fputs</code>和<code>puts</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="fputs和puts性质"><code>fputs</code>和<code>puts</code>性质</h3>
<ol>
<li><code>fputs</code>将一个以<code>NULL</code>字节结束的字符串写到指定的流中，尾端的<code>NULL</code>不输出。这并不是每次输出一行，只有<code>NULL</code>前面的字节中包含<code>'\n'</code>时，才会输出一行。</li>
<li><code>puts</code>不会输出<code>NULL</code>字节，但是会自动将字符串后添加一个换行符。</li>
<li><code>puts</code>并不像<code>gets</code>那样不安全，但是因为自动加了换行符很难受。所以尽量使用<code>fgets</code>和<code>fputs</code>。</li>
</ol>
<h2 id="二进制直接i-o">二进制直接I/O</h2>
<p>除了可以以字符和行为单位进行读取，还可以使用二进制stream进行I/O。</p>
<h3 id="fread和fwrite原型"><code>fread</code>和<code>fwrite</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="fread和fwrite性质"><code>fread</code>和<code>fwrite</code>性质</h3>
<ol>
<li><code>fread</code>和<code>fwrite</code>通常用来读写一个二进制数组或者一个结构体。<code>ptr</code>是要读写的首地址，<code>size</code>是每个对象的大小，<code>nmemb</code>是要写的对象的个数。</li>
<li><code>fread</code>和<code>fwrite</code>返回读写的对象数，读出错或者到达文件结尾，返回的数可以少于<code>nmemb</code>。可以调用<code>ferror</code>或者<code>feof</code>判断是结束还是出错。如果写返回的数值小于<code>nmemb</code>，那么就是出错。</li>
<li><code>fread</code>只能用于读在同一个系统上的数据，因为不同的系统上二进制文件的格式可能不同。</li>
<li><code>fread</code>和<code>read</code>的区别，<code>read</code>是系统调用，而<code>fread</code>是ISO C的函数。<code>read</code>的buf大小是字节，而<code>fread</code>的size是每个对象的大小，<code>nmemb</code>是对象的个数。</li>
</ol>
<h2 id="格式化i-o">格式化I/O</h2>
<p>除了三种非格式化的I/O，还有标准化I/O函数。标准化I/O函数需要指定格式说明。</p>
<h3 id="输出格式说明">输出格式说明</h3>
<p>格式说明控制其余参数如何编写，以后如何限制。每个参数按照转换说明编写，转换说明以%号开始。除了转换说明外，格式化字符串中的其他字符都按照原样输出。<br>
一个输出格式说明由四个可选部分构成：<br>
<code>%[flags][fldwidth][precision][lenmodifier] convtype</code></p>
<h4 id="flags">flags</h4>
<ul>
<li><code>'</code>，将整数按千位分组字符</li>
<li>‘-’，左对齐</li>
<li><code>+</code>，显示带符号数的正负号</li>
<li><code></code>，如果第一个字符不是正负号，在前面加上一个空格</li>
<li><code>#</code>，指定另一种形式，比如0x指定十六进制</li>
<li><code>0</code>，添加前导0而不是空格进行填充</li>
</ul>
<h4 id="fldwitdth">fldwitdth</h4>
<p>最小宽度，多余字符用空格填充</p>
<h4 id="precision">precision</h4>
<p>整形转换后最少输出数字位数<br>
浮点数转换后小数点后的最少位数。<br>
字符串转换后最大字节数</p>
<p>精度使用一个<code>.</code>，然后跟着一个可选的非负十进制整数或者<code>x</code>。</p>
<h4 id="lenmodifier">lenmodifier</h4>
<p><code>l</code>, <code>ll</code> , <code>L</code>分别表示<code>long</code>, <code>long long</code>以及<code>long double</code>。</p>
<h4 id="convtype">convtype</h4>
<ul>
<li><code>d</code>, <code>i</code>，有符号十进制</li>
<li><code>o</code>，无符号八进制</li>
<li><code>u</code>，无符号十进制</li>
<li><code>x</code>, <code>X</code>，无符号十六禁止</li>
<li><code>f</code>, <code>F</code>，双精度浮点数</li>
<li><code>e</code>, <code>E</code>，指数形式双精度浮点苏</li>
<li><code>g</code>, <code>G</code></li>
<li><code>a</code>, <code>A</code>，十六进制指数形式双精度浮点数</li>
<li><code>c</code>，字符</li>
<li><code>s</code>，字符串</li>
<li><code>p</code>，指向void的指针</li>
<li><code>n</code>，</li>
<li><code>%</code>，一个<code>%</code>字符</li>
<li><code>C</code>，宽字符，等于<code>lc</code></li>
<li><code>S</code>，宽字符串，等于<code>ls</code></li>
</ul>
<p>常见的格式化输出函数原型如下：</p>
<h3 id="printf-frpintf-dprintf-snprintf和fpritnf原型"><code>printf</code>, <code>frpintf</code>, <code>dprintf</code>, <code>snprintf</code>和<code>fpritnf</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="printf-frpintf-snprintf-dprintf和fpritnf性质"><code>printf</code>,<code>frpintf</code>, <code>snprintf</code>,<code>dprintf</code>和<code>fpritnf</code>性质</h3>
<ol>
<li><code>printf</code>将格式化数据输出到标准输出</li>
<li><code>fprintf</code>将格式化数据写到指定的流。</li>
<li><code>dprintf</code>将格式化数据写到指定的文件描述符。</li>
<li><code>sprintf</code>将格式化数据送入数组<code>buf</code>中，<code>sprintf</code>在数组的尾端自动加一个null字节，但是该字符不包含在返回值中。</li>
<li><code>sprintf</code>可能会造成<code>buf</code>指向的缓冲区溢出，调用者有责任保证该缓冲区足够大。</li>
<li><code>snprintf</code>是为了解决缓冲区溢出的问题而引入的，它需要显式指定缓冲区的长度，超过这个长度的话，输入数据都会被丢弃，同样<code>ssprintf</code>在数组的尾端自动加一个null字节，但是该字符不包含在返回值中。</li>
</ol>
<h3 id="输入格式说明">输入格式说明</h3>
<p>一个输入格式转换说明由三个可选部分：<br>
<code>%[*][fldwidth][m][lenmodifier] convtype</code></p>
<ol>
<li>fldwidth用于说明最大宽度</li>
<li>lenmodifier说明要用转换结果赋值的参数大小，<code>printf</code>函数族支持的长度修饰符同样能够得到<code>scanf</code>函数族的支持。</li>
<li>而convtype符号和<code>printf</code>中类似，但是有一些区别。比如，输入中的带符号数可以复制给无符号类型。</li>
</ol>
<h3 id="scanf-fscnaf-sscanf原型"><code>scanf</code>, <code>fscnaf</code>, <code>sscanf</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="scanf-fscnaf-sscanf性质"><code>scanf</code>, <code>fscnaf</code>, <code>sscanf</code>性质</h3>
<ol>
<li><code>scanf</code>用于分析输入字符串，并将字符序列转换成指定类型的变量。格式后的各个参数给出了变量的地址，用转换结果对这些变量赋值。</li>
<li>格式说明控制如何转换参数，以便于对他们赋值，除了转换说明和空白字符外，格式字符串中的其他字符必须和输入匹配，如果有一个不匹配，就停止处理。</li>
</ol>
<h2 id="标准i-o效率">标准I/O效率</h2>
<p><code>fgets</code>, <code>fgetc</code>, <code>getc</code>, <code>read</code>这几个函数，哪个效率更高？<br>
当他们同时读取一个300万行的98.5M的程序时，<code>read</code>效果最好。它们的系统CPU时间基本一样，但是用户CPU时间查了很多，以及等待I/O的时间也差了很多。为什么呢？</p>
<ol>
<li>系统CPU时间相同，因为它们对内核提出的读写请求数基本相同。</li>
<li>CPU时间差太多是因为，<code>getc</code>和<code>fgetc</code>需要进行上亿次的循环（上亿个字符），而<code>fgets</code>需要进行百万次的循环，而<code>read</code>只需要几万次（缓冲区大小设置为4096时）。</li>
<li><code>fgetc</code>和<code>read</code>缓冲区大小设置为1时，<code>read</code>要慢很多，因为<code>read</code>调用了两亿次系统调用，而<code>fget</code>调用了两亿次函数调用。系统调用的时间和各项开销要比函数调用大得多。</li>
</ol>
<h2 id="定位stream">定位stream</h2>
<p>有三种方法对I/O stream进行定位，分别是<code>ftell</code>和<code>fseek</code>，<code>ftello</code>和<code>fseeko</code>，<code>fgetpos</code>和<code>fsetpos</code>。它们的原型如下：</p>
<h3 id="ftell-feek-ftello-fseeko和fgetpos-fsetpos原型"><code>ftell</code>, <code>feek</code>, <code>ftello</code>, <code>fseeko</code>和<code>fgetpos</code>, <code>fsetpos</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *stream, <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *stream, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="keyword">off_t</span> ftello(FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="ftell-feek-ftello-fseeko和fgetpos-fsetpos性质"><code>ftell</code>, <code>feek</code>, <code>ftello</code>, <code>fseeko</code>和<code>fgetpos</code>, <code>fsetpos</code>性质</h3>
<ol>
<li><code>ftell</code>和<code>fseek</code>假设文件的位置可以存放在一个长整形中，而<code>ftello</code>和<code>fseeko</code>使用<code>off_t</code>代替了长整形。除此之外，它们完全相同。</li>
<li><code>fgetpos</code>和<code>fsetpos</code>是ISO C的标准，其他是SUS，所以跨平台时，使用<code>fgetpos</code>和<code>fsetpos</code>。</li>
<li>对于二进制文件，<code>whence</code>可以使用<code>SEEK_SET</code>, <code>SEEK_CUR</code>，这是跨平台的，而<code>SEEK_END</code>不是平台的。</li>
<li>对于文本文件，<code>whence</code>必须要用<code>SEEK_SET</code>且<code>offset</code>只能是0或者<code>ftell</code>返回的值。</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<p>所有的standard I/O库都要使用到文件的I/O。每个I/O stream都有一个和其相关的文件描述符，可以使用<code>fileno</code>函数获得stream的文件描述符。</p>
<h2 id="临时文件">临时文件</h2>
<p>ISO C提供了两个函数<code>tmpnam</code>和<code>tmpfile</code>帮助创建临时文件。它们的原型如下：</p>
<h3 id="tmpnam和tmpfile原型"><code>tmpnam</code>和<code>tmpfile</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="tmpnam和tmpfile性质"><code>tmpnam</code>和<code>tmpfile</code>性质</h3>
<ol>
<li><code>tmpnam</code>产生一个与现有文件名不同的一个有效路径名字符串。避免使用<code>tmpnam</code>。</li>
<li><code>tmpfile</code>创建一个临时二进制文件(wb+)，在关闭文件或者程序结束时自动删除这个文件。注意UNIX对于二进制文件不做特殊区分。</li>
<li><code>tmpfile</code>函数经常使用的标准UNIX技术是先使用<code>tmpnam</code>产生一个唯一的路径名，然后使用它创建一个文件，并且立刻<code>unlink</code>它。注意，对一个文件<code>unlink</code>之后，如果链接计数等于0，并不立即删除它，因为可能有进程在使用这个文件，关闭文件时才删除文件。</li>
<li><code>mkdtemp</code>和<code>mkstemp</code>是XSI的扩展部分。</li>
<li><code>mkstemp</code>和<code>mkdtemp</code>都需要传入一个字符串，它的后六位设置为<code>XXXXXX</code>，函数通过将这些占位符替换成不同的字符构建一个唯一的路径名。如果只指定了名字，就创建在当前目录下。</li>
<li><code>mkdtemp</code>创建的目录的权限是<code>S_IRUSR</code>,<code>S_IWUSR</code>, <code>S_IXUSR</code>。<code>mkstemp</code>创建的文件的权限是<code>S_IRUSR</code>,<code>S_IWUSR</code>，可以使用<code>umask</code>进行修改。</li>
<li><code>mkstemp</code>创建的文件不会被自动删除。</li>
</ol>
<h2 id="内存stream">内存stream</h2>
<p>Standard I/O把数据缓存在内存中，因此字符和单行的I/O更有效一些，我们也可以使用<code>setbuf</code>和<code>setvbuf</code>让标准I/O库使用自己指定的缓冲区。<br>
在SUS4之后添加了对memory streams的支持，这些standard I/O streams没有底层文件支持，但是仍然可以使用FILE指针访问，所有的I/O都是通过在缓冲区和主存中来回交换字节实现的。这些流虽然看起来像文件流，但是某些特征更像字符串操作。</p>
<p>有三个函数可以用于内存流的创建，它们分别是<code>fmemopen</code>，<code>open_memstream</code>和<code>open_wmemstream</code>。</p>
<h3 id="fmemopen函数和属性"><code>fmemopen</code>函数和属性</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>fmemopen</code>函数open memory as stream</li>
<li><code>fmemopen</code>函数允许调用者提供缓冲区用于memory stream，<code>size</code>指定了缓冲区大小的字节数。如果<code>buf</code>为空，<code>fmemopen</code>会分配<code>size</code>字节数的缓冲区，流关闭时缓冲区会被释放。</li>
<li><code>type</code>和<code>fopen</code>的取值一样，总共有15种取值，</li>
</ol>
<h3 id="open-memstream和open-wmemstream函数和属性"><code>open_memstream</code>和<code>open_wmemstream</code>函数和属性</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">open_memstream</span><span class="params">(<span class="keyword">char</span> **ptr, <span class="keyword">size_t</span> *sizeloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">open_wmemstream</span><span class="params">(<span class="keyword">wchar_t</span> **ptr, <span class="keyword">size_t</span> *sizeloc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它们一个面向字节，一个面向宽字节。它们和<code>fmemopen</code>之间的区别：</p>
<ol>
<li>创建的流只能打开；</li>
<li>不能指定自己的缓冲区，但是可以访问缓冲区地址和大小。</li>
<li>关闭流后需要自己释放缓冲区</li>
<li>对流添加字节会增加缓冲区大小。</li>
<li>缓冲区地址和长度只有在调用<code>fclose</code>或者<code>fflush</code>后才有效。这些值只有在下一次流写入或者调用<code>fclose</code>前。</li>
</ol>
<h2 id="标准i-o的替代软件">标准I/O的替代软件</h2>
<p>标准I/O库的一个不足是效率不高。这和它复制的数据量有关。每当使用一次<code>fgets</code>和<code>fputs</code>时，通常需要复制两次数据，一次是在用户程序的行缓冲区和标准I/O缓冲区之间，一次是在内核和标准I/O缓冲区之间。<br>
OK，这章我就认识到了这一个很重要的知识点。。<br>
使用<code>fgets</code>需要用户指定<code>fgets</code>使用的缓冲区，或者使用<code>getline</code>，如果传入的指针指向NULL，<code>getline</code>会负责分配缓冲区大小。<br>
标准I/O可以设置行缓冲和全缓冲，如果设置缓冲的话也需要一个缓冲区，通常是由系统指定的，当然也可以通过<code>setbuf</code>和<code>setvbuf</code>自己进行更改。而在<code>setbuf</code>中，如果<code>buf</code>是<code>NULL</code>的话，是关闭缓冲区，如果不为空的话，必须是<code>BUFSIZ</code>大小。在<code>setvbuf</code>中，通过<code>mode</code>指定缓冲区的类型，<code>buf</code>是<code>NULL</code>的话，库函数负责分配缓冲区。否则<code>buf</code>是多大就用多大的缓冲区。<br>
直接使用系统调用<code>read</code>和<code>write</code>函数也需要设置缓冲区，这是系统调用级别的，大小可以任意指定，通常使用<code>sturct stat.st_blksize</code>的大小。标准I/O库用的缓冲区和<code>read</code>,<code>write</code>指的是一个（我自己的理解）。<br>
内核中有buffer cache和page cache，调用<code>write</code>只是将数据复制到buffer cache和page cache，然后排入队列，实际的写磁盘操作可能在满足某个条件之后才实际写入磁盘。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuffer</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://stackoverflow.com/questions/20937616/what-is-the-difference-between-a-stream-and-a-file" target="_blank" rel="noopener">https://stackoverflow.com/questions/20937616/what-is-the-difference-between-a-stream-and-a-file</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/21/UNIX-file-and-directory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/21/UNIX-file-and-directory/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX file and directory</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-21 10:18:13" itemprop="dateCreated datePublished" datetime="2019-11-21T10:18:13+08:00">2019-11-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:33:44" itemprop="dateModified" datetime="2019-12-17T16:33:44+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一节主要介绍文件系统和文件的一些属性，这些属性都存在<code>stat</code>函数给出的<code>struct stat</code>结构体中，<code>struct stat</code>的部分字段如下所示，接下来的小节会对这些字段进行详细的介绍：</p>
<h3 id="struct-stat"><code>struct stat</code></h3>
<p>这个结构体包括：</p>
<ol>
<li><code>mode_t st_mode;</code> 文件类型和文件权限控制</li>
<li><code>ino_t st_ino;</code> 文件存放的i-node号</li>
<li><code>dev_t st_dev;</code> 文件所在文件系统的设备号</li>
<li><code>dev_t st_rdev;</code> 特殊文件所在文件系统的设备号</li>
<li><code>nlink_t st_nlink;</code> 链接到文件指向的i-node节点的数量，即hardlink</li>
<li><code>uid_t st_uid;</code> 文件所有者的UID</li>
<li><code>gid_t st_gid;</code> 文件所有者的GID</li>
<li><code>off_t st_size;</code> 普通文件的字节数</li>
<li><code>struct timespec st_atime;</code> 最后一次access文件内容的时间</li>
<li><code>struct timespec st_mtime;</code> 最后一个modification文件内容的时间</li>
<li><code>struct timespec st_ctime;</code> 最后一次文件i-node 内容change的时间</li>
<li><code>blksize_t st_blksize;</code> 最合适的I/O block size</li>
<li><code>blkcnt_t st_blocks;</code> 分配了多少个disk blocks</li>
</ol>
<h2 id="文件系统">文件系统</h2>
<p>UNIX文件系统有多种实现，比如基于BSD的UNIX文件系统(UFS)，linux的ext4文件系统，以及Mac OS X的HFS文件系统。本节拿UFS举例子。<br>
一个磁盘可以有一个或者多个partition，每个partition可以包含文件系统也可以不包含。对于UFS文件系统，它由boot blocks，super block，cylinder groups组成。每一个cylinder group由super block copy, config info, i-node图，block bitmap以及i-nodes和data blocks组成。i-node节点是固定长度的记录项，它包含有关文件的大部分信息。</p>
<ol>
<li>i-node节点包含了文件的：文件类型，文件访问权限，文件长度，和指向文件数据的指针等，<code>stat</code>绝大部分的数据都取自i-node。</li>
<li>data blocks中存放实际的数据，包含data blocks和directory blocks。data blocks存放文件的实际数据。目录也是文件，directory blocks也是data block，只不过它是存放目录文件中所有directory entry(目录项)的data blcok，一个directory entroy包括文件名和i-node编号。i-node节点编号的数据类型是<code>ino_t</code>。</li>
<li>hard links：在每一个i-node中，都有一个链接计数，记录指向它的目录项个数，POSIX.1常量<code>LINK_MAX</code>指定了一个文件连接数的最大值。链接计数可以从<code>st_nlink</code>中得到，类型是<code>nlink_t</code>。hard link创建一个新的目录项指向链接目标的i-node节点，删除原来的目录项对新的目录项没有影响。只有当指向i-node节点的链接数等于0时且没有进程使用该文件时，可以删除该文件。</li>
<li>symbolic links：symbolic links文件的实际内容，也就是存储在data blocks中的内容，是该symbolic link指向的文件的名字。symbolic link和hard link不一样，它有自己的i-node号，删除它指向的文件，这个symbolic link会失效，变成一个dead link。它的文件类型是<code>S_IFLNK</code>。</li>
<li>一个目录项不能指向另一个文件系统的i-node，所以hard link不能跨越文件系统。</li>
<li>在不更换文件系统的情况下为一个文件重命名的话。文件的实际内容没有变，只是构造了一个新的目录项，它的i-node就是待重命名的文件，然后删除老的目录项。链接的计数并不会改变，这就是<code>mv</code>命令的工作方式。</li>
<li>i-node节点指向的数据块也可以存放目录项，在i-node的<code>st_mode</code>中可以确定它的类型是<code>S_IFDIR</code>。创建一个名为<code>testdir</code>的空目录，它的链接计数是2，一个是<code>.</code>目录，一个是<code>testdir</code>。<code>testdir</code>的上一级目录，它的链接计数是3（假设上一级目录只包含<code>testdir</code>），一个是这个目录的名字，一个是<code>.</code>，一个是<code>testdir</code>中的<code>..</code>。</li>
</ol>
<p>关于linux文件系统，可以查看<a href="https://mxxhcm.github.io/2019/05/07/linux-file-system/">linux file system</a>.</p>
<h3 id="设备特殊文件">设备特殊文件</h3>
<p>这一小节主要介绍<code>st_dev</code>和<code>st_rdev</code>字段。</p>
<ol>
<li>每个文件系统所在的存储设备都由其主次设备号表示。设备号所用的数据类型是基本系统数据类型<code>dev_t</code>。主设备号标识设备驱动程序，次设备号标识特定的子设备。一个磁盘驱动器通常可以包含多个文件系统，同一个磁盘上的文件系统通常具有相同的主设备号，但是次设备号却不同。</li>
<li>每个文件名中的<code>st_dev</code>是存放该文件名和其对应i节点的文件系统的设备号。</li>
<li>可以使用两个宏<code>major</code>和<code>minor</code>访问主，次设备号，它们的参数都是<code>st_dev</code>。POSIX.1说明<code>dev_t</code>类型存在，但是没有定义它是什么，具体取值与实现相关。</li>
<li>只有字符特殊文件和块特殊文件才有<code>st_rdev</code>值，同样使用<code>major</code>和<code>minor</code>两个宏访问相应的主次设备号。</li>
<li>块特殊文件是包含随机访问文件系统的设备，比如硬盘驱动器，软盘驱动器和CD-ROM以及磁带等。</li>
</ol>
<h2 id="文件类型">文件类型</h2>
<p>文件类型信息包含在<code>struct stat</code>的<code>st_mode</code>字段中。UNIX系统的文件类型有以下几种：</p>
<ol>
<li>普通文件，可以是二进制文件，也可以是文本文件。除了二进制可执行文件必须遵循标准化格式外，其他的文件对于UNIX内核来说基本上没有区别。使用<code>S_ISREG</code>宏进行判断。</li>
<li>目录文件，包含了其他文件的名字，以及指向这些文件有关信息的指针。对一个目录具有读权限的任意进程都可以读目录的内容，但是只有内核才可以直接写目录文件。使用<code>S_ISDIR</code>宏进行判断。</li>
<li>block special file，提供对设备带缓冲的访问，每次访问以固定的长度进行。使用<code>S_ISBLK</code>宏进行判断。</li>
<li>character special file，提供对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是block special file要是character special file。使用<code>S_ISCHR</code>宏进行判断。</li>
<li>FIFO，用于进程间通信。使用<code>S_ISFIFO</code>宏进行判断。</li>
<li>socket，用于进程间的网络通信。使用<code>S_ISSOCK</code>宏进行判断。</li>
<li>symbolic link，指向另一个文件。使用<code>S_ISLNK</code>宏进行判断。</li>
</ol>
<h2 id="stat-fstat-fstatat-lstat"><code>stat</code>, <code>fstat</code>, <code>fstatat</code>, <code>lstat</code></h2>
<p>可以通过<code>stat</code>等函数获得文件（各类文件）的<code>struct stat</code>结构体，它们的原型如下：</p>
<h3 id="函数原型">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="性质">性质</h3>
<ol>
<li><code>stat</code>将pathname指定的文件的有关信息存在放在<code>statbuf</code>中</li>
<li><code>fstat</code>将文件描述符指定的文件的有关信息存在放在<code>statbuf</code>中</li>
<li><code>lstat</code>和<code>stat</code>类似，但是当文件是一个symbolic link时，<code>lstat</code>返回symbolic link相关的信息，<code>stat</code>返回的是symbolic link链向的文件。</li>
<li><code>fstatat</code>相当于将前三个函数进行了整合：<br>
当<code>dirfd</code>设置为<code>AT_FDCWD</code>时或者pathname是绝对路径时，设置<code>AT_SYSLINK_NOFOLLOW</code> flags时，相当于<code>lstat</code>。<br>
当<code>dirfd</code>设置为<code>AT_FDCWD</code>时或者pathname是绝对路径时，<code>AT_SYSLINK_NOFOLLOW</code> flags不进行设置时，相当于<code>stat</code>。<br>
当<code>dirfd</code>既不是<code>AT_FDCWD</code>而且pathname不是绝对路径时，就是<code>fstatat</code>处理的情况了。</li>
</ol>
<h2 id="hard-link和函数link-linkat-unlink-unlinkat和remove">hard link和函数<code>link</code>, <code>linkat</code>, <code>unlink</code>, <code>unlinkat</code>和<code>remove</code></h2>
<p>任何一个文件可以有多个目录项指向它的i-node节点。可以使用<code>link</code>和<code>linkat</code>创建hard link，使用<code>unlink</code>和<code>unlinkat</code>, <code>remove</code>删除hard link。</p>
<h3 id="hard-link的特点">hard link的特点</h3>
<ol>
<li>使用hard link链接的文件具有相同的inode和data block。</li>
<li>删除一个hard link不会影响其他具有相同inode号的文件。</li>
<li>只能对已经存在的文件创建hard link。</li>
<li>不能跨越文件系统创建hard link，因为每个文件系统的i-node节点都是单独的。</li>
<li>不能对目录创建hard link，可能会形成循环。</li>
</ol>
<h3 id="link和linkat的函数原型"><code>link</code>和<code>linkat</code>的函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="link和linkat的函数性质"><code>link</code>和<code>linkat</code>的函数性质</h3>
<ol>
<li><code>link</code>和<code>linkat</code>应该是原子操作。</li>
<li><code>linkat</code>和<code>link</code>类似。</li>
</ol>
<h3 id="unlink和unlinkat的函数原型"><code>unlink</code>和<code>unlinkat</code>的函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="unlink和unlinkat的函数性质"><code>unlink</code>和<code>unlinkat</code>的函数性质</h3>
<ol>
<li>如果<code>pathname</code>是hard link，这两个函数删除<code>pathname</code>的相应目录项，将<code>pathname</code>指向文件的i-node的链接数减一。</li>
<li>如果<code>pathname</code>是symbolic link，<code>unlink</code>删除的是symbolic link本身，而不follow它。</li>
<li>给出symbolic link时，没有任何函数能够删除symbolic link指向的文件。</li>
<li>如果链接数等于0，并且内核检查打开该文件的进程个数，如果它们都等于0。<code>unlink</code>会删除这个文件。如果链接数或者打开文件的进程个数大于0，不会对文件做修改。</li>
<li><code>unlinkat</code>和<code>unlink</code>类似。</li>
</ol>
<h3 id="remove的函数原型"><code>remove</code>的函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="remove的函数性质"><code>remove</code>的函数性质</h3>
<ol>
<li><code>remove</code>可以解除对文件或者目录的hard link。</li>
<li>作用于目录时，<code>remove</code>相当于<code>rmdir</code>。</li>
<li>作用于文件时，<code>remove</code>相当于<code>unlink</code>。</li>
</ol>
<h2 id="symbolic-link和函数symlink-symbolinkat-readlink-readlinkat">symbolic link和函数<code>symlink</code>,<code>symbolinkat</code>, <code>readlink</code>, <code>readlinkat</code></h2>
<p>hard links有一些限制：</p>
<ol>
<li>链接和文件必须处于同一文件系统中，</li>
<li>只有root用户才能创建指向目录的链接。</li>
</ol>
<h3 id="symbolic-link的特点">symbolic link的特点</h3>
<p>而symbolic link可以避开hard link的这些限制。</p>
<ol>
<li>symbolic可以看成文件的间接指针，它有自己的文件属性和权限，有自己的i-node号和data block，而所有指向一个i-node节点的hard link拥有相同的i-node。</li>
<li>symbolic link对于它指向的对象没有任何文件系统的限制，任何用户都可以创建指向目录的symbolic link。</li>
<li>使用文件名字为参数调用文件函数时，需要知道这个函数是否处理symbolic link的。如果函数具有处理symbolic link的功能，那么它处理的是symbolic link指向的文件，否则它直接处理这个symbolic link本身。<br>
如下所示，是常见的函数是否处理symbolic link，<code>fstat</code>和<code>fchmod</code>因为处理的是文件描述符，这个文件描述符是否是symbolic link本身通常是由<code>open</code>决定的。<br>
<code>access</code>,<code>chdir</code>, <code>chmod</code>, <code>chown</code>，<code>creat</code>, <code>exec</code>, <code>link</code>, <code>open</code>, <code>opendir</code>, <code>pathconf</code>, <code>stat</code>, <code>truncate</code>跟随symbolic link。<br>
<code>lchown</code>,<code>lstat</code>, <code>readlink</code>, <code>remove</code>, <code>rename</code>, <code>unlink</code>不跟随symbolic link。</li>
<li>使用symbolic link可能在文件系统中引入循环。<code>unlink</code>不跟随symbolic link，所以使用<code>unlink</code>消除symbolic link。但是hard link的循环很难消除。这也是为什么<code>link</code>函数不允许构造指向目录的hard link的原因。</li>
<li>symbolic link可以指向系统中并不存在的文件。所以<code>creat</code>的参数可以是symbolic link。</li>
</ol>
<p>创建和读取symbolic link的函数原型如下：</p>
<h3 id="symlink和symlinkat函数原型"><code>symlink</code>和<code>symlinkat</code>函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *linkpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *target, <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *linkpath)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="symlink和symlinkat函数性质"><code>symlink</code>和<code>symlinkat</code>函数性质</h3>
<ol>
<li><code>linkpath</code>和<code>target</code>不需要在同一个文件系统，而且<code>target</code>甚至可以不存在</li>
<li><code>symlinkat</code>和<code>symlink</code>类似。</li>
</ol>
<h3 id="readlink和readlinkat函数原型"><code>readlink</code>和<code>readlinkat</code>函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsiz);</span><br><span class="line"><span class="keyword">ssize_t</span> readlinkat(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsiz);</span><br></pre></td></tr></table></figure>
<h3 id="readlink和readlinkat函数性质"><code>readlink</code>和<code>readlinkat</code>函数性质</h3>
<ol>
<li><code>open</code>函数跟随symbolic link，而<code>readlink</code>打开symbolic link本身，并且读取symbolic link中的名字</li>
<li><code>readlink</code>组合了<code>open</code>,<code>close</code>和<code>read</code>的所有操作。如果函数成功执行，返回读入buf的字节数。</li>
<li><code>readlinkat</code>和<code>readlink</code>类似。</li>
</ol>
<h2 id="和进程相关的uid和gid">和进程相关的UID和GID</h2>
<p>每一个进程有6个或者更多和它相关的ID：</p>
<h3 id="实际uid和gid">实际UID和GID</h3>
<p>real UID和real GID，用来表示当前用户。</p>
<h3 id="有效uid和gid">有效UID和GID</h3>
<p>effective UID和effective UID，决定我们的文件访问权限。通常情况下，effective UID以及effective GID和real UID以及real GID一样。</p>
<h3 id="set-user-id和set-group-id">Set-User-ID和Set-Group-ID</h3>
<p>saved set-user-ID和saved set-group-ID，在执行一个程序时，包含了有效user ID和有效group ID的副本。<br>
每一个文件都有一个UID和GID，它们的值在<code>st_uid</code>和<code>st_gid</code>中。<br>
当执行一个程序文件时，进程的effective UID通常就是real UID，而effective GID通常就是real GID。但是可以在<code>st_mode</code>中设置一个特殊的flag，意思是当执行此文件时，将执行此文件的进程的effective UID设置为文件所有者的UID。同样，还有另一个特殊的flag，它将执行此文件的进程的effective GID设置为文件组所有者的UID。这两个标志位被记为set-user-ID bit和set-group-ID bit，它们都存放在<code>st_mode</code>中，可以使用<code>S_ISUID</code>和<code>S_ISGID</code>测试。<br>
<strong>运行set UID程序的进程通常会获得额外的权限！！！所以要格外注意。</strong></p>
<h2 id="文件和目录的访问权限">文件和目录的访问权限</h2>
<p><code>st_mode</code>中还包含了文件的访问权限。对于所有文件类型（不单单是文件和目录），都有三种访问权限：</p>
<h3 id="r-读权限">r-读权限</h3>
<p>读权限查询目录名内的数据。</p>
<h3 id="w-写权限">w-写权限</h3>
<ul>
<li>新建文件与目录</li>
<li>删除文件或者目录</li>
<li>重命名以及转移文件或者目录</li>
</ul>
<h3 id="x-可执行权限">x-可执行权限</h3>
<ul>
<li>进入某目录</li>
<li>切换到该目录（cd命令）</li>
<li>对于只具有可执行权限的目录，可以使用<code>cd</code>进入该目录，也可以打开该目录的文件，或者进入下一级目录。但是需要我们知道它们的名字，不能使用<code>ls</code>命令查看，因为没有读目录的权限。。</li>
</ul>
<p>!!!能不能进入某一目录只与该目录的x权限有关，如果不拥有某目录的x权限，即使拥有r权限，那么也无法执行该目录下的任何命令。<br>
但是即使拥有了x权限，但是没有r权限，能进入该目录但是不能打开该目录，因为没有读取的权限，但是可以进入下一级目录或者打开当前目录的文件（因为不能读目录，所以需要知道下一级目录的名字或者当前目录下要打开的文件的名字），路径上的所有目录都必须有可执行权限。。</p>
<h3 id="sticky-bit">sticky bit</h3>
<p><code>S_ISVTX</code>较老版本的UNIX叫做表示stick bit，而新版UNIX叫做saved-text bit，这也是<code>S_ISVTX</code>名字的由来。这一位的作用是，当一个可执行文件的这一位被设置了，当该程序第一次被执行，在它终止时，程序正文部分的一个副本，即机器指令，仍然保存在交换区中，这使得下次执行该程序时能较快的载入内存。因为通常的UNIX文件系统中，文件的数据块都是随机存放的，相对来说，交换区被当做一个连续文件来处理。而现在的UNIX系统都使用了虚拟存储系统和快速文件系统，已经不需要这种技术了。<br>
现在系统扩展了stick bit的使用，SUS允许对目录设置目录的stick bit，如果一个目录设置了stick bit，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或者重命名该目录下的文件：</p>
<ol>
<li>拥有该文件</li>
<li>拥有此目录</li>
<li>是root用户</li>
</ol>
<p>比如/tmp目录，设置了stick bit，任何用户都可以在这个目录下创建文件。任意用户,组和其它对这两个目录的权限都是读写和执行。但是用户不能删除和重命名属于其他人的文件。</p>
<h3 id="十二个访问权限位">十二个访问权限位</h3>
<p>将<code>rwx</code>和user, group以及other进行组合，总共有九个访问权限位，再加上<code>S_ISUID</code>,<code>S_ISGID</code>和<code>S_ISVTX</code>三个特殊位：</p>
<ul>
<li>S_ISUID，set user id,</li>
<li>S_ISGID, set group id,</li>
<li>S_ISVTX, stick bit,</li>
<li>S_IRUSR, user read,</li>
<li>S_IWUSR, user write,</li>
<li>S_IXUSR, user exectu,</li>
<li>S_IRGRP, group read,</li>
<li>S_IWGRP, group write,</li>
<li>S_IXGRP, group exectuble,</li>
<li>S_IROTH, other read,</li>
<li>S_IWOTH, other write,</li>
<li>S_TXOTH, other exectuble,</li>
</ul>
<p>可以对最后九项做一个简洁版的表示：<br>
S_IRWXU = S_IRUSR|R_IWUSR|S_IXUSR<br>
S_IRWXG = S_IRGRP|S_IWGRP|S_IXGRP<br>
S_IRWXO = S_IROTH|S_IWOTH|S_IXOTH</p>
<h3 id="文件和目录的操作规则">文件和目录的操作规则</h3>
<ol>
<li>使用名字打开任意类型的文件时，对于文件名字中包含的每一个目录，包括当前工作目录，都应该具有执行权限。</li>
<li>对于一个文件的读权限决定了我们能够打开先有文件进行读操作。这与<code>open</code>函数的<code>O_RDONLY</code>和<code>O_RDWR</code>有关。</li>
<li>对于一个文件的写权限决定了我们能够打开先有文件进行写操作。这与<code>open</code>函数的<code>O_WRONLY</code>和<code>O_RDWR</code>有关。</li>
<li>如果要在<code>open</code>函数中指定<code>O_TRUNC</code>标志，必须对该文件拥有写权限。</li>
<li>为了在一个目录中创建新文件，必须对这个目录具有写权限和执行权限。</li>
<li>为了删除一个现有文件，必须对包含该文件的目录拥有写权限和执行权限，而不必对文件本身拥有读权限和写权限。</li>
<li>如果使用7个<code>exec</code>函数中的任何一个执行某个文件，都必须拥有该文件的写权限。</li>
</ol>
<h3 id="访问权限检测">访问权限检测</h3>
<p>进程每次打开，创建或者删除一个文件时，内核就会进行文件访问权限测试，这种测试可能涉及到文件的UID，文件的组GID，进程的effective UID和effective GID。文件的UID和文件的GID都是文件的属性，而effective UID和effective GID是进程的属性。<br>
内核进行访问权限测试的步骤如下：</p>
<ol>
<li>如果进程的effective UID是0，结束权限判断，允许各项访问。否则跳转第2步进行判断。</li>
<li>如果进程的effectiev UID等于文件UID，也就是<code>st_uid</code>，结束权限判断，根据访问权限位允许相应操作。否则跳转第3步。</li>
<li>如果进程的effective GID等于文件的GID，结束权限判断，根据访问权限的设置允许相应的操作，否则跳转第4步。</li>
<li>如果不满足前三条，就按照若其他用户的访问权限位判定操作是否合法。</li>
</ol>
<p>总结一下，就是依次判断effective UID是不是等于root，effective UID是不是等于<code>st_uid</code>，或者effective GID是不是等于<code>st_gid</code>，如果都不满足，就按照其它权限判定当前进程对文件的操作是否被允许。按照顺序来判断，满足一个就不用判断后面的了。</p>
<h2 id="函数umask">函数<code>umask</code></h2>
<p>前面介绍了和文件相关的9个访问权限位，使用进程创建文件时，文件的权限可以由<code>umask</code>修改，相当于在原有的mode上减去<code>umask</code>指定的mode。函数<code>umask</code>的原型如下：</p>
<h3 id="函数原型-v2">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</span><br></pre></td></tr></table></figure>
<h3 id="特点">特点</h3>
<ol>
<li>这个函数的作用是去掉<code>cmask</code>中指定的权限，返回之前的mode。</li>
<li><strong>在程序中使用<code>open</code>和<code>creat</code>等创建新文件时，如果想要确保指定的访问限权被激活，必须在进程运行时修改<code>umask</code>的值。否则，<code>umask</code>可能会覆盖掉我们创建文件时指定的mode。</strong></li>
<li>shell中有内置的<code>umask</code>命令，SUS要求shell的<code>umask</code>除了支持八进制的拒绝权限外，还要支持符号格式的指定许可的权限。使用<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask -S</span><br></pre></td></tr></table></figure></li>
</ol>
<p>查看。</p>
<h2 id="新文件和目录的uid和gid">新文件和目录的UID和GID</h2>
<p>创建文件时，新文件的UID被设置为进程的effective UID。关于新文件的GID，可以选择以下两种方式中的一个进行设置：</p>
<ol>
<li>新文件的GID可以是进程的effective GID</li>
<li>新文件的GID可以是它所在目录的GID。</li>
</ol>
<p>不同的UNIX实现有不同的设置，这里拿linux来说，Linux 3.2.0以后，新文件的GID取决于它所在目录的set-group ID bit是否被设置，如果被设置了，新文件的ID就是它所在目录的GID，否则就是进程的effective GID。<br>
新目录的UID和GID和文件一样。</p>
<h2 id="函数mkdir-mkdirat和rmdir">函数<code>mkdir</code>，<code>mkdirat</code>和<code>rmdir</code></h2>
<p>可以使用<code>mkdir和</code>mkdirat<code>创建目录，使用</code>rmdir`删除目录。它们的原型如下：</p>
<h3 id="函数原型-v3">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="性质-v2">性质</h3>
<ol>
<li><code>mkdir</code>创建一个空目录，自动包含<code>.</code>和<code>..</code>项。文件的访问</li>
<li>目录的权限默认权限是进程的<code>umask</code>给出的。对于目录，我们至少需要指定execute位。</li>
<li>目录的UID和GID跟进程<code>create</code>文件时一样。</li>
<li><code>mkdirat</code>和<code>mkdir</code>类似。</li>
<li><code>rmdir</code>删除目录。</li>
</ol>
<h2 id="函数access和faccessat">函数<code>access</code>和<code>faccessat</code></h2>
<p>使用<code>open</code>函数打开文件时，内核使用进程的effective UID和effective GID检测它对文件的访问权限。<br>
<code>acess</code>使用进程的real UID和real GID进行权限访问测试。访问权限测试步骤和之前介绍的四步一样，只不过使用real UID和real GID代替了effective UID和effective GID。</p>
<h3 id="函数原型-v4">函数原型</h3>
<p><code>access</code>和<code>faccessat</code>的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数和区别">参数和区别</h3>
<ol>
<li><code>mode</code>可选参数有，<code>F_OK</code>，<code>R_OK</code>, <code>W_OK</code>,<code>X_OK</code>，其中<code>F_OK</code>表示测试这个文件是否存在。</li>
<li><code>faccessat</code>和<code>access</code>在两种情况下相同，<code>dirfd</code>设置为<code>AT_FDCWD</code>且<code>pathname</code>四相对路径和<code>pathname</code>是绝对路径。否则的话，<code>faccessat</code>就是测试相对于<code>dirfd</code>指向的打开目录下的<code>pathname</code>的权限。</li>
<li>如果<code>flags</code>设置为<code>AT_EACCESS</code>的话，权限访问检测使用的是effective UID和effective GID而不是real UID和real GID。</li>
</ol>
<h2 id="函数chmod-fchmod和fchmodat">函数<code>chmod</code>, <code>fchmod</code>和<code>fchmodat</code></h2>
<p>文件的访问权限可以使用<code>chmod</code>, <code>fchmod</code>和<code>fchmodat</code>进行修改，它们的原型如下：</p>
<h3 id="原型">原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="特点-v2">特点</h3>
<ol>
<li><code>chmod</code>在指定的文件上进行操作</li>
<li><code>fchmod</code>是对已经打开的文件文件描述符进行操作。</li>
<li><code>fchmodat</code>和<code>chmod</code>在两种情况下是相等的，当<code>pathname</code>是绝对路径时，以及<code>dirfd</code>设置为<code>AT_FDCWD</code>且<code>pathname</code>是相对路径的时候。否则，<code>fchmodat</code>操作相对于打开目录的pathname。</li>
<li>当flags设置了<code>AT_SYMLINK_NOFLOLLW</code>时，不会followsymbolic link。</li>
<li>在以下两种情况下，<code>chmod</code>函数自动清除两个权限位：
<ul>
<li>新创建文件的GID可能不是调用进程的effective GID。新文件的GID可能是父目录的GID。如果新文件的GID不等于进程的effective GID，而且进程没有root权限，set-group-id位会被自动关闭。</li>
<li>stick bit的设置</li>
</ul>
</li>
</ol>
<h2 id="函数chown-fchown-chownat和lchown">函数<code>chown</code>, <code>fchown</code>,<code>chownat</code>和<code>lchown</code></h2>
<p>可以使用<code>chown</code>, <code>fchown</code>,<code>chownat</code>和<code>lchown</code>更改文件的UID和GID。它们的原型如下：</p>
<h3 id="函数原型-v5">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="特点-v3">特点</h3>
<ol>
<li>当文件不是symbolic link时，所有的函数操作类似。</li>
<li>当文件是symbolic link时，<code>lchown</code>和设置了<code>AT_SYMLINK_NOFOLLOW</code>标志的<code>fchownat</code>都修改的是symbolic link本身，而不是它链接的对象。</li>
<li><code>fchown</code>操作的是<code>fd</code>指向的已经打开的文件，因为它在一个已经打开的文件上操作，所以它不能修改symbolic link本身。</li>
<li><code>fchownat</code>和<code>fchown</code>或者<code>lchown</code>在下面两种情况下是等价的：当pathname是决定路径或者<code>dirfd</code>设置为<code>AT_FDCWD</code>时且pathname是相对路径时。在这两种情况下，如果<code>flags</code>设置了<code>AT_SYMLINK_NOFOLLOW</code>标志，<code>fchownat</code>和<code>lchown</code>一样，否则<code>fchownat</code>和<code>fchown</code>一样。如果不是这两种情况，<code>fchowat</code>是操作相对于打开目录的pathname。</li>
<li>根据<code>_POSIX_CHOWN_RESTRICTED</code>常量的值，可以查询是否只有超级用户才能更改文件的所有者，如果这个常量对指定的文件有效，那么
<ul>
<li>只有root进程才能更新该文件的UID，普通用户不能修改其他用户文件的UID</li>
<li>如果进程拥有此文件(进程的effective UID等于文件的UID)， 可以更改这些文件的GID，但是只能更改到进程的effective GID或者继承的附属组ID之一。</li>
</ul>
</li>
<li>如果这些函数由非root进程调用，在成功返回时，set UID和set GID位都会被清楚。</li>
</ol>
<h2 id="函数rename和renameat">函数<code>rename</code>和<code>renameat</code></h2>
<p>可以使用函数<code>rename</code>和<code>rename</code>对文件或者目录进行重命名。它们的原型如下：</p>
<h3 id="函数原型-v6">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="性质-v3">性质</h3>
<ol>
<li>ISO C对文件定义了<code>reanme</code>，但是ISO C没有对目录定义该函数。POSIX.1扩展了定义，使得它<code>rename</code>可以处理目录和symbolic link。</li>
<li>如果<code>oldpath</code>指向普通文件，那么为文件进行重命名。如果<code>newname</code>存在，它不能是一个目录。如果它不是目录，先将该目录项删除，然后将<code>oldname</code>重命名为<code>newname</code>。进程需要对<code>oldpath</code>和<code>newpath</code>的父目录都拥有写和执行权限，因为<code>rename</code>会修改这两个目录。</li>
<li>如果<code>oldpath</code>指向目录，为目录重命名。如果<code>newname</code>已经存在，那么它必须是一个目录，而且应该是空目录。如果<code>newname</code>目录存在且为空，先将它删除，然后将<code>oldname</code>重命名为<code>newname</code>。且<code>newname</code>不能包含<code>oldname</code>，比如不能将<code>/usr/foo</code>重命名为<code>/usr/foo/testdir</code>，因为不能删除<code>/usr/foo</code>目录。</li>
<li>如果<code>oldpath</code>指向symbolic link，<code>rename</code>不follow symbolic link，直接处理symbolic link本身。</li>
<li>不能对<code>.</code>和<code>..</code>进行重命名。或者说<code>.</code>和<code>..</code>不能出现在<code>oldpath</code>和<code>newpath</code>上。</li>
<li>当<code>oldpath</code>和<code>newpath</code>指向同一个文件，函数不做任何操作直接返回。</li>
<li><code>renameat</code>和<code>rename</code>类似。</li>
</ol>
<h2 id="文件长度">文件长度</h2>
<p><code>struct stat</code>中的<code>st_size</code>以字节为单位表示文件的长度。这个字段只对普通文件，目录文件和symbolic link有意义。<br>
对于普通文件，它的长度可以是0，在开始读这种文件时，得到EOF标志。<br>
对于目录，文件长度通常是一个数的整数倍。<br>
对于symbolic link，文件长度是链接指向的文件名的实际字节数，不包含null字节。<br>
对于现在的大多数UNIX系统，提供了<code>st_blksize</code>和<code>st_blocks</code>字段。<code>st_blksize</code>表示对文件I/O适合的块长度，第二个是所分配的固定大小的block数量。</p>
<h3 id="文件中的hole">文件中的hole</h3>
<ol>
<li>普通文件可以有hole，hole是当前文件偏移量超过文件尾端，然后进行写入造成的。</li>
<li>对于同样长度的有空洞和没有空洞的文件来说，它们所占用的blocks块数是不同的。这里说的同样长度指的是字节数，使用<code>ls -l</code>列出来的长度，那些空洞不占用磁盘上的存储区。</li>
<li>使用<code>cat</code>进行复制时，会将空洞使用0字节填满。</li>
<li>使用<code>du -s file.txt</code>可以查看文件所占用的blocks数量，这些blocks中还有一些用来存放指向实际数据块的指针。</li>
</ol>
<h3 id="文件截断">文件截断</h3>
<p>可以使用<code>truncate</code>和<code>ftruncate</code>截断文件，函数原型是：</p>
<h4 id="函数原型-v7">函数原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="特点-v4">特点</h4>
<ol>
<li>当<code>length</code>长度小于原来文件的长度时，超过<code>length</code>的进行截断。</li>
<li>当<code>length</code>长度大于原来文件的长度时，原来的文件长度到<code>length</code>之间的数据被读作0。</li>
<li><code>ftruncate</code>操作的是文件描述符，<code>truncate</code>操作的是文件。</li>
</ol>
<h2 id="文件的时间">文件的时间</h2>
<h3 id="文件的三个时间">文件的三个时间</h3>
<p>每一个文件守护三个时间：</p>
<ol>
<li><code>st_atim</code>，记录文件数据的最后访问时间。使用<code>ls -u</code>查看。</li>
<li><code>st_mtim</code>，记录文件数据的最后修改时间。默认的<code>ls</code>显示的就是文件的最后修改时间。</li>
<li><code>st_ctim</code>，记录i-node状态的最后更改时间。使用<code>ls -c</code>查看。常见的许多操作都会影响i-node，主要就是<code>i-node</code>中存放的那些信息，更改文件权限，更改文件的<code>st_uid</code>和<code>st_gid</code>，文件的链接数等等。</li>
</ol>
<p>这个让我想不明白的是为什么<code>link</code>,<code>unlink</code>,<code>creat</code>等会影响所使用文件的父目录的inode节点。</p>
<h3 id="函数futimens-utimensat和utimes原型">函数<code>futimens</code>, <code>utimensat</code>和<code>utimes</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> struct timeval times[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="函数futimens-utimensat和utimes性质">函数<code>futimens</code>, <code>utimensat</code>和<code>utimes</code>性质</h3>
<ol>
<li>
<p>如果<code>times</code>为空，访问时间和修改时间都设为当前时间</p>
</li>
<li>
<p>如果<code>times</code>指向两个<code>timespec</code>结构的数组，任一元素的<code>tv_nsec</code>字段的值为<code>UTIME_NOW</code>，相应的时间戳设置为当前时间，忽略相应的<code>tv_sec</code>字段。</p>
</li>
<li>
<p>如果<code>times</code>指向两个<code>timespec</code>结构的数组，任一元素的<code>tv_nsec</code>字段的值为<code>UTIME_OMIT</code>，相应的时间戳保持不变，忽略相应的<code>tv_sec</code>字段。</p>
</li>
<li>
<p>如果<code>times</code>指向两个<code>timespec</code>结构的数组，<code>tv_nsec</code>字段的值既不是<code>UTIME_NOW</code>也不是<code>UTIME_OMIT</code>，相应的时间戳设置为相应的<code>tv_sec</code>和<code>tv_nsec</code>字段。</p>
</li>
<li>
<p><code>futimens</code>需要打开文件更改它的时间</p>
</li>
<li>
<p><code>utimensat</code>可以使用文件名更改时间。</p>
</li>
<li>
<p><code>utimes</code>对路径进行操作。</p>
</li>
<li>
<p><code>struct timespec</code>结构体是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;</span><br><span class="line">    <span class="keyword">long</span> tv_nsec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p><code>struct timeval</code> 结构体是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;  <span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;   <span class="comment">//微妙</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<h2 id="读目录">读目录</h2>
<p>目录可以被任何具有读权限的用户读取，但是为了保护文件系统，只有kernel可以写目录。目录的<code>w</code>权限位和<code>x</code>权限位表示的是用户是否可以在目录中创建或者删除新文件，并不是说用户可以写目录本身。</p>
<p>给出<code>opendir</code>, <code>fopendir</code>,</p>
<h3 id="函数原型-v8">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dirp, <span class="keyword">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="函数性质">函数性质</h3>
<ol>
<li><code>opendir</code>将文件转换成目录处理函数需要的<code>DIR</code>结构，而<code>fdopendir</code>将文件描述符转换成目录处理函数需要的<code>DIR</code>结构。这里的<code>DIR</code>到底是什么，没有告诉，so上有一个回答说它是不透明数据类型，只需要使用它，不需要知道它的定义[3]。</li>
<li><code>telldir</code>和<code>seekdir</code>不是POSIX.1的组成部分，但是它是SUS的XSI扩展。所有UNIX系统都会提供这两个实现。</li>
<li><code>struct dirent</code>结构体定义在<code>&lt;dirent.h&gt;</code>头文件中，它与实现相关，但是必须包含以下两个成员：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ino_d d_ino;</span><br><span class="line"><span class="keyword">char</span> d_name[];</span><br></pre></td></tr></table></figure></li>
</ol>
<p>POSIX.1并没有定义<code>d_ino</code>，而POSIX.1的XSI扩展定义了<code>d_ino</code>。</p>
<ol start="4">
<li><code>DIR</code>是一个内部结构，这几个函数使用这个内部结构保存当前正在被读的目录的有关信息。<code>opendir</code>和<code>fdopendir</code>返回<code>DIR</code>，而其他函数把<code>DIR</code>当做参数。<br>
使用<code>opendir</code>打开文件时，<code>readdir</code>返回的是目录项中的第一项。<br>
使用<code>fdopndir</code>打开文件时，<code>readdir</code>返回的第一项取决于传递给<code>fopendir</code>的文件描述符的当前文件偏移量。</li>
</ol>
<h2 id="函数chdir-fchdir和getcwd">函数<code>chdir</code>, <code>fchdir</code>和<code>getcwd</code></h2>
<p>每一个进程都有一个当前工作目录，**当前工作目录是进程的一个属性，**这个目录是搜索所有相对路径名的起点，不以&quot;/&quot;开始的路径名都是相对路径名。可以使用<code>chdir</code>后者<code>fchdir</code>改变当前进程的工作目录。它们的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>chdir</code>的参数是<code>path</code>，而<code>fchidir</code>的参数是文件描述符。</p>
<h3 id="chdir只会改变当前进程的work-dir"><code>chdir</code>只会改变当前进程的work dir</h3>
<p>**需要注意的一点是，<code>chdir</code>和<code>fchdir</code>只改变调用这个函数本身的进程，并不影响其他进程。**比如在shell中运行一个程序，在这个程序中更改了进程的当前工作目录，结束这个程序的执行时，shell的当前工作目录并不会改变，因为shell和我们刚才执行的程序属于两个不同的进程。因此，如果要改变shell进程自己的工作目录，应该使用shell直接调用<code>chdir</code>函数，所以<code>cd</code>命令内建在shell中。<br>
<code>getcwd</code>是获得进程当前工作的绝对路径名。内核并不保存目录的完整路径名（linux除外），为了获得进程当前工作的绝对路径名。<code>getcwd</code>需要从当前工作目录开始，找到它的上一级目录，读取目录项，找到和工作目录i节点编号相同的目录项，得到对应的文件名。就这样一层一层的向上找，这就找到了绝对路径名。<code>getcwd</code>会followsymbolic link，但是不会知道它是由哪里链接到这里的。</p>
<h3 id="和进程相关的目录getcwd">和进程相关的目录<code>getcwd</code></h3>
<p>当一个应用程序需要在经过一些列目录操作之后返回它刚开始的工作目录时。可以先使用<code>getcwd</code>获得最开始的工作目录，保存起来，最后再使用<code>chdir</code>进行恢复。<br>
<code>fchdir</code>可以有更简单的操作，在刚开始时，保存目录的文件描述符。最后使用<code>fchdir</code>直接打开这个文件描述符。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://unix.stackexchange.com/questions/21251/execute-vs-read-bit-how-do-directory-permissions-in-linux-work" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/21251/execute-vs-read-bit-how-do-directory-permissions-in-linux-work</a><br>
3.<a href="https://superuser.com/questions/168578/why-must-a-folder-be-executable/168583" target="_blank" rel="noopener">https://superuser.com/questions/168578/why-must-a-folder-be-executable/168583</a><br>
4.<a href="https://stackoverflow.com/questions/22122405/where-is-dir-defined" target="_blank" rel="noopener">https://stackoverflow.com/questions/22122405/where-is-dir-defined</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/20/data-structure-bineary-search-trees-vs-binary-heaps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/20/data-structure-bineary-search-trees-vs-binary-heaps/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">data structure bineary search trees vs binary heaps</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-20 09:37:58" itemprop="dateCreated datePublished" datetime="2019-11-20T09:37:58+08:00">2019-11-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:13:35" itemprop="dateModified" datetime="2019-12-17T16:13:35+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/6147242/heap-vs-binary-search-tree-bst" target="_blank" rel="noopener">https://stackoverflow.com/questions/6147242/heap-vs-binary-search-tree-bst</a><br>
2.<a href="https://cs.stackexchange.com/questions/27860/whats-the-difference-between-a-binary-search-tree-and-a-binary-heap" target="_blank" rel="noopener">https://cs.stackexchange.com/questions/27860/whats-the-difference-between-a-binary-search-tree-and-a-binary-heap</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/18/UNIX-file-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/18/UNIX-file-IO/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX file I/O</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 19:19:20" itemprop="dateCreated datePublished" datetime="2019-11-18T19:19:20+08:00">2019-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-24 10:10:01" itemprop="dateModified" datetime="2019-11-24T10:10:01+08:00">2019-11-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="注意事项">注意事项</h2>
<ol>
<li><code>creat</code>以只写方式打开文件，不能进行读操作。</li>
<li>为什么有了<code>open</code>要有<code>creat</code>，早期的<code>open</code>只支持0,1,2三个flag，不能打开不存在的文件，需要有单独的系统调用创建文件。而有了新的<code>open</code>以后就不需要<code>creat</code>了。</li>
<li><code>open</code>和<code>dup</code>返回的文件描述符一定是最小的未使用的文件描述符。</li>
<li>以<code>O_APPEND</code>打开的文件，如果进行<code>write</code>的话，即使使用<code>lseek</code>定位到非文件结尾处，最后也是在文件结尾处进行写。因为使用<code>O_APPEND</code>的<code>write</code>是由两个系统调用函数<code>lseek</code>和“普通的”<code>write</code>构成的一个操作。而<code>read</code>操作可以使用<code>lseek</code>进行定位。</li>
<li>所有的磁盘I/O都要经过内核的block buffers块缓存区，也称为内核的(buffer cache)缓冲区高速缓存。有一个例外就是对原始磁盘设备的I/O，先不考虑这种情况。<code>read</code>和<code>write</code>的数据都要被内核进行缓冲，术语unbuffered I/O指的是在用户的进程中不会对这两个函数进行自动缓冲，每次<code>read</code>和<code>write</code>都会进行一次系统调用。</li>
</ol>
<h2 id="文件i-o">文件I/O</h2>
<p>UNIX系统中的大多数文件I/O只用到了5个函数：<code>open</code>,<code>read</code>,<code>write</code>, <code>lseek</code>和<code>close</code>。不同的缓冲长度对<code>read</code>和<code>write</code>的速度影响。<br>
本章介绍的函数通常被称为不带缓冲的I/O，不带缓冲的I/O指的是每个<code>read</code>和<code>write</code>都调用内核中的一个系统调用，它们不是ISO C的组成部分，但是，它们都是POSIX.1和SUS的组成部分。<br>
只要涉及在多个进程之间共享资源，原子操作的概念就非常重要。本章还进行一步讨论在多个进程之间如何共享文件，以及所涉及的内核有关数据结构。相应的函数有：<code>dup</code>, <code>fcntl</code>,<code>sync</code>, <code>fsync</code>和<code>ioctl</code>等。</p>
<h2 id="文件描述符">文件描述符</h2>
<p>对于内核而言，所有打开的文件都是通过文件描述符引用。文件描述符是一个非负整数。当打开或者创建一个新文件时，内核向进程返回一个文件描述符。当读，写一个文件时，使用<code>open</code>或者<code>creat</code>返回的文件描述符标识该文件，将其作为参数传递给<code>read</code>或者<code>write</code>。<br>
UNIX系统shell把文件描述符0和进程的标准输入关联，文件描述符1和标准输出关联，文件描述符2和标准错误关联。为了提高系统的可读性，通常把它们换成符号常量<code>STDIN_FILENO</code>,<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>，它们都在头文件<code>&lt;unistd.h&gt;</code>中定义。<br>
文件描述符的变化范围是0到<code>OPEN_MAX-1</code>，早起的UNIX系统实现采用的上限值是19，现在的很多系统将它增加到63。（对于Linux, FreeBSD等的很多版本，文件描述符的变化范围几乎是无限的，只受到硬件资源的约束）</p>
<h2 id="open-openat和creat-close"><code>open</code>,<code>openat</code>和<code>creat</code>, <code>close</code></h2>
<p>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>pathname</code>是路径名，可以是相对路径也可以是绝对路径，<code>flags</code>的选项有很多，它们定义在<code>&lt;fcntl.h&gt;</code>头文件中。flag参数必须在<code>O_RDONLY</code>,<code>O_WRONLY</code>和<code>O_RDWR</code>之中选且只能选一个。然后还有很多其他的可选flag，常见的有：<code>O_APPEND</code>，<code>O_CREAT</code>，<code>O_EXCL</code>, <code>O_DIRECTORY</code>等，使用<code>man 2 open</code>就可以查看。</p>
<h3 id="openat-vs-open"><code>openat</code> vs <code>open</code></h3>
<p><code>open</code>和<code>openat</code>返回的一定是最小的没有使用的文件描述符。可以利用这一点可以在标准输入，标准输出，或者标准错误上打开新的文件。一个应用程序可以先关闭标准输出，然后打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符1上打开。<br>
<code>dirfd</code>参数是<code>open</code>和<code>openat</code>的区别，它们之间的关系有以下三种：</p>
<ol>
<li><code>pathname</code>指定的是绝对路径名，<code>dirfd</code>参数被忽略，<code>open</code>和<code>openat</code>一样。</li>
<li><code>pathname</code>指定的是相对路径名，<code>dirfd</code>制定了相对路径名在文件系统中的开始地址，<code>dirfd</code>参数通过打开相对路径名的目录来获取。</li>
<li><code>pathname</code>指定了相对路径名，<code>dirfd</code>的参数是特殊值<code>AT_FDCWD</code>，这种情况下，路径名是在当前工作目录中获取，<code>openat</code>和<code>open</code>在操作上类似。</li>
</ol>
<h3 id="openat作用"><code>openat</code>作用</h3>
<p>为什么增加<code>openat</code>函数，它的目的是解决两个问题：</p>
<ol>
<li>让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。同一进程中的所有线程共享相同的当前工作目录。</li>
<li>避免time-of-check-to-time-of-use错误。它的基本思想是，如果有两个基于文件的系统调用，第二个调用的结果依赖于第一个调用的结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间，文件可能改变了，这就造成了第一个调用的结果不再有效，使得程序的最终结果是错误的。</li>
</ol>
<h3 id="文件名和路径名过长">文件名和路径名过长</h3>
<p>当文件名和路径名过长时，是截断为系统允许的最长量还是返回出错信息？这个是由系统的历史形成的。通常BSD和Linux总是会返回出错，而System V和Solaris等不一定。<br>
具体的可以根据POSIX.1定义的常量<code>_POSIX_NO_TRUC</code>决定是截断还是出错。根据文件系统的类型，这个值可以变换。可以使用<code>fpathconf</code>或者<code>pathconf</code>查询目录具体支持哪种行为。<br>
如果<code>_POSIX_NO_TRUC</code>有效，当路径名超过<code>PATH_MAX</code>或者路径名中的任一文件名超过<code>NAME_MAX</code>时，返回出错，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。</p>
<h3 id="create和open"><code>create</code>和<code>open</code></h3>
<p><code>create</code>其实相当于指定了<code>open</code>的flags为<code>O_WRONLY|O_CREAT|O_TRUNC</code>。<br>
为什么有了<code>open</code>还要有<code>creat</code>，在早期的UNIX版本中，<code>flags</code>只能为0,1或者2。无法打开一个不存在的文件。因此需要另一个系统调用<code>creat</code>创建新文件。现在的<code>open</code>系统调用提供了<code>O_CREAT</code>和<code>O_TRUNC</code>选项，也就不需要<code>creat</code>了。</p>
<p><code>creat</code>的不足：<code>creat</code>以<strong>只写方式</strong>打开所创建的文件，即创建新文件之后，只能对新文件进行写操作，不能进行读操作。如果要创建一个临时文件，先写文件，然后再读文件。在<code>open</code>的老版本时，即不能打开不存在的文件时，需要先使用<code>creat</code>创建新文件，然后关闭该文件，然后使用<code>open</code>读文件。现在的话，可以使用以下方式实现创建新文件并进行读写：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_RDWR|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<h3 id="close函数"><code>close</code>函数</h3>
<p>调用<code>close</code>关闭一个已经打开的文件。函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建文件">创建文件</h3>
<ol>
<li>
<p>创建一个只写文件（如果文件存在，将文件清零）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">creat(filename, mode);</span><br><span class="line">open(filename, O_WRONLY|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>创建一个读写文件（如果文件存在，将文件清零）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_RDWR|O_CREAT|O_TRUNC);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>检测并创建一个只写文件（ 如果文件存在，错处，返回-1）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_WRONLY|O_CREAT|O_EXCL, mode);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>检测并创建一个读写文件（ 如果文件存在，错处，返回-1）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_RDWR|O_CREAT|O_EXCL, mode);</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<h2 id="lseek-read-write"><code>lseek</code>, <code>read</code>, <code>write</code></h2>
<p>它们的原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<h3 id="当前文件偏移量">当前文件偏移量</h3>
<ol>
<li>每一个打开文件都有一个和它相关联的当前文件偏移量(current file offset)。它通常是一个非负整数，用来度量从文件开始处的字节数。</li>
<li>通常情况下，读写操作都是从current file offset开始的，并且使偏移量增加读写的字节数。</li>
<li>除了指定<code>O_APPEND</code>选项外，打开一个文件时，默认的current file offset都是0。</li>
<li><code>whence</code>有三个取值，<code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code>。<code>lseek</code>成功执行，返回的offset等于<code>whence+offset</code>，对于<code>SEEK_CUR</code>和<code>SEEK_END</code>来说，参数<code>offset</code>可正可负，只要保证返回的current file offset非负即可。</li>
<li><code>lseek</code>中的<code>l</code>表示<code>long</code>。</li>
<li>current file offset可以大于文件长度，这种情况会在文件中构成一个空洞。空洞不要求占据磁盘上的存储区。</li>
</ol>
<h3 id="read"><code>read</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p><code>read</code>函数从文件描述符标示的文件中读取至多<code>count</code>个字节到<code>buf</code>指定的位置。如果操作成功的话，返回读到的字节数，如果已经到了文件结尾，返回0。出错的话，返回-1，设置errno。<br>
在以下几种情况下，读到的字节数可能少于<code>count</code>：</p>
<ol>
<li>读普通文件时，在读满<code>count</code>个之前就已经到了文件尾端。</li>
<li>某个信号造成中断时，而已经读取了部分数据时。</li>
<li>从终端设备读时，通常一次最多读一行。</li>
<li>从网络读时，网络中的缓冲机制。</li>
<li>从管道或者FIFO读取时，管道包含的字节数少于<code>count</code>。</li>
<li>从面向记录的设备读时，一次最多返回一个记录。</li>
<li>第二个参数<code>void*</code>表示通用指针。</li>
<li>返回值<code>ssize_t</code>是有符号类型，因为它需要返回正整数字节，0和-1。</li>
<li>第三个参数<code>size_t</code>是一个无符号类型。</li>
</ol>
<h3 id="write"><code>write</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p>它的返回值通常和<code>count</code>一样，否则就是出错了。出错的常量原因有：</p>
<ol>
<li>磁盘满了，</li>
<li>超过了一个给定进程的文件长度限制。</li>
<li>如果<code>lseek</code>返回的当前文件偏移量不在文件结尾，<code>write</code>会覆盖掉相应位置的数据。</li>
</ol>
<p>对于普通文件，写操作从文件的当前偏移量开始，如果打开文件时指定了<code>O_APPEND</code>选项，那么文件偏移量设置在文件结尾处。在一次写成功之后，文件偏移量增加实际写的字节数。</p>
<h3 id="创建含有空洞的文件">创建含有空洞的文件</h3>
<p>当<code>lseek</code>使得当前文件偏移量超过了现有文件长度，再继续进行<code>write</code>之后，当前文件偏移量和文件长度之间的内容就是空洞，它一般不占用磁盘空间，但是使用<code>ls</code>时，会把它计算成字节长度。</p>
<h2 id="i-o的效率">I/O的效率</h2>
<p>进程终止时，UNIX系统内核会关闭所有打开的文件描述符，但是并不会关闭标准输入和输出。<br>
在选取<code>read</code>和<code>write</code>的buffer大小时，也有一定技巧。大多数文件系统都使用了预读(read ahead)技术。当进行顺序读取时，系统试图读入比应用所要求的更多数据，并且假设应用很快就会读这些数据。<br>
在使用<code>ext4</code>文件系统时，它的磁盘块长度是4096，所以当BUFFER大于等于4096时，读写时间几乎不变。</p>
<h2 id="文件共享">文件共享</h2>
<h3 id="i-o数据结构">I/O数据结构</h3>
<p>UNIX支持在不同进程之间共享打开文件。这需要使用到内核用于I/O的数据结构。内核使用三种数据结构表示打开文件：进程表记录项，文件表项和节点表项。</p>
<ol>
<li>进程表记录项。每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，每隔描述符占用一项，其中内容有：文件描述符标志和指向文件表项的指针。</li>
<li>文件表项。内核为所有打开文件维持一张文件表。每个表项包含：文件状态标志，当前文件偏移量和指向该文件节点表项的指针</li>
<li>节点表项。每个打开设备都有一个节点结构。包含文件的所有者，文件长度，指向文件实际数据块在磁盘上所在的指针等。</li>
</ol>
<p>如果两个进程打开了同一个文件，每个进程都会获得各自相应文件的一个文件表项，这两个文件表项中的节点表项指针指向同一个节点表项。也有可能多个进程的文件描述符指向同一个文件表项。<br>
自己的总结，每一个文件都有一个节点表项，记录文件长度和数据存储地址，而文件表项记录的是在节点表项的哪个位置进行什么操作，进程表记录项记录了每个进程打开了几个文件，每个文件的文件表项在哪里。</p>
<h3 id="write和lseek对当前文件偏移量的影响"><code>write</code>和<code>lseek</code>对当前文件偏移量的影响</h3>
<ol>
<li><code>write</code>在写入完成后，在文件表项的当前文件偏移量上加上写入的字节数，如果当前文件偏移量超过了当前文件长度，更新节点表项中的文件长度，相当于文件长度增加了。</li>
<li><code>lseek</code>只修改文件表项中的当前文件偏移量，不进行任何I/O操作。</li>
<li><code>lseel</code>定位到文件尾端的时候，文件表项中当前文件偏移量被设置为节点表项中的当前文件长度。</li>
<li>使用<code>O_APPEND</code>打开文件的时候，文件表项中的文件状态标志也会被修改，对于使用<code>O_APPEND</code>操作打开的文件，进行<code>write</code>操作相当于先将当前文件偏移量设置为节点表项中的文件长度，然后再<code>write</code>，即使先使用<code>lseek</code>将当前文件偏移量设置为<code>SEEK_SET</code>也不行，也是进行追加。所以在每次append之前不用先进行<code>lseek</code>，<code>lseek</code>了也白做。但是<code>read</code>可以使用<code>lseek</code>正常进行。</li>
</ol>
<h2 id="原子操作">原子操作</h2>
<p>如果一个操作是原子操作，那么这个操作的所有步骤要么不执行，要不全部执行。</p>
<h3 id="追加文件">追加文件</h3>
<p>指定<code>open</code>的<code>O_APPEND</code>选项实现追加操作，<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileno=open(filename, O_RDWR|O_APPEND);</span><br><span class="line">write(file, buf, BUFSIZE);</span><br></pre></td></tr></table></figure></p>
<p>追加文件是一个原子操作，如果不是原子操作的话，就相当于：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fileno = open(filename, O_RDWR);</span><br><span class="line">lseek(fileno, <span class="number">0</span>, SEEK_END);</span><br><span class="line">write(fileno, buf, BUFSIZE);</span><br></pre></td></tr></table></figure></p>
<p>如果是单进程，上面两段代码是等价的，但是如果是多进程的话，下面代码就可能会出错。进程A lseek，进程B lseek，进程A write，进程B write。进程B的操作会覆盖进程A的操作。<br>
所以这也就解释了使用选项<code>O_APPEND</code>后的操作，因为这个append的<code>write</code>是由两个系统调用组成的原子操作，先<code>lseek</code>，再普通的<code>write</code>。所以在调用<code>write</code>之前不用<code>lseek</code>，就算你<code>lseek</code>了也是白<code>lseek</code>。</p>
<h3 id="读写原子操作">读写原子操作</h3>
<p>读写的原子操作原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>pread</code>相当于调用<code>lseek</code>和<code>read</code>的原子操作，但是<code>pread</code>不改变当前文件偏移量。<br>
调用<code>write</code>相当于调用<code>lseek</code>和<code>write</code>的原子操作，但是<code>pwrite</code>不改变当前文件偏移量。</p>
<h3 id="创建文件原子操作">创建文件原子操作</h3>
<p>检查文件是否存在和创建文件是一个原子操作。如果这个操作不是原子操作，比如说是由<code>open</code>和<code>creat</code>两个函数调用组成的一个操作，它们不是一个原子操作。当前进程确定一个文件不存在，决定创建该文件。在<code>open</code>和<code>creat</code>调用之间，另一个进程创建了这个文件，并写入了数据。当前进程会再次创建这个文件，覆盖掉另一个进程写入的数据。</p>
<h2 id="dup和dup2复制文件描述符"><code>dup</code>和<code>dup2</code>复制文件描述符</h2>
<p>UNIX系统提供了两个原子操作<code>dup</code>和<code>dup2</code>对一个指定的文件描述符进行复制。如果得到的新文件描述符和fd不同，那么这两个文件描述符共享同一个文件表项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dup返回的文件描述符一定是当前可用文件描述符中的最小值。和open一个文件类似。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过fd2指定返回的新的文件描述符。</span></span><br><span class="line"><span class="comment">// 如果fd2和fd相等，返回fd2</span></span><br><span class="line"><span class="comment">// 如果fd2和fd不等，关闭fd2，然后返回fd2。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(inf fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>非原子操作的文件描述符复制可以通过<code>fcntl</code>实现。</p>
<h2 id="sync-fsync和fdatasync"><code>sync</code>,<code>fsync</code>和<code>fdatasync</code></h2>
<p>UNIX系统在内核中设置了缓冲区高速缓存或者页高速缓存，大多数磁盘的I/O都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些写入磁盘，这方方式叫做<strong>延迟写</strong>。<br>
等到内核需要使用缓冲区存放其他磁盘块数据时，它会把所有延迟写数据写入磁盘。为了保证磁盘上实际文件系统和缓冲区中内容的一致性，UNIX提供了三个函数，它们的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.将所有修改过的块缓冲区排入队列，然后就返回，并不等待实际写磁盘操作结束。</span></span><br><span class="line"><span class="comment">// 通常情况下，update系统守护进程一般每隔30秒调用一次`sync`函数，这就保证了定期将内核块缓冲区的内容写入磁盘。命令sync(1)也会调用`sync`函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.只对文件描述符`fd`指定的一个文件起作用，等到写磁盘操作结束才返回。更新文件的数据和属性。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.只对文件描述符`fd`指定的一个文件起作用，等到写磁盘操作结束才返回。只更新文件的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="fcntl"><code>fcntl</code></h2>
<p>fcntl是文件控制函数，它的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>fcntl有很多种功能，这一节先介绍以下五种：</p>
<ol>
<li>复制一个已有的描述符，设置<code>cmd</code>为<code>F_DUPFD</code>或者<code>F_DUPFD_CLOEXEC</code>。</li>
<li>获取和设置文件描述符标志，设置<code>cmd</code>为<code>F_GETFD</code>或者<code>F_SETFD</code>。当前只有一个文件描述符标志，就是<code>FD_CLOEXEC</code>。</li>
<li>获取和设置文件状态标志，设置<code>cmd</code>为<code>F_GETFL</code>或者<code>F_SETFL</code>。<br>
获取文件状态标志时，介绍<code>open</code>时给出了许多文件状态标志。对于五个互斥的权限，需使用<code>O_ACCMODE</code>取得访问方式位，然后与相应的权限比对。对于其他的权限，将返回值和相应的标志进行与操作，判断是否设置了相应位。<br>
设置文件状态标志位时，可以更改的几个权限有，<code>O_APPEND</code>, <code>O_NONBLOCK</code>, <code>O_SYNC</code>, <code>O_DSYNC</code>, <code>O_RSYNC</code>, <code>O_FSYNC</code>, <code>O_ASYNC</code>。</li>
<li>获取和设置异步I/O所有权，设置<code>cmd</code>为<code>F_GETOWN</code>或者<code>F_SETOWN</code>。</li>
<li>获取和设置记录锁，设置<code>cmd</code>为<code>F_GETLK</code>，或者<code>F_SETLK</code>或者<code>F_SETLKW</code>。</li>
</ol>
<p>在修改文件描述符标志或者文件状态标志时，必须要先获得现在的标志值，然后对它进行修改，获得新的标志值，然后进行设置。不能单单设置一个标志值，否则会关闭以前设置的标志位。</p>
<h2 id="ioctl"><code>ioctl</code></h2>
<p>这个有点看不懂。</p>
<h2 id="dev-fd"><code>/dev/fd</code></h2>
<p>UNIX提供了<code>/dev/fd</code>目录，其中包含了名为0, 1, 2的文件。打开<code>/dev/fd/0</code>,<code>/dev/fd/1</code>, <code>/dev/fd/2</code>相当于复制描述符n。即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/df/0"</span>, mode);</span><br><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>上述两行代码是相等的。文件描述符0和fd共享同一个文件表项。在Linux中，文件描述符被映射成指向底层物理文件的符号链接。比如打开<code>/dev/fd/0</code>时，实际上打开的是与标准输入关联的文件。返回的新文件描述符的mode和<code>/dev/fd</code>文件描述符的mode并不相关。所以，即使我们使用<code>O_RDWR</code> mode打开<code>/dev/fd/0</code>，也不能对<code>fd</code>进行写操作。<br>
Linux下提供了<code>/dev/stdin</code>，<code>/dev/stdout</code>, <code>/dev/stderr</code>，它们和<code>/dev/fd/0</code>等都是一样的。在shell中，可以使用dev/fd作为参数，把标准输入和输出当做一个文件，可以像处理其他文件一样进行操作。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">329</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
