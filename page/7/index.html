<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/7/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/7/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/12/04/UNIX-signal/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/12/04/UNIX-signal/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX signal</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-12-04 15:22:47" itemprop="dateCreated datePublished" datetime="2019-12-04T15:22:47+08:00">2019-12-04</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-25 00:20:49" itemprop="dateModified" datetime="2020-02-25T00:20:49+08:00">2020-02-25</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>Signals是软件终端。它提供了一种处理异步事件的方法。</p>
<h2 id="什么是signal">什么是signal</h2>
<p>每一个signal都有一个名字，它们以三个字符<code>SIG</code>开头。例如：</p>
<ul>
<li><code>SIGABRT</code>是abort signal，调用abort函数时产生这种signal</li>
<li><code>SIGALRM</code>是闹钟signal，由alarm函数设置的定时器超时后产生这种signal</li>
</ul>
<p>在头文件<code>&lt;singal.h&gt;</code>中，signal name都被定义成正整数常量。如果内核包含对用户级应用程序有意义的文件，被认为是一种不好的形式，如果应用程序和内核需要使用同一个定义，那么就将有关信息放在内核头文件中，然后用户级头文件再包含该内核头文件。比如Linux 3.2.0将signal定义在<code>&lt;bits/signum.h&gt;</code>中。</p>
<p>很多条件可以产生signal：</p>
<ul>
<li>用户按一些键</li>
<li>硬件异常</li>
<li>调用<code>kill(2)</code>函数</li>
<li>调用<code>kill(1)</code>命令，它是<code>kill(2)</code>的接口</li>
<li>检测到某种软件条件已经发生</li>
</ul>
<p>常见的signal可以分为以下几类：</p>
<ul>
<li>程序出错signals，用于report程序错误</li>
<li>Termination singals，用于中断或者终止程序</li>
<li>Alarm signals,</li>
<li>异步I/O signals</li>
<li>Joc control signals</li>
<li>操作错误signal</li>
<li>miscellaneous signals</li>
<li>signal messages</li>
</ul>
<p>关于具体的每个signal的介绍，可以看书，看文档<code>man 7 signal</code>，或者查看另一篇文章<a href>UNIX signals</a>。</p>
<p>在某个signal出现后，可以按照以下三种方式之一进行signal处理：</p>
<ol>
<li>忽略singal。有两个signal不能被忽略：<code>SIGKILL</code>和<code>SIGTSTP</code>，它们向内核或者root用户踢欧冠呢了停止或者终止进程的可靠方法。还有某些硬件signal，除零或者非法内存引用，进程的行为是未定义的。</li>
<li>捕获signal。通过内核接收到某个signal后，调用相应的用户函数。</li>
<li>执行系统默认动作。对于大多数系统，默认动作是终止进程的执行。</li>
</ol>
<h2 id="函数signal">函数<code>signal</code></h2>
<p><code>signal</code>是ISO C定义的。但是ISO C不涉及多进程，进程组，终端I/O等概念。所以它对signal的定义非常含糊，对于UNIX的用处很小。<code>signal</code>的实现在不同UNIX版本上是不同的，最好使用<code>sigaction</code>函数代替<code>signal</code>。</p>
<h3 id="signal定义"><code>signal</code>定义</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">sighandler_t</span> signal(<span class="keyword">int</span> signum, <span class="keyword">sighandler_t</span> handler);</span><br></pre></td></tr></table></figure>
<h3 id="signal性质"><code>signal</code>性质</h3>
<ol>
<li><code>signal</code>函数有两个参数和一个返回值。第一个参数<code>signum</code>是整形，表示一个signal，第二个参数handler是函数指针，返回值也是一个函数指针。</li>
<li><code>handler</code>的值是常量<code>SIG_IGN</code>，<code>SIG_DFL</code>或者一个函数的地址。分别表示忽略该信号，执行默认动作，或者调用相应的函数。</li>
<li>**<code>signal</code>函数的返回值是指向之前的信号处理程序的函数指针。**所以，对于signal来说，只有改变信号的处理方式才能确定信号的当前处理方式。</li>
</ol>
<h3 id="exec和fork"><code>exec</code>和<code>fork</code></h3>
<p>当使用<code>exec</code>执行一个程序时，所有signal的状态都是系统默认或者忽略。<code>exec</code>函数将原先设置为要捕获的signal更改为默认动作，其他signal的状态不变。比如一个进程原先要捕获的signal，执行一个新程序后就不再catch了，因为signal catch函数的地址可能在执行的新程序文件中无意义了。</p>
<p>而fork因为复制了父进程的内存映像，所以信号捕捉函数的地址在子进程中是有意义的，子进程继承了父进程的信号处理方式。</p>
<h2 id="不可靠的signal">不可靠的<code>signal</code></h2>
<p>之前一些版本的signal是不可靠的，不可靠说的是：</p>
<ol>
<li>signal会丢失。比如一个signal发生了，但是进程却不知道。</li>
<li>进程对signal的控制能力很差。进程只能catch或者ignore signal，并不能阻塞signal。</li>
<li>进程每次接到signal对其进行处理时，然后将signal重置为默认值。</li>
<li>进程不希望发生某种signal时，不能关闭它，只能ignore它。</li>
</ol>
<h2 id="中断的系统调用">中断的系统调用</h2>
<p>如果进程在执行一个<strong>低速系统调用</strong>而<strong>阻塞</strong>期间捕捉到一个signal，这个系统调用就会被中断不再继续执行（不再阻塞），返回出错，errno设置为EINTR。<br>
什么是低速系统调用？系统调用被分为两类，一类是低速系统调用，另一类是其他系统调用。低速系统调用是指<strong>可能会使进程永远阻塞</strong>的一类系统调用，比如：</p>
<ol>
<li>如果某些类型文件（管道，终端设备和网络设备）的数据不存在，则读操作可能会使调用者永远阻塞。</li>
<li>pause和wait函数等。</li>
<li>…</li>
</ol>
<p>注意，与磁盘I/O有关的系统调用大多数时候总是会很快返回。</p>
<h2 id="可重入函数">可重入函数</h2>
<p>signal发生的时间是任意的，进程正在执行的正常指令可能会被信号处理程序中断，会对进程造成破坏。<br>
SUS说明了在信号处理程序中保证调用安全的函数，这些函数是可重入的，被称为异步信号安全的(async-signal safe)。如下所示是异步信号安全的函数：<br>
<img src="/2019/12/04/UNIX-signal/re.png" alt="re"><br>
其余的大多数函数是不可重入的，因为它们可能满足以下条件：</p>
<ol>
<li>使用静态数据结构；</li>
<li>调用<code>malloc</code>或者<code>free</code>；</li>
<li>是标准I/O函数。</li>
</ol>
<p>因为每个线程只有一个errno变量，所以信号处理程序可能会修改它的原值。因此，在调用可重入函数之前，应该先保存errno，在调用后恢复errno。</p>
<h2 id="sigcld语义">SIGCLD语义</h2>
<h2 id="可靠signal">可靠signal</h2>
<h2 id="函数">函数</h2>
<p>ISO C并不涉及多进程，所以它不能定义以进程ID为参数的函数。</p>
<h3 id="kill和raise"><code>kill</code>和<code>raise</code></h3>
<p>kill向参数pid指定的进程或者进程组发送一个signal。<br>
raise向调用者发送一个signal，ISO C中没有线程，POSIX.1扩展了raise可以处理多线程。单线程程序中等价于<code>kill(getpid(), sig)</code>。在多线程程序中等价于<code>pthread_kill(pthread_self(), sig)</code>。</p>
<h3 id="alarm和pause"><code>alarm</code>和<code>pause</code></h3>
<p>alarm不阻塞，当某个时刻到达时，内核会产生一个SIGALRM信号。<br>
pause使调用进程挂起，直到捕捉到任意一个信号，执行相应的信号处理程序，并从其返回时，pause才返回。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://www.gnu.org/software/libc/manual/html_node/Standard-Signals.html#Standard-Signals" target="_blank" rel="noopener">https://www.gnu.org/software/libc/manual/html_node/Standard-Signals.html#Standard-Signals</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/28/C-function-passing-arguments/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/C-function-passing-arguments/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">C/C++ function passing arguments</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 23:49:24" itemprop="dateCreated datePublished" datetime="2019-11-28T23:49:24+08:00">2019-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-15 23:05:42" itemprop="dateModified" datetime="2019-12-15T23:05:42+08:00">2019-12-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参数传递">参数传递</h2>
<p>形参初始化的机理和变量初始化一样。形参的类型决定了形参和实参交互的方式。如形参是引用类型，它将绑定到对应的实参上；否则，将实参的值拷贝后赋给形参。<br>
当形参是引用类型时，我们说它对应的实参被<strong>引用传递</strong>，或者函数被<strong>传引用调用</strong>。和其他引用一样，引用形参也是它绑定的对象的别名；也就是说，引用形参是它对应的实参的别名。<br>
当实参的值被拷贝给形参时，形参和实参是两个相互独立的对象。我们说这样的实参被<strong>值传递</strong>或者函数被<strong>传值调用</strong>。</p>
<p>因为C中没有引用，所以C中传递参数的方式只有值传递，而C++中还有引用，不仅有值传递，还有引用传递。</p>
<h2 id="值传参和引用传参">值传参和引用传参</h2>
<h3 id="值传参">值传参</h3>
<p>当初始化一个非引用类型的变量时，初始值被拷贝给变量。此时，对变量的改动不会影响初始值。值传参的原理和这个一样，函数对形参做的所有操作都不会影响实参。</p>
<h4 id="指针形参">指针形参</h4>
<p>指针的行为和其他非引用类型一样。当执行指针拷贝操作时，拷贝的是指针的值。拷贝之后，两个指针是不同的指针。但是因为指针可以让我们间接访问它所指向的对象，所以可以通过指针修改它所指对象的值。</p>
<h3 id="引用传参">引用传参</h3>
<p>函数接受的参数是引用类型的话就是引用传参。通过使用引用形参，函数可以改变一个或者多个实参的值。<br>
引用传参的好处：</p>
<ol>
<li>避免拷贝，可以避免低效的拷贝操作，或者有些类型不支持拷贝，比如IO类型。</li>
<li>间接的实现多个返回值（也可以通过值传递指针实现）。</li>
</ol>
<h3 id="值传参和引用传参的区别">值传参和引用传参的区别</h3>
<p>值传参是将原始变量的值拷贝一份给形参，函数对形参的操作不会影响实参（指针可以简介的修改）。<br>
而引用传参是相当于直接把实参的引用给传递了形参，任何对形参的修改都是直接对实参的修改。</p>
<h2 id="const形参和实参"><code>const</code>形参和实参</h2>
<p>当形参是<code>const</code>时，必须注意顶层<code>const</code>，顶层<code>const</code>作业于对象本身。当用实参初始化形参时，会忽略掉顶层<code>const</code>，即形参的顶层<code>const</code>被忽略掉了。当形参有顶层<code>const</code>时，传递给它常量或者非常量对象都是可以的。</p>
<h3 id="指针或者引用形参和const">指针或者引用形参和<code>const</code></h3>
<p>形参的初始化方式和变量的初始化方式是一样的，所以指针或者引用形参和<code>const</code>结合时，按照<code>const</code>变量的初始化规则执行就行。</p>
<h3 id="尽量使用常量引用">尽量使用常量引用</h3>
<p>把函数不会修改的形参定义成普通的引用是一种比较常见的错误，这么做带给函数的调用者一种误导，即函数可以修改它的实参的值。此外，使用引用而非常量引用也会极大地限制函数所能接受的实参类型。（比如，不能把<code>const</code>对象，字面值或者需要类型转换的对象传递给普通的引用传参）</p>
<h2 id="数组形参">数组形参</h2>
<p>数组有两个特殊的性质：</p>
<ol>
<li>不允许拷贝，因为不能拷贝数组，所以不能以值传递的方式使用数组参数。</li>
<li>在使用数组时通常会将其转换成指针。因为数组会被转换成指针，所以为函数传递数组时，实际上传递的是指向数组首元素的指针，这样子可以节约开销。</li>
</ol>
<h3 id="管理数组转换的指针">管理数组转换的指针</h3>
<p>当传递给函数一个数组时，实参自动的转成指向数组首元素的指针，数组的大小对于函数的调用没有什么影响。因为数组是以指针的形式传递给函数的，所以函数其实是不知道数组的大小的，调用者应该为此提供一些额外的信息。通常有三种方式：</p>
<ol>
<li>显示传递一个表示数组大小的形参</li>
<li>使用标记指定数组长度，要求数组本身包含一个结束标记，典型的例子是C风格字符串。</li>
<li>使用标准库规范，传递数组首元素和尾后元素的指针。可以使用<code>begin</code>和<code>end</code>函数获得数组的首元素和尾后元素的指针。</li>
</ol>
<h3 id="数组形参和const">数组形参和<code>const</code></h3>
<p>当函数不需要对数组进行写操作时，数组形参应该是指向<code>const</code>的指针（底层const）。只有当函数确实需要改变数组元素值的时候，才把形参定义成指向非常量的指针。</p>
<h3 id="数组引用形参">数组引用形参</h3>
<p>C++允许将变量定义成数组的引用，形参也可以是数组的引用。此时，引用形参绑定到数组上。</p>
<h3 id="传递多维数组">传递多维数组</h3>
<p>C++其实没有真正的多维数组，多维数组其实就是数组的数组。把多维数组传递给函数时，传递的是指向数组首元素的指针。而多维数组是数组的数组，首元素本身就是一个数组，多维数组转换成指向数组的指针。数组第二维以及后面维度都是数组类型的一部分，不能省略。</p>
<h2 id="函数指针形参">函数指针形参</h2>
<p>和数组类似，虽然不能定义函数类型的形参，但是形参可以是指向函数的指针。这个时候，形参看起来是函数类型，实际上是当成指针使用。<br>
可以直接把函数作为实参使用，这个时候它会自动的转换成指针：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第三个参数是函数类型，它会自动的转换成指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">bool</span> pf(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"><span class="comment">//第三个参数是显式声明的指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">useBigger</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2, <span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span> &amp;, <span class="keyword">const</span> <span class="built_in">string</span> &amp;))</span></span>;</span><br><span class="line"><span class="comment">// 函数lengthCompare会被自动的转换成函数指针</span></span><br><span class="line">useBigger(s1, s2, lengthCompare);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用typedef和delctype简化函数指针">使用<code>typedef</code>和<code>delctype</code>简化函数指针</h3>
<p>可以使用下列语句定义函数指针：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面两个是函数类型：</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="keyword">bool</span> <span class="title">Func</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">delctype</span><span class="params">(lengthCompare)</span> Func2</span>; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//下面两个是函数指针类型：</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">delctype</span><span class="params">(lengthCompare)</span> *FuncP2</span>;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是，<code>decltype</code>返回函数类型，不会将函数自动转换成指针类型，只有在前面加上<code>*</code>才能得到指针。</p>
<h2 id="可变形参">可变形参</h2>
<p>当不知道向函数传递多少个参数时，C++ 11提供了两种方法处理不同数量实参，如果所有实参类型相同，传递<code>initializer_list</code>标准库类型，如果实参类型不同，编写特殊的函数，可变参数模板。<br>
此外，C++ 还有一种特殊的形参，叫做省略符，可以用它传递可变数量的实参。</p>
<h3 id="initializer-list形参"><code>initializer_list</code>形参</h3>
<p>如果实参数量未知，但是类型相同，可以使用标准库类型<code>initializer_list</code>类型的形参。该标准库提供的操作如下：</p>
<ul>
<li><code>initializer_list&lt;T&gt; lst</code>，默认初始化，T类型元素的空列表</li>
<li><code>initializer_list&lt;T&gt; lst{a, b, c...}</code>，list元素是对应初始值的副本，列表中的元素是<code>const</code></li>
<li><code>lst2(lst)</code>和<code>lst2 = lst</code>，注意，拷贝或者赋值一个<code>initializer_list</code>对象不会拷贝列表中的元素；拷贝后，原始列表和副本共享元素。</li>
<li><code>lst.size()</code></li>
<li><code>lst.begin()</code></li>
<li><code>lst.end()</code></li>
</ul>
<p><code>initializer_list</code>是一个标准库类型，它也是一个模板，它的元素永远都是常量。</p>
<p>有一个疑问，就是<code>std::initializer_list</code>和<code>std::vector</code>有什么区别？[2,3,4]<br>
拷贝<code>std::initializer_list</code>的时候并不会拷贝底层的对象。相当于拷贝了“指针”，或者说<code>std::initializer_list</code>有reference semantics而<code>std::vector</code>具有value semantics。</p>
<blockquote>
<p>Initializer lists may be implemented as a pair of pointers or pointer and length. Copying a std::initializer_list does not copy the underlying objects.</p>
</blockquote>
<h3 id="省略符形参">省略符形参</h3>
<p>省略符形参是为了便于C++访问某些特殊的C代码而设置的。省略符形参只能出现在形参列表的最后一个位置：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(param_list, ...)</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(...)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="main命令行选项"><code>main</code>命令行选项</h2>
<p>详细可以查看<a href>C/C++ main argc argv</a>。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版<br>
2.<a href="https://stackoverflow.com/questions/27753420/initializer-list-vs-vector" target="_blank" rel="noopener">https://stackoverflow.com/questions/27753420/initializer-list-vs-vector</a><br>
3.<a href="https://en.cppreference.com/w/cpp/utility/initializer_list" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/initializer_list</a><br>
4.<a href="https://stackoverflow.com/questions/14414832/why-use-initializer-list-instead-of-vector-in-parameters" target="_blank" rel="noopener">https://stackoverflow.com/questions/14414832/why-use-initializer-list-instead-of-vector-in-parameters</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/28/C-separate-compilation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/C-separate-compilation/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">C/C++ separate compilation</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 23:24:38" itemprop="dateCreated datePublished" datetime="2019-11-28T23:24:38+08:00">2019-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-10 19:27:09" itemprop="dateModified" datetime="2019-12-10T19:27:09+08:00">2019-12-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="功能文件头文件和实现">功能文件头文件和实现</h2>
<h3 id="头文件">头文件</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print_string.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PRINT_STRING</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRINT_STRING</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h3 id="实现">实现</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// print_string.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print_string.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_string</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s\n"</span>,  str);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试文件实现">测试文件实现</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"print_string.h"</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> str[] = <span class="string">"hello world"</span>;</span><br><span class="line">    print_string(str);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编译和链接">编译和链接</h2>
<p>执行以下命令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ main.cpp print_string.cpp -o main</span><br><span class="line">./main</span><br></pre></td></tr></table></figure>
<h2 id="理解">理解</h2>
<p>在<code>main</code>中包含了<code>print_string.h</code>头文件，相当于对函数进行了声明。然后使用<code>g++</code>编译的时候相当于提供了<code>print_string</code>的实现。</p>
<p>关于分离式编译的原理可以查看<a href>CSAPP linking</a>。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/28/UNIX-Process-Relationships/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/28/UNIX-Process-Relationships/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">Process Relationships</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-28 00:06:11" itemprop="dateCreated datePublished" datetime="2019-11-28T00:06:11+08:00">2019-11-28</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-01-04 12:30:45" itemprop="dateModified" datetime="2020-01-04T12:30:45+08:00">2020-01-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>在UNIX Process Control中，介绍了：</p>
<ol>
<li>每一个进程都有一个父进程，初始的kernel-level的进程通常是它自己。</li>
<li>当子进程终止的时候，父进程可以获得子进程的exit status。</li>
<li>同时在介绍<code>waitpid</code>的时候`提到了process groups，并且解释了我们可以等待一个进程组中任意进程的终止。</li>
</ol>
<p>这一篇文章更详细的介绍了process groups，以及POSIX.1中引入的session的概念。同时还介绍了用于登录的login shell和所有从login shell中启动的进程的关系。</p>
<h2 id="终端登录">终端登录</h2>
<h3 id="bsd登录">BSD登录</h3>
<p>系统bootstrap时，内核创建进程号为1的init进程。init进程使系统进行入多用户模式，init读取文件<code>/etc/tty</code>，对每一个允许登录的终端设备，init调用一次<code>fork</code>，它所生成的子程序<code>exec getty</code>程序。<br>
<code>getty</code>对终端设备调用<code>open</code>函数，以读写方式打开终端。一旦终端被打开，文件描述符0,1,2就被关联到该设备。然后<code>getty</code>输出<code>login</code>等字样，等待用户输入。当用户输入username之后，<code>getty</code>工作就结束了，接下来通过类似于以下的方式调用<code>login</code>：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execle(&quot;/bin/login&quot;, &quot;login&quot;, &quot;-p&quot;, username, (char*)0, envp);</span><br></pre></td></tr></table></figure></p>
<p><code>login</code>得到了用户名，接下来调用<code>getpasswd</code>提示用户键入密码，然后调用<code>crypt</code>将用户键入的口令和shadow中的pwsswd比较，判断密码是否正确。如果密码正确的话，<code>login</code>还会进行以下工作：</p>
<ol>
<li>将当前工作目录改为用户的主目录。</li>
<li>调用<code>chown</code>更改终端的控制权，使登录用户成为它的所有者。</li>
<li>对终端设备的权限改成用户读和写。</li>
<li>用<code>login</code>得到的所有参数进行初始化</li>
<li><code>login</code>进程更改登录用户的<code>uid</code>并调用该用户的登录shell。</li>
</ol>
<p>当然现代的<code>login</code>不仅仅进行这些工作，还会根据启动文件更改或者增加用户的环境变量等等。</p>
<h2 id="网络登录">网络登录</h2>
<h3 id="bsd登录-v2">BSD登录</h3>
<p>网络登录的话，BSD中有一个inetd进程，等待绝大多数互联想链接。作为系统启动的一部分，<code>init</code>调用一个shell，使其执行shell脚本/etc/rc，shell脚本启动一个守护进程inetd。当这个shell脚本终止时，inetd的进程变成init。inetd等待TCP/IP连接，每当有一个连接到达时，就执行一次<code>fork</code>，然后使用<code>exec</code>执行相应的子程序。<br>
比如一个TELNET服务请求。客服进程打开一个到服务主机的TCP连接，客户机运行TELNET服务进程（用telnetd表示）。它们之间使用TELNET应用协议通过TCP交换数据。客服进程的用户登录到服务进程所在的主机。<br>
然后telnetd进程打开一个伪终端设备，并且使用<code>fork</code>将它们分成两个进程。父进程处理通过网络的通信，子进程执行login程序。父进程和子进程之间通过伪终端相连接。在调用<code>exec</code>之前，子进程使其文件描述符0,1,2和伪终端相连。登录成功的话，执行和终端操作类似的设置。</p>
<p>当通过终端或者网络登录时，我们得到一个登录shell，它的标准输入，标准输出和标准错误要么连接到一个终端设备，要么连接到一个伪终端设备。</p>
<h2 id="进程组">进程组</h2>
<p>除了pid，每一个进程还属于一个process group。进程组是一个或者一组进程的集合。他们都是同一个job的进程，每一个进程组都有一个唯一的进程组id，和pid类似，可以存放在pid_t中。函数<code>getpgrp</code>获得process group的ID，<code>getpgid</code>获得指定进程的进程组ID，它们都是SUS定义的。<br>
每个进程组有一个组长进程，组长进程的进程组ID和它的进程ID一样。进程组组长可以创建一个进程组，创建该组中的进程，然后终止。只要在某个进程组中有一个进程存在，那么该进程组就存在，跟其组长是否终止无关。<br>
可以调用<code>setpgid</code>创建一个新的进程组后者加入一个现有的进程组。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>setpgid</code>将pid号为pid的进程的进程组ID设置为pgid。当子进程调用了<code>exec</code>之后，父进程就不能修改子进程的进程组ID了。<br>
通常在job control shell中，在fork之后调用此函数，父进程设置子进程的进程组ID，子进程也设置子进程的进程组ID，这两个调用总有一个是重复的，但是可以确保子进程的组ID被正确设置了。</p>
<h2 id="session">Session</h2>
<p>Session是一个或者多个进程组的集合。比如一个session可以有三个进程组：<br>
进程组1：登录shell，<br>
进程组2：proc1, proc2<br>
进程组3：proc3, proc4, proc5<br>
等等。通常一个进程组的进程是由一个shell pipeline生成的。比如上面的进程组可能是通过以下shell命令实现的：<br>
proc1 | proc2 &amp;<br>
proc3 | proc4 | proc5</p>
<p>可以调用<code>setsid</code>创建一个新的session：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> setsid(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure></p>
<p>这个函数具有以下性质：<br>
如果调用这个函数的进程不是一个进程组的组长，就创建一个新的session：</p>
<ol>
<li>该进程变成新的session的session leader，这个session leader是创建该session的进程。注意SUS只说明了session leader，而没有像pid和process gid之类的session id。也就是说session leader是有唯一PID的单个进程，可以将session leader的ID当做session ID。<strong>注意什么是session leader，它是一个进程，而session ID是session leader的PID，或者也把session ID较为session leader的process group ID</strong>。</li>
<li>调用进程是新进程组和新session中的唯一一个进程。</li>
<li>新的session没有controlling terminal。</li>
</ol>
<h2 id="控制终端">控制终端</h2>
<p>session和process group的一些其他属性：</p>
<ul>
<li>一个session通常会有一个controlling terminal，通常是终端设备或者伪终端设备。</li>
<li>建立和控制终端连接的session leader被称为controlling process（控制进程）。</li>
<li>一个session中的几个process group可以被分为一个foreground process group（前台进程组）和多个background process group（后台进程组）。</li>
<li>如果一个session有一个controlling terminal，那么它有一个前台进程组，其它进程组为后台进程组。</li>
<li>无论何时键入终端的中断键，ctrl+C，都会将中断信号发送至前台进程组的所有进程。</li>
<li>无论何时键入终端的退出键，ctrl+\，都会将退出信号发送到前台进程组的所有进程。</li>
<li>如果终端接口检测到网络已经断开，将挂断信号发送到session leader。</li>
</ul>
<p>登录shell属于后台进程组，它是session leader，也就是controlling process。登录时，会自动建立controlling terminal。有时候不管标准输入，标准输出是否重定向，程序都要和控制终端交互，可以open文件/dev/tty。在内核中，/dev/tty是controlling terminal的同义词，如果没有controlling terminal，对于这个设备的open失败。</p>
<h2 id="tcgetpgrp-tcsetpgrp和tcgetsid"><code>tcgetpgrp</code>, <code>tcsetpgrp</code>和<code>tcgetsid</code></h2>
<h3 id="函数原型">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> tcgetpgrp(<span class="keyword">int</span> fd);</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tcsetpgrp</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">pid_t</span> pgrp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;termios.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> tcgetsid(<span class="keyword">int</span> fd);</span><br></pre></td></tr></table></figure>
<h3 id="属性">属性</h3>
<ol>
<li><code>tcgetpgrp</code>返回前台进程组ID，它与在fd上打开的终端相关联。</li>
<li>如果进程有一个controlling terminal，这个进程可以调用<code>tcsetpgrp</code>将前台进程组ID设置为pgrpid，fd必须引用该session的controlling terminal。</li>
<li>可以通过<code>tcgetsid</code>函数获得session leader的进程组ID。</li>
</ol>
<h2 id="job-control">job control</h2>
<p>可以在一个终端上启动多个jobs（groups of process），它控制哪个job可以访问终端，哪个job应该在后台运行，job control需要满足以下三个条件：</p>
<ol>
<li>支持job control的shell</li>
<li>内核的终端驱动程序必须支持job contrl</li>
<li>内核必须支持某些特定的job-control signals。</li>
</ol>
<p>在shell中使用job contrl，我们可以创建前台的job，也可以创建后台的job，一个job是进程的集合，通常是进程的pipeline，可以在后台运行多个job。<br>
可以通过键入几个特殊字符和终端驱动程序进行交互作用，控制前台进程组的所有进程：</p>
<ul>
<li>中断，ctrl+C，产生SIGINT</li>
<li>退出，ctrl+\，产生SIGQUIT</li>
<li>挂起，ctrl+Z，产生SIGSTRP</li>
</ul>
<p>终端驱动程序还需要处理一些情况：</p>
<ol>
<li>当后台job试图读取终端时<br>
如果有一个前台job和多个后台jobs。一般情况下，只有前台job接收终端输入，当后台job试图从终端读取，并不会报错，终端驱动程序会检测这种情况，并且向后台job发出一个SIGTTIN signal。这个signal会停止后台job，shell向有关用户发出通知说你的后台job停止啦！然后用户可以用shell命令将它转换后前台job，从终端读取。<br>
如果</li>
<li>当后台job试图写终端时<br>
当用户禁止后台job向controlling terminal写后，当后台job试图写向标准输出，终端驱动程序识别出这个写操作来自于后台job，向该job发出SIGTTOU signal，阻塞相应的job。当用户使用fg将后台job转换为前台job时，job继续执行。</li>
</ol>
<h2 id="shell执行过程">shell执行过程</h2>
<p>有些shell支持job control，比如bash，有些不支持，比如Bourne shell。</p>
<p>执行以下命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pgid,sid,comm | cat      // 后台job</span><br><span class="line">ps -o pid,ppid,pgid,sid,comm | cat &amp;    // 前台job</span><br></pre></td></tr></table></figure></p>
<h3 id="不支持job-control的shell">不支持job control的shell</h3>
<p>在不支持job control的shell中，管道的最后一个进程是shell的子进程，而执行管道中其他命令的进程是该最后进程的子进程。当最后一个进程终止时，shell得到通知。<br>
所有的job的process group id和shell的都一样。<br>
<img src="/2019/11/28/UNIX-Process-Relationships/shell_no_job_control.png" alt="shell_no_job_control"></p>
<h3 id="支持job-control的shell">支持job control的shell</h3>
<p>而在支持job control的shell中<br>
每一个job都有一个自己的process group id，和shell的不一样。<br>
shell是两个job的父进程。</p>
<h2 id="孤儿进程组">孤儿进程组</h2>
<p>当一个进程的父进程退出之后，而子进程还没有结束，这个进程就成了孤儿进程。进程组也可以是孤儿进程组。<br>
什么是孤儿进程组：<br>
进程组中每个成员的父进程要么是它组内的一个成员，要么不是这个进程组所在session的成员。</p>
<h2 id="freebsd实现">FreeBSD实现</h2>
<p>每个session都会有一个seesion结构，它包含：</p>
<ul>
<li><code>s_count</code></li>
<li><code>s_leader</code></li>
<li><code>s_ttyvp</code></li>
<li><code>s_ttyp</code></li>
<li><code>s_sid</code>，这一部分不是SUS的组成，只有FreeBSD有。</li>
</ul>
<p>每个终端或者伪终端会在内核中分配一个tty结构，它包含：</p>
<ul>
<li><code>t_session</code></li>
<li><code>t_pgrp</code></li>
<li><code>t_termios</code></li>
<li><code>t_winsize</code></li>
</ul>
<p>每个进程组都包含一个pgrp结构，它包含：</p>
<ul>
<li><code>pg_id</code></li>
<li><code>pg_session</code></li>
<li><code>pg_memebers</code></li>
</ul>
<p>每个进程都有一个<code>proc</code>结构，它包含：</p>
<ul>
<li><code>p_pid</code></li>
<li><code>p_ptr</code></li>
<li><code>p_grp</code></li>
<li><code>p_pglist</code></li>
</ul>
<p>进程通过v_node结构体访问/dev/tty。</p>
<p>它们之间的关系如下图所示：<br>
<img src="/2019/11/28/UNIX-Process-Relationships/" alt="session_and_process_group"></p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/27/assembly-languages/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/27/assembly-languages/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">assembly languages</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-27 21:36:52 / 修改时间：22:00:57" itemprop="dateCreated datePublished" datetime="2019-11-27T21:36:52+08:00">2019-11-27</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/汇编/" itemprop="url" rel="index"><span itemprop="name">汇编</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="机器指令">机器指令</h2>
<p>计算机指令可以表示为序列化的bits，一般来说，这是一个程序最低级别的表示-每一条指令都等于CPU的一个单个的，不可分隔的指令。这种表示方法叫做机器语言，因为它是机器可以理解的唯一一种形式。</p>
<h2 id="汇编语言">汇编语言</h2>
<p>一种更高level的表示叫做assembly language。Assembly language和机器语言的很类似，通常可以很方便的把程序从汇编语言转换成机器语言。因为机器语言和汇编语言的相似性，每一个不同的机器架构都有它自己的汇编语言。事实上，每一个架构都可能有好几个汇编语言。<br>
汇编语言的优势是汇编语言对于人类来说是更容易阅读和理解的。举例来说，将寄存器20和寄存器17的内容相加，并将结果存放在寄存器16的MIPS机器语言指令是：0x02918020。给出这个指令，很难直接理解它是怎么工作的。相同的MISP汇编指令是：<br>
<code>add $16, $20, $17</code><br>
可读性更强。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/26/C-strlen-vs-sizeof/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/26/C-strlen-vs-sizeof/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">C/C++ strlen vs sizeof</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-26 10:07:37" itemprop="dateCreated datePublished" datetime="2019-11-26T10:07:37+08:00">2019-11-26</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 15:33:22" itemprop="dateModified" datetime="2019-12-17T15:33:22+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <ol>
<li><code>strlen</code>不计算字符串数组的null字节，而<code>sizeof</code>会计算null字节所占的字节。</li>
<li><code>strlen</code>是一个函数，使用时需进行一次系统调用。而<code>sizeof</code>会在编译时计算。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版8.3节</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-struct/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-struct/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX struct</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 17:34:51" itemprop="dateCreated datePublished" datetime="2019-11-25T17:34:51+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-08 13:52:58" itemprop="dateModified" datetime="2019-12-08T13:52:58+08:00">2019-12-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>struct FILE<br>
{</p>
<p>};</p>
<p>struct DIR<br>
{</p>
<p>};</p>
<h2 id="结构体">结构体</h2>
<p>POSIX定义了<br>
struct dirent<br>
{</p>
<p>};</p>
<p>struct pwd<br>
{</p>
<p>};</p>
<p>struct spwd<br>
{</p>
<p>};</p>
<p>struct grp<br>
{</p>
<p>};</p>
<p>struct timespec<br>
{</p>
<p>};</p>
<p>struct sm{</p>
<p>};</p>
<h2 id="进程资源限制">进程资源限制</h2>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">struct rlimit&#123;</span><br><span class="line">    rlim_t rlim_cur;</span><br><span class="line">    rlim_t rlim_max;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版<br>
2.<a href="https://en.cppreference.com/w/c/chrono/timespec" target="_blank" rel="noopener">https://en.cppreference.com/w/c/chrono/timespec</a><br>
3.<a href="https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html" target="_blank" rel="noopener">https://www.gnu.org/software/libc/manual/html_node/Elapsed-Time.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-Process-Control/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-Process-Control/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX Process Control</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 10:31:02" itemprop="dateCreated datePublished" datetime="2019-11-25T10:31:02+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-20 16:45:20" itemprop="dateModified" datetime="2020-02-20T16:45:20+08:00">2020-02-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一节主要介绍UNIX系统的进程控制，包括进程创建，进程执行和进程控制。以及进程属性的各种的ID-real UID, real GID和effective UID, effective GID和save UID， set UID和set GID，以及它们如何收到进程控制原语的影响。</p>
<h2 id="进程标识-pid">进程标识(pid)</h2>
<p>每一个进程都有一个非负整数表示它的唯一进程ID。进程ID标识符总是唯一的，但是可以复用。<br>
关于和进程ID相关的内容，可以查看<a href></a>。</p>
<h2 id="fork"><code>fork</code></h2>
<p><code>fork</code>创建一个子进程。函数原型：</p>
<h3 id="fork原型"><code>fork</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="fork性质"><code>fork</code>性质</h3>
<ol>
<li><strong>进程ID</strong>。<code>fork</code>调用一次，返回两次，分别是0和子进程ID，用以区别父进程和子进程。对于父进程，返回子进程ID，对于子进程，返回0。因为父进程可能有多个子进程，并且没有提供获得一个进程所有子进程ID的函数，而fork只有一个父进程，可以通过<code>getppid</code>获得它的父进程的ID。所以这样子进行区分。</li>
<li>子进程和父进程分别继续执行调用<code>fork</code>之后的指令。子进程是父进程的副本。子进程获得父本的数据段，堆和栈的完全副本。这是子进程的副本，和父进程不一样，它们并不共享数据的内存空间，但是它们共享text segment。</li>
<li>现代的操作系统实现，使用写时复制代替了父进程数据段，堆和栈的完全副本。这些区域是由父进程和子进程共享的，但是它们的访问权限是只读。如果父进程或者子进程想要对这些区域进行修改的话，内核会为修改区域的那块内存制作一个副本，用于进程修改。</li>
<li>父进程和子进程因为不共享数据，堆和栈，每个进程都有自己的变量，不会相互影响。</li>
<li><strong>执行顺序</strong>。<code>fork</code>后父进程和子进程的执行顺序是不确定的，这跟内核的调度算法有关。如果要求父进程和子进程之间进行同步，需要它们之间进行某种形式的进程通信。</li>
<li><strong>文件共享</strong>。对于父进程打开的文件，<code>fork</code>相当于将父进程的文件描述符都复制到了子进程中，相当于对父进程的每一个文件描述符，都调用了<code>dup</code>函数。父进程和子进程每个相同的打开文件描述符共享同一个文件表项。一般来说，在<code>fork</code>之后处理文件描述符有以下两种情况：
<ul>
<li>父进程等待子进程完成。父进程不需要对它的文件描述符做任何处理。</li>
<li>父进程和子进程分别执行不同的程序段。父进程和子进程各自关闭它们不需要的文件描述符。</li>
</ul>
</li>
<li><strong><code>fork</code>后子进程继承的信息</strong>。
<ul>
<li>real UID, real GID, effective UID, effective GID</li>
<li>set UID和 set GID</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>Session ID</li>
<li>控制终端</li>
<li>cwd</li>
<li>root dir</li>
<li>umask</li>
<li>signal mask</li>
<li>文件描述符标志</li>
<li>环境</li>
<li>共享的内存段</li>
<li>内存映像</li>
<li>Resource limits</li>
</ul>
</li>
<li><strong>父进程和子进程的区别。</strong>
<ul>
<li><code>fork</code>的返回值不同</li>
<li>pid不同</li>
<li>它们有不同的ppid</li>
<li>子进程的很多时间设置为0</li>
<li>父进程设置的文件锁子进程不继承。</li>
<li>子进程的未处理闹钟被清除</li>
<li>子进程的未处理信号被设置为空集。</li>
</ul>
</li>
<li><strong><code>fork</code>的两种用法</strong>。
<ul>
<li>父进程和子进程分别执行不同的代码。比如网络服务中，父进程负责等待客户端请求，子进程负责处理父进程接收到的请求。</li>
<li>一个进程要执行不同的程序。对shell比较常见，通常执行完<code>fork</code>返回后立即调用<code>exec</code>。</li>
</ul>
</li>
</ol>
<h2 id="vfork"><code>vfork</code></h2>
<p>创建一个子进程，并且阻塞父进程，函数原型如下：</p>
<h3 id="vfork原型"><code>vfork</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> vfork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>
<h3 id="vfork属性"><code>vfork</code>属性</h3>
<ol>
<li><code>vfork</code>和<code>fork</code>都创建一个新进程，但是<code>vfork</code>并不会将父进程的地址空间完全复制到子进程中。因为子进程会立即调用<code>exec</code>或者<code>exit</code>，就不会引用该地址空间。但是如果在调用<code>exec</code>或者<code>exit</code>之前，它会在父进程的空间中运行，这种做法会提高效率。但是如果子进程修改除了<code>vfork</code>的返回值，或者在没有调用<code>exit</code>或者<code>exec</code>之前调用其他函数，这种行为是未定义的。</li>
<li><code>vfork</code>保证子进程先运行，在子进程没有调用<code>exec</code>或者<code>exit</code>时，内核会使父进程休眠，在子进程调用<code>exec</code>或者<code>exit</code>这两个中的任何一个后，父进程才会恢复运行。如果子进程需要父进程进一步操作的时候，就会产生死锁。</li>
</ol>
<h2 id="exit函数"><code>exit</code>函数</h2>
<p>关于<code>exit</code>函数的介绍，可以查看<a href>C/C++ exit and return</a>。<br>
总共有八种方式可以让进程终止，包括五种正常和三种异常，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回，相当于调用<code>exit</code>。</li>
<li>调用<code>exit</code>，ISO C定义的，它的操作包括调用各个exit handler，处理所有标准I/O流。<code>exit</code>会冲洗标准I/O流，如果这是函数库所采取的唯一的动作，那么不会出现什么问题。而如果<code>exit</code>除了冲洗标准I/O流，还会关闭I/O流，那么在<code>vfork</code>时就会出问题了。当然，现在的<code>exit</code>实现都不会关闭流了，这个操作一般都交给内核实现。</li>
<li>调用<code>_exit</code>或者<code>_Exit</code>，ISO C定义了<code>_Exit</code>，而POSIX.1说明了<code>_exit</code>。它的目的是提供一种无需运行exit handler或者信号处理程序而终止的方法。是否对标准I/O流进行flush，取决于实现。在UNIX中，<code>_Exit</code>和<code>_exit</code>是同义的，并不冲洗I/O流。</li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<p>不管进程以哪种方式终止，最后都会执行内核中的同一段代码，这段代码为相关进程关闭所有打开的文件描述符，释放它使用的内存。<br>
为了让终止进程能够通知父进程它是如何终止的。对于3个终止函数，将它的<code>exit status</code>作为参数传递给函数。在异常终止的情况下，内核产生一个指示其异常终止原因的terminaiton status（终止状态）。在任意终止情况下，这个终止进程的父进程都能用<code>wait</code>或者<code>waitpid</code>函数获得它的终止状态。<br>
<strong>如果父进程在子进程之前终止</strong>，所有终止进程的子进程的父进程都变成<code>init</code>进程，<code>init</code>进程负责获得终止状态。对于一个即将终止的进程，内核检查所有活动进程，判断其中是否有待终止进程的子进程，如果有的话，将这些进程的父进程的ID改为<code>init</code>进程的PID 1。<br>
<strong>如果子进程在父进程之前终止</strong>。内核为每一个终止进程保留了一部分信息，当终止进程的父进程调用<code>wait</code>或者<code>waitpid</code>时，可以获取这些信息，这些信息包含终止进程PID，进程的终止状态，进程占用的CPU时间总量。内核可以释放这些进程的内存，关闭打开的文件。如果一个进程终止了，但是它的父进程没有等待它，它被称为一个zombie（僵尸）进程，这些信息不会被释放。如果一个长期运行的进程，<code>fork</code>了很多子进程，除非父进程调用wait得到子进程的终止状态，否则它们就会变成僵尸进程。<br>
<code>init</code>的子进程，不会变成僵尸进程，因为<code>init</code>进程被编写成无论何时只要有一个子进程终止，<code>init</code>就会调用一个<code>wait</code>函数获得其终止状态。</p>
<h2 id="wait和waitpid"><code>wait</code>和<code>waitpid</code></h2>
<p>当一个进程终止的话（无论正常还是异常），内核就会向它的父进程发送<code>SIGCHLD</code>信号。而子进程终止是个异步事件，可以在父进程运行的任何时候发生。对于这种信号，父进程可以忽略它，或者调用一个信号处理函数。<br>
调用了<code>wait</code>或者<code>waitpid</code>的进程，可能会处于以下几种状态之一：</p>
<ol>
<li>所有子进程都还在运行，则阻塞。</li>
<li>一个子进程已经终止，正在等待父进程获取其终止状态，那么取得该子进程的终止状态立即返回。</li>
<li>如果它没有任何子进程，立即出错返回。</li>
</ol>
<p>如果进程由于接收到<code>SIGCHLD</code>而调用<code>wait</code>，我们期望<code>wait</code>会立即返回。如果在随机的时间点调用<code>wait</code>，进程可能会阻塞。</p>
<h3 id="wait和waitpid原型"><code>wait</code>和<code>waitpid</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *wstatus);</span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>
<h3 id="wait和waitpid性质"><code>wait</code>和<code>waitpid</code>性质</h3>
<ol>
<li>在一个子进程终止前，<code>wait</code>使其调用者阻塞，直到任意一个子进程终止。<code>wait</code>返回终止子进程的进程ID。如果<code>wait</code>要等待一个特定的进程，将返回的pid和要等待的pid相比，如果不相等，将这个pid和termination status保存起来，再次调用<code>wait</code>，直到等到目标pid。下一次想要等待一个特定进程的时候，现场看已经终止的进程列表中是否已有它 ，没有的haunted继续调用<code>wait</code>。</li>
<li>ISO中定义了<code>waitpid</code>中option的四个可能值：0，<code>WNOHANG</code>, <code>WUNTRACED</code>和<code>WCONTINUED</code>。POSXI扩展了许多其他选项。其中0表示阻塞调用，<code>WNOHANG</code>表示如果没有子进程结束就立刻退出，<code>WUNTRACED</code>表示如果一个子进程停止了也返回，<code>WCONTINUED</code>表示一个子进程恢复运行了也会返回。</li>
<li>指定option为0时，设置<code>waitpid</code>阻塞等待指定的进程pid。当<code>pid</code>为-1时，<code>waitpid</code>和<code>wait</code>一样。当<code>pid</code>大于或者小于0时，等待相应的pid（绝对值）。当pid等于0时，等待gid等于调用进程组id的任意一个子进程。</li>
<li>指定option为<code>WNOHANG</code>，设置<code>waitpid</code>不阻塞，表示如果没有子进程结束，就立刻返回。在Linux上，<code>WNOHANG</code>是1。</li>
<li>指定option为<code>WUNTRACED</code>和<code>WCONTINUED</code>，设置<code>waitpid</code>支持job control。</li>
<li>对于<code>wait</code>，只有当调用进程没有子进程时，才出错。对于<code>waitpid</code>，指定的进程或者进程组不存在，或者参数pid不是调用进程的子进程时，都会出错。</li>
<li><code>wstatus</code>是一个整形指针。如果它不为空指针，终止进程的终止状态就存放在它所指的单元内。</li>
<li><code>wstatus</code>指向的整形变量的意义是由实现定义的，其中的某一些位表示exit status，即正常退出。另外一些位表示signal number，表示不正常退出，一位表示是否产生core file，等等。POSIX.1指定了termination status可以用<code>&lt;sys/wait.h&gt;</code>中定义的宏查看。四个互斥宏可以用来取得进程终止的原因：
<ul>
<li><code>WIFEXITED(status)</code>，如果status是一个正常终止子进程返回的，为true。执行<code>WEXITSTATUS(statue)</code>获取子进程传递给<code>exit</code>或者<code>_exit</code>的参数的低八位。</li>
<li><code>WIFSIGNALED(status)</code>，如果status是一个异常终止子进程返回的，为true。执行<code>WTERMSIG(status)</code>获取使得子进程终止的signal。</li>
<li><code>WIFSTOPPED(status)</code>，如果status是一个当前暂停的子进程返回的，为true。执行<code>WSTOPSIG(status)</code>获取使得子进程暂停的signal。</li>
<li><code>WIFCONTINUED(status)</code>，。</li>
</ul>
</li>
<li><code>fork</code>两次可以让原始进程不用自己调用<code>wait</code>，也可以避免产生僵尸进程。</li>
</ol>
<h2 id="waitid"><code>waitid</code></h2>
<h3 id="waitid原型"><code>waitid</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">waitid</span><span class="params">(<span class="keyword">idtype_t</span> idtype, <span class="keyword">id_t</span> id, <span class="keyword">siginfo_t</span> *infop, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="waitid性质"><code>waitid</code>性质</h3>
<ol>
<li><code>waitid</code>是SUS指定的，不是ISO C的部分。</li>
<li><code>waitid</code>和<code>waitpid</code>类似，但是它使用两个单独的参数表示要等到的子进程所属的类型，用<code>idtype</code>表明<code>id</code>的类型，用<code>id</code>表示pid或者进程组id。<code>idtype</code>的取值如下：
<ul>
<li><code>P_PID</code>，等待特定进程，id指定要等待的子进程的pid</li>
<li><code>P_PGID</code>，等待特定进程组中的任一子进程，id是包含要等待子进程的组ID</li>
<li><code>P_ALL</code>，等待任意子进程，忽略id。</li>
</ul>
</li>
<li><code>options</code>参数是以下标志的按位或运算。
<ul>
<li><code>WCONTINUED</code></li>
<li><code>WEXITED</code></li>
<li><code>WNOHANG</code></li>
<li><code>WNOWAIT</code></li>
<li><code>WSTOPPED</code></li>
</ul>
</li>
<li><code>siginfo_t</code>结构体包含了子进程状态改变有关signal的详细信息。</li>
</ol>
<h2 id="wait3和wait4"><code>wait3</code>和<code>wait4</code></h2>
<p>大多数UNIX系统都支持<code>wait3</code>和<code>wait4</code>，它们是从BSD延续下来的。它们的功能比POSIX.1函数<code>wait</code>, <code>waitpid</code>和<code>waitid</code>要多一个。可以通过附加参数允许内核返回终止进程以及其所有子进程使用的资源概况。包含用户CPU时间总量，系统CPU时间总量，缺页次数，接收到的signal次数。<br>
它们的原型如下：</p>
<h3 id="wait3和wait4原型"><code>wait3</code>和<code>wait4</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pid_t</span> wait3(<span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options, struct rusage *rusage);</span><br><span class="line"><span class="keyword">pid_t</span> wait4(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options, struct rusage *rusage);</span><br></pre></td></tr></table></figure>
<h2 id="race-condition">race condition</h2>
<p>如果多个进程都企图对共享数据进行某种处理，而且最后的结果取决于进程运行的顺序时，我们认为发生了race condition。<br>
如果一个进程希望等待子进程终止，可以调用<code>wait</code>函数中的一个。如果一个子进程想要等待父进程终止，可以使用下列形式的循环，称为轮询（polling)<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(getppid() != <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种方式浪费了很多CPU时间。为了避免这些问题，可以使用signal或者进程间通信解决这些问题。</p>
<h2 id="exec"><code>exec</code></h2>
<p>通常使用<code>fork</code>创建新的子进程之后，子进程往往会调用一种<code>exec</code>函数执行另一个程序。当进程调用<code>exec</code>函数时，该进程执行的程序完全替换为新程序，而新程序从其<code>main</code>函数开始执行。调用<code>exec</code>并不会创建新进程，所以前后的进程ID不变。<code>exec</code>使用磁盘上的一个新程序替换了当前进程的text segment, data segment, heap和stack。<code>exec</code>函数只有在出错的时候才返回-1，并且设置<code>errno</code>。<br>
总共有七种不同的<code>exec</code>函数，它们被统称为<code>exec</code>函数。它们的原型如下：</p>
<h3 id="exec函数原型"><code>exec</code>函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/*, (char *) NULL, char * const envp[] */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">const</span> <span class="keyword">char</span> *arg, ... <span class="comment">/* (char  *) NULL */</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvpe</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *file, <span class="keyword">char</span> *<span class="keyword">const</span> argv[],</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">int</span> fexecve(<span class="keyword">int</span> fd, <span class="keyword">char</span> *<span class="keyword">const</span> argv[], <span class="keyword">char</span> *<span class="keyword">const</span> envp[]);</span></span></span><br></pre></td></tr></table></figure>
<h3 id="exec函数属性"><code>exec</code>函数属性</h3>
<ol>
<li><strong>传入参数的区别。</strong> <code>path</code>是路径名作为参数，<code>file</code>是文件名作为参数。如果<code>path</code>中包含<code>'/'</code>，将它看成路径名。否则按照PATH环境变量，在它指定的目录中搜寻可执行文件。如果函数<code>execlp</code>和<code>execvp</code>在PATH指定的目录中找到的文件不是link editor产生的可执行文件，就会把它当做一个shell脚本，调用<code>/bin/sh</code>，把这个文件当做shell的输入。</li>
<li><strong>argmuent list的区别。</strong> l表示的是列表，v表示的是向量。<code>execl</code>, <code>execlp</code>和<code>execle</code>要求将新程序的每个命令行参数都说明为一个单独的参数，这种参数表以空指针结尾。而<code>execv</code>,<code>execvp</code>, <code>execve</code>和<code>fexecve</code>，需要先构造一个指向各个参数的指针数组，然后将该数组的地址作为这四个函数的参数。</li>
<li><strong>environment list的区别。</strong> 以e结尾的函数，<code>execve</code>, <code>execvpe</code>,<code>execle</code>, <code>fexecve</code>等可以传递一个指向environment字符串指针数组的指针，这个是自己指定的环境。其他几个不带e的函数使用进程中的environ变量为新程序复制现有的环境。</li>
<li>调用<code>exec</code>后，进程ID没有改变，但是新程序从调用进程继承了以下属性：
<ul>
<li>pid和ppid</li>
<li>real UID, real GID,</li>
<li>附属组ID</li>
<li>进程组ID</li>
<li>Session ID</li>
<li>控制终端</li>
<li>闹钟余留时间</li>
<li>cwd</li>
<li>root dir</li>
<li>umask</li>
<li>文件锁</li>
<li>进程信号屏蔽</li>
<li>未处理信号</li>
<li>资源限制</li>
<li>nice值</li>
<li>时间</li>
</ul>
</li>
<li>在<code>exec</code>前后，real UID和real GID不变，effective ID取决于是否设置set UID和set GID。如果新程序的set UID已经设置，则effective ID变成程序文件所有者的ID，否则不变。</li>
<li>这几个函数中，只有<code>execve</code>是系统调用，其他几个都只是库函数，最终都要调用<code>execve</code>。</li>
</ol>
<h2 id="解释器文件">解释器文件</h2>
<p>关于解释器文件，可以查看<a href></a>。</p>
<h2 id="system"><code>system</code></h2>
<p>关于system的介绍，可以查看<a href></a>。</p>
<h2 id="进程会计">进程会计</h2>
<p>大多数UNIX系统都提供了一个选项进行进程会计处理。启动该选项之后，每当进程结束时内核就会写一个会记记录。典型的会计记录是一个二进制数据，一般包括命令名，所有的CPU时间总量，UID和GID，启动时间等。所有的标准都没有定义进程会记，所以实现上就千差万别。<br>
<code>acct</code>函数启用和关闭进程会计。<br>
会记记录结构定义在头文件<code>&lt;sys/acct.h&gt;</code>的<code>struct acct</code>中，其中<code>ac_flag</code>标志记录了进程执行期间的某些事件：</p>
<ul>
<li><code>AFORK</code>，进程是<code>fork</code>产生的，但是未调用<code>exec</code></li>
<li><code>ASU</code>，进程使用superuser权限</li>
<li><code>ACORE</code>，进程转储到core</li>
<li><code>AXSIG</code>，进程由一个signal杀死</li>
<li><code>AEXPND</code>，扩展的会计条目</li>
<li><code>ANVER</code>，新纪录格式</li>
</ul>
<p>在LINUX上，<code>ac_flag</code>是枚举类型，所以不能使用<code>#ifdef</code>判断是否支持<code>ACCORE</code>等flag，可以使用<code>if !defied HAS_ACCORE</code>进行判断。</p>
<p>会计记录所需的各个数据（各CPU时间，传输的字符数等）都由内核保存在process table中，并在一个新进程被创建时初始化，进程终止时写一个会计记录。这产生了两个后果：</p>
<ol>
<li>对于那些不会终止的进程，比如<code>init</code>进程，我们无法获得它的会计记录。内核守护进程也不会终止，所以也不会产生会计记录。</li>
<li>在会计文件中记录的顺序对应于进程终止的顺序，而不是它们启动的顺序。</li>
</ol>
<p>会记记录对应于进程而不是程序。在<code>fork</code>之后，内核为子进程初始化一个记录，而不是在一个新程序被执行初始化时。<code>exec</code>并不会创建一个新的记录，但是相应记录中的名字会改变，<code>AFORK</code>标志没了。</p>
<h2 id="获得当前登录用户名">获得当前登录用户名</h2>
<p>可以使用<code>getlogin</code>获得当前登录用户的用户名。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getlogin</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="进程调度">进程调度</h2>
<p>调度策略和调度优先级是由内核确定的。</p>
<h3 id="nice-getpriority-setpriority原型"><code>nice</code>, <code>getpriority</code>, <code>setpriority</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nice</span><span class="params">(<span class="keyword">int</span> inc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpriority</span><span class="params">(<span class="keyword">int</span> which, <span class="keyword">id_t</span> who, <span class="keyword">int</span> prio)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="nice-getpriority-setpriority属性"><code>nice</code>, <code>getpriority</code>, <code>setpriority</code>属性</h3>
<ol>
<li><code>nice</code>函数将输入的参数加到当前的<code>nice</code>值上。<code>nice</code>值越大，优先级越低，否则越高。</li>
<li>在单核的机器中，同时运行一个父进程和一个子进程，它们的<code>nice</code>值不同的话，CPU占用比也可能会不同，这取决于进程调度程序如何使用<code>nice</code>值。在多核的机器上可能看不到这样的结果。</li>
</ol>
<h2 id="进程时间">进程时间</h2>
<p>可以使用<code>times</code>获得某进程和它的子进程的CPU时间以及墙上时钟时间，<code>times</code>通过<code>struct tms</code>传递信息。它的内容如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tms</span> &#123;</span></span><br><span class="line">    <span class="keyword">clock_t</span> tms_utime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_stime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_cutime;</span><br><span class="line">    <span class="keyword">clock_t</span> tms_cstime;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>它包含进程的用户CPU时间，系统CPU时间和子进程的用户CPU时间和系统CPU时间。但是不包含墙上时钟时间，墙上时钟时间是通过函数的返回值得到的，而且得到的时间是相对于过去某个时间点得到的，所以不能使用它的绝对值，要使用相对值。比如第一次调用<code>times</code>，记录返回值，等到下一次调用<code>times</code>时，用新的值减去刚才保存的值，得到墙上时间时间。<br>
<strong>所有时间（结构体和返回值）的单位都是滴答数。</strong><br>
函数原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/times.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">clock_t</span> times(struct tms *buf);</span><br></pre></td></tr></table></figure></p>
<p>shell的<code>time(1)</code>可以使用<code>times(2)</code>实现，看程序。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-Process-Environment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-Process-Environment/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX Process Environment</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 10:22:51" itemprop="dateCreated datePublished" datetime="2019-11-25T10:22:51+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-02 10:54:56" itemprop="dateModified" datetime="2019-12-02T10:54:56+08:00">2019-12-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一部分介绍的是进程运行的环境。主要包括进程执行时，<code>main</code>函数是如何被调用的，命令行参数如何传递给进程的，进程的存储空间结构，如何分配存储空间，环境变量的使用，以及进程是怎么终止的。</p>
<h2 id="main函数和argc-argv"><code>main</code>函数和<code>argc</code>, <code>argv</code></h2>
<p>C语言总是从<code>main</code>函数开始执行，C语言中<code>main</code>有两个原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>argc</code>是命令行参数的个数，<code>argv</code>是一个指针数组，ISO C和POSIX.1都要求<code>argv[argc]</code>设置为<code>NULL</code>，所以可以用它作为参数处理的循环终止条件。关于更多指针的信息可以查看<a href></a>。<br>
当内核执行C程序（使用一个<code>exec</code>函数）时，在调用<code>main</code>函数之前设置一个特殊的启动例程。可执行程序文件将这个启动例程指定为程序的起始地址，这是由link editor设置的，它会被C编译器调用。启动例程从内核命令获得命令行参数和环境变量值，然后为调用<code>main</code>函数做好准备。</p>
<p>关于更多C和C++中<code>main</code>的介绍，可以查看<a href="https://mxxhcm.github.io/2019/11/12/C-CPP-main-argc-argv/">C/C++ main argc argv</a>。</p>
<h2 id="全局变量environ">全局变量<code>environ</code></h2>
<p>每个C程序都会接收到一个environment list，和<code>argv</code>一样，它是一个指针数组。每个指针指向一个以<code>null</code>结束的C字符串的地址，这个指针数组的地址存放在全局变量<code>environ</code>中：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br></pre></td></tr></table></figure></p>
<p>在历史上，UNIX大多支持三个参数的<code>main</code>函数，第三个参数就是environment list：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但是ISO C规定<code>main</code>只能有两个参数，POSIX.1也就规定使用全局变量<code>environ</code>而不是第三个参数。如果要查看所有的环境变量时，使用<code>environ</code>，而访问某个特定的环境变量时，使用<code>getenv</code>和<code>setenv</code>。</p>
<h2 id="进程终止">进程终止</h2>
<p>总共有八种方式可以让进程终止，包括五种正常和三种异常，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回</li>
<li>调用<code>exit</code></li>
<li>调用<code>_exit</code>或者<code>_Exit</code></li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h3 id="exit函数"><code>exit</code>函数</h3>
<h4 id="函数原型">函数原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h4 id="性质">性质</h4>
<ol>
<li><code>exit</code>和<code>_Exit</code>是ISO C的内容，而<code>_exit</code>是POSIX.1的内容</li>
<li>它们都用于正常终止一个程序，<code>_Exit</code>和<code>_exit</code>立刻进入内核，而<code>exit</code>先执行一些清理操作，然后返回内核。<code>exit</code>函数总是执行一个标准I/O库的关闭操作，对于所有打开的流调用<code>fclose</code>函数，所有带有未写缓冲的标准I/O流被flush。</li>
<li>三个退出函数都需要一个整形的参数，被称为exit status。</li>
<li>如果满足以下条件：
<ul>
<li>调用这三个函数不带终止状态</li>
<li><code>main</code>执行了一个不带返回值的<code>return</code>语句</li>
<li><code>main</code>没有声明返回类型为整形，进程的终止状态是未定义的。<br>
那么这个进程的终止状态是未定义的。</li>
</ul>
</li>
<li><code>main</code>返回返回一个整型值和用该值调用<code>exit</code>是等价的。对于某些C编译器和UNIX lint(1)程序来说，会产生警告信息，因为这些编译器并不了解<code>main</code>中的<code>return</code>和<code>exit</code>的作用是相同的。避开这种警告信息的一种方法是在<code>main</code>中使用<code>return</code>而不是<code>exit</code>，这样做的结果是UNIX grep命令无法找出程序中所有的<code>exit</code>调用。另一个方法是将<code>main</code>声明为<code>void</code>而不是<code>int</code>，然后调用<code>exit</code>，但是这不并不是标准，ISO C和POSIX.1定义<code>main</code>的返回值应当是带符号整形。</li>
</ol>
<p>关于更多<code>exit</code>函数的内容，可以查看<a href></a>。<br>
关于<code>exit</code>和<code>return</code>的内容，更多可以查看<a href>C/C++ exit and return</a>。</p>
<h3 id="atexit"><code>atexit</code></h3>
<p>每个进程可以通过<code>atexit</code> register至多32个由<code>exit</code>自动调用的函数，这些函数被称为exit handler（终止处理程序）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>atexit</code>的参数是一个函数地址，不会有返回值</li>
<li><code>exit</code>调用<code>atexit</code> register的程序的顺序和使用<code>atexit</code>进行register的顺序相反。</li>
<li>ISO C和POSIX.1标准规定，<code>exit</code>首先调用各个exit handler，然后使用<code>fclose</code>关闭所有标准I/O流。</li>
<li>POSIX.1对ISO C进行了扩展，如果程序调用了任何<code>exec</code>函数，清除exit handler。</li>
<li>内核执行一个程序的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一办法是显式或者隐式的（通过<code>exit</code>）调用<code>_exit</code>和<code>_Exit</code>。</li>
</ol>
<h2 id="c程序的存储空间布局">C程序的存储空间布局</h2>
<p>更多关于C程序存储空间布局可以查看<a href="https://mxxhcm.github.io/2019/10/19/C-program-memory-layout/">C/C++ program memory layout</a>。</p>
<h2 id="共享库">共享库</h2>
<p>共享库使得可执行文件中不再需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，使用动态链接的方法将程序和共享库函数链接，这减少了每个可执行文件的长度，但是增加了一些时间运行开销。这种时间开销发生在程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个优点是可以使用库函数的新版本代替老版本而无需对使用该库的程序重新链接和编辑。</p>
<h2 id="内存空间分配">内存空间分配</h2>
<p>ISO C说明了三个用于memory allocation的函数，<code>malloc</code>, <code>calloc</code>和<code>realloc</code>，它们的原型如下，更多关于C中<code>malloc</code>的内容可以查看<a href>C/C++ malloc(alloc) free new and delete</a>。</p>
<h3 id="malloc-calloc和realloc原型"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reallocarray</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-calloc和realloc属性"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>属性</h3>
<ol>
<li><code>malloc</code>，分配指定字节的内存空间，初始值不定。</li>
<li><code>calloc</code>，为指定长度的固定数量的对象分配空间，每一个bit都被初始化为0。</li>
<li><code>realloc</code>，增加或者减少已经分配的内存空间的大小。当这个大小增加时，可能需要将之前分配的空间中的数据移到另一个足够大的区域以便于增加大小，新增加的区域内的值是不确定的。</li>
<li>这三个函数返回的指针一定是对齐的，保证它可以用于任何对象。比如<code>double</code>的要求最严格，需要从8的倍数的地址单元开始，这三个函数返回的地址一定满足这个要求。</li>
<li>它们的返回类型都是<code>void*</code>，需要使用强制类型转换。</li>
<li><code>realloc</code>函数可以增加或者减少之前分配的内存空间的大小。比如分配了一个固定大小的数组，后来发小它不够用了，可以使用<code>realloc</code>对它进行扩充，如果原有的存储后有足够的大小进行扩充，则可以在原存储区的位置上向高地址进行扩充，无需移动原有数组，返回和传入相同的指针。如果原来的内存空间后没有足够的空间，就重新分配一个足够大的内存空间，再将原有数据的内容复制过去，然后释放原来的内存空间，返回新的指针。</li>
<li><code>realloc</code>传入的参数是存储区的新长度。如果传入的<code>ptr</code>参数是<code>NULL</code>指针，那就退化成了<code>malloc</code>。</li>
<li><code>free</code>可以释放<code>ptr</code>指向的内存空间，释放的空间通常送入可用内存池，之后可以通过这三个函数重新分配。</li>
<li><code>malloc</code>和<code>free</code>底层通常使用<code>sbrk</code>系统调用实现，这个系统调用扩充或者减小进程的堆，虽然<code>sbrk</code>可以扩充或者缩小进程的堆，但是一般<code>malloc</code>和<code>free</code>的实现不会减少进程的内存空间，释放的内存空间保存在<code>malloc</code>池中，而不是交给内核。</li>
<li>大多数实现分配的空间要比请求的空间大一些，因为需要存储一些管理信息，如block的大小，指向下一个block的指针等等。因此，如果对超过一个分配区域的内存进行读写的话，会造成很严重的错误。</li>
<li><code>free</code>一个已经释放了的块，<code>free</code>的不是<code>alloc</code>函数的返回值，没有进行<code>free</code>等等，都有可能造成很严重的后果。</li>
</ol>
<h2 id="环境变量">环境变量</h2>
<p>环境变量的形式是：<br>
<code>name = value</code><br>
UNIX内核并不使用环境变量，通常都是应用程序使用这些环境变量。比如shell使用了大量的环境变量。</p>
<h3 id="标准定义">标准定义</h3>
<p>ISO C定义了<code>getenv</code>函数可以获取环境变量。但是ISO C没有定义任何环境变量，SUS环境变量包括POSIX.1和XSI环境变量。<br>
除了获取环境变量，有时候我们也需要设置环境变量。ISO C没有定义获取环境变量的函数。SUS除了定义了ISO C，还定义了<code>putenv</code>, <code>setenv</code>和<code>unsetenv</code>对环境变量进行操作。</p>
<h3 id="putenv-setenv和unsetenv原型"><code>putenv</code>,<code>setenv</code>和<code>unsetenv</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="putenv-setenv和unsetenv性质"><code>putenv</code>,<code>setenv</code>和<code>unsetenv</code>性质</h3>
<ol>
<li><code>putenv</code>，创建或者重置一个<code>name</code>。</li>
<li><code>setenv</code>，如果<code>name</code>不存在，创建<code>name</code>；如果<code>name</code>存在，<code>rewrite</code>不为零，重写，<code>rewrite</code>为零，不进行重写。</li>
<li><code>unsetenv</code>，移除<code>name</code>的定义。如果<code>name</code>不存在，不会出错。</li>
<li>环境变量的修改和增加可能会遇到一些问题。因为环境变量存放在进程地址空间的最上面的一个不可扩展的空间。<br>
<strong>如果修改一个存在的<code>name</code></strong>：<br>
当新的<code>value</code>的长度小于等于原来的<code>value</code>长度时，直接覆盖就行；<br>
当新的<code>value</code>的长度大于原来的<code>value</code>长度时，只需要给新的<code>name-value</code>字符串分配空间就行了。使用<code>malloc</code>为新的字符串分配空间，然后将该字符串复制到新的空间，让environment list中<code>name</code>的指针指向新分配的存放字符串的空间即可。</li>
</ol>
<p><strong>如果增加一个新的<code>name</code>，不仅需要给新的<code>name-value</code>分配空间，指针数组的元素也增加了，还需要给指针数组分配新的空间</strong>。首先给新的<code>name-value</code>字符串分配空间，调用<code>malloc</code>先为字符串分配空间，然后将该字符串复制到这个空间：<br>
如果这是第一次增加一个<code>name</code>，必须调用<code>malloc</code>为指针数组增加空间。将原来的指针数组复制到新分配的空间中，然后将新字符串的指针放在指针数组的尾部，然后存放一个空指针。最后让全局变量<code>char **environ</code>指向这个指针数组。如果原来的指针数组存放在栈顶之上，需要将它复制到堆中。需要注意的是，这个指针数组中的未修改的环境变量的指针还是指向栈顶的字符串上。<br>
如果这不是第一个添加<code>name</code>，只需要使用<code>realloc</code>重新多分配一个指针数组的空间即可，然后将它指向新字符串的地址即可。</p>
<h2 id="setjmp和longjmp"><code>setjmp</code>和<code>longjmp</code></h2>
<h3 id="setjmp和longjmp原型"><code>setjmp</code>和<code>longjmp</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="setjmp和longjmp属性"><code>setjmp</code>和<code>longjmp</code>属性</h3>
<ol>
<li>自动变量存储在每个函数的栈帧中。</li>
<li><code>setjmp</code>和<code>longjmp</code>实在栈上跳过若干调用栈，返回到当前函数调用路径上的某个函数中。</li>
</ol>
<h2 id="getrlimit和setrlimit"><code>getrlimit</code>和<code>setrlimit</code></h2>
<p>每个进程能使用的资源都是有限的，可以使用<code>getrlimt</code>和<code>setrlimit</code>进行修改。它们都是XSI扩展，不是ISO C的定义。有些资源可以设置为<code>RLIM_INFINITY</code>，表示无限。</p>
<h3 id="getrlimit和setrlimit性质"><code>getrlimit</code>和<code>setrlimit</code>性质</h3>
<ol>
<li>任何一个进程都可以将<code>rlim_cur</code>改为小于等于<code>rlim_max</code>。</li>
<li>任何一个进程都可以将<code>rlim_max</code>改小，但是不能小于<code>rlim_cur</code>，且这个更改是不可逆的。</li>
<li>只有root用户可以更改<code>rlim_max</code>。</li>
</ol>
<p>它们的原型原型如下：</p>
<h3 id="getrlimit和setrlimit原型"><code>getrlimit</code>和<code>setrlimit</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="resource种类">resource种类</h4>
<ul>
<li>RLIMIT_AS</li>
<li>RLIMIT_VMEM</li>
<li>RLIMIT_DATA</li>
<li>RLIMIT_SWAP</li>
<li>RLIMIT_STACK</li>
<li>RLIMIT_NPROC</li>
<li>RLIMIT_FSIZE</li>
<li>RLIMIT_NOFILE</li>
<li>RLIMIT_NICE</li>
<li>…</li>
</ul>
<h4 id="结构体">结构体</h4>
<p>结构体<code>struct rlimt</code>的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;    <span class="comment">// soft limit</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;    <span class="comment">// hard limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>《APUE》第三版</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/24/UNIX-system-data-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/24/UNIX-system-data-file/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX system data file</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 14:17:20" itemprop="dateCreated datePublished" datetime="2019-11-24T14:17:20+08:00">2019-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-20 11:57:53" itemprop="dateModified" datetime="2020-02-20T11:57:53+08:00">2020-02-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="系统文件">系统文件</h2>
<table>
<thead>
<tr>
<th style="text-align:center">文件名</th>
<th style="text-align:center">结构</th>
<th style="text-align:center">查看结构内容</th>
<th style="text-align:center">头文件</th>
<th style="text-align:center">查询函数</th>
<th style="text-align:center">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/etc/passwd</td>
<td style="text-align:center">passwd</td>
<td style="text-align:center">man 5 passwd</td>
<td style="text-align:center">pwd.h</td>
<td style="text-align:center">getpwnam, getpwuid</td>
<td style="text-align:center">可以使用vipw直接修改。</td>
</tr>
<tr>
<td style="text-align:center">/etc/shadow</td>
<td style="text-align:center">shadow</td>
<td style="text-align:center">man 5 shadow</td>
<td style="text-align:center">shadow.h</td>
<td style="text-align:center">getspnam</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/group</td>
<td style="text-align:center">group</td>
<td style="text-align:center">man 5 group</td>
<td style="text-align:center">grp.h</td>
<td style="text-align:center">getgrnam, getgrgid</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/hosts</td>
<td style="text-align:center">hostent</td>
<td style="text-align:center">man 5 hosts</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getnameinfo, getaddrinfo</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/networks</td>
<td style="text-align:center">netent</td>
<td style="text-align:center">man 5 networks</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getnetbyname, getnetbyaddr</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/protocols</td>
<td style="text-align:center">protoent</td>
<td style="text-align:center">man 5 protocols</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getprotobyname, getprotobynumber</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/services</td>
<td style="text-align:center">servent</td>
<td style="text-align:center">man 5 services</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getservbyname, getservbyprot</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/var/run/utmp/,/var/log/wtmp/</td>
<td style="text-align:center">utmp</td>
<td style="text-align:center">man 5 utmp</td>
<td style="text-align:center">utmp.h</td>
<td style="text-align:center">getutid, getutline</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="其他操作">其他操作</h2>
<ol>
<li>查看整个口令文件：<code>struct pwd *getpwdent(void);</code><br>
<code>void setpwent(void);</code><br>
<code>void endpwent(void);</code></li>
<li>查看整个shadow文件:<code>struct pwd* getspent(void);</code><br>
<code>void setspent(void);</code><br>
<code>void endspent(void);</code></li>
<li>查看整个group文件：<code>struct pwd* getgrent(void);</code><br>
<code>void setgrent(void);</code><br>
<code>void endgrent(void);</code></li>
</ol>
<p>一般来说，对于第一节中列出的所有文件，都存在三个函数：<code>get</code>，<code>set</code>和<code>end</code>，它们的功能类型。<br>
第一次调用<code>get</code>函数，返回第一项，接下来顺序的返回文件中的每一项。<br>
<code>set</code>函数定位到数据库的开始位置。<br>
<code>end</code>函数关闭相应的数据库。</p>
<h2 id="附属组id">附属组ID</h2>
<p>使用newgrp(1)加GID在当前seeion内更改组ID，不加参数更改回原来的组(/etc/passwd)中的组。<br>
附属组ID的引入可以使得一个用户至多拥有16个另外的组（常用值是16）。<br>
有三个函数可以操作附属组ID：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前用户的至多size个gid，如果size=0，返回总共的附属组ID的个数，如果size!=0，返回实际写入数组中的组ID的个数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">gid_t</span> <span class="built_in">list</span>[])</span></span>;</span><br><span class="line"><span class="comment">// 为调用进程设置附属组ID。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">gid_t</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">// 为user初始化GID。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *user, <span class="keyword">gid_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="登录账户记录">登录账户记录</h2>
<p>utmp文件记录当前登录到系统的各个用户。<br>
wtmp文件记录各个登录和注销事件。<br>
同样，可以使用<code>struct utmp* getutent(void);</code><br>
<code>void setutent(void);</code><br>
<code>void endtuent(void);</code><br>
这三个访问。<br>
<code>who(1)</code>读取utmp文件。<br>
<code>last(1)</code>读取wtmp文件。</p>
<h2 id="系统标识">系统标识</h2>
<p>使用utsname(1)获得主机和操作系统相关的消息，通过定义在<code>&lt;sys/utsname.h&gt;</code>中的uname实现。<br>
使用hostname(1)获取和设置主机名，通过定义在<code>&lt;unistd.h&gt;</code>中的gethostname和sethostname实现。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">334</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
