<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/page/7/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/page/7/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/25/UNIX-Process-Environment/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/25/UNIX-Process-Environment/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX Process Environment</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-25 10:22:51" itemprop="dateCreated datePublished" datetime="2019-11-25T10:22:51+08:00">2019-11-25</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-02 10:54:56" itemprop="dateModified" datetime="2019-12-02T10:54:56+08:00">2019-12-02</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一部分介绍的是进程运行的环境。主要包括进程执行时，<code>main</code>函数是如何被调用的，命令行参数如何传递给进程的，进程的存储空间结构，如何分配存储空间，环境变量的使用，以及进程是怎么终止的。</p>
<h2 id="main函数和argc-argv"><code>main</code>函数和<code>argc</code>, <code>argv</code></h2>
<p>C语言总是从<code>main</code>函数开始执行，C语言中<code>main</code>有两个原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>其中<code>argc</code>是命令行参数的个数，<code>argv</code>是一个指针数组，ISO C和POSIX.1都要求<code>argv[argc]</code>设置为<code>NULL</code>，所以可以用它作为参数处理的循环终止条件。关于更多指针的信息可以查看<a href></a>。<br>
当内核执行C程序（使用一个<code>exec</code>函数）时，在调用<code>main</code>函数之前设置一个特殊的启动例程。可执行程序文件将这个启动例程指定为程序的起始地址，这是由link editor设置的，它会被C编译器调用。启动例程从内核命令获得命令行参数和环境变量值，然后为调用<code>main</code>函数做好准备。</p>
<p>关于更多C和C++中<code>main</code>的介绍，可以查看<a href="https://mxxhcm.github.io/2019/11/12/C-CPP-main-argc-argv/">C/C++ main argc argv</a>。</p>
<h2 id="全局变量environ">全局变量<code>environ</code></h2>
<p>每个C程序都会接收到一个environment list，和<code>argv</code>一样，它是一个指针数组。每个指针指向一个以<code>null</code>结束的C字符串的地址，这个指针数组的地址存放在全局变量<code>environ</code>中：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span> **environ;</span><br></pre></td></tr></table></figure></p>
<p>在历史上，UNIX大多支持三个参数的<code>main</code>函数，第三个参数就是environment list：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[], <span class="keyword">char</span> *envp[])</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>但是ISO C规定<code>main</code>只能有两个参数，POSIX.1也就规定使用全局变量<code>environ</code>而不是第三个参数。如果要查看所有的环境变量时，使用<code>environ</code>，而访问某个特定的环境变量时，使用<code>getenv</code>和<code>setenv</code>。</p>
<h2 id="进程终止">进程终止</h2>
<p>总共有八种方式可以让进程终止，包括五种正常和三种异常，前五种是正常终止，后五种是异常终止：</p>
<ol>
<li>从<code>main</code>返回</li>
<li>调用<code>exit</code></li>
<li>调用<code>_exit</code>或者<code>_Exit</code></li>
<li>最后一个线程从其启动例程返回</li>
<li>最后一个线程调用<code>pthread_exit</code></li>
<li>调用<code>abort</code></li>
<li>接到一个<code>signal</code></li>
<li>最后一个线程对取消请求做出响应</li>
</ol>
<h3 id="exit函数"><code>exit</code>函数</h3>
<h4 id="函数原型">函数原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">exit</span><span class="params">(<span class="keyword">int</span> status)</span></span>;</span><br><span class="line"><span class="keyword">void</span> _Exit(<span class="keyword">int</span> status);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> _exit(<span class="keyword">int</span> status);</span><br></pre></td></tr></table></figure>
<h4 id="性质">性质</h4>
<ol>
<li><code>exit</code>和<code>_Exit</code>是ISO C的内容，而<code>_exit</code>是POSIX.1的内容</li>
<li>它们都用于正常终止一个程序，<code>_Exit</code>和<code>_exit</code>立刻进入内核，而<code>exit</code>先执行一些清理操作，然后返回内核。<code>exit</code>函数总是执行一个标准I/O库的关闭操作，对于所有打开的流调用<code>fclose</code>函数，所有带有未写缓冲的标准I/O流被flush。</li>
<li>三个退出函数都需要一个整形的参数，被称为exit status。</li>
<li>如果满足以下条件：
<ul>
<li>调用这三个函数不带终止状态</li>
<li><code>main</code>执行了一个不带返回值的<code>return</code>语句</li>
<li><code>main</code>没有声明返回类型为整形，进程的终止状态是未定义的。<br>
那么这个进程的终止状态是未定义的。</li>
</ul>
</li>
<li><code>main</code>返回返回一个整型值和用该值调用<code>exit</code>是等价的。对于某些C编译器和UNIX lint(1)程序来说，会产生警告信息，因为这些编译器并不了解<code>main</code>中的<code>return</code>和<code>exit</code>的作用是相同的。避开这种警告信息的一种方法是在<code>main</code>中使用<code>return</code>而不是<code>exit</code>，这样做的结果是UNIX grep命令无法找出程序中所有的<code>exit</code>调用。另一个方法是将<code>main</code>声明为<code>void</code>而不是<code>int</code>，然后调用<code>exit</code>，但是这不并不是标准，ISO C和POSIX.1定义<code>main</code>的返回值应当是带符号整形。</li>
</ol>
<p>关于更多<code>exit</code>函数的内容，可以查看<a href></a>。<br>
关于<code>exit</code>和<code>return</code>的内容，更多可以查看<a href>C/C++ exit and return</a>。</p>
<h3 id="atexit"><code>atexit</code></h3>
<p>每个进程可以通过<code>atexit</code> register至多32个由<code>exit</code>自动调用的函数，这些函数被称为exit handler（终止处理程序）。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">atexit</span><span class="params">(<span class="keyword">void</span> (*function)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>atexit</code>的参数是一个函数地址，不会有返回值</li>
<li><code>exit</code>调用<code>atexit</code> register的程序的顺序和使用<code>atexit</code>进行register的顺序相反。</li>
<li>ISO C和POSIX.1标准规定，<code>exit</code>首先调用各个exit handler，然后使用<code>fclose</code>关闭所有标准I/O流。</li>
<li>POSIX.1对ISO C进行了扩展，如果程序调用了任何<code>exec</code>函数，清除exit handler。</li>
<li>内核执行一个程序的唯一方法是调用一个<code>exec</code>函数。进程自愿终止的唯一办法是显式或者隐式的（通过<code>exit</code>）调用<code>_exit</code>和<code>_Exit</code>。</li>
</ol>
<h2 id="c程序的存储空间布局">C程序的存储空间布局</h2>
<p>更多关于C程序存储空间布局可以查看<a href="https://mxxhcm.github.io/2019/10/19/C-program-memory-layout/">C/C++ program memory layout</a>。</p>
<h2 id="共享库">共享库</h2>
<p>共享库使得可执行文件中不再需要包含公用的库函数，只需要在所有进程都可引用的存储区保存这种库例程的一个副本。程序第一次执行或者第一次调用某个库函数时，使用动态链接的方法将程序和共享库函数链接，这减少了每个可执行文件的长度，但是增加了一些时间运行开销。这种时间开销发生在程序第一次被执行时，或者每个共享库函数第一次被调用时。共享库的另一个优点是可以使用库函数的新版本代替老版本而无需对使用该库的程序重新链接和编辑。</p>
<h2 id="内存空间分配">内存空间分配</h2>
<p>ISO C说明了三个用于memory allocation的函数，<code>malloc</code>, <code>calloc</code>和<code>realloc</code>，它们的原型如下，更多关于C中<code>malloc</code>的内容可以查看<a href>C/C++ malloc(alloc) free new and delete</a>。</p>
<h3 id="malloc-calloc和realloc原型"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">calloc</span><span class="params">(<span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">realloc</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">reallocarray</span><span class="params">(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> nmemb, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="malloc-calloc和realloc属性"><code>malloc</code>, <code>calloc</code>和<code>realloc</code>属性</h3>
<ol>
<li><code>malloc</code>，分配指定字节的内存空间，初始值不定。</li>
<li><code>calloc</code>，为指定长度的固定数量的对象分配空间，每一个bit都被初始化为0。</li>
<li><code>realloc</code>，增加或者减少已经分配的内存空间的大小。当这个大小增加时，可能需要将之前分配的空间中的数据移到另一个足够大的区域以便于增加大小，新增加的区域内的值是不确定的。</li>
<li>这三个函数返回的指针一定是对齐的，保证它可以用于任何对象。比如<code>double</code>的要求最严格，需要从8的倍数的地址单元开始，这三个函数返回的地址一定满足这个要求。</li>
<li>它们的返回类型都是<code>void*</code>，需要使用强制类型转换。</li>
<li><code>realloc</code>函数可以增加或者减少之前分配的内存空间的大小。比如分配了一个固定大小的数组，后来发小它不够用了，可以使用<code>realloc</code>对它进行扩充，如果原有的存储后有足够的大小进行扩充，则可以在原存储区的位置上向高地址进行扩充，无需移动原有数组，返回和传入相同的指针。如果原来的内存空间后没有足够的空间，就重新分配一个足够大的内存空间，再将原有数据的内容复制过去，然后释放原来的内存空间，返回新的指针。</li>
<li><code>realloc</code>传入的参数是存储区的新长度。如果传入的<code>ptr</code>参数是<code>NULL</code>指针，那就退化成了<code>malloc</code>。</li>
<li><code>free</code>可以释放<code>ptr</code>指向的内存空间，释放的空间通常送入可用内存池，之后可以通过这三个函数重新分配。</li>
<li><code>malloc</code>和<code>free</code>底层通常使用<code>sbrk</code>系统调用实现，这个系统调用扩充或者减小进程的堆，虽然<code>sbrk</code>可以扩充或者缩小进程的堆，但是一般<code>malloc</code>和<code>free</code>的实现不会减少进程的内存空间，释放的内存空间保存在<code>malloc</code>池中，而不是交给内核。</li>
<li>大多数实现分配的空间要比请求的空间大一些，因为需要存储一些管理信息，如block的大小，指向下一个block的指针等等。因此，如果对超过一个分配区域的内存进行读写的话，会造成很严重的错误。</li>
<li><code>free</code>一个已经释放了的块，<code>free</code>的不是<code>alloc</code>函数的返回值，没有进行<code>free</code>等等，都有可能造成很严重的后果。</li>
</ol>
<h2 id="环境变量">环境变量</h2>
<p>环境变量的形式是：<br>
<code>name = value</code><br>
UNIX内核并不使用环境变量，通常都是应用程序使用这些环境变量。比如shell使用了大量的环境变量。</p>
<h3 id="标准定义">标准定义</h3>
<p>ISO C定义了<code>getenv</code>函数可以获取环境变量。但是ISO C没有定义任何环境变量，SUS环境变量包括POSIX.1和XSI环境变量。<br>
除了获取环境变量，有时候我们也需要设置环境变量。ISO C没有定义获取环境变量的函数。SUS除了定义了ISO C，还定义了<code>putenv</code>, <code>setenv</code>和<code>unsetenv</code>对环境变量进行操作。</p>
<h3 id="putenv-setenv和unsetenv原型"><code>putenv</code>,<code>setenv</code>和<code>unsetenv</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putenv</span><span class="params">(<span class="keyword">char</span> *<span class="built_in">string</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> *value, <span class="keyword">int</span> overwrite)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unsetenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="putenv-setenv和unsetenv性质"><code>putenv</code>,<code>setenv</code>和<code>unsetenv</code>性质</h3>
<ol>
<li><code>putenv</code>，创建或者重置一个<code>name</code>。</li>
<li><code>setenv</code>，如果<code>name</code>不存在，创建<code>name</code>；如果<code>name</code>存在，<code>rewrite</code>不为零，重写，<code>rewrite</code>为零，不进行重写。</li>
<li><code>unsetenv</code>，移除<code>name</code>的定义。如果<code>name</code>不存在，不会出错。</li>
<li>环境变量的修改和增加可能会遇到一些问题。因为环境变量存放在进程地址空间的最上面的一个不可扩展的空间。<br>
<strong>如果修改一个存在的<code>name</code></strong>：<br>
当新的<code>value</code>的长度小于等于原来的<code>value</code>长度时，直接覆盖就行；<br>
当新的<code>value</code>的长度大于原来的<code>value</code>长度时，只需要给新的<code>name-value</code>字符串分配空间就行了。使用<code>malloc</code>为新的字符串分配空间，然后将该字符串复制到新的空间，让environment list中<code>name</code>的指针指向新分配的存放字符串的空间即可。</li>
</ol>
<p><strong>如果增加一个新的<code>name</code>，不仅需要给新的<code>name-value</code>分配空间，指针数组的元素也增加了，还需要给指针数组分配新的空间</strong>。首先给新的<code>name-value</code>字符串分配空间，调用<code>malloc</code>先为字符串分配空间，然后将该字符串复制到这个空间：<br>
如果这是第一次增加一个<code>name</code>，必须调用<code>malloc</code>为指针数组增加空间。将原来的指针数组复制到新分配的空间中，然后将新字符串的指针放在指针数组的尾部，然后存放一个空指针。最后让全局变量<code>char **environ</code>指向这个指针数组。如果原来的指针数组存放在栈顶之上，需要将它复制到堆中。需要注意的是，这个指针数组中的未修改的环境变量的指针还是指向栈顶的字符串上。<br>
如果这不是第一个添加<code>name</code>，只需要使用<code>realloc</code>重新多分配一个指针数组的空间即可，然后将它指向新字符串的地址即可。</p>
<h2 id="setjmp和longjmp"><code>setjmp</code>和<code>longjmp</code></h2>
<h3 id="setjmp和longjmp原型"><code>setjmp</code>和<code>longjmp</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;setjmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setjmp</span><span class="params">(jmp_buf env)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">longjmp</span><span class="params">(jmp_buf env, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="setjmp和longjmp属性"><code>setjmp</code>和<code>longjmp</code>属性</h3>
<ol>
<li>自动变量存储在每个函数的栈帧中。</li>
<li><code>setjmp</code>和<code>longjmp</code>实在栈上跳过若干调用栈，返回到当前函数调用路径上的某个函数中。</li>
</ol>
<h2 id="getrlimit和setrlimit"><code>getrlimit</code>和<code>setrlimit</code></h2>
<p>每个进程能使用的资源都是有限的，可以使用<code>getrlimt</code>和<code>setrlimit</code>进行修改。它们都是XSI扩展，不是ISO C的定义。有些资源可以设置为<code>RLIM_INFINITY</code>，表示无限。</p>
<h3 id="getrlimit和setrlimit性质"><code>getrlimit</code>和<code>setrlimit</code>性质</h3>
<ol>
<li>任何一个进程都可以将<code>rlim_cur</code>改为小于等于<code>rlim_max</code>。</li>
<li>任何一个进程都可以将<code>rlim_max</code>改小，但是不能小于<code>rlim_cur</code>，且这个更改是不可逆的。</li>
<li>只有root用户可以更改<code>rlim_max</code>。</li>
</ol>
<p>它们的原型原型如下：</p>
<h3 id="getrlimit和setrlimit原型"><code>getrlimit</code>和<code>setrlimit</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/resource.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit *rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit *rlim)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="resource种类">resource种类</h4>
<ul>
<li>RLIMIT_AS</li>
<li>RLIMIT_VMEM</li>
<li>RLIMIT_DATA</li>
<li>RLIMIT_SWAP</li>
<li>RLIMIT_STACK</li>
<li>RLIMIT_NPROC</li>
<li>RLIMIT_FSIZE</li>
<li>RLIMIT_NOFILE</li>
<li>RLIMIT_NICE</li>
<li>…</li>
</ul>
<h4 id="结构体">结构体</h4>
<p>结构体<code>struct rlimt</code>的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur;    <span class="comment">// soft limit</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max;    <span class="comment">// hard limit</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li>《APUE》第三版</li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/24/UNIX-system-data-file/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/24/UNIX-system-data-file/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX system data file</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 14:17:20" itemprop="dateCreated datePublished" datetime="2019-11-24T14:17:20+08:00">2019-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-02-20 11:57:53" itemprop="dateModified" datetime="2020-02-20T11:57:53+08:00">2020-02-20</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="系统文件">系统文件</h2>
<table>
<thead>
<tr>
<th style="text-align:center">文件名</th>
<th style="text-align:center">结构</th>
<th style="text-align:center">查看结构内容</th>
<th style="text-align:center">头文件</th>
<th style="text-align:center">查询函数</th>
<th style="text-align:center">其他</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">/etc/passwd</td>
<td style="text-align:center">passwd</td>
<td style="text-align:center">man 5 passwd</td>
<td style="text-align:center">pwd.h</td>
<td style="text-align:center">getpwnam, getpwuid</td>
<td style="text-align:center">可以使用vipw直接修改。</td>
</tr>
<tr>
<td style="text-align:center">/etc/shadow</td>
<td style="text-align:center">shadow</td>
<td style="text-align:center">man 5 shadow</td>
<td style="text-align:center">shadow.h</td>
<td style="text-align:center">getspnam</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/group</td>
<td style="text-align:center">group</td>
<td style="text-align:center">man 5 group</td>
<td style="text-align:center">grp.h</td>
<td style="text-align:center">getgrnam, getgrgid</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/hosts</td>
<td style="text-align:center">hostent</td>
<td style="text-align:center">man 5 hosts</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getnameinfo, getaddrinfo</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/networks</td>
<td style="text-align:center">netent</td>
<td style="text-align:center">man 5 networks</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getnetbyname, getnetbyaddr</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/protocols</td>
<td style="text-align:center">protoent</td>
<td style="text-align:center">man 5 protocols</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getprotobyname, getprotobynumber</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/etc/services</td>
<td style="text-align:center">servent</td>
<td style="text-align:center">man 5 services</td>
<td style="text-align:center">netdb.h</td>
<td style="text-align:center">getservbyname, getservbyprot</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">/var/run/utmp/,/var/log/wtmp/</td>
<td style="text-align:center">utmp</td>
<td style="text-align:center">man 5 utmp</td>
<td style="text-align:center">utmp.h</td>
<td style="text-align:center">getutid, getutline</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h2 id="其他操作">其他操作</h2>
<ol>
<li>查看整个口令文件：<code>struct pwd *getpwdent(void);</code><br>
<code>void setpwent(void);</code><br>
<code>void endpwent(void);</code></li>
<li>查看整个shadow文件:<code>struct pwd* getspent(void);</code><br>
<code>void setspent(void);</code><br>
<code>void endspent(void);</code></li>
<li>查看整个group文件：<code>struct pwd* getgrent(void);</code><br>
<code>void setgrent(void);</code><br>
<code>void endgrent(void);</code></li>
</ol>
<p>一般来说，对于第一节中列出的所有文件，都存在三个函数：<code>get</code>，<code>set</code>和<code>end</code>，它们的功能类型。<br>
第一次调用<code>get</code>函数，返回第一项，接下来顺序的返回文件中的每一项。<br>
<code>set</code>函数定位到数据库的开始位置。<br>
<code>end</code>函数关闭相应的数据库。</p>
<h2 id="附属组id">附属组ID</h2>
<p>使用newgrp(1)加GID在当前seeion内更改组ID，不加参数更改回原来的组(/etc/passwd)中的组。<br>
附属组ID的引入可以使得一个用户至多拥有16个另外的组（常用值是16）。<br>
有三个函数可以操作附属组ID：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获得当前用户的至多size个gid，如果size=0，返回总共的附属组ID的个数，如果size!=0，返回实际写入数组中的组ID的个数。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getgroups</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">gid_t</span> <span class="built_in">list</span>[])</span></span>;</span><br><span class="line"><span class="comment">// 为调用进程设置附属组ID。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgroups</span><span class="params">(<span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">gid_t</span> *<span class="built_in">list</span>)</span></span>;</span><br><span class="line"><span class="comment">// 为user初始化GID。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">initgroups</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *user, <span class="keyword">gid_t</span> group)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="登录账户记录">登录账户记录</h2>
<p>utmp文件记录当前登录到系统的各个用户。<br>
wtmp文件记录各个登录和注销事件。<br>
同样，可以使用<code>struct utmp* getutent(void);</code><br>
<code>void setutent(void);</code><br>
<code>void endtuent(void);</code><br>
这三个访问。<br>
<code>who(1)</code>读取utmp文件。<br>
<code>last(1)</code>读取wtmp文件。</p>
<h2 id="系统标识">系统标识</h2>
<p>使用utsname(1)获得主机和操作系统相关的消息，通过定义在<code>&lt;sys/utsname.h&gt;</code>中的uname实现。<br>
使用hostname(1)获取和设置主机名，通过定义在<code>&lt;unistd.h&gt;</code>中的gethostname和sethostname实现。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/24/linux-glibc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/24/linux-glibc/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">linux glibc</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-24 11:57:59" itemprop="dateCreated datePublished" datetime="2019-11-24T11:57:59+08:00">2019-11-24</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 17:01:53" itemprop="dateModified" datetime="2019-12-17T17:01:53+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/linux/" itemprop="url" rel="index"><span itemprop="name">linux</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="查看当前linux系统的glibc版本">查看当前linux系统的glibc版本</h2>
<blockquote>
<p>ldd --version</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldd (Ubuntu GLIBC 2.27-3ubuntu1) 2.27</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">This is free software; see the source for copying conditions.  There is NO</span><br><span class="line">warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.</span><br><span class="line">Written by Roland McGrath and Ulrich Drepper.</span><br></pre></td></tr></table></figure>
<p>我的笔记本上的glibc是2.27版本。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://www.linuxquestions.org/questions/linux-software-2/how-to-check-glibc-version-263103/" target="_blank" rel="noopener">https://www.linuxquestions.org/questions/linux-software-2/how-to-check-glibc-version-263103/</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/22/C-standard-IO-library/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/22/C-standard-IO-library/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">C (ISO C) Standard I/O library</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-22 23:28:22" itemprop="dateCreated datePublished" datetime="2019-11-22T23:28:22+08:00">2019-11-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-18 23:02:58" itemprop="dateModified" datetime="2019-12-18T23:02:58+08:00">2019-12-18</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="总结">总结</h2>
<ol>
<li><code>fgets</code>, <code>sprintf</code>, <code>snprintf</code>会在缓冲区数组的结尾加上一个null字节，但是使用的时候不会包含这个字节。</li>
<li><code>fgets</code>和<code>getline</code>都会读入回车，并且将它存入缓冲区，<code>getchar</code>, <code>getc</code>和<code>fgetc</code>也会读入回车，并且将它存起来。</li>
<li>每个标准I/O流都有一个和它相关联的文件描述符，可以对一个流调用<code>fileno</code>获得它的文件描述符。<code>fileno</code>不是ISO C的部分，因为文件描述符不属于ISO C。</li>
<li>标准I/O库的一个不足是效率不高。这和它复制的数据量有关。每当使用一次<code>fgets</code>和<code>fputs</code>时，通常需要复制两次数据，一次是在用户程序的行缓冲区和标准I/O缓冲区之间，一次是在内核和标准I/O缓冲区之间。<br>
使用<code>fgets</code>需要用户指定<code>fgets</code>使用的缓冲区，或者使用<code>getline</code>，如果传入的指针指向NULL，<code>getline</code>会负责分配缓冲区大小。<br>
<code>read</code>和<code>write</code>需要设置缓冲区，这是系统调用级别的，大小可以任意指定，通常使用<code>sturct stat.st_blksize</code>的大小，用户如果直接调用<code>read</code>和<code>write</code>的话，需要自己设置缓冲区。而标准I/O库可以自己选择是否进行缓冲，如果缓冲的话，标准I/O库可以负责进行缓冲区大小选择和分配，也可以用户自己进行指定缓冲类型：行缓冲和全缓冲，用户也可以自己通过<code>setbuf</code>和<code>setvbuf</code>更改缓冲区大小和地址。而在<code>setbuf</code>中，如果<code>buf</code>是<code>NULL</code>的话，是关闭缓冲区，如果不为空的话，必须是<code>BUFSIZ</code>大小。在<code>setvbuf</code>中，通过<code>mode</code>指定缓冲区的类型，<code>buf</code>是<code>NULL</code>的话，库函数负责分配缓冲区。否则<code>buf</code>是多大就用多大的缓冲区。<br>
而在内核中，还存在buffer cache和page cache，用于“延迟写”，减少和磁盘的交互。</li>
</ol>
<h2 id="概述">概述</h2>
<h3 id="特殊符号的ascii">特殊符号的ASCII</h3>
<p>'\n’是10。<br>
EOF是-1。</p>
<h3 id="标准i-o和文件i-o">标准I/O和文件I/O</h3>
<p>文件I/O是围绕文件描述符进行的，使用<code>open</code>打开一个文件时，返回一个文件描述符，然后使用文件描述符进行后续I/O操作。文件I/O是UNIX相关的实现，其他系统可能有不同的实现，是不跨平台的。<br>
标准I/O是围绕stream进行I/O操作的。当标准I/O库打开或者创建一个文件时，一个流已经和文件相关联。标准I/O库处理很多细节，比如缓冲区分配，使用优化的长度块执行I/O等，使用户不用担心选择多大的block进行I/O会更快。标准I/O库是ISO C标准定义的，不仅仅UNIX系统有实现，凡是支持ISO C标准的操作系统都应该实现，是支持跨平台的。标准I/O在UNIX上需要使用文件I/O实现，在windows等其他系统上就需要其他的实现。</p>
<h3 id="stream和file对象">stream和<code>FILE</code>对象</h3>
<blockquote>
<p>12.1 Streams<br>
For historical reasons, the type of the C data structure that represents a stream is called FILE rather than “stream”. Since most of the library functions deal with objects of type FILE *, sometimes the term file pointer is also used to mean “stream”. This leads to unfortunate confusion over terminology in many books on C.</p>
</blockquote>
<p>标准I/O的操作是围绕stream进行的，当打开一个stream时，它返回一个指向FILE类型的指针（通常叫做文件指针）。FILE是一个结构体，包含了标准I/O管理这个stream需要的所有信息，包含用于实际I/O的文件描述符，指向这个流缓冲区的指针，缓冲区的长度，当前缓冲区中的字符等。为了引用一个stream，需要将FILE指针作为参数传递给每个标准I/O函数。</p>
<h3 id="stream的定向">stream的定向</h3>
<p>对于ASCII字符集，一个字符用一个字节表示。对于国际字符集，一个字符用多个字节表示。标准I/O FILE stream可以用于单字节也可以用于多字节字符集。stream的orientation决定了读写的字符是单字节还是多字节，最开始创建stream时，它的orientation没有被确定，使用什么字符的I/O就会将stream的orientation定义为什么。<br>
有两个函数可以改变stream的orientation，它们是<code>freopen</code>和<code>fwide</code>，原型如下：</p>
<h3 id="freopen和fwide原型"><code>freopen</code>和<code>fwide</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fwide</span><span class="params">(FILE *stream, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="freopen和fwide性质"><code>freopen</code>和<code>fwide</code>性质</h3>
<ol>
<li><code>fwide</code>用于设置stream的orientation。如果<code>mode</code>为负，是单字节定向的。如果<code>mode</code>为正，是多字节定向的。如果<code>mode</code>为0，<code>fwide</code>确定当前stream的oritentation并返回。</li>
<li><code>fwide</code>不能改变已经定向的stream的orientation。</li>
<li><code>fwide</code>没有出错返回</li>
</ol>
<h3 id="标准输入-标准输出和标准错误">标准输入，标准输出和标准错误</h3>
<p>通常对一个进程预定义了三个stream，它们可以自动的被进程使用。它们是标准输入，标准输出和标准错误，这些stream引用的文件和文件描述符<code>STDIN_FILENO</code>,<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>所引用的文件一样。<br>
这三个stream定义在头文件<code>&lt;stdio.h&gt;</code>中，通过预定义文件指针<code>stdin</code>, <code>stdou</code>和<code>stderr</code>使用。</p>
<h2 id="三种缓冲类型">三种缓冲类型</h2>
<p>标准I/O库提供缓冲的目的是尽可能减少<code>read</code>和<code>write</code>的调用次数，标准I/O库对每个流自动的进行缓冲管理，使得应用程序不用考虑缓冲区的管理。<br>
标准I/O提供了三种类型的缓冲：</p>
<h3 id="全缓冲">全缓冲</h3>
<p>填满标准I/O的缓冲区之后，进行实际的I/O操作。对于存储在磁盘上的文件通常是由标准I/O实施全缓冲的。在一个流上第一次执行I/O操作时，相关的标准I/O函数调用<code>malloc</code>获得需要的缓冲区。</p>
<h3 id="行缓冲">行缓冲</h3>
<p>在行缓冲中，当输入和输出遇到换行符时，标准I/O库执行I/O操作。但是需要注意的是行缓冲区的长度是固定的，当行缓冲区满时即使没有遇到换行符也进行I/O操作。当涉及终端的I/O时，通常使用行缓冲。使用标准I/O的<code>fputc</code>允许我们一次输出一个字符，但是只有在写了一行之后才能进行实际I/O操作。<br>
此外，任何时候只要通过标准I/O库要求从一个不带缓冲的流或者一个行缓冲的流中得到输入数据，那么就会flush所有行缓冲输出流。从行缓冲的流中得到输入数据的一个例子就是从终端按下回车，刚才输入的数据就会立刻从输出流中输出。</p>
<h3 id="不带缓冲">不带缓冲</h3>
<p>标准I/O库不对字符进行缓冲存储。如果将字符传入不带缓冲的输出流中，字符会立即输出到输出流关联的文件或者设备。</p>
<h3 id="fflush函数"><code>fflush</code>函数</h3>
<p>标准I/O库使用flush将输出流缓冲区的内容写到和输出流相关联的文件，缓冲区可以使用标准I/O例程自动的flush，比如当缓冲区填满时，或者缓冲区不满时可以手动调用<code>fflush</code>函数进行flush。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">flussh</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>任何时候，都可以手动强制冲洗一个流，当<code>fp</code>是<code>NULL</code>时，冲洗所有的输出流。<br>
注意<code>fflush</code>和<code>fsync</code>的区别，<code>fflush</code>是将位于主存中的缓冲区的内存冲洗到内核。而内核也有一个缓冲区，叫做buffer cache或者page cache，内核接收到数据会首先将它们写入buffer cache或者page cache中，然后排入队列，晚些时候再写，这种方式叫做延迟写。<code>fsync</code>是将buff cache中的内容立即写入磁盘而不等待。</p>
<h3 id="iso-c缓冲标准和unix具体实现">ISO C缓冲标准和UNIX具体实现</h3>
<p>ISO C要求：</p>
<ol>
<li>当且仅当标准输入和标准输出不指向交互设备时，它们才是全缓冲的。</li>
<li>标准错误不会是全缓冲的。</li>
</ol>
<p>UNIX具体实现：</p>
<ol>
<li>标准错误不带缓冲</li>
<li>指向终端设备的流，都是行缓冲的，否则是全缓冲的。</li>
</ol>
<h3 id="修改默认缓冲">修改默认缓冲</h3>
<p>可以通过<code>setbuf</code>和<code>setvbuf</code>更改流的缓冲类型。</p>
<h3 id="setbuf和setvfuf原型"><code>setbuf</code>和<code>setvfuf</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setvbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">int</span> mode, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="setbuf和setvfuf性质"><code>setbuf</code>和<code>setvfuf</code>性质</h3>
<ol>
<li>这些函数需要在流被打开后调用，因为他们需要文件指针作为参数，而且应该在对流执行任何操作之前调用。</li>
<li>可以使用<code>setbuf</code>函数打开和关闭缓冲机制。将<code>buf</code>设置为<code>NULL</code>，就是关闭缓冲。如果<code>buf</code>不为<code>NULL</code>，它必须指向一个长度为<code>BUFSIZ</code>的缓冲区，通常在这之后就是全缓冲的，如果和终端设备关联，可能会是行缓冲的。</li>
<li><code>setvbuf</code>可以通过<code>mode</code>指定缓冲的类型，<code>_IOFBF</code>是全缓冲，<code>_IOLBF</code>是行缓冲，<code>_IONBF</code>是不缓冲。指定不缓冲，忽略<code>buf</code>和<code>size</code>参数。如果指定全缓冲或者行缓冲，<code>buf</code>和<code>size</code>可以通过<code>buf</code>和<code>size</code>指定缓冲区的位置和大小。如果指定带缓冲，而<code>buf</code>是<code>NULL</code>，系统会自动分配<code>BUFSIZE</code>大小的缓冲区。</li>
<li>一般而言，应该由操作系统选择缓冲区的长度，并且自动分配缓冲区，这种情况下，关闭流，标准I/O库会自动释放缓冲区。</li>
</ol>
<h2 id="打开一个stream">打开一个stream</h2>
<p>可以使用<code>fopen</code>, <code>freopen</code>和<code>fdopen</code>函数打开一个standard I/O stream。它们的原型如下：</p>
<h3 id="fopen-freopen和fdopen原型"><code>fopen</code>, <code>freopen</code>和<code>fdopen</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">fdopen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">freopen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> <span class="keyword">char</span> *mode, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="fopen-freopen和fdopen性质"><code>fopen</code>, <code>freopen</code>和<code>fdopen</code>性质</h3>
<ol>
<li><code>fopen</code>打开路径名为<code>pathname</code>的一个文件</li>
<li><code>fdopen</code>使用一个已有的文件描述符，并将一个标准I/O stream和该文件描述符结合。<strong>这个函数通常用于由创建管道和网络通信通道函数返回的文件描述符，因为这些特殊文件不能使用标准I/O函数<code>fopen</code>打开，所以需要使用设备专用函数获得一个文件描述符，然后使用<code>fdopen</code>将文件描述符和一个I/O stream结合。</strong></li>
<li><code>freopen</code>函数在一个指定的stream打开一个指定的文件，如果这个stream已经打开，先关闭这个stream；如果这个stream已经进行了定向，使用<code>freopen</code>清楚该定向。<strong>这个函数一般用于将一个指定的文件打开为一个预定义的stream：stdin, stdout和stderr。</strong></li>
<li><code>fopen</code>和<code>freopen</code>是ISO C的部分，因为ISO C不包含文件描述符，所以只有POSIX.1有<code>fdopen</code>。</li>
<li><code>mode</code>有15种取值：<code>r</code>, <code>w</code>, <code>a</code>, <code>rb</code>, <code>wb</code>, <code>ab</code>,<code>r+</code>,<code>r+b</code>, <code>rb+</code>,<code>w+</code>,<code>w+b</code>,<code>wb+</code>, <code>a+</code>, <code>a+b</code>, <code>ab+</code>。对于标准I/O来说，使用<code>b</code>可以区分二进制和文本文件。但是对于UNIX来说，二进制和文本文件没有区别，有没有<code>b</code>无所谓。</li>
<li>当用追加写时，如果有多个进程用追加写方式打开同一个文件，每个进程的数据都会正确的写入文件中。</li>
<li><code>fdopen</code>不会截断也不会创建文件。对于<code>fdopen</code>来说，因为需要文件描述符，所以文件必须是打开的，当<code>mode</code>是<code>w</code>,<code>wb</code>时，并不会截断文件，<code>a</code>和<code>ab</code>也不能用于创建文件，因为文件描述符必须引用一个存在的文件。而如果使用<code>a+</code>, <code>ab+</code>, <code>w+</code>, <code>wb+</code>等，这个时候文件已经存在了，不会创建，也不会截断，需要写或者追加就行了，就不会有前半句说的问题了。</li>
<li>使用<code>a</code>和<code>w</code>相关的<code>mode</code>创建文件时，没有办法指定文件的权限位。而POSIX.1要求使用如下的权限创建文件：<br>
<code>S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IOTH|S_IWOTH</code><br>
可以在使用<code>fopen</code>等函数之前，使用<code>umask</code>指定文件的权限位。</li>
<li>如果流引用终端设备，是行缓冲的，否则是全缓冲的。</li>
</ol>
<h3 id="fclose函数和性质"><code>fclose</code>函数和性质</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fclose</span><span class="params">(FILE *fp)</span></span>;</span><br></pre></td></tr></table></figure>
<p>在文件被关闭之前，flush输出数据。缓冲区中的输入数据被丢弃。如果标准I/O库为这个stream自动分配了缓冲区，释放该缓冲区。<br>
当一个进程正常终止时，所有带未写缓冲数据的标准I/O都被flush，所有打开的标准I/O都被关闭。</p>
<h2 id="读写stream">读写stream</h2>
<p>对于一个打开的stream，可以使用3种不同的类型的非格式化I/O以及格式化I/O，对其进行读写操作。<br>
3种非格式化I/O包括：</p>
<ol>
<li>单字符的I/O。如果流是带缓冲的，标准I/O会负责处理缓冲。</li>
<li>单行的I/O。<strong>这里需要注意一下，单行I/O指定的buffer和标准I/O的buffer不一样。</strong></li>
<li>直接I/O（direct I/O）。</li>
</ol>
<h2 id="ferror和feof-clearerr函数和属性"><code>ferror</code>和<code>feof</code>, <code>clearerr</code>函数和属性</h2>
<p>不管是出错还是到达文件结束，<code>getc</code>,<code>fgetc</code>和<code>ungetc</code>等许多函数都返回同样的值<code>EOF</code>，<code>EOF</code>是-1，可以使用<code>ferro</code>和<code>feof</code>判断到底是出错还是到达文件尾端。大多数实现中是为每个流在<code>FILE</code>对象中维护了出错标志和文件结束标志，可以使用<code>clearerr</code>清除相应的标志。函数的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearerr</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">feof</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ferror</span><span class="params">(FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="单字符i-o">单字符I/O</h2>
<p><code>getc</code>, <code>fgetc</code>和<code>getchar</code>函数可以用于一个读一个字符。它们的原型如下：</p>
<h3 id="getc-fgetc和getchar-ungetc原型"><code>getc</code>, <code>fgetc</code>和<code>getchar</code>, <code>ungetc</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getc</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getchar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="getc-fgetc和getchar-ungetc性质"><code>getc</code>, <code>fgetc</code>和<code>getchar</code>, <code>ungetc</code>性质</h3>
<p><code>getc</code>和<code>fgetc</code>功能一样，只不过<code>getc</code>可以被实现为宏，而<code>fgetc</code>不能被实现为宏。所以：</p>
<ol>
<li><code>getc</code>的参数不应该是具有副作用的表达式，因为它可能会被计算多次。</li>
<li><code>fgetc</code>一定是函数，所以可以得到它的地址。可以当做参数传递给其他函数。</li>
<li><code>fgetc</code>的调用时间通常要比<code>getc</code>长，因为调用函数的时间通常比调用宏的时间长。</li>
</ol>
<h3 id="ungetchar函数和属性"><code>ungetchar</code>函数和属性</h3>
<ol>
<li>从流中读取的数据可以送回流中。</li>
<li>ISO C规定可以支持任何次数的回送，但是一次只能送一个字符。</li>
<li>回送的字符可以不是上次读到的字符。</li>
<li>回送的字符不能是<code>EOF</code>，但是读到文件尾端时，还可以回送一个字符，因为一次成功的<code>ungetc</code>调用会清除<code>EOF</code>标志。</li>
<li>用<code>ungetc</code>只能将字符写入到标准I/O库的流缓冲区中，并没有将它们写到底层设备或者文件中。</li>
</ol>
<p>函数的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ungetc</span><span class="params">(<span class="keyword">int</span> c, FILE* fp)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="输出函数putc-fputc和putchar">输出函数<code>putc</code>, <code>fputc</code>和<code>putchar</code></h3>
<p>它们的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putc</span><span class="params">(<span class="keyword">int</span> c, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">putchar</span><span class="params">(<span class="keyword">int</span> c)</span></span>;     <span class="comment">//相当于putc(c, stdout);</span></span><br></pre></td></tr></table></figure></p>
<h2 id="单行i-o">单行I/O</h2>
<p><code>fgets</code>和<code>gets</code>,<code>getline</code>提供了单行输入的功能，单行I/O需要指定一个缓冲区，这个缓冲区是用户自己定义的，是应用程序级别的，它和标准I/O的buffer不一样，我们可以通过<code>setbuf</code>和<code>setvbuf</code>设置标准I/O的buffer，这是标准I/O即库函数层级的，而<code>read</code>和<code>write</code>等使用的buffer又是一类buffer，这是系统调用层级的，我们也可以自己指定。<br>
它们的原型如下：</p>
<h3 id="fgets和gets-getline原型"><code>fgets</code>和<code>gets</code>,<code>getline</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">gets</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="keyword">ssize_t</span> getline(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, FILE *stream);</span><br><span class="line"><span class="keyword">ssize_t</span> getdelim(<span class="keyword">char</span> **lineptr, <span class="keyword">size_t</span> *n, <span class="keyword">int</span> delim, FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="fgets和gets-getline性质"><code>fgets</code>和<code>gets</code>,<code>getline</code>性质</h3>
<ol>
<li><code>gets</code>从标准输入读，而<code>fgets</code>从指定的流中读</li>
<li><code>gets</code>不会读入<code>'\n'</code>，而<code>fgets</code>, <code>getline</code>都会读入<code>'\n'</code>;</li>
<li><code>fgets</code>需要指定缓冲的长度，遇到<code>&quot;\n&quot;</code>停止，但是不能超过<code>n-1</code>个字符，读入的字符送入缓冲区。缓冲区以<code>NULL</code>字节结尾，如果这一行包含最后一个换行符超过了<code>n-1</code>个字符，<code>fgets</code>只返回一个不完整的行，但是这一行还是以<code>NULL</code>结束，下一次调用继续从该行读。</li>
<li><code>gets</code>不推荐使用，因为没有指定缓冲区的长度，可能会造成缓冲区溢出，很危险。</li>
</ol>
<h3 id="fputs和puts原型"><code>fputs</code>和<code>puts</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fputs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s, FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">puts</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *s)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="fputs和puts性质"><code>fputs</code>和<code>puts</code>性质</h3>
<ol>
<li><code>fputs</code>将一个以<code>NULL</code>字节结束的字符串写到指定的流中，尾端的<code>NULL</code>不输出。这并不是每次输出一行，只有<code>NULL</code>前面的字节中包含<code>'\n'</code>时，才会输出一行。</li>
<li><code>puts</code>不会输出<code>NULL</code>字节，但是会自动将字符串后添加一个换行符。</li>
<li><code>puts</code>并不像<code>gets</code>那样不安全，但是因为自动加了换行符很难受。所以尽量使用<code>fgets</code>和<code>fputs</code>。</li>
</ol>
<h2 id="二进制直接i-o">二进制直接I/O</h2>
<p>除了可以以字符和行为单位进行读取，还可以使用二进制stream进行I/O。</p>
<h3 id="fread和fwrite原型"><code>fread</code>和<code>fwrite</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">size_t</span> fread(<span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br><span class="line"><span class="keyword">size_t</span> fwrite(<span class="keyword">const</span> <span class="keyword">void</span> *ptr, <span class="keyword">size_t</span> size, <span class="keyword">size_t</span> nmemb, FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="fread和fwrite性质"><code>fread</code>和<code>fwrite</code>性质</h3>
<ol>
<li><code>fread</code>和<code>fwrite</code>通常用来读写一个二进制数组或者一个结构体。<code>ptr</code>是要读写的首地址，<code>size</code>是每个对象的大小，<code>nmemb</code>是要写的对象的个数。</li>
<li><code>fread</code>和<code>fwrite</code>返回读写的对象数，读出错或者到达文件结尾，返回的数可以少于<code>nmemb</code>。可以调用<code>ferror</code>或者<code>feof</code>判断是结束还是出错。如果写返回的数值小于<code>nmemb</code>，那么就是出错。</li>
<li><code>fread</code>只能用于读在同一个系统上的数据，因为不同的系统上二进制文件的格式可能不同。</li>
<li><code>fread</code>和<code>read</code>的区别，<code>read</code>是系统调用，而<code>fread</code>是ISO C的函数。<code>read</code>的buf大小是字节，而<code>fread</code>的size是每个对象的大小，<code>nmemb</code>是对象的个数。</li>
</ol>
<h2 id="格式化i-o">格式化I/O</h2>
<p>除了三种非格式化的I/O，还有标准化I/O函数。标准化I/O函数需要指定格式说明。</p>
<h3 id="输出格式说明">输出格式说明</h3>
<p>格式说明控制其余参数如何编写，以后如何限制。每个参数按照转换说明编写，转换说明以%号开始。除了转换说明外，格式化字符串中的其他字符都按照原样输出。<br>
一个输出格式说明由四个可选部分构成：<br>
<code>%[flags][fldwidth][precision][lenmodifier] convtype</code></p>
<h4 id="flags">flags</h4>
<ul>
<li><code>'</code>，将整数按千位分组字符</li>
<li>‘-’，左对齐</li>
<li><code>+</code>，显示带符号数的正负号</li>
<li><code></code>，如果第一个字符不是正负号，在前面加上一个空格</li>
<li><code>#</code>，指定另一种形式，比如0x指定十六进制</li>
<li><code>0</code>，添加前导0而不是空格进行填充</li>
</ul>
<h4 id="fldwitdth">fldwitdth</h4>
<p>最小宽度，多余字符用空格填充</p>
<h4 id="precision">precision</h4>
<p>整形转换后最少输出数字位数<br>
浮点数转换后小数点后的最少位数。<br>
字符串转换后最大字节数</p>
<p>精度使用一个<code>.</code>，然后跟着一个可选的非负十进制整数或者<code>x</code>。</p>
<h4 id="lenmodifier">lenmodifier</h4>
<p><code>l</code>, <code>ll</code> , <code>L</code>分别表示<code>long</code>, <code>long long</code>以及<code>long double</code>。</p>
<h4 id="convtype">convtype</h4>
<ul>
<li><code>d</code>, <code>i</code>，有符号十进制</li>
<li><code>o</code>，无符号八进制</li>
<li><code>u</code>，无符号十进制</li>
<li><code>x</code>, <code>X</code>，无符号十六禁止</li>
<li><code>f</code>, <code>F</code>，双精度浮点数</li>
<li><code>e</code>, <code>E</code>，指数形式双精度浮点苏</li>
<li><code>g</code>, <code>G</code></li>
<li><code>a</code>, <code>A</code>，十六进制指数形式双精度浮点数</li>
<li><code>c</code>，字符</li>
<li><code>s</code>，字符串</li>
<li><code>p</code>，指向void的指针</li>
<li><code>n</code>，</li>
<li><code>%</code>，一个<code>%</code>字符</li>
<li><code>C</code>，宽字符，等于<code>lc</code></li>
<li><code>S</code>，宽字符串，等于<code>ls</code></li>
</ul>
<p>常见的格式化输出函数原型如下：</p>
<h3 id="printf-frpintf-dprintf-snprintf和fpritnf原型"><code>printf</code>, <code>frpintf</code>, <code>dprintf</code>, <code>snprintf</code>和<code>fpritnf</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">printf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fprintf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dprintf</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">snprintf</span><span class="params">(<span class="keyword">char</span> *str, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="printf-frpintf-snprintf-dprintf和fpritnf性质"><code>printf</code>,<code>frpintf</code>, <code>snprintf</code>,<code>dprintf</code>和<code>fpritnf</code>性质</h3>
<ol>
<li><code>printf</code>将格式化数据输出到标准输出</li>
<li><code>fprintf</code>将格式化数据写到指定的流。</li>
<li><code>dprintf</code>将格式化数据写到指定的文件描述符。</li>
<li><code>sprintf</code>将格式化数据送入数组<code>buf</code>中，<code>sprintf</code>在数组的尾端自动加一个null字节，但是该字符不包含在返回值中。</li>
<li><code>sprintf</code>可能会造成<code>buf</code>指向的缓冲区溢出，调用者有责任保证该缓冲区足够大。</li>
<li><code>snprintf</code>是为了解决缓冲区溢出的问题而引入的，它需要显式指定缓冲区的长度，超过这个长度的话，输入数据都会被丢弃，同样<code>ssprintf</code>在数组的尾端自动加一个null字节，但是该字符不包含在返回值中。</li>
</ol>
<h3 id="输入格式说明">输入格式说明</h3>
<p>一个输入格式转换说明由三个可选部分：<br>
<code>%[*][fldwidth][m][lenmodifier] convtype</code></p>
<ol>
<li>fldwidth用于说明最大宽度</li>
<li>lenmodifier说明要用转换结果赋值的参数大小，<code>printf</code>函数族支持的长度修饰符同样能够得到<code>scanf</code>函数族的支持。</li>
<li>而convtype符号和<code>printf</code>中类似，但是有一些区别。比如，输入中的带符号数可以复制给无符号类型。</li>
</ol>
<h3 id="scanf-fscnaf-sscanf原型"><code>scanf</code>, <code>fscnaf</code>, <code>sscanf</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">scanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fscanf</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sscanf</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *str, <span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="scanf-fscnaf-sscanf性质"><code>scanf</code>, <code>fscnaf</code>, <code>sscanf</code>性质</h3>
<ol>
<li><code>scanf</code>用于分析输入字符串，并将字符序列转换成指定类型的变量。格式后的各个参数给出了变量的地址，用转换结果对这些变量赋值。</li>
<li>格式说明控制如何转换参数，以便于对他们赋值，除了转换说明和空白字符外，格式字符串中的其他字符必须和输入匹配，如果有一个不匹配，就停止处理。</li>
</ol>
<h2 id="标准i-o效率">标准I/O效率</h2>
<p><code>fgets</code>, <code>fgetc</code>, <code>getc</code>, <code>read</code>这几个函数，哪个效率更高？<br>
当他们同时读取一个300万行的98.5M的程序时，<code>read</code>效果最好。它们的系统CPU时间基本一样，但是用户CPU时间查了很多，以及等待I/O的时间也差了很多。为什么呢？</p>
<ol>
<li>系统CPU时间相同，因为它们对内核提出的读写请求数基本相同。</li>
<li>CPU时间差太多是因为，<code>getc</code>和<code>fgetc</code>需要进行上亿次的循环（上亿个字符），而<code>fgets</code>需要进行百万次的循环，而<code>read</code>只需要几万次（缓冲区大小设置为4096时）。</li>
<li><code>fgetc</code>和<code>read</code>缓冲区大小设置为1时，<code>read</code>要慢很多，因为<code>read</code>调用了两亿次系统调用，而<code>fget</code>调用了两亿次函数调用。系统调用的时间和各项开销要比函数调用大得多。</li>
</ol>
<h2 id="定位stream">定位stream</h2>
<p>有三种方法对I/O stream进行定位，分别是<code>ftell</code>和<code>fseek</code>，<code>ftello</code>和<code>fseeko</code>，<code>fgetpos</code>和<code>fsetpos</code>。它们的原型如下：</p>
<h3 id="ftell-feek-ftello-fseeko和fgetpos-fsetpos原型"><code>ftell</code>, <code>feek</code>, <code>ftello</code>, <code>fseeko</code>和<code>fgetpos</code>, <code>fsetpos</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseek</span><span class="params">(FILE *stream, <span class="keyword">long</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">ftell</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewind</span><span class="params">(FILE *stream)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fgetpos</span><span class="params">(FILE *stream, <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsetpos</span><span class="params">(FILE *stream, <span class="keyword">const</span> <span class="keyword">fpos_t</span> *pos)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fseeko</span><span class="params">(FILE *stream, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span></span>;</span><br><span class="line"><span class="keyword">off_t</span> ftello(FILE *stream);</span><br></pre></td></tr></table></figure>
<h3 id="ftell-feek-ftello-fseeko和fgetpos-fsetpos性质"><code>ftell</code>, <code>feek</code>, <code>ftello</code>, <code>fseeko</code>和<code>fgetpos</code>, <code>fsetpos</code>性质</h3>
<ol>
<li><code>ftell</code>和<code>fseek</code>假设文件的位置可以存放在一个长整形中，而<code>ftello</code>和<code>fseeko</code>使用<code>off_t</code>代替了长整形。除此之外，它们完全相同。</li>
<li><code>fgetpos</code>和<code>fsetpos</code>是ISO C的标准，其他是SUS，所以跨平台时，使用<code>fgetpos</code>和<code>fsetpos</code>。</li>
<li>对于二进制文件，<code>whence</code>可以使用<code>SEEK_SET</code>, <code>SEEK_CUR</code>，这是跨平台的，而<code>SEEK_END</code>不是平台的。</li>
<li>对于文本文件，<code>whence</code>必须要用<code>SEEK_SET</code>且<code>offset</code>只能是0或者<code>ftell</code>返回的值。</li>
</ol>
<h2 id="实现细节">实现细节</h2>
<p>所有的standard I/O库都要使用到文件的I/O。每个I/O stream都有一个和其相关的文件描述符，可以使用<code>fileno</code>函数获得stream的文件描述符。</p>
<h2 id="临时文件">临时文件</h2>
<p>ISO C提供了两个函数<code>tmpnam</code>和<code>tmpfile</code>帮助创建临时文件。它们的原型如下：</p>
<h3 id="tmpnam和tmpfile原型"><code>tmpnam</code>和<code>tmpfile</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">tmpnam</span><span class="params">(<span class="keyword">char</span> *s)</span></span>;</span><br><span class="line"><span class="function">FILE *<span class="title">tmpfile</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">mkdtemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkstemp</span><span class="params">(<span class="keyword">char</span> *<span class="keyword">template</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="tmpnam和tmpfile性质"><code>tmpnam</code>和<code>tmpfile</code>性质</h3>
<ol>
<li><code>tmpnam</code>产生一个与现有文件名不同的一个有效路径名字符串。避免使用<code>tmpnam</code>。</li>
<li><code>tmpfile</code>创建一个临时二进制文件(wb+)，在关闭文件或者程序结束时自动删除这个文件。注意UNIX对于二进制文件不做特殊区分。</li>
<li><code>tmpfile</code>函数经常使用的标准UNIX技术是先使用<code>tmpnam</code>产生一个唯一的路径名，然后使用它创建一个文件，并且立刻<code>unlink</code>它。注意，对一个文件<code>unlink</code>之后，如果链接计数等于0，并不立即删除它，因为可能有进程在使用这个文件，关闭文件时才删除文件。</li>
<li><code>mkdtemp</code>和<code>mkstemp</code>是XSI的扩展部分。</li>
<li><code>mkstemp</code>和<code>mkdtemp</code>都需要传入一个字符串，它的后六位设置为<code>XXXXXX</code>，函数通过将这些占位符替换成不同的字符构建一个唯一的路径名。如果只指定了名字，就创建在当前目录下。</li>
<li><code>mkdtemp</code>创建的目录的权限是<code>S_IRUSR</code>,<code>S_IWUSR</code>, <code>S_IXUSR</code>。<code>mkstemp</code>创建的文件的权限是<code>S_IRUSR</code>,<code>S_IWUSR</code>，可以使用<code>umask</code>进行修改。</li>
<li><code>mkstemp</code>创建的文件不会被自动删除。</li>
</ol>
<h2 id="内存stream">内存stream</h2>
<p>Standard I/O把数据缓存在内存中，因此字符和单行的I/O更有效一些，我们也可以使用<code>setbuf</code>和<code>setvbuf</code>让标准I/O库使用自己指定的缓冲区。<br>
在SUS4之后添加了对memory streams的支持，这些standard I/O streams没有底层文件支持，但是仍然可以使用FILE指针访问，所有的I/O都是通过在缓冲区和主存中来回交换字节实现的。这些流虽然看起来像文件流，但是某些特征更像字符串操作。</p>
<p>有三个函数可以用于内存流的创建，它们分别是<code>fmemopen</code>，<code>open_memstream</code>和<code>open_wmemstream</code>。</p>
<h3 id="fmemopen函数和属性"><code>fmemopen</code>函数和属性</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">fmemopen</span><span class="params">(<span class="keyword">void</span> *buf, <span class="keyword">size_t</span> size, <span class="keyword">const</span> <span class="keyword">char</span> *mode)</span></span>;</span><br></pre></td></tr></table></figure>
<ol>
<li><code>fmemopen</code>函数open memory as stream</li>
<li><code>fmemopen</code>函数允许调用者提供缓冲区用于memory stream，<code>size</code>指定了缓冲区大小的字节数。如果<code>buf</code>为空，<code>fmemopen</code>会分配<code>size</code>字节数的缓冲区，流关闭时缓冲区会被释放。</li>
<li><code>type</code>和<code>fopen</code>的取值一样，总共有15种取值，</li>
</ol>
<h3 id="open-memstream和open-wmemstream函数和属性"><code>open_memstream</code>和<code>open_wmemstream</code>函数和属性</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">open_memstream</span><span class="params">(<span class="keyword">char</span> **ptr, <span class="keyword">size_t</span> *sizeloc)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wchar.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">FILE *<span class="title">open_wmemstream</span><span class="params">(<span class="keyword">wchar_t</span> **ptr, <span class="keyword">size_t</span> *sizeloc)</span></span>;</span><br></pre></td></tr></table></figure>
<p>它们一个面向字节，一个面向宽字节。它们和<code>fmemopen</code>之间的区别：</p>
<ol>
<li>创建的流只能打开；</li>
<li>不能指定自己的缓冲区，但是可以访问缓冲区地址和大小。</li>
<li>关闭流后需要自己释放缓冲区</li>
<li>对流添加字节会增加缓冲区大小。</li>
<li>缓冲区地址和长度只有在调用<code>fclose</code>或者<code>fflush</code>后才有效。这些值只有在下一次流写入或者调用<code>fclose</code>前。</li>
</ol>
<h2 id="标准i-o的替代软件">标准I/O的替代软件</h2>
<p>标准I/O库的一个不足是效率不高。这和它复制的数据量有关。每当使用一次<code>fgets</code>和<code>fputs</code>时，通常需要复制两次数据，一次是在用户程序的行缓冲区和标准I/O缓冲区之间，一次是在内核和标准I/O缓冲区之间。<br>
OK，这章我就认识到了这一个很重要的知识点。。<br>
使用<code>fgets</code>需要用户指定<code>fgets</code>使用的缓冲区，或者使用<code>getline</code>，如果传入的指针指向NULL，<code>getline</code>会负责分配缓冲区大小。<br>
标准I/O可以设置行缓冲和全缓冲，如果设置缓冲的话也需要一个缓冲区，通常是由系统指定的，当然也可以通过<code>setbuf</code>和<code>setvbuf</code>自己进行更改。而在<code>setbuf</code>中，如果<code>buf</code>是<code>NULL</code>的话，是关闭缓冲区，如果不为空的话，必须是<code>BUFSIZ</code>大小。在<code>setvbuf</code>中，通过<code>mode</code>指定缓冲区的类型，<code>buf</code>是<code>NULL</code>的话，库函数负责分配缓冲区。否则<code>buf</code>是多大就用多大的缓冲区。<br>
直接使用系统调用<code>read</code>和<code>write</code>函数也需要设置缓冲区，这是系统调用级别的，大小可以任意指定，通常使用<code>sturct stat.st_blksize</code>的大小。标准I/O库用的缓冲区和<code>read</code>,<code>write</code>指的是一个（我自己的理解）。<br>
内核中有buffer cache和page cache，调用<code>write</code>只是将数据复制到buffer cache和page cache，然后排入队列，实际的写磁盘操作可能在满足某个条件之后才实际写入磁盘。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuf</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setbuffer</span><span class="params">(FILE *stream, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">fgets</span><span class="params">(<span class="keyword">char</span> *s, <span class="keyword">int</span> size, FILE *stream)</span></span>;</span><br></pre></td></tr></table></figure>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://stackoverflow.com/questions/20937616/what-is-the-difference-between-a-stream-and-a-file" target="_blank" rel="noopener">https://stackoverflow.com/questions/20937616/what-is-the-difference-between-a-stream-and-a-file</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/21/UNIX-file-and-directory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/21/UNIX-file-and-directory/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX file and directory</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-21 10:18:13" itemprop="dateCreated datePublished" datetime="2019-11-21T10:18:13+08:00">2019-11-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:33:44" itemprop="dateModified" datetime="2019-12-17T16:33:44+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一节主要介绍文件系统和文件的一些属性，这些属性都存在<code>stat</code>函数给出的<code>struct stat</code>结构体中，<code>struct stat</code>的部分字段如下所示，接下来的小节会对这些字段进行详细的介绍：</p>
<h3 id="struct-stat"><code>struct stat</code></h3>
<p>这个结构体包括：</p>
<ol>
<li><code>mode_t st_mode;</code> 文件类型和文件权限控制</li>
<li><code>ino_t st_ino;</code> 文件存放的i-node号</li>
<li><code>dev_t st_dev;</code> 文件所在文件系统的设备号</li>
<li><code>dev_t st_rdev;</code> 特殊文件所在文件系统的设备号</li>
<li><code>nlink_t st_nlink;</code> 链接到文件指向的i-node节点的数量，即hardlink</li>
<li><code>uid_t st_uid;</code> 文件所有者的UID</li>
<li><code>gid_t st_gid;</code> 文件所有者的GID</li>
<li><code>off_t st_size;</code> 普通文件的字节数</li>
<li><code>struct timespec st_atime;</code> 最后一次access文件内容的时间</li>
<li><code>struct timespec st_mtime;</code> 最后一个modification文件内容的时间</li>
<li><code>struct timespec st_ctime;</code> 最后一次文件i-node 内容change的时间</li>
<li><code>blksize_t st_blksize;</code> 最合适的I/O block size</li>
<li><code>blkcnt_t st_blocks;</code> 分配了多少个disk blocks</li>
</ol>
<h2 id="文件系统">文件系统</h2>
<p>UNIX文件系统有多种实现，比如基于BSD的UNIX文件系统(UFS)，linux的ext4文件系统，以及Mac OS X的HFS文件系统。本节拿UFS举例子。<br>
一个磁盘可以有一个或者多个partition，每个partition可以包含文件系统也可以不包含。对于UFS文件系统，它由boot blocks，super block，cylinder groups组成。每一个cylinder group由super block copy, config info, i-node图，block bitmap以及i-nodes和data blocks组成。i-node节点是固定长度的记录项，它包含有关文件的大部分信息。</p>
<ol>
<li>i-node节点包含了文件的：文件类型，文件访问权限，文件长度，和指向文件数据的指针等，<code>stat</code>绝大部分的数据都取自i-node。</li>
<li>data blocks中存放实际的数据，包含data blocks和directory blocks。data blocks存放文件的实际数据。目录也是文件，directory blocks也是data block，只不过它是存放目录文件中所有directory entry(目录项)的data blcok，一个directory entroy包括文件名和i-node编号。i-node节点编号的数据类型是<code>ino_t</code>。</li>
<li>hard links：在每一个i-node中，都有一个链接计数，记录指向它的目录项个数，POSIX.1常量<code>LINK_MAX</code>指定了一个文件连接数的最大值。链接计数可以从<code>st_nlink</code>中得到，类型是<code>nlink_t</code>。hard link创建一个新的目录项指向链接目标的i-node节点，删除原来的目录项对新的目录项没有影响。只有当指向i-node节点的链接数等于0时且没有进程使用该文件时，可以删除该文件。</li>
<li>symbolic links：symbolic links文件的实际内容，也就是存储在data blocks中的内容，是该symbolic link指向的文件的名字。symbolic link和hard link不一样，它有自己的i-node号，删除它指向的文件，这个symbolic link会失效，变成一个dead link。它的文件类型是<code>S_IFLNK</code>。</li>
<li>一个目录项不能指向另一个文件系统的i-node，所以hard link不能跨越文件系统。</li>
<li>在不更换文件系统的情况下为一个文件重命名的话。文件的实际内容没有变，只是构造了一个新的目录项，它的i-node就是待重命名的文件，然后删除老的目录项。链接的计数并不会改变，这就是<code>mv</code>命令的工作方式。</li>
<li>i-node节点指向的数据块也可以存放目录项，在i-node的<code>st_mode</code>中可以确定它的类型是<code>S_IFDIR</code>。创建一个名为<code>testdir</code>的空目录，它的链接计数是2，一个是<code>.</code>目录，一个是<code>testdir</code>。<code>testdir</code>的上一级目录，它的链接计数是3（假设上一级目录只包含<code>testdir</code>），一个是这个目录的名字，一个是<code>.</code>，一个是<code>testdir</code>中的<code>..</code>。</li>
</ol>
<p>关于linux文件系统，可以查看<a href="https://mxxhcm.github.io/2019/05/07/linux-file-system/">linux file system</a>.</p>
<h3 id="设备特殊文件">设备特殊文件</h3>
<p>这一小节主要介绍<code>st_dev</code>和<code>st_rdev</code>字段。</p>
<ol>
<li>每个文件系统所在的存储设备都由其主次设备号表示。设备号所用的数据类型是基本系统数据类型<code>dev_t</code>。主设备号标识设备驱动程序，次设备号标识特定的子设备。一个磁盘驱动器通常可以包含多个文件系统，同一个磁盘上的文件系统通常具有相同的主设备号，但是次设备号却不同。</li>
<li>每个文件名中的<code>st_dev</code>是存放该文件名和其对应i节点的文件系统的设备号。</li>
<li>可以使用两个宏<code>major</code>和<code>minor</code>访问主，次设备号，它们的参数都是<code>st_dev</code>。POSIX.1说明<code>dev_t</code>类型存在，但是没有定义它是什么，具体取值与实现相关。</li>
<li>只有字符特殊文件和块特殊文件才有<code>st_rdev</code>值，同样使用<code>major</code>和<code>minor</code>两个宏访问相应的主次设备号。</li>
<li>块特殊文件是包含随机访问文件系统的设备，比如硬盘驱动器，软盘驱动器和CD-ROM以及磁带等。</li>
</ol>
<h2 id="文件类型">文件类型</h2>
<p>文件类型信息包含在<code>struct stat</code>的<code>st_mode</code>字段中。UNIX系统的文件类型有以下几种：</p>
<ol>
<li>普通文件，可以是二进制文件，也可以是文本文件。除了二进制可执行文件必须遵循标准化格式外，其他的文件对于UNIX内核来说基本上没有区别。使用<code>S_ISREG</code>宏进行判断。</li>
<li>目录文件，包含了其他文件的名字，以及指向这些文件有关信息的指针。对一个目录具有读权限的任意进程都可以读目录的内容，但是只有内核才可以直接写目录文件。使用<code>S_ISDIR</code>宏进行判断。</li>
<li>block special file，提供对设备带缓冲的访问，每次访问以固定的长度进行。使用<code>S_ISBLK</code>宏进行判断。</li>
<li>character special file，提供对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是block special file要是character special file。使用<code>S_ISCHR</code>宏进行判断。</li>
<li>FIFO，用于进程间通信。使用<code>S_ISFIFO</code>宏进行判断。</li>
<li>socket，用于进程间的网络通信。使用<code>S_ISSOCK</code>宏进行判断。</li>
<li>symbolic link，指向另一个文件。使用<code>S_ISLNK</code>宏进行判断。</li>
</ol>
<h2 id="stat-fstat-fstatat-lstat"><code>stat</code>, <code>fstat</code>, <code>fstatat</code>, <code>lstat</code></h2>
<p>可以通过<code>stat</code>等函数获得文件（各类文件）的<code>struct stat</code>结构体，它们的原型如下：</p>
<h3 id="函数原型">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="性质">性质</h3>
<ol>
<li><code>stat</code>将pathname指定的文件的有关信息存在放在<code>statbuf</code>中</li>
<li><code>fstat</code>将文件描述符指定的文件的有关信息存在放在<code>statbuf</code>中</li>
<li><code>lstat</code>和<code>stat</code>类似，但是当文件是一个symbolic link时，<code>lstat</code>返回symbolic link相关的信息，<code>stat</code>返回的是symbolic link链向的文件。</li>
<li><code>fstatat</code>相当于将前三个函数进行了整合：<br>
当<code>dirfd</code>设置为<code>AT_FDCWD</code>时或者pathname是绝对路径时，设置<code>AT_SYSLINK_NOFOLLOW</code> flags时，相当于<code>lstat</code>。<br>
当<code>dirfd</code>设置为<code>AT_FDCWD</code>时或者pathname是绝对路径时，<code>AT_SYSLINK_NOFOLLOW</code> flags不进行设置时，相当于<code>stat</code>。<br>
当<code>dirfd</code>既不是<code>AT_FDCWD</code>而且pathname不是绝对路径时，就是<code>fstatat</code>处理的情况了。</li>
</ol>
<h2 id="hard-link和函数link-linkat-unlink-unlinkat和remove">hard link和函数<code>link</code>, <code>linkat</code>, <code>unlink</code>, <code>unlinkat</code>和<code>remove</code></h2>
<p>任何一个文件可以有多个目录项指向它的i-node节点。可以使用<code>link</code>和<code>linkat</code>创建hard link，使用<code>unlink</code>和<code>unlinkat</code>, <code>remove</code>删除hard link。</p>
<h3 id="hard-link的特点">hard link的特点</h3>
<ol>
<li>使用hard link链接的文件具有相同的inode和data block。</li>
<li>删除一个hard link不会影响其他具有相同inode号的文件。</li>
<li>只能对已经存在的文件创建hard link。</li>
<li>不能跨越文件系统创建hard link，因为每个文件系统的i-node节点都是单独的。</li>
<li>不能对目录创建hard link，可能会形成循环。</li>
</ol>
<h3 id="link和linkat的函数原型"><code>link</code>和<code>linkat</code>的函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">linkat</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="link和linkat的函数性质"><code>link</code>和<code>linkat</code>的函数性质</h3>
<ol>
<li><code>link</code>和<code>linkat</code>应该是原子操作。</li>
<li><code>linkat</code>和<code>link</code>类似。</li>
</ol>
<h3 id="unlink和unlinkat的函数原型"><code>unlink</code>和<code>unlinkat</code>的函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlinkat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="unlink和unlinkat的函数性质"><code>unlink</code>和<code>unlinkat</code>的函数性质</h3>
<ol>
<li>如果<code>pathname</code>是hard link，这两个函数删除<code>pathname</code>的相应目录项，将<code>pathname</code>指向文件的i-node的链接数减一。</li>
<li>如果<code>pathname</code>是symbolic link，<code>unlink</code>删除的是symbolic link本身，而不follow它。</li>
<li>给出symbolic link时，没有任何函数能够删除symbolic link指向的文件。</li>
<li>如果链接数等于0，并且内核检查打开该文件的进程个数，如果它们都等于0。<code>unlink</code>会删除这个文件。如果链接数或者打开文件的进程个数大于0，不会对文件做修改。</li>
<li><code>unlinkat</code>和<code>unlink</code>类似。</li>
</ol>
<h3 id="remove的函数原型"><code>remove</code>的函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="remove的函数性质"><code>remove</code>的函数性质</h3>
<ol>
<li><code>remove</code>可以解除对文件或者目录的hard link。</li>
<li>作用于目录时，<code>remove</code>相当于<code>rmdir</code>。</li>
<li>作用于文件时，<code>remove</code>相当于<code>unlink</code>。</li>
</ol>
<h2 id="symbolic-link和函数symlink-symbolinkat-readlink-readlinkat">symbolic link和函数<code>symlink</code>,<code>symbolinkat</code>, <code>readlink</code>, <code>readlinkat</code></h2>
<p>hard links有一些限制：</p>
<ol>
<li>链接和文件必须处于同一文件系统中，</li>
<li>只有root用户才能创建指向目录的链接。</li>
</ol>
<h3 id="symbolic-link的特点">symbolic link的特点</h3>
<p>而symbolic link可以避开hard link的这些限制。</p>
<ol>
<li>symbolic可以看成文件的间接指针，它有自己的文件属性和权限，有自己的i-node号和data block，而所有指向一个i-node节点的hard link拥有相同的i-node。</li>
<li>symbolic link对于它指向的对象没有任何文件系统的限制，任何用户都可以创建指向目录的symbolic link。</li>
<li>使用文件名字为参数调用文件函数时，需要知道这个函数是否处理symbolic link的。如果函数具有处理symbolic link的功能，那么它处理的是symbolic link指向的文件，否则它直接处理这个symbolic link本身。<br>
如下所示，是常见的函数是否处理symbolic link，<code>fstat</code>和<code>fchmod</code>因为处理的是文件描述符，这个文件描述符是否是symbolic link本身通常是由<code>open</code>决定的。<br>
<code>access</code>,<code>chdir</code>, <code>chmod</code>, <code>chown</code>，<code>creat</code>, <code>exec</code>, <code>link</code>, <code>open</code>, <code>opendir</code>, <code>pathconf</code>, <code>stat</code>, <code>truncate</code>跟随symbolic link。<br>
<code>lchown</code>,<code>lstat</code>, <code>readlink</code>, <code>remove</code>, <code>rename</code>, <code>unlink</code>不跟随symbolic link。</li>
<li>使用symbolic link可能在文件系统中引入循环。<code>unlink</code>不跟随symbolic link，所以使用<code>unlink</code>消除symbolic link。但是hard link的循环很难消除。这也是为什么<code>link</code>函数不允许构造指向目录的hard link的原因。</li>
<li>symbolic link可以指向系统中并不存在的文件。所以<code>creat</code>的参数可以是symbolic link。</li>
</ol>
<p>创建和读取symbolic link的函数原型如下：</p>
<h3 id="symlink和symlinkat函数原型"><code>symlink</code>和<code>symlinkat</code>函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *target, <span class="keyword">const</span> <span class="keyword">char</span> *linkpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">symlinkat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *target, <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *linkpath)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="symlink和symlinkat函数性质"><code>symlink</code>和<code>symlinkat</code>函数性质</h3>
<ol>
<li><code>linkpath</code>和<code>target</code>不需要在同一个文件系统，而且<code>target</code>甚至可以不存在</li>
<li><code>symlinkat</code>和<code>symlink</code>类似。</li>
</ol>
<h3 id="readlink和readlinkat函数原型"><code>readlink</code>和<code>readlinkat</code>函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> readlink(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsiz);</span><br><span class="line"><span class="keyword">ssize_t</span> readlinkat(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> bufsiz);</span><br></pre></td></tr></table></figure>
<h3 id="readlink和readlinkat函数性质"><code>readlink</code>和<code>readlinkat</code>函数性质</h3>
<ol>
<li><code>open</code>函数跟随symbolic link，而<code>readlink</code>打开symbolic link本身，并且读取symbolic link中的名字</li>
<li><code>readlink</code>组合了<code>open</code>,<code>close</code>和<code>read</code>的所有操作。如果函数成功执行，返回读入buf的字节数。</li>
<li><code>readlinkat</code>和<code>readlink</code>类似。</li>
</ol>
<h2 id="和进程相关的uid和gid">和进程相关的UID和GID</h2>
<p>每一个进程有6个或者更多和它相关的ID：</p>
<h3 id="实际uid和gid">实际UID和GID</h3>
<p>real UID和real GID，用来表示当前用户。</p>
<h3 id="有效uid和gid">有效UID和GID</h3>
<p>effective UID和effective UID，决定我们的文件访问权限。通常情况下，effective UID以及effective GID和real UID以及real GID一样。</p>
<h3 id="set-user-id和set-group-id">Set-User-ID和Set-Group-ID</h3>
<p>saved set-user-ID和saved set-group-ID，在执行一个程序时，包含了有效user ID和有效group ID的副本。<br>
每一个文件都有一个UID和GID，它们的值在<code>st_uid</code>和<code>st_gid</code>中。<br>
当执行一个程序文件时，进程的effective UID通常就是real UID，而effective GID通常就是real GID。但是可以在<code>st_mode</code>中设置一个特殊的flag，意思是当执行此文件时，将执行此文件的进程的effective UID设置为文件所有者的UID。同样，还有另一个特殊的flag，它将执行此文件的进程的effective GID设置为文件组所有者的UID。这两个标志位被记为set-user-ID bit和set-group-ID bit，它们都存放在<code>st_mode</code>中，可以使用<code>S_ISUID</code>和<code>S_ISGID</code>测试。<br>
<strong>运行set UID程序的进程通常会获得额外的权限！！！所以要格外注意。</strong></p>
<h2 id="文件和目录的访问权限">文件和目录的访问权限</h2>
<p><code>st_mode</code>中还包含了文件的访问权限。对于所有文件类型（不单单是文件和目录），都有三种访问权限：</p>
<h3 id="r-读权限">r-读权限</h3>
<p>读权限查询目录名内的数据。</p>
<h3 id="w-写权限">w-写权限</h3>
<ul>
<li>新建文件与目录</li>
<li>删除文件或者目录</li>
<li>重命名以及转移文件或者目录</li>
</ul>
<h3 id="x-可执行权限">x-可执行权限</h3>
<ul>
<li>进入某目录</li>
<li>切换到该目录（cd命令）</li>
<li>对于只具有可执行权限的目录，可以使用<code>cd</code>进入该目录，也可以打开该目录的文件，或者进入下一级目录。但是需要我们知道它们的名字，不能使用<code>ls</code>命令查看，因为没有读目录的权限。。</li>
</ul>
<p>!!!能不能进入某一目录只与该目录的x权限有关，如果不拥有某目录的x权限，即使拥有r权限，那么也无法执行该目录下的任何命令。<br>
但是即使拥有了x权限，但是没有r权限，能进入该目录但是不能打开该目录，因为没有读取的权限，但是可以进入下一级目录或者打开当前目录的文件（因为不能读目录，所以需要知道下一级目录的名字或者当前目录下要打开的文件的名字），路径上的所有目录都必须有可执行权限。。</p>
<h3 id="sticky-bit">sticky bit</h3>
<p><code>S_ISVTX</code>较老版本的UNIX叫做表示stick bit，而新版UNIX叫做saved-text bit，这也是<code>S_ISVTX</code>名字的由来。这一位的作用是，当一个可执行文件的这一位被设置了，当该程序第一次被执行，在它终止时，程序正文部分的一个副本，即机器指令，仍然保存在交换区中，这使得下次执行该程序时能较快的载入内存。因为通常的UNIX文件系统中，文件的数据块都是随机存放的，相对来说，交换区被当做一个连续文件来处理。而现在的UNIX系统都使用了虚拟存储系统和快速文件系统，已经不需要这种技术了。<br>
现在系统扩展了stick bit的使用，SUS允许对目录设置目录的stick bit，如果一个目录设置了stick bit，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或者重命名该目录下的文件：</p>
<ol>
<li>拥有该文件</li>
<li>拥有此目录</li>
<li>是root用户</li>
</ol>
<p>比如/tmp目录，设置了stick bit，任何用户都可以在这个目录下创建文件。任意用户,组和其它对这两个目录的权限都是读写和执行。但是用户不能删除和重命名属于其他人的文件。</p>
<h3 id="十二个访问权限位">十二个访问权限位</h3>
<p>将<code>rwx</code>和user, group以及other进行组合，总共有九个访问权限位，再加上<code>S_ISUID</code>,<code>S_ISGID</code>和<code>S_ISVTX</code>三个特殊位：</p>
<ul>
<li>S_ISUID，set user id,</li>
<li>S_ISGID, set group id,</li>
<li>S_ISVTX, stick bit,</li>
<li>S_IRUSR, user read,</li>
<li>S_IWUSR, user write,</li>
<li>S_IXUSR, user exectu,</li>
<li>S_IRGRP, group read,</li>
<li>S_IWGRP, group write,</li>
<li>S_IXGRP, group exectuble,</li>
<li>S_IROTH, other read,</li>
<li>S_IWOTH, other write,</li>
<li>S_TXOTH, other exectuble,</li>
</ul>
<p>可以对最后九项做一个简洁版的表示：<br>
S_IRWXU = S_IRUSR|R_IWUSR|S_IXUSR<br>
S_IRWXG = S_IRGRP|S_IWGRP|S_IXGRP<br>
S_IRWXO = S_IROTH|S_IWOTH|S_IXOTH</p>
<h3 id="文件和目录的操作规则">文件和目录的操作规则</h3>
<ol>
<li>使用名字打开任意类型的文件时，对于文件名字中包含的每一个目录，包括当前工作目录，都应该具有执行权限。</li>
<li>对于一个文件的读权限决定了我们能够打开先有文件进行读操作。这与<code>open</code>函数的<code>O_RDONLY</code>和<code>O_RDWR</code>有关。</li>
<li>对于一个文件的写权限决定了我们能够打开先有文件进行写操作。这与<code>open</code>函数的<code>O_WRONLY</code>和<code>O_RDWR</code>有关。</li>
<li>如果要在<code>open</code>函数中指定<code>O_TRUNC</code>标志，必须对该文件拥有写权限。</li>
<li>为了在一个目录中创建新文件，必须对这个目录具有写权限和执行权限。</li>
<li>为了删除一个现有文件，必须对包含该文件的目录拥有写权限和执行权限，而不必对文件本身拥有读权限和写权限。</li>
<li>如果使用7个<code>exec</code>函数中的任何一个执行某个文件，都必须拥有该文件的写权限。</li>
</ol>
<h3 id="访问权限检测">访问权限检测</h3>
<p>进程每次打开，创建或者删除一个文件时，内核就会进行文件访问权限测试，这种测试可能涉及到文件的UID，文件的组GID，进程的effective UID和effective GID。文件的UID和文件的GID都是文件的属性，而effective UID和effective GID是进程的属性。<br>
内核进行访问权限测试的步骤如下：</p>
<ol>
<li>如果进程的effective UID是0，结束权限判断，允许各项访问。否则跳转第2步进行判断。</li>
<li>如果进程的effectiev UID等于文件UID，也就是<code>st_uid</code>，结束权限判断，根据访问权限位允许相应操作。否则跳转第3步。</li>
<li>如果进程的effective GID等于文件的GID，结束权限判断，根据访问权限的设置允许相应的操作，否则跳转第4步。</li>
<li>如果不满足前三条，就按照若其他用户的访问权限位判定操作是否合法。</li>
</ol>
<p>总结一下，就是依次判断effective UID是不是等于root，effective UID是不是等于<code>st_uid</code>，或者effective GID是不是等于<code>st_gid</code>，如果都不满足，就按照其它权限判定当前进程对文件的操作是否被允许。按照顺序来判断，满足一个就不用判断后面的了。</p>
<h2 id="函数umask">函数<code>umask</code></h2>
<p>前面介绍了和文件相关的9个访问权限位，使用进程创建文件时，文件的权限可以由<code>umask</code>修改，相当于在原有的mode上减去<code>umask</code>指定的mode。函数<code>umask</code>的原型如下：</p>
<h3 id="函数原型-v2">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</span><br></pre></td></tr></table></figure>
<h3 id="特点">特点</h3>
<ol>
<li>这个函数的作用是去掉<code>cmask</code>中指定的权限，返回之前的mode。</li>
<li><strong>在程序中使用<code>open</code>和<code>creat</code>等创建新文件时，如果想要确保指定的访问限权被激活，必须在进程运行时修改<code>umask</code>的值。否则，<code>umask</code>可能会覆盖掉我们创建文件时指定的mode。</strong></li>
<li>shell中有内置的<code>umask</code>命令，SUS要求shell的<code>umask</code>除了支持八进制的拒绝权限外，还要支持符号格式的指定许可的权限。使用<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask -S</span><br></pre></td></tr></table></figure></li>
</ol>
<p>查看。</p>
<h2 id="新文件和目录的uid和gid">新文件和目录的UID和GID</h2>
<p>创建文件时，新文件的UID被设置为进程的effective UID。关于新文件的GID，可以选择以下两种方式中的一个进行设置：</p>
<ol>
<li>新文件的GID可以是进程的effective GID</li>
<li>新文件的GID可以是它所在目录的GID。</li>
</ol>
<p>不同的UNIX实现有不同的设置，这里拿linux来说，Linux 3.2.0以后，新文件的GID取决于它所在目录的set-group ID bit是否被设置，如果被设置了，新文件的ID就是它所在目录的GID，否则就是进程的effective GID。<br>
新目录的UID和GID和文件一样。</p>
<h2 id="函数mkdir-mkdirat和rmdir">函数<code>mkdir</code>，<code>mkdirat</code>和<code>rmdir</code></h2>
<p>可以使用<code>mkdir和</code>mkdirat<code>创建目录，使用</code>rmdir`删除目录。它们的原型如下：</p>
<h3 id="函数原型-v3">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkdirat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rmdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="性质-v2">性质</h3>
<ol>
<li><code>mkdir</code>创建一个空目录，自动包含<code>.</code>和<code>..</code>项。文件的访问</li>
<li>目录的权限默认权限是进程的<code>umask</code>给出的。对于目录，我们至少需要指定execute位。</li>
<li>目录的UID和GID跟进程<code>create</code>文件时一样。</li>
<li><code>mkdirat</code>和<code>mkdir</code>类似。</li>
<li><code>rmdir</code>删除目录。</li>
</ol>
<h2 id="函数access和faccessat">函数<code>access</code>和<code>faccessat</code></h2>
<p>使用<code>open</code>函数打开文件时，内核使用进程的effective UID和effective GID检测它对文件的访问权限。<br>
<code>acess</code>使用进程的real UID和real GID进行权限访问测试。访问权限测试步骤和之前介绍的四步一样，只不过使用real UID和real GID代替了effective UID和effective GID。</p>
<h3 id="函数原型-v4">函数原型</h3>
<p><code>access</code>和<code>faccessat</code>的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数和区别">参数和区别</h3>
<ol>
<li><code>mode</code>可选参数有，<code>F_OK</code>，<code>R_OK</code>, <code>W_OK</code>,<code>X_OK</code>，其中<code>F_OK</code>表示测试这个文件是否存在。</li>
<li><code>faccessat</code>和<code>access</code>在两种情况下相同，<code>dirfd</code>设置为<code>AT_FDCWD</code>且<code>pathname</code>四相对路径和<code>pathname</code>是绝对路径。否则的话，<code>faccessat</code>就是测试相对于<code>dirfd</code>指向的打开目录下的<code>pathname</code>的权限。</li>
<li>如果<code>flags</code>设置为<code>AT_EACCESS</code>的话，权限访问检测使用的是effective UID和effective GID而不是real UID和real GID。</li>
</ol>
<h2 id="函数chmod-fchmod和fchmodat">函数<code>chmod</code>, <code>fchmod</code>和<code>fchmodat</code></h2>
<p>文件的访问权限可以使用<code>chmod</code>, <code>fchmod</code>和<code>fchmodat</code>进行修改，它们的原型如下：</p>
<h3 id="原型">原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="特点-v2">特点</h3>
<ol>
<li><code>chmod</code>在指定的文件上进行操作</li>
<li><code>fchmod</code>是对已经打开的文件文件描述符进行操作。</li>
<li><code>fchmodat</code>和<code>chmod</code>在两种情况下是相等的，当<code>pathname</code>是绝对路径时，以及<code>dirfd</code>设置为<code>AT_FDCWD</code>且<code>pathname</code>是相对路径的时候。否则，<code>fchmodat</code>操作相对于打开目录的pathname。</li>
<li>当flags设置了<code>AT_SYMLINK_NOFLOLLW</code>时，不会followsymbolic link。</li>
<li>在以下两种情况下，<code>chmod</code>函数自动清除两个权限位：
<ul>
<li>新创建文件的GID可能不是调用进程的effective GID。新文件的GID可能是父目录的GID。如果新文件的GID不等于进程的effective GID，而且进程没有root权限，set-group-id位会被自动关闭。</li>
<li>stick bit的设置</li>
</ul>
</li>
</ol>
<h2 id="函数chown-fchown-chownat和lchown">函数<code>chown</code>, <code>fchown</code>,<code>chownat</code>和<code>lchown</code></h2>
<p>可以使用<code>chown</code>, <code>fchown</code>,<code>chownat</code>和<code>lchown</code>更改文件的UID和GID。它们的原型如下：</p>
<h3 id="函数原型-v5">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="特点-v3">特点</h3>
<ol>
<li>当文件不是symbolic link时，所有的函数操作类似。</li>
<li>当文件是symbolic link时，<code>lchown</code>和设置了<code>AT_SYMLINK_NOFOLLOW</code>标志的<code>fchownat</code>都修改的是symbolic link本身，而不是它链接的对象。</li>
<li><code>fchown</code>操作的是<code>fd</code>指向的已经打开的文件，因为它在一个已经打开的文件上操作，所以它不能修改symbolic link本身。</li>
<li><code>fchownat</code>和<code>fchown</code>或者<code>lchown</code>在下面两种情况下是等价的：当pathname是决定路径或者<code>dirfd</code>设置为<code>AT_FDCWD</code>时且pathname是相对路径时。在这两种情况下，如果<code>flags</code>设置了<code>AT_SYMLINK_NOFOLLOW</code>标志，<code>fchownat</code>和<code>lchown</code>一样，否则<code>fchownat</code>和<code>fchown</code>一样。如果不是这两种情况，<code>fchowat</code>是操作相对于打开目录的pathname。</li>
<li>根据<code>_POSIX_CHOWN_RESTRICTED</code>常量的值，可以查询是否只有超级用户才能更改文件的所有者，如果这个常量对指定的文件有效，那么
<ul>
<li>只有root进程才能更新该文件的UID，普通用户不能修改其他用户文件的UID</li>
<li>如果进程拥有此文件(进程的effective UID等于文件的UID)， 可以更改这些文件的GID，但是只能更改到进程的effective GID或者继承的附属组ID之一。</li>
</ul>
</li>
<li>如果这些函数由非root进程调用，在成功返回时，set UID和set GID位都会被清楚。</li>
</ol>
<h2 id="函数rename和renameat">函数<code>rename</code>和<code>renameat</code></h2>
<p>可以使用函数<code>rename</code>和<code>rename</code>对文件或者目录进行重命名。它们的原型如下：</p>
<h3 id="函数原型-v6">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">rename</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">renameat</span><span class="params">(<span class="keyword">int</span> olddirfd, <span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">int</span> newdirfd, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="性质-v3">性质</h3>
<ol>
<li>ISO C对文件定义了<code>reanme</code>，但是ISO C没有对目录定义该函数。POSIX.1扩展了定义，使得它<code>rename</code>可以处理目录和symbolic link。</li>
<li>如果<code>oldpath</code>指向普通文件，那么为文件进行重命名。如果<code>newname</code>存在，它不能是一个目录。如果它不是目录，先将该目录项删除，然后将<code>oldname</code>重命名为<code>newname</code>。进程需要对<code>oldpath</code>和<code>newpath</code>的父目录都拥有写和执行权限，因为<code>rename</code>会修改这两个目录。</li>
<li>如果<code>oldpath</code>指向目录，为目录重命名。如果<code>newname</code>已经存在，那么它必须是一个目录，而且应该是空目录。如果<code>newname</code>目录存在且为空，先将它删除，然后将<code>oldname</code>重命名为<code>newname</code>。且<code>newname</code>不能包含<code>oldname</code>，比如不能将<code>/usr/foo</code>重命名为<code>/usr/foo/testdir</code>，因为不能删除<code>/usr/foo</code>目录。</li>
<li>如果<code>oldpath</code>指向symbolic link，<code>rename</code>不follow symbolic link，直接处理symbolic link本身。</li>
<li>不能对<code>.</code>和<code>..</code>进行重命名。或者说<code>.</code>和<code>..</code>不能出现在<code>oldpath</code>和<code>newpath</code>上。</li>
<li>当<code>oldpath</code>和<code>newpath</code>指向同一个文件，函数不做任何操作直接返回。</li>
<li><code>renameat</code>和<code>rename</code>类似。</li>
</ol>
<h2 id="文件长度">文件长度</h2>
<p><code>struct stat</code>中的<code>st_size</code>以字节为单位表示文件的长度。这个字段只对普通文件，目录文件和symbolic link有意义。<br>
对于普通文件，它的长度可以是0，在开始读这种文件时，得到EOF标志。<br>
对于目录，文件长度通常是一个数的整数倍。<br>
对于symbolic link，文件长度是链接指向的文件名的实际字节数，不包含null字节。<br>
对于现在的大多数UNIX系统，提供了<code>st_blksize</code>和<code>st_blocks</code>字段。<code>st_blksize</code>表示对文件I/O适合的块长度，第二个是所分配的固定大小的block数量。</p>
<h3 id="文件中的hole">文件中的hole</h3>
<ol>
<li>普通文件可以有hole，hole是当前文件偏移量超过文件尾端，然后进行写入造成的。</li>
<li>对于同样长度的有空洞和没有空洞的文件来说，它们所占用的blocks块数是不同的。这里说的同样长度指的是字节数，使用<code>ls -l</code>列出来的长度，那些空洞不占用磁盘上的存储区。</li>
<li>使用<code>cat</code>进行复制时，会将空洞使用0字节填满。</li>
<li>使用<code>du -s file.txt</code>可以查看文件所占用的blocks数量，这些blocks中还有一些用来存放指向实际数据块的指针。</li>
</ol>
<h3 id="文件截断">文件截断</h3>
<p>可以使用<code>truncate</code>和<code>ftruncate</code>截断文件，函数原型是：</p>
<h4 id="函数原型-v7">函数原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="特点-v4">特点</h4>
<ol>
<li>当<code>length</code>长度小于原来文件的长度时，超过<code>length</code>的进行截断。</li>
<li>当<code>length</code>长度大于原来文件的长度时，原来的文件长度到<code>length</code>之间的数据被读作0。</li>
<li><code>ftruncate</code>操作的是文件描述符，<code>truncate</code>操作的是文件。</li>
</ol>
<h2 id="文件的时间">文件的时间</h2>
<h3 id="文件的三个时间">文件的三个时间</h3>
<p>每一个文件守护三个时间：</p>
<ol>
<li><code>st_atim</code>，记录文件数据的最后访问时间。使用<code>ls -u</code>查看。</li>
<li><code>st_mtim</code>，记录文件数据的最后修改时间。默认的<code>ls</code>显示的就是文件的最后修改时间。</li>
<li><code>st_ctim</code>，记录i-node状态的最后更改时间。使用<code>ls -c</code>查看。常见的许多操作都会影响i-node，主要就是<code>i-node</code>中存放的那些信息，更改文件权限，更改文件的<code>st_uid</code>和<code>st_gid</code>，文件的链接数等等。</li>
</ol>
<p>这个让我想不明白的是为什么<code>link</code>,<code>unlink</code>,<code>creat</code>等会影响所使用文件的父目录的inode节点。</p>
<h3 id="函数futimens-utimensat和utimes原型">函数<code>futimens</code>, <code>utimensat</code>和<code>utimes</code>原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimensat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>], <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">futimens</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct timespec times[<span class="number">2</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utimes</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *filename, <span class="keyword">const</span> struct timeval times[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="函数futimens-utimensat和utimes性质">函数<code>futimens</code>, <code>utimensat</code>和<code>utimes</code>性质</h3>
<ol>
<li>
<p>如果<code>times</code>为空，访问时间和修改时间都设为当前时间</p>
</li>
<li>
<p>如果<code>times</code>指向两个<code>timespec</code>结构的数组，任一元素的<code>tv_nsec</code>字段的值为<code>UTIME_NOW</code>，相应的时间戳设置为当前时间，忽略相应的<code>tv_sec</code>字段。</p>
</li>
<li>
<p>如果<code>times</code>指向两个<code>timespec</code>结构的数组，任一元素的<code>tv_nsec</code>字段的值为<code>UTIME_OMIT</code>，相应的时间戳保持不变，忽略相应的<code>tv_sec</code>字段。</p>
</li>
<li>
<p>如果<code>times</code>指向两个<code>timespec</code>结构的数组，<code>tv_nsec</code>字段的值既不是<code>UTIME_NOW</code>也不是<code>UTIME_OMIT</code>，相应的时间戳设置为相应的<code>tv_sec</code>和<code>tv_nsec</code>字段。</p>
</li>
<li>
<p><code>futimens</code>需要打开文件更改它的时间</p>
</li>
<li>
<p><code>utimensat</code>可以使用文件名更改时间。</p>
</li>
<li>
<p><code>utimes</code>对路径进行操作。</p>
</li>
<li>
<p><code>struct timespec</code>结构体是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;</span><br><span class="line">    <span class="keyword">long</span> tv_nsec;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p><code>struct timeval</code> 结构体是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span>&#123;</span></span><br><span class="line">    <span class="keyword">time_t</span> tv_sec;  <span class="comment">//秒</span></span><br><span class="line">    <span class="keyword">long</span> tv_usec;   <span class="comment">//微妙</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<h2 id="读目录">读目录</h2>
<p>目录可以被任何具有读权限的用户读取，但是为了保护文件系统，只有kernel可以写目录。目录的<code>w</code>权限位和<code>x</code>权限位表示的是用户是否可以在目录中创建或者删除新文件，并不是说用户可以写目录本身。</p>
<p>给出<code>opendir</code>, <code>fopendir</code>,</p>
<h3 id="函数原型-v8">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function">DIR *<span class="title">fdopendir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rewinddir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">telldir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">seekdir</span><span class="params">(DIR *dirp, <span class="keyword">long</span> loc)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="函数性质">函数性质</h3>
<ol>
<li><code>opendir</code>将文件转换成目录处理函数需要的<code>DIR</code>结构，而<code>fdopendir</code>将文件描述符转换成目录处理函数需要的<code>DIR</code>结构。这里的<code>DIR</code>到底是什么，没有告诉，so上有一个回答说它是不透明数据类型，只需要使用它，不需要知道它的定义[3]。</li>
<li><code>telldir</code>和<code>seekdir</code>不是POSIX.1的组成部分，但是它是SUS的XSI扩展。所有UNIX系统都会提供这两个实现。</li>
<li><code>struct dirent</code>结构体定义在<code>&lt;dirent.h&gt;</code>头文件中，它与实现相关，但是必须包含以下两个成员：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ino_d d_ino;</span><br><span class="line"><span class="keyword">char</span> d_name[];</span><br></pre></td></tr></table></figure></li>
</ol>
<p>POSIX.1并没有定义<code>d_ino</code>，而POSIX.1的XSI扩展定义了<code>d_ino</code>。</p>
<ol start="4">
<li><code>DIR</code>是一个内部结构，这几个函数使用这个内部结构保存当前正在被读的目录的有关信息。<code>opendir</code>和<code>fdopendir</code>返回<code>DIR</code>，而其他函数把<code>DIR</code>当做参数。<br>
使用<code>opendir</code>打开文件时，<code>readdir</code>返回的是目录项中的第一项。<br>
使用<code>fdopndir</code>打开文件时，<code>readdir</code>返回的第一项取决于传递给<code>fopendir</code>的文件描述符的当前文件偏移量。</li>
</ol>
<h2 id="函数chdir-fchdir和getcwd">函数<code>chdir</code>, <code>fchdir</code>和<code>getcwd</code></h2>
<p>每一个进程都有一个当前工作目录，**当前工作目录是进程的一个属性，**这个目录是搜索所有相对路径名的起点，不以&quot;/&quot;开始的路径名都是相对路径名。可以使用<code>chdir</code>后者<code>fchdir</code>改变当前进程的工作目录。它们的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchdir</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getcwd</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><code>chdir</code>的参数是<code>path</code>，而<code>fchidir</code>的参数是文件描述符。</p>
<h3 id="chdir只会改变当前进程的work-dir"><code>chdir</code>只会改变当前进程的work dir</h3>
<p>**需要注意的一点是，<code>chdir</code>和<code>fchdir</code>只改变调用这个函数本身的进程，并不影响其他进程。**比如在shell中运行一个程序，在这个程序中更改了进程的当前工作目录，结束这个程序的执行时，shell的当前工作目录并不会改变，因为shell和我们刚才执行的程序属于两个不同的进程。因此，如果要改变shell进程自己的工作目录，应该使用shell直接调用<code>chdir</code>函数，所以<code>cd</code>命令内建在shell中。<br>
<code>getcwd</code>是获得进程当前工作的绝对路径名。内核并不保存目录的完整路径名（linux除外），为了获得进程当前工作的绝对路径名。<code>getcwd</code>需要从当前工作目录开始，找到它的上一级目录，读取目录项，找到和工作目录i节点编号相同的目录项，得到对应的文件名。就这样一层一层的向上找，这就找到了绝对路径名。<code>getcwd</code>会followsymbolic link，但是不会知道它是由哪里链接到这里的。</p>
<h3 id="和进程相关的目录getcwd">和进程相关的目录<code>getcwd</code></h3>
<p>当一个应用程序需要在经过一些列目录操作之后返回它刚开始的工作目录时。可以先使用<code>getcwd</code>获得最开始的工作目录，保存起来，最后再使用<code>chdir</code>进行恢复。<br>
<code>fchdir</code>可以有更简单的操作，在刚开始时，保存目录的文件描述符。最后使用<code>fchdir</code>直接打开这个文件描述符。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://unix.stackexchange.com/questions/21251/execute-vs-read-bit-how-do-directory-permissions-in-linux-work" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/21251/execute-vs-read-bit-how-do-directory-permissions-in-linux-work</a><br>
3.<a href="https://superuser.com/questions/168578/why-must-a-folder-be-executable/168583" target="_blank" rel="noopener">https://superuser.com/questions/168578/why-must-a-folder-be-executable/168583</a><br>
4.<a href="https://stackoverflow.com/questions/22122405/where-is-dir-defined" target="_blank" rel="noopener">https://stackoverflow.com/questions/22122405/where-is-dir-defined</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/20/data-structure-bineary-search-trees-vs-binary-heaps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/20/data-structure-bineary-search-trees-vs-binary-heaps/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">data structure bineary search trees vs binary heaps</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-20 09:37:58" itemprop="dateCreated datePublished" datetime="2019-11-20T09:37:58+08:00">2019-11-20</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:13:35" itemprop="dateModified" datetime="2019-12-17T16:13:35+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/6147242/heap-vs-binary-search-tree-bst" target="_blank" rel="noopener">https://stackoverflow.com/questions/6147242/heap-vs-binary-search-tree-bst</a><br>
2.<a href="https://cs.stackexchange.com/questions/27860/whats-the-difference-between-a-binary-search-tree-and-a-binary-heap" target="_blank" rel="noopener">https://cs.stackexchange.com/questions/27860/whats-the-difference-between-a-binary-search-tree-and-a-binary-heap</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/18/UNIX-file-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/18/UNIX-file-IO/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">UNIX file I/O</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 19:19:20" itemprop="dateCreated datePublished" datetime="2019-11-18T19:19:20+08:00">2019-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-24 10:10:01" itemprop="dateModified" datetime="2019-11-24T10:10:01+08:00">2019-11-24</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="注意事项">注意事项</h2>
<ol>
<li><code>creat</code>以只写方式打开文件，不能进行读操作。</li>
<li>为什么有了<code>open</code>要有<code>creat</code>，早期的<code>open</code>只支持0,1,2三个flag，不能打开不存在的文件，需要有单独的系统调用创建文件。而有了新的<code>open</code>以后就不需要<code>creat</code>了。</li>
<li><code>open</code>和<code>dup</code>返回的文件描述符一定是最小的未使用的文件描述符。</li>
<li>以<code>O_APPEND</code>打开的文件，如果进行<code>write</code>的话，即使使用<code>lseek</code>定位到非文件结尾处，最后也是在文件结尾处进行写。因为使用<code>O_APPEND</code>的<code>write</code>是由两个系统调用函数<code>lseek</code>和“普通的”<code>write</code>构成的一个操作。而<code>read</code>操作可以使用<code>lseek</code>进行定位。</li>
<li>所有的磁盘I/O都要经过内核的block buffers块缓存区，也称为内核的(buffer cache)缓冲区高速缓存。有一个例外就是对原始磁盘设备的I/O，先不考虑这种情况。<code>read</code>和<code>write</code>的数据都要被内核进行缓冲，术语unbuffered I/O指的是在用户的进程中不会对这两个函数进行自动缓冲，每次<code>read</code>和<code>write</code>都会进行一次系统调用。</li>
</ol>
<h2 id="文件i-o">文件I/O</h2>
<p>UNIX系统中的大多数文件I/O只用到了5个函数：<code>open</code>,<code>read</code>,<code>write</code>, <code>lseek</code>和<code>close</code>。不同的缓冲长度对<code>read</code>和<code>write</code>的速度影响。<br>
本章介绍的函数通常被称为不带缓冲的I/O，不带缓冲的I/O指的是每个<code>read</code>和<code>write</code>都调用内核中的一个系统调用，它们不是ISO C的组成部分，但是，它们都是POSIX.1和SUS的组成部分。<br>
只要涉及在多个进程之间共享资源，原子操作的概念就非常重要。本章还进行一步讨论在多个进程之间如何共享文件，以及所涉及的内核有关数据结构。相应的函数有：<code>dup</code>, <code>fcntl</code>,<code>sync</code>, <code>fsync</code>和<code>ioctl</code>等。</p>
<h2 id="文件描述符">文件描述符</h2>
<p>对于内核而言，所有打开的文件都是通过文件描述符引用。文件描述符是一个非负整数。当打开或者创建一个新文件时，内核向进程返回一个文件描述符。当读，写一个文件时，使用<code>open</code>或者<code>creat</code>返回的文件描述符标识该文件，将其作为参数传递给<code>read</code>或者<code>write</code>。<br>
UNIX系统shell把文件描述符0和进程的标准输入关联，文件描述符1和标准输出关联，文件描述符2和标准错误关联。为了提高系统的可读性，通常把它们换成符号常量<code>STDIN_FILENO</code>,<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>，它们都在头文件<code>&lt;unistd.h&gt;</code>中定义。<br>
文件描述符的变化范围是0到<code>OPEN_MAX-1</code>，早起的UNIX系统实现采用的上限值是19，现在的很多系统将它增加到63。（对于Linux, FreeBSD等的很多版本，文件描述符的变化范围几乎是无限的，只受到硬件资源的约束）</p>
<h2 id="open-openat和creat-close"><code>open</code>,<code>openat</code>和<code>creat</code>, <code>close</code></h2>
<p>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>pathname</code>是路径名，可以是相对路径也可以是绝对路径，<code>flags</code>的选项有很多，它们定义在<code>&lt;fcntl.h&gt;</code>头文件中。flag参数必须在<code>O_RDONLY</code>,<code>O_WRONLY</code>和<code>O_RDWR</code>之中选且只能选一个。然后还有很多其他的可选flag，常见的有：<code>O_APPEND</code>，<code>O_CREAT</code>，<code>O_EXCL</code>, <code>O_DIRECTORY</code>等，使用<code>man 2 open</code>就可以查看。</p>
<h3 id="openat-vs-open"><code>openat</code> vs <code>open</code></h3>
<p><code>open</code>和<code>openat</code>返回的一定是最小的没有使用的文件描述符。可以利用这一点可以在标准输入，标准输出，或者标准错误上打开新的文件。一个应用程序可以先关闭标准输出，然后打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符1上打开。<br>
<code>dirfd</code>参数是<code>open</code>和<code>openat</code>的区别，它们之间的关系有以下三种：</p>
<ol>
<li><code>pathname</code>指定的是绝对路径名，<code>dirfd</code>参数被忽略，<code>open</code>和<code>openat</code>一样。</li>
<li><code>pathname</code>指定的是相对路径名，<code>dirfd</code>制定了相对路径名在文件系统中的开始地址，<code>dirfd</code>参数通过打开相对路径名的目录来获取。</li>
<li><code>pathname</code>指定了相对路径名，<code>dirfd</code>的参数是特殊值<code>AT_FDCWD</code>，这种情况下，路径名是在当前工作目录中获取，<code>openat</code>和<code>open</code>在操作上类似。</li>
</ol>
<h3 id="openat作用"><code>openat</code>作用</h3>
<p>为什么增加<code>openat</code>函数，它的目的是解决两个问题：</p>
<ol>
<li>让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。同一进程中的所有线程共享相同的当前工作目录。</li>
<li>避免time-of-check-to-time-of-use错误。它的基本思想是，如果有两个基于文件的系统调用，第二个调用的结果依赖于第一个调用的结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间，文件可能改变了，这就造成了第一个调用的结果不再有效，使得程序的最终结果是错误的。</li>
</ol>
<h3 id="文件名和路径名过长">文件名和路径名过长</h3>
<p>当文件名和路径名过长时，是截断为系统允许的最长量还是返回出错信息？这个是由系统的历史形成的。通常BSD和Linux总是会返回出错，而System V和Solaris等不一定。<br>
具体的可以根据POSIX.1定义的常量<code>_POSIX_NO_TRUC</code>决定是截断还是出错。根据文件系统的类型，这个值可以变换。可以使用<code>fpathconf</code>或者<code>pathconf</code>查询目录具体支持哪种行为。<br>
如果<code>_POSIX_NO_TRUC</code>有效，当路径名超过<code>PATH_MAX</code>或者路径名中的任一文件名超过<code>NAME_MAX</code>时，返回出错，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。</p>
<h3 id="create和open"><code>create</code>和<code>open</code></h3>
<p><code>create</code>其实相当于指定了<code>open</code>的flags为<code>O_WRONLY|O_CREAT|O_TRUNC</code>。<br>
为什么有了<code>open</code>还要有<code>creat</code>，在早期的UNIX版本中，<code>flags</code>只能为0,1或者2。无法打开一个不存在的文件。因此需要另一个系统调用<code>creat</code>创建新文件。现在的<code>open</code>系统调用提供了<code>O_CREAT</code>和<code>O_TRUNC</code>选项，也就不需要<code>creat</code>了。</p>
<p><code>creat</code>的不足：<code>creat</code>以<strong>只写方式</strong>打开所创建的文件，即创建新文件之后，只能对新文件进行写操作，不能进行读操作。如果要创建一个临时文件，先写文件，然后再读文件。在<code>open</code>的老版本时，即不能打开不存在的文件时，需要先使用<code>creat</code>创建新文件，然后关闭该文件，然后使用<code>open</code>读文件。现在的话，可以使用以下方式实现创建新文件并进行读写：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_RDWR|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<h3 id="close函数"><code>close</code>函数</h3>
<p>调用<code>close</code>关闭一个已经打开的文件。函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建文件">创建文件</h3>
<ol>
<li>
<p>创建一个只写文件（如果文件存在，将文件清零）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">creat(filename, mode);</span><br><span class="line">open(filename, O_WRONLY|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>创建一个读写文件（如果文件存在，将文件清零）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_RDWR|O_CREAT|O_TRUNC);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>检测并创建一个只写文件（ 如果文件存在，错处，返回-1）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_WRONLY|O_CREAT|O_EXCL, mode);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>检测并创建一个读写文件（ 如果文件存在，错处，返回-1）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_RDWR|O_CREAT|O_EXCL, mode);</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<h2 id="lseek-read-write"><code>lseek</code>, <code>read</code>, <code>write</code></h2>
<p>它们的原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<h3 id="当前文件偏移量">当前文件偏移量</h3>
<ol>
<li>每一个打开文件都有一个和它相关联的当前文件偏移量(current file offset)。它通常是一个非负整数，用来度量从文件开始处的字节数。</li>
<li>通常情况下，读写操作都是从current file offset开始的，并且使偏移量增加读写的字节数。</li>
<li>除了指定<code>O_APPEND</code>选项外，打开一个文件时，默认的current file offset都是0。</li>
<li><code>whence</code>有三个取值，<code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code>。<code>lseek</code>成功执行，返回的offset等于<code>whence+offset</code>，对于<code>SEEK_CUR</code>和<code>SEEK_END</code>来说，参数<code>offset</code>可正可负，只要保证返回的current file offset非负即可。</li>
<li><code>lseek</code>中的<code>l</code>表示<code>long</code>。</li>
<li>current file offset可以大于文件长度，这种情况会在文件中构成一个空洞。空洞不要求占据磁盘上的存储区。</li>
</ol>
<h3 id="read"><code>read</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p><code>read</code>函数从文件描述符标示的文件中读取至多<code>count</code>个字节到<code>buf</code>指定的位置。如果操作成功的话，返回读到的字节数，如果已经到了文件结尾，返回0。出错的话，返回-1，设置errno。<br>
在以下几种情况下，读到的字节数可能少于<code>count</code>：</p>
<ol>
<li>读普通文件时，在读满<code>count</code>个之前就已经到了文件尾端。</li>
<li>某个信号造成中断时，而已经读取了部分数据时。</li>
<li>从终端设备读时，通常一次最多读一行。</li>
<li>从网络读时，网络中的缓冲机制。</li>
<li>从管道或者FIFO读取时，管道包含的字节数少于<code>count</code>。</li>
<li>从面向记录的设备读时，一次最多返回一个记录。</li>
<li>第二个参数<code>void*</code>表示通用指针。</li>
<li>返回值<code>ssize_t</code>是有符号类型，因为它需要返回正整数字节，0和-1。</li>
<li>第三个参数<code>size_t</code>是一个无符号类型。</li>
</ol>
<h3 id="write"><code>write</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p>它的返回值通常和<code>count</code>一样，否则就是出错了。出错的常量原因有：</p>
<ol>
<li>磁盘满了，</li>
<li>超过了一个给定进程的文件长度限制。</li>
<li>如果<code>lseek</code>返回的当前文件偏移量不在文件结尾，<code>write</code>会覆盖掉相应位置的数据。</li>
</ol>
<p>对于普通文件，写操作从文件的当前偏移量开始，如果打开文件时指定了<code>O_APPEND</code>选项，那么文件偏移量设置在文件结尾处。在一次写成功之后，文件偏移量增加实际写的字节数。</p>
<h3 id="创建含有空洞的文件">创建含有空洞的文件</h3>
<p>当<code>lseek</code>使得当前文件偏移量超过了现有文件长度，再继续进行<code>write</code>之后，当前文件偏移量和文件长度之间的内容就是空洞，它一般不占用磁盘空间，但是使用<code>ls</code>时，会把它计算成字节长度。</p>
<h2 id="i-o的效率">I/O的效率</h2>
<p>进程终止时，UNIX系统内核会关闭所有打开的文件描述符，但是并不会关闭标准输入和输出。<br>
在选取<code>read</code>和<code>write</code>的buffer大小时，也有一定技巧。大多数文件系统都使用了预读(read ahead)技术。当进行顺序读取时，系统试图读入比应用所要求的更多数据，并且假设应用很快就会读这些数据。<br>
在使用<code>ext4</code>文件系统时，它的磁盘块长度是4096，所以当BUFFER大于等于4096时，读写时间几乎不变。</p>
<h2 id="文件共享">文件共享</h2>
<h3 id="i-o数据结构">I/O数据结构</h3>
<p>UNIX支持在不同进程之间共享打开文件。这需要使用到内核用于I/O的数据结构。内核使用三种数据结构表示打开文件：进程表记录项，文件表项和节点表项。</p>
<ol>
<li>进程表记录项。每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，每隔描述符占用一项，其中内容有：文件描述符标志和指向文件表项的指针。</li>
<li>文件表项。内核为所有打开文件维持一张文件表。每个表项包含：文件状态标志，当前文件偏移量和指向该文件节点表项的指针</li>
<li>节点表项。每个打开设备都有一个节点结构。包含文件的所有者，文件长度，指向文件实际数据块在磁盘上所在的指针等。</li>
</ol>
<p>如果两个进程打开了同一个文件，每个进程都会获得各自相应文件的一个文件表项，这两个文件表项中的节点表项指针指向同一个节点表项。也有可能多个进程的文件描述符指向同一个文件表项。<br>
自己的总结，每一个文件都有一个节点表项，记录文件长度和数据存储地址，而文件表项记录的是在节点表项的哪个位置进行什么操作，进程表记录项记录了每个进程打开了几个文件，每个文件的文件表项在哪里。</p>
<h3 id="write和lseek对当前文件偏移量的影响"><code>write</code>和<code>lseek</code>对当前文件偏移量的影响</h3>
<ol>
<li><code>write</code>在写入完成后，在文件表项的当前文件偏移量上加上写入的字节数，如果当前文件偏移量超过了当前文件长度，更新节点表项中的文件长度，相当于文件长度增加了。</li>
<li><code>lseek</code>只修改文件表项中的当前文件偏移量，不进行任何I/O操作。</li>
<li><code>lseel</code>定位到文件尾端的时候，文件表项中当前文件偏移量被设置为节点表项中的当前文件长度。</li>
<li>使用<code>O_APPEND</code>打开文件的时候，文件表项中的文件状态标志也会被修改，对于使用<code>O_APPEND</code>操作打开的文件，进行<code>write</code>操作相当于先将当前文件偏移量设置为节点表项中的文件长度，然后再<code>write</code>，即使先使用<code>lseek</code>将当前文件偏移量设置为<code>SEEK_SET</code>也不行，也是进行追加。所以在每次append之前不用先进行<code>lseek</code>，<code>lseek</code>了也白做。但是<code>read</code>可以使用<code>lseek</code>正常进行。</li>
</ol>
<h2 id="原子操作">原子操作</h2>
<p>如果一个操作是原子操作，那么这个操作的所有步骤要么不执行，要不全部执行。</p>
<h3 id="追加文件">追加文件</h3>
<p>指定<code>open</code>的<code>O_APPEND</code>选项实现追加操作，<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fileno=open(filename, O_RDWR|O_APPEND);</span><br><span class="line">write(file, buf, BUFSIZE);</span><br></pre></td></tr></table></figure></p>
<p>追加文件是一个原子操作，如果不是原子操作的话，就相当于：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fileno = open(filename, O_RDWR);</span><br><span class="line">lseek(fileno, <span class="number">0</span>, SEEK_END);</span><br><span class="line">write(fileno, buf, BUFSIZE);</span><br></pre></td></tr></table></figure></p>
<p>如果是单进程，上面两段代码是等价的，但是如果是多进程的话，下面代码就可能会出错。进程A lseek，进程B lseek，进程A write，进程B write。进程B的操作会覆盖进程A的操作。<br>
所以这也就解释了使用选项<code>O_APPEND</code>后的操作，因为这个append的<code>write</code>是由两个系统调用组成的原子操作，先<code>lseek</code>，再普通的<code>write</code>。所以在调用<code>write</code>之前不用<code>lseek</code>，就算你<code>lseek</code>了也是白<code>lseek</code>。</p>
<h3 id="读写原子操作">读写原子操作</h3>
<p>读写的原子操作原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>pread</code>相当于调用<code>lseek</code>和<code>read</code>的原子操作，但是<code>pread</code>不改变当前文件偏移量。<br>
调用<code>write</code>相当于调用<code>lseek</code>和<code>write</code>的原子操作，但是<code>pwrite</code>不改变当前文件偏移量。</p>
<h3 id="创建文件原子操作">创建文件原子操作</h3>
<p>检查文件是否存在和创建文件是一个原子操作。如果这个操作不是原子操作，比如说是由<code>open</code>和<code>creat</code>两个函数调用组成的一个操作，它们不是一个原子操作。当前进程确定一个文件不存在，决定创建该文件。在<code>open</code>和<code>creat</code>调用之间，另一个进程创建了这个文件，并写入了数据。当前进程会再次创建这个文件，覆盖掉另一个进程写入的数据。</p>
<h2 id="dup和dup2复制文件描述符"><code>dup</code>和<code>dup2</code>复制文件描述符</h2>
<p>UNIX系统提供了两个原子操作<code>dup</code>和<code>dup2</code>对一个指定的文件描述符进行复制。如果得到的新文件描述符和fd不同，那么这两个文件描述符共享同一个文件表项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dup返回的文件描述符一定是当前可用文件描述符中的最小值。和open一个文件类似。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过fd2指定返回的新的文件描述符。</span></span><br><span class="line"><span class="comment">// 如果fd2和fd相等，返回fd2</span></span><br><span class="line"><span class="comment">// 如果fd2和fd不等，关闭fd2，然后返回fd2。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(inf fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>非原子操作的文件描述符复制可以通过<code>fcntl</code>实现。</p>
<h2 id="sync-fsync和fdatasync"><code>sync</code>,<code>fsync</code>和<code>fdatasync</code></h2>
<p>UNIX系统在内核中设置了缓冲区高速缓存或者页高速缓存，大多数磁盘的I/O都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些写入磁盘，这方方式叫做<strong>延迟写</strong>。<br>
等到内核需要使用缓冲区存放其他磁盘块数据时，它会把所有延迟写数据写入磁盘。为了保证磁盘上实际文件系统和缓冲区中内容的一致性，UNIX提供了三个函数，它们的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.将所有修改过的块缓冲区排入队列，然后就返回，并不等待实际写磁盘操作结束。</span></span><br><span class="line"><span class="comment">// 通常情况下，update系统守护进程一般每隔30秒调用一次`sync`函数，这就保证了定期将内核块缓冲区的内容写入磁盘。命令sync(1)也会调用`sync`函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.只对文件描述符`fd`指定的一个文件起作用，等到写磁盘操作结束才返回。更新文件的数据和属性。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.只对文件描述符`fd`指定的一个文件起作用，等到写磁盘操作结束才返回。只更新文件的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="fcntl"><code>fcntl</code></h2>
<p>fcntl是文件控制函数，它的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>fcntl有很多种功能，这一节先介绍以下五种：</p>
<ol>
<li>复制一个已有的描述符，设置<code>cmd</code>为<code>F_DUPFD</code>或者<code>F_DUPFD_CLOEXEC</code>。</li>
<li>获取和设置文件描述符标志，设置<code>cmd</code>为<code>F_GETFD</code>或者<code>F_SETFD</code>。当前只有一个文件描述符标志，就是<code>FD_CLOEXEC</code>。</li>
<li>获取和设置文件状态标志，设置<code>cmd</code>为<code>F_GETFL</code>或者<code>F_SETFL</code>。<br>
获取文件状态标志时，介绍<code>open</code>时给出了许多文件状态标志。对于五个互斥的权限，需使用<code>O_ACCMODE</code>取得访问方式位，然后与相应的权限比对。对于其他的权限，将返回值和相应的标志进行与操作，判断是否设置了相应位。<br>
设置文件状态标志位时，可以更改的几个权限有，<code>O_APPEND</code>, <code>O_NONBLOCK</code>, <code>O_SYNC</code>, <code>O_DSYNC</code>, <code>O_RSYNC</code>, <code>O_FSYNC</code>, <code>O_ASYNC</code>。</li>
<li>获取和设置异步I/O所有权，设置<code>cmd</code>为<code>F_GETOWN</code>或者<code>F_SETOWN</code>。</li>
<li>获取和设置记录锁，设置<code>cmd</code>为<code>F_GETLK</code>，或者<code>F_SETLK</code>或者<code>F_SETLKW</code>。</li>
</ol>
<p>在修改文件描述符标志或者文件状态标志时，必须要先获得现在的标志值，然后对它进行修改，获得新的标志值，然后进行设置。不能单单设置一个标志值，否则会关闭以前设置的标志位。</p>
<h2 id="ioctl"><code>ioctl</code></h2>
<p>这个有点看不懂。</p>
<h2 id="dev-fd"><code>/dev/fd</code></h2>
<p>UNIX提供了<code>/dev/fd</code>目录，其中包含了名为0, 1, 2的文件。打开<code>/dev/fd/0</code>,<code>/dev/fd/1</code>, <code>/dev/fd/2</code>相当于复制描述符n。即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/df/0"</span>, mode);</span><br><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>上述两行代码是相等的。文件描述符0和fd共享同一个文件表项。在Linux中，文件描述符被映射成指向底层物理文件的符号链接。比如打开<code>/dev/fd/0</code>时，实际上打开的是与标准输入关联的文件。返回的新文件描述符的mode和<code>/dev/fd</code>文件描述符的mode并不相关。所以，即使我们使用<code>O_RDWR</code> mode打开<code>/dev/fd/0</code>，也不能对<code>fd</code>进行写操作。<br>
Linux下提供了<code>/dev/stdin</code>，<code>/dev/stdout</code>, <code>/dev/stderr</code>，它们和<code>/dev/fd/0</code>等都是一样的。在shell中，可以使用dev/fd作为参数，把标准输入和输出当做一个文件，可以像处理其他文件一样进行操作。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/18/how-C-program-works/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/18/how-C-program-works/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">How C program works</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 14:27:10" itemprop="dateCreated datePublished" datetime="2019-11-18T14:27:10+08:00">2019-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-19 22:36:20" itemprop="dateModified" datetime="2019-11-19T22:36:20+08:00">2019-11-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="none"></h2>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://mapan1984.github.io/program/2018/03/10/C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/#c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">https://mapan1984.github.io/program/2018/03/10/C-编译过程与库文件的作用/#c语言编译过程</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/14/C-lvalue-and-rvalue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/14/C-lvalue-and-rvalue/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">C and C++ lvalue and rvalue</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-14 17:22:02" itemprop="dateCreated datePublished" datetime="2019-11-14T17:22:02+08:00">2019-11-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:14:38" itemprop="dateModified" datetime="2019-12-17T16:14:38+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对象-object-和值-value">对象(object)和值(value)</h2>
<h3 id="c11标准">C11标准</h3>
<p>C11标准的定义如下([14]3.15, 3.19)：</p>
<blockquote>
<p>3.15 object<br>
region of data storage in the execution environment, the contents of which can represent values<br>
NOTE When referenced, an object may be interpreted as having a particular type; see 6.3.2.1.<br>
3.19 value<br>
precise meaning of the contents of an object when interpreted as having a specific type</p>
</blockquote>
<p>object是一块内存空间，它的内容可以表示值。当被使用时，一个对象可以解释为一种特定的类型。value是以具体类型解析object中的内容。</p>
<h3 id="c-11标准">C++11标准</h3>
<p>C++11标准的定义如下([17]1.8)：</p>
<blockquote>
<p>An object is a region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. — end note ]<br>
An object can have a name.<br>
An object has a storage duration which influences its lifetime.<br>
An object has a type.<br>
The term object type refers to the type with which the object is created.</p>
</blockquote>
<p>C++ 中的obejct也是一个内存空间。object可以有名字，可以有类型（内置类型还是复合类型都行），有一个duration。也就是C++ Primer第五版中说的对象是具有某种数据类型的内存空间，可以有名，可以没有名字。</p>
<h2 id="c语言中的lvalue和rvalue">C语言中的lvalue和rvalue</h2>
<h3 id="左值和右值的定义">左值和右值的定义</h3>
<p>C中早期的定义：<br>
左值是一个表达式，可以出现在赋值操作的左边或者右边，而右值只能出现在左边。<br>
C11中左值的定义：</p>
<blockquote>
<p>An lvalue is an expression (with an object type other than void) that potentially designates an object;64) if an lvalue does not designate an object when it is evaluated, the behavior is undefined. When an object is said to have a particular type, the type is specified by the lvalue used to designate the object. A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a constqualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a constqualified type.</p>
</blockquote>
<h3 id="可修改左值和不可修改左值">可修改左值和不可修改左值</h3>
<ol>
<li>
<p>左值指向的位置的内容，如果可以被修改，那么这个左值是一个可修改左值，否则就是不可修改左值。</p>
</li>
<li>
<p>如果一个表达式指向内存中的一个位置，并且它的类型是算术类型，<code>struct</code>，<code>union</code>或者pointer，那么它就是一个可修改左值。</p>
</li>
<li>
<p>可修改左值不能含有数组类型，不完整的类型，<code>const</code>修饰的类型，它们都是不可修改左值。如果<code>struct</code>或者<code>union</code>要是可修改左值，那么它们不能有<code>const</code>成员。</p>
</li>
<li>
<p>为什么可修改左值不能是<code>array</code>，我们不能对数组赋值，但是可以通过下标操作对数组进行赋值，所以数组名字不能是一个可修改的左值。或者说数组名字其实是数组首元素的地址。这里的数组赋值说的是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">b = a;  <span class="comment">//想要做的操作是把数组a赋值给数组b，这是错误的。</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>为什么没有说函数不能是可修改左值，函数名指定的是一个函数不是一个对象，所以函数名不能是左值，自然也不能是一个可修改左值。</p>
</li>
<li>
<p>数组和指针都是左值，但是数组是不可修改左值，而指针是可修改左值（非const）。数组作为作为右值表示的是数组首元素的地址，数组作为左值，表示的是数组类型，是不能修改的左值。而指针变量可以作为左值，因为我们可以取得它的地址，指针变量作为右值是指针变量存储的值，即它指向变量的地址。</p>
</li>
</ol>
<h3 id="左值类型">左值类型</h3>
<p>C语言中的左值有以几种：</p>
<ol>
<li>任意类型变量的名字</li>
<li>下标运算符<code>[]</code></li>
<li>指针的成员访问操作<code>-&gt;</code>和<code>.</code></li>
<li>单目运算符解引用<code>*</code>的表达式，不能指向一个数组</li>
<li>指针的解引用操作，不能是一个函数指针</li>
<li>数组，<code>const</code>对象，是一个不可修改左值，比如<code>const int a = 0;</code>，<code>a</code>是一个不可修改左值</li>
<li>字符串字面值常量是一个不可修改左值[12]，因为C中没有字符串类型，字符串常量都是以字符数组类型存储的，而在C中，除了左值以外没有任何方式可以让数组存在于表达式中。</li>
</ol>
<h3 id="左值和右值的转换">左值和右值的转换</h3>
<h4 id="左值到右值的隐式类型转换-13">左值到右值的隐式类型转换[13]</h4>
<ol>
<li>C语言存在左值到右值的默认类型转换，当运算符需要右值操作对象时，而给出的是左值操作对象时，编译器会默认将左值转换成右值。</li>
<li>数组到指针的转换。在需要右值操作对象的时候，编译器换将数组名转换为其首元素的地址，类型为指向元素的指针。</li>
<li>函数到指针的转换。</li>
</ol>
<p>一般情况下，对象之间的运算，对象是以右值的形式参与的。比如<code>+</code>运算符需要两个右值运算数：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中,<code>a</code>和<code>b</code>都是左值，在<code>int c = a+b;</code>中，它们经历了隐式的类型转换，将左值转换为了右值。<br>
除了数组，函数，不完整的类型，所有的左值都可以转换为右值，但是右值不能转换为左值。</p>
<h4 id="右值产生左值">右值产生左值</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a[<span class="number">0</span>]; <span class="comment">//a和&amp;a[0]都是数组首元素的值</span></span><br><span class="line">*(p+<span class="number">1</span>) = <span class="number">-1</span>;    <span class="comment">//p+1是右值，但是*(p+1)是左值</span></span><br></pre></td></tr></table></figure>
<h4 id="左值产生右值">左值产生右值</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;var;  <span class="comment">//var是左值，但是&amp;var是右值。</span></span><br></pre></td></tr></table></figure>
<p>单目运算符<code>&amp;</code>需要一个左值作为它的运算对象，当且仅当<code>n</code>是一个变量时，<code>&amp;n</code>是一个有效的表达式，<code>&amp;12</code>是错误的。</p>
<h2 id="c-中表达式的value-category">C++中表达式的value category</h2>
<p>C++ 中，一个表达式有两个基本属性，基本类型和值类别。在C++ 中有五种value category，它们的关系如下：<br>
<img src="/2019/11/14/C-lvalue-and-rvalue/value_category.png" alt="value_category"><br>
每一个表达式属于三种基本value中的一个：lvalue, xvalue和prvalue，表达式的这种属性叫做value category。</p>
<h3 id="lvalue"><code>lvalue</code></h3>
<blockquote>
<p>An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example,the result of calling a function whose return type is an lvalue reference is an lvalue. — end example ]</p>
</blockquote>
<p>左值指定了一个函数或者对象（变量）。它存放在内存中的某个位置，并且允许使用取值地址符<code>&amp;</code>获取这块内存的地址。如果<code>E</code>是指针类型的表达式，那么<code>*E</code>是<code>E</code>指向的函数或者对象的左值表达式。左值分为可修改左值和不可修改左值，像常量，数组名，等属于不可修改左值，而其它的左值都是可修改左值。如果一个表达式不是左值，那么它就被定义为右值。<br>
怎么样判断左值，满足以下两点中任何一点就是一个左值：</p>
<ol>
<li>是否有名字</li>
<li>是否能够取到它的地址</li>
</ol>
<p>C++ Primer中给出的一个方法：当一个对象被用作右值的时候，用的是对象的值。当一个对象被用作左值的时候，用的是对象在内存中的位置。<br>
示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = &amp;ch; <span class="comment">//ch可以当做左值，也可以当做右值</span></span><br><span class="line">&amp;ch = <span class="number">3</span>;  <span class="comment">//错误，因为&amp;ch我们只能取得它的值，并不能获取它在内存中的地址，即它只是一个右值，不能当做左值。</span></span><br></pre></td></tr></table></figure>
<p><strong>对象（变量）和指针变量中存放的内容（即地址）的区别，对象可以直接进行赋值。指针变量中存放的是一个地址，地址本身就是一个数字，是一个右值，不能对其进行赋值，对这个地址进行解引用，得到指针指向对象的左值表达式。</strong></p>
<h3 id="xvalue"><code>xvalue</code></h3>
<blockquote>
<p>An xvalue (an “eXpiring” value) also refers to an object, usually near the end of its lifetime (so that its resources may be moved, for example). An xvalue is the result of certain kinds of expressions involving rvalue references (8.3.2). [Example: The result of calling a function whose return type is an rvalue reference is an xvalue. — end example ]</p>
</blockquote>
<p><code>xvalue</code>也指向一个对象，通常在对象声明周期的最后。一个<code>xvalue</code>是和右值引用相关的特定表达式的结果。</p>
<h3 id="prvalue"><code>prvalue</code></h3>
<blockquote>
<p>A prvalue (“pure” rvalue) is an rvalue that is not an xvalue.</p>
</blockquote>
<p>prvalue<code>是不是xvalue的rvalue。下列表达式是</code>prvalue`表达式：</p>
<ul>
<li>一个字面值常量（除了字符串常量），比如<code>42</code>, <code>true</code>或者<code>nullptr</code></li>
<li>返回值类型是非引用类型的函数调用或者重载的operator表达式的结果。</li>
<li>内置的后置自增自减运算符, <code>a++</code>, <code>a--</code>。</li>
<li>内置的算术表达式，<code>a+b</code>, <code>a&amp;b</code>, <code>a&lt;&lt;b</code>。</li>
<li><code>a&gt;b</code>, <code>a==b</code>, <code>a&gt;=b</code>，内置的比较表达式</li>
<li><code>&amp;a</code>,内置的取地址符</li>
<li><code>a.m</code>表达式的成员对象，其中<code>m</code>是一个member enumerator或者一个非静态的成员函数，或者[a是一个rvalue，m是一个非引用类型的非静态数据成员，until C++ 11]。</li>
</ul>
<h3 id="glvalue">glvalue</h3>
<blockquote>
<p>A glvalue (“generalized” lvalue) is an lvalue or an xvalue.</p>
</blockquote>
<p>一个glvalue是一个lvalue或者一个xvalue。下面的表达式是xvalue表达式：</p>
<ul>
<li>返回值类型是引用类型的函数调用或者重载的operator表达式的结果。</li>
<li><code>a[n]</code>，内置的下标表达式，a是一个array rvalue。</li>
<li><code>a.m</code>，对象成员的表达式，其中a是一个rvalue，m是一个非引用类型的非静态数据成员。</li>
</ul>
<h3 id="rvalue">rvalue</h3>
<blockquote>
<p>An rvalue (so called, historically, because rvalues could appear on the right-hand side of an assignment expression) is an xvalue, a temporary object (12.2) or subobject thereof, or a value that is not associated with an object.</p>
</blockquote>
<p>一个右值可以是一个xvalue，一个临时对象，或者一个没有和对象关联的值。</p>
<h2 id="c-和c中lvalue的区别">C++和C中lvalue的区别</h2>
<p>《C++ Primer》中说C++ 和C中的左值和右值不一样，我怎么觉得都一样呢。（好吧，自己还是道行太浅了）。<br>
举例来说：</p>
<ol>
<li>比如说<code>++i</code>和<code>--i</code>操作，在C中，它是一个右值，而在C++ 中，它是左值，而<code>i++</code>和<code>i--</code>在C和C++ 中都是右值[9]。</li>
<li>在C语言中，三目运算符（?:）的结果一定是右值，而在C++中，如果:旁边的两个操作数是左值，那么结果也是左值[10]。</li>
</ol>
<h3 id="c-中的左值运算">C++中的左值运算</h3>
<ol>
<li>赋值运算需要一个非常量左值作为左侧运算对象，得到的结果也仍然是一个左值。</li>
<li>取地址符用作一个左值运算对象，返回一个指向该运算对象的地址，这个值是一个右值。</li>
<li>内置解引用运算符，下标运算符，迭代器解引用运算符，<code>string</code>和<code>vector</code>的求值结果都是左值。</li>
<li>内置类型和迭代器的递增递运算符作用于左值运算对象，其前置版本所得的结果也是左值，即<code>++iter</code>, <code>++i</code>等。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C和指针》<br>
2.《C++ Primer》<br>
3.<a href="https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/</a><br>
4.<a href="https://segmentfault.com/a/1190000003793498" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003793498</a><br>
5.<a href="https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type" target="_blank" rel="noopener">https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type</a><br>
6.<a href="https://www.quora.com/What-is-lvalue-and-rvalue-in-C" target="_blank" rel="noopener">https://www.quora.com/What-is-lvalue-and-rvalue-in-C</a><br>
7.<a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c" target="_blank" rel="noopener">https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c</a><br>
8.<a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c" target="_blank" rel="noopener">https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c</a><br>
9.<a href="https://www.zhihu.com/question/29936562/answer/46129706" target="_blank" rel="noopener">https://www.zhihu.com/question/29936562/answer/46129706</a><br>
10.<a href="https://www.zhihu.com/question/313519801/answer/642403872" target="_blank" rel="noopener">https://www.zhihu.com/question/313519801/answer/642403872</a><br>
11.<a href="https://www.zhihu.com/question/36052573/answer/65743965" target="_blank" rel="noopener">https://www.zhihu.com/question/36052573/answer/65743965</a><br>
12.<a href="https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value</a><br>
13.<a href="https://www.zhihu.com/question/25814721/answer/31648501" target="_blank" rel="noopener">https://www.zhihu.com/question/25814721/answer/31648501</a><br>
14.<a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues" target="_blank" rel="noopener">https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues</a><br>
15.<a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf</a><br>
16.<a href="https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard" target="_blank" rel="noopener">https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard</a><br>
17.<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a><br>
18.<a href="https://en.cppreference.com/w/cpp/language/value_category" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/language/value_category</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-variable-declaration-and-definition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-variable-declaration-and-definition/" class="post-title-link" itemprop="http://mxxhcm.github.io/page/7/index.html">C++ variable declaration and definition</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 21:22:49" itemprop="dateCreated datePublished" datetime="2019-11-13T21:22:49+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-12-17 16:15:59" itemprop="dateModified" datetime="2019-12-17T16:15:59+08:00">2019-12-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="c-类型">C++类型</h2>
<p>C++中，对象（变量）的类型通常有两种：</p>
<ol>
<li>基本内置类型，整形和浮点型。整形又包括整数，布尔型，字符串，浮点型又包括单精度浮点型和双精度浮点型，详细介绍可以查看<a href="https://mxxhcm.github.io/2019/11/05/C-fundamental-types-and-variables/">C++算术类型</a>。</li>
<li>复合类型，包括<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">指针</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-array/">数组</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-reference/">引用</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-class/">类</a>，结构，联合类型。</li>
</ol>
<h2 id="变量和对象">变量和对象</h2>
<h3 id="变量">变量</h3>
<p>变量是一个有名字的，可供程序操作的存储空间。C++ 中的每个变量都有数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能够参数的运算。对于C++ 程序员来说，变量和对象一般可以互用。</p>
<h3 id="对象">对象</h3>
<p>什么是对象，具有某种数据类型的内存空间，并不区分是复合类型还是内置类型，也不区分是否有名字和是否只读。</p>
<h2 id="变量定义">变量定义</h2>
<p>一条定义语句由一个基本数据类型和紧随其后的一个或者多个声明符组成。每个声明符声明了一个变量并且指定该变量为与基本数据类型有关的某种类型。<br>
基本变量的声明语句由数据类型和变量名组成，声明符就是变量名。而复合类型的声明语句中声明符除了变量名，还会有类型修饰符，如<code>*</code>,<code>&amp;</code>和<code>[]</code>等等。比如引用的声明语句中将声明符写成<code>&amp;d</code>的形式，其中<code>d</code>是声明的变量名,<code>&amp;</code>是类型修饰符。指针是另外一种复合类型，通常将声明符写成<code>*d</code>的形式，其中<code>d</code>是变量名，<code>*</code>是类型修饰符。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p>在指针操作中，其中操作符<code>*</code>称为解引用，操作符<code>&amp;</code>称为取地址符。</p>
<h3 id="复合类型的定义">复合类型的定义</h3>
<p>变量的定义包含一个基本数据类型和一组声明符。在一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是一条定义语句可能定义处不同类型的变量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure></p>
<p>在定义语句中，类型修饰符<code>*</code>和<code>&amp;</code>仅仅修饰紧随其后的变量。关于引用和指针的声明，一般有两种写法：</p>
<ol>
<li>
<p>将修饰符和变量名写在一起，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>把修饰符和类型名写在一块，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1;</span><br><span class="line"><span class="keyword">int</span>* p2;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这两种方法都对，C++ primer采用第一种。</p>
<h4 id="指向指针的指针">指向指针的指针</h4>
<p>声明符中修饰符的个数没限制，可以写很多个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival; <span class="comment">//pi指向一个int数</span></span><br><span class="line"><span class="keyword">int</span> **pi = &amp;pi; <span class="comment">//pi指向一个int的指针。</span></span><br></pre></td></tr></table></figure>
<h4 id="指针的引用">指针的引用</h4>
<p>引用不是对象，所以指针不能指向引用。但是指针是对象，所以有指针的引用。复杂的指针或者引用的声明语句，从右往左读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;    <span class="comment">//从右往左阅读，r是一个引用，是谁的引用，int*的引用。</span></span><br><span class="line"></span><br><span class="line">r = &amp;i; </span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">// i=0</span></span><br></pre></td></tr></table></figure>
<h2 id="变量初始化">变量初始化</h2>
<p>初始化是在变量创建时给一个特定的值，而赋值是把对象的当前值擦除，使用一个新值代替。</p>
<h3 id="默认初始化">默认初始化</h3>
<p>当变量没有指定初值，使用默认初始化的方式进行初始化。默认值由变量类型和变量位置决定。<br>
对于内置类型的变量，如果没有显式初始化，它的位置由定义的位置决定。函数内部的内置类型不会被初始化，定义于任何函数外部的内置类型被初始化为0。未初始化的变量的值是未定义的。<br>
对于自定义的类型来说，每个类决定初始化对象的方式，而且是否允许不经过初始化就定义对象也由自己决定。如果类允许这种行为，由类决定对象的初始值是什么；如果类要求每个对象显示初始化，在创建类对象没有进行明确的初始化操作时，会引发错误。</p>
<h2 id="声明和定义的区别">声明和定义的区别</h2>
<ol>
<li>声明需要给出变量的类型和名字，但是不需要申请存储空间。</li>
<li>只进行声明的话使用<code>extern</code>关键字，不要显式的初始化变量。包含了显式初始化的声明就变成了定义。</li>
<li>变量只能定义一次，但是可以声明多次。可以方便的在多个文件中使用同一个变量。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/6/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><span class="page-number current">7</span><a class="page-number" href="/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/page/33/">33</a><a class="extend next" rel="next" href="/page/8/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">327</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
