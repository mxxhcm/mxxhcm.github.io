---
title: C/C++ compound type array
date: 2019-11-13 14:09:40
tags:
 - 数组
 - array
 - 指针
 - C/C++
categories: C/C++
---


## 数组
数组和`vector`类似，但是数组是定长的，大小不变，而`vector`是可变的，可以把`vector`看成可变长度的数组。
如果不清楚元素的确切个数，使用vector。

## 定义和初始化
数组的维度必须是确定的，在编译时就知道，即是一个常量表达式（值不会改变并且在编译时就已知）。
默认情况下，数组的元素被默认初始化。和内置类型的变量一样，如果在数组内部定义了某种内置类型的数组，那么默认初始化得到的数组含有未定义的值。
### 显式的初始化数组
1. 可以忽略维度，编译器会根据初始值推测出来；
2. 如果指明维度，初始值的数量不应该超出指定的大小；
3. 如果维度比提供的初始值大，其它的元素被初始化成默认值（值初始化）。

### 字符数组
1. 使用字符串字面值初始化。``` c
char str1[] = "helloworld";
//编译器会隐式的在最后加一个"\0"，sizeof(str)会计算这个"\0", strlen(str)不会
```
2. 使用列表初始化。```c
char str2[] = {'h', 'e', 'l', 'l', 'o'};
char str3[] = {'h', 'e', 'l', 'l', 'o', '\0'};
```

### 数组不支持直接拷贝和直接赋值
1. 不支持数组的拷贝是为了避免不必要的复制开销，数组复制将会导致连续的内存读和写。
2. 为什么用指针代替数组，不是因为他们太像了，而是避免赋值的开销，因为c里面只有值传递，如果对数组采用pass by value，会有很大的开销。

### 数组和指针
当使用数组作为右值时，编译器会自动将数组转化成数组首元素的地址。[2]那么array和&array有什么区别呢？[3]`
```c
int array[] = {1, 2, 3, 4,5};
printf("array=%p, &array=%p\n", array, &array);

printf("array+1=%p: &array+1=%p\n", array+1, &array+1);
```
程序的输出如下：
``` text
array=0x7ffc50c541c0: &array=0x7ffc50c541c0
array+1=0x7ffc50c541c4: &array+1=0x7ffc50c541d4
```
根据上面程序的输出，`array`和`&array`得到了一样的地址。但是它们并不是一样的！！！它们的地址相同，但是地址的类型不同。
对指针进行算术运算，将`array`和`&array`都加一，我们却得到了不同的结果。事实上，`array`是指向数组第一个元素的指针，而`&array`是指向整个`int [5]`数组的指针。因此，根据指针运算规则，对地址`array`和`&array`进行算术运算，得到了不同的结果。


### 数组的指针和数组的引用
对于数组来说，采用从内向外的方式，即名数组名字开始，然后向左看数组类型，向右看数组大小。```c
int *ptrs[10]; //ptr是一个数组，数组的类型是int*的，大小是10
int (*ptr_array)[10]; //ptr_array是一个指针，指针指向一个大小为10的数组，数组的类型是int
int (&ref_array)[10]; //ref_array是一个引用，绑定到一个大小为10的数组，数组的类型是int
```

## 访问数组元素
使用范围for语句或者下标`[]`运算符，使用数组下标的时候，通常定义为无符号的`size_t`类型。


## 指针和数组
1. 指针和数组的联系很紧密，使用数组的时候编译器一般会把它转换成指针。
2. 使用取地址符获取某个对象的指针，对数组元素使用取地址符就能得到指向该元素的指针。
3. 在很多用到数组名字的时候，编译器都会自动的将它转换成一个指向数组首元素的指针。
4. 使用`auto`分析数组类型时会推断出指针类型，而使用`decltype`会推断出数组类型。

## 多维数组

## 参考文献
1.《C++ Primer第五版》
2.https://stackoverflow.com/questions/1641957/is-an-array-name-a-pointer
3.https://www.geeksforgeeks.org/whats-difference-between-array-and-array-for-int-array5/
