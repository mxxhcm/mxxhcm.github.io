---
title: C++ compound type
date: 2019-11-09 22:24:47
tags:
categories:
---

## 复合类型
复合类型是指基于其他类型定义的类型，C++中两种常见的复合类型是引用和指针。
一条声明语句由一个基本数据类型和紧随其后的声明符列表组成。每个声明符声明了一个变量并且指定该变量为与基本数据类型有关的某种类型。
简单的声明语句由数据类型和变量名组成，声明符就是变量名。引用的声明语句中将声明符写成`&d`的形式，其中`d`是声明的变量名。指针是另外一种复合类型，通常将声明符写成`*d`的形式，其中`d`是变量名。
```c
int a = 3;
int &b = a;
int *p = &a;
```
在指针操作中，其中操作符`*`称为解引用，操作符`&`称为取地址符。

## 复合类型的声明
变量的定义包含一个基本数据类型和一组声明符。在一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是一条定义语句可能定义处不同类型的变量：```c
int i = 1024, *p = &i, &r = i;
```
在定义语句中，类型修饰符`*`和`&`仅仅修饰紧随其后的变量。关于引用和指针的声明，一般有两种写法：
1. 将修饰符和变量名写在一起，即：```c
int *p1, *p2;
```
2. 把修饰符和类型名写在一块，即：``` c
int* p1;
int* p2;
```

这两种方法都对，C++ primer采用第一种。

### 指向指针的指针
声明符中修饰符的个数没限制，可以写很多个。
```c
int ival = 1024;
int *pi = &ival; //pi指向一个int数
int **pi = &pi; //pi指向一个int的指针。
```

### 指针的引用
引用不是对象，所以指针不能指向引用。但是指针是对象，所以有指针的引用。复杂的指针或者引用的声明语句，从右往左读。

```c
int i = 42;
int *p;
int *&r = p;    //从右往左阅读，r是一个引用，是谁的引用，int*的引用。

r = &i; 
*r = 0; // i=0
```

## 引用（左值引用）
1. 引用不是一个对象，没有实际地址，不能定义指向引用的指针。
2. 引用只是一个别名，必须和一个已经存在的对象绑定在一起，无法更改，必须初始化。
3. 定义引用时，标识符必须以`&`开头。
4. 除了两种特殊情况外，所有引用的类型都必须和它绑定的对象严格匹配。
5. 引用只能绑定在对象上，不能绑定在字面值或者某个表达式上。（const引用除外）

## 指针
### 指针和引用的不同点
1. 指针本身就是一个对象，允许赋值和拷贝，在生命周期内可以指向几个不同的对象；而引用本身并非一个对象，一定定义了引用，它就和一个对象终生绑定在了一起。
2. 指针定义时无须赋值；而引用必须在定义时赋值。

### 指针的特点
1. 存放的是对象的地址，要想获取变量的地址，需要使用取地址符`&`，访问指针中地址指向的变量，使用解引用符号`*`，即：```c
int val = 32;
int *p = & val; //指针p存放的是变量val的地址
int b = *p; //b被初始化为32,p存放的是val的地址，*p获得该地址指向的变量val。
*p = 3; //将val赋值为3
```
2. 赋值永远改变的是`=`左侧的对象，可以用来判断到底是改变了指针的值还是改变了指针所指的对象的值。
3. 除了两种特殊情况外，所有指针的类型都必须和它指向的对象严格匹配。

### 指针的值，就是地址，有四种可能取值
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，没有指向任何对象
4. 无效指针，除了以上三种情况的任何值。

使用无效指针和使用未初始化变量是同类错误，编译器都不负责进行检查。

### 指针的大小
任何类型的指针本身所占的大小都是相等的，取决于计算机的地址大小，如果是`32`位的地址，指针的大小就是`4`个字节，如果是`64`位的地址，指针的大小就是`8`个字节。

### 空指针
有以下几种方法声明空指针：``` c
// 方法1.
int *p1 = nullptr;
// 方法2.
int *p2 = 0;
// 方法3.
int *p3 = NULL;//NULL定义在cstdlib中
```
最好使用`nullptr`或者`0`，而避免使用`NULL`。

### `void*`指针
`void *`指针可以存放任意类型的地址，但是我们并不知道它存放的是什么类型的对象。

## `const`类型
1. `const`修饰的变量一经初始化，不能改变其值，而且必须进行初始化。
2. 可以使用任意对象（包含非`const`对象）初始化`const`对象。
3. `const`对象默认只在当前文件中有效。如果需要在其他文件中使用，在声明和定义的文件中都需要加上`extern`关键字；而非`const`对象在定义时不需要使用`extern`关键字，只需要在其他文件的声明中加上`extern`即可。
4. 编译器遇到`const`变量时，会将所有该变量出现的地方都换成相应的值。

### 引用和`const`
可以把应用绑定到`const`对象上，就像绑定到其他常量上，称为对常量的引用（reference to const)，和普通引用的不同在与，对常量的引用不能用作修改它绑定的对象：```c
const int ci = 1024;
const int &r1 = ci;

r1 = 42;    //这行代码是错的，因为r1是对常量的引用
int &r2 = ci;   //这行代码也是错的，因为r2是普通引用
```
常量引用是对常量的引用的简称。严格来说，并不存在常量引用，因为引用不是一个对象，我们没办法让引用本身恒定不变。但是因为C++中，引用绑定的对象是不能更改的，所以从这层意义上理解，所有的引用又都称得上常量。引用的对象是常量还是非常量决定了引用能进行的操作，但是影响不到引用和对象的绑定关系。

#### 初始化和对常量的引用
之前说过引用的类型对象必须和引用对象的类型一样。但是有两个例外，**一个例外就是初始化常量引用时可以使用任意表达式作为初值。**如：```c
int i = 43;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1*2;
int &r4 = r1*2;
```
根据上面的例子我们也可以看出，对常量的引用可能引用一个非常量对象，我们不能通过`r`改变`i`的值，但是我们可以直接改变`i`的值，因为`r`和`i`是绑定的，所以`r`的值也改变了。

当把一个常量引用绑定到另一种类型上的时候，会发生什么？```
double dval = 3.14;
const int &ri = dval;
```
上述代码将一个`dobule`类型的变量绑定到一个`const int`型引用上，为了让`ri`绑定一个整数，编译器将上述代码变成了以下形式：```
const int temp = dval;
const int &ri = temp;
```
将`ri`绑定到了一个临时对象`temp`上，但是我们想要`ri`操作的是`dval`而不是`temp`，所以这种行为被判定为非法。


### 指针和`const`
指针也可以指向常量。类似于对常量的引用（常量引用），有指向常量的指针（pointer to const)。
1. 之前说过指针指向的类型对象必须和指针的类型一样。但是有两个例外，一个例外就是指向常量的指针可以使用非常量对象的地址进行初始化。
2. 要想存放指向常量的地址，必须使用指向常量的指针。
3. 指向常量的指针不能用于改变其所指对象的值，很容易明白，因为指向的是常量，而常量的值是不能修改的，所以指向常量的指针自然不能修改它指向的对象的值。
4. 那么指向常量的指针的指向能否改变？当然可以了，要不然就不会有`const`指针了，即指针本就就是常量对象，指向不能改变的指针对象。

可以认为指向常量的指针和对常量的引用都是他们自认为指向了常量对象，而常量对象不能被修改，所以就不能修改所指对象的值。```c
const double pi = 3.14;
double *ptr = &pi;  //报错，必须是指向常量的指针
const double *cptr = &pi;    //
*cptr = 4;  //不能修改常量指针指向的常量的值
```

#### `const`指针
引用不是对象，而指针是对象，因此就像其他对象一样，可以把指针本身定义为常量，叫做常量指针，常量指针必须初始化。
`const`指针必须初始化，它指向变量的值能否改变只取决于它指向变量的类型。``` c
int val = 3;
int *const curErr = &val;   //
const double pi = 3.14;
const double *const pip = &pi;  //
```

### 顶层`const`
用顶层`const`表示指针本身是一个常量，用底层`const`表示指针指向的对象是一个常量。指针可以既是顶层`const`又是底层`const`。
更一般的，顶层`const`可以表示任何的对象是常量，这一点对任意类型都使用。而底层`const`则和指针，引用等复合类型有关。
可以把一个顶层`const`赋值给非顶层`const`对象；但是不能把底层`const`赋值给非底层`const`对象，这个多加几句，因为底层`const`一定是和复合类型指针和引用相关的，所以要把它赋值给一个非底层的`const`对象，这个待赋值的对象也一定是指针和引用，如果它是非底层`const`对象，那么就可以通过它修改它指向的对象了，而这个对象是`const`的，不能被修改。

对常量的引用（常量引用）可以和常量对量绑定；
对常量的引用（常量引用）可以和非常量对量绑定；
非常量引用不可以和常量对象绑定；
非常量引用可以和非常量对象绑定；

指向常量的指针可以指向常量对象；
指向常量的指针可以指向非常量对象；
常量指针可以指向非常量对象；
常量指针不可以指向常量对象；
普通指针不可以指向常量对象；
普通指针可以指向非常量对象；

常量指针（顶层const）可以用来初始化非常量对象。
对常量的引用和指向常量的指针（底层const）不可以用来初始化非常量对象。

### `constexpr`和常量表达式
常量表达式，值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值和用常量表达式初始化的`const`对象也是常量表达式。比如：```c
int size = 23;  //不是常量表达式，因为他不是`const`对象
const int sz = get_size();  //sz是常量，但不是常量表达式，因为它的值需要等到运行时才能获得。
```
常量表达式一定是常量，但是常量不一定是常量表达式。
声明为`constexpr`的变量由编译器验证它是否是常量表达式。
声明为`constexpr`的变量一定是个常量，而且必须用常量表达式初始化。
如果认定变量一定是个常量表达式，就把它声明成`constexpr`类型，即`constexpr`用于声明常量表达式。

#### 字面值类型
算术类型，引用和指针都属于字面值类型，`string`，IO库和类不属于字面值类型。算术类型包含整形和浮点型，整形中又包含整数，字符和布尔。`constexpr`只能用于字面值类型。
指针和引用能用定义成`constexpr`，但是初值受到严格限制，一个`constexpr`指针的初始值必须是`nullptr`，`0`或者某个固定地址的对象。一般来说，函数内部的变量(除了`static`变量)没有存在固定地址中，而所有函数之外的对象地址固定不变，能用来初始化`constexpr`指针。`constexpr`声明的指针是顶层`const`，即指针本身是个`const`，它指向的对象不能变，它指向的对象的值能变。

## 类型操作
### 别名`typedef`和`using`
``` c
typdef dobuel wages;    //类型别名
using SI = Sales_imte;  //别名声明
```

#### 指针，常量和类型别名
```c
typedef char *pstring;
const pstring cstr = 0; //基本数据类型是char *，即指针类型
const pstring *p;
```
不能简单的把`pstring`用`char *`替换，如果替换了变成下式：
```c
const char *cstr = 0;   //基本数据类型是const char，
```
很容易把`*`看成是声明符的一部分，即`*cstr`的一部分，但是实际上`*`是和`const char`在一起的。`const char *cstr`是**指向`char`常量的指针**，而`const pstring cstr`是指向`char`的**常量指针**。

### `auto`关键字
编译器自动分析表达式的类型，`auto`定义的变量必须有初值。
使用一条`auto`语句可以声明多个变量，多个变量的基本数据类型必须一样。
```
auto i= 0, *p = &i; //正确
auto i = 1, d = 3.14;   //错误
```

#### 复合类型，常量和`auto`
1. 编译器使用`auto`推断出来的值和初始值类型有时候不完全一样。比如使用引用其实使用的是引用对象的值。
2. `auto`会忽略顶层`const`，保留底层`const`。如果希望`auto`推断出的是顶层`const`，需要显式的加一个`const`，即`const auto = ...`。
3. 将引用的类型设为`auto`也可以保留初始值中的顶层`const`属性，
4. 如果给初始值绑定一个引用，并且设为`auto`类型，这个对象就不是顶层`const`了。```c
int i = 0, &r = i;
auto a = r; // a是一个int,而不是int &

const int ci = i, &cr = ci;
auto b = ci;    //b是一个int
auto c = cr;    //c是一个int, cr是ci别名，ci是顶层const
auto d = &i;    //d是int *
auto e = &ci;   //e是一个指向const的指针。

const auto f = ci;  //f是const int
auto &g = ci;   // g是int &

const auto &j = 43;//这个j就不是顶层const了，类型是const int &，它是底层const。
```
### `decltype`类型
`decltype`和`auto`的区别：
1. 它只返回表达式的类型。
2. 它能识别顶层`const`和引用类型``` c
int i = 0, &ri = i, *pi = &i;
decltype(ri);       //是int &
decltype(ri+0);    //是int
const int ci = 0, &cj = ci;
decltype(ci) p = 0; //const int,
decltype(cj) q = 0; //const int &，顶层常量引用可以初始化成字面值
decltype(ci) x; //错误，常量必须初始化
decltype(cj) y; //错误，引用必须初始化
```
引用从来都是作为它所指对象的同义词出现，只有在`decltype`处是例外。

#### `decltype`和引用
1. 如果表达式的内容是解引用操作，使用`decltype`将会得到引用类型。
2. `decltype((variable))`的结果永远是引用，而`decltype(variable)`的结果只有在真的是引用的时候才会返回引用。``` c
int i = 0;
decltype((i)) d;
decltype(i) e;
```

## 类
头文件一旦改变，相关的源文件必须重新编译获取更新过的声明。
预处理器变量无视C++中关于作用域的规则。
加上头文件保护符，防止重复包含。
头文件保护符必须唯一。

```c
#ifndef SALES_DATA_H
#define SALES_DATA_H
#endif
```

## 数组
数组和`vector`类似，但是数组是定长的，大小不变，而`vector`是可变的，可以把`vector`看成可变长度的数组。
如果不清楚元素的确切个数，使用vector。

## 定义和初始化
数组的维度必须是确定的，在编译时就知道，即是一个常量表达式（值不会改变并且在编译时就已知）。
默认情况下，数组的元素被默认初始化。和内置类型的变量一样，如果在数组内部定义了某种内置类型的数组，那么默认初始化得到的数组含有未定义的值。
### 显式的初始化数组
1. 可以忽略维度，编译器会根据初始值推测出来；
2. 如果指明维度，初始值的数量不应该超出指定的大小；
3. 如果维度比提供的初始值大，其它的元素被初始化成默认值（值初始化）。

### 字符数组
1. 使用字符串字面值初始化。``` c
char str1[] = "helloworld";
//编译器会隐式的在最后加一个"\0"，sizeof(str)会计算这个"\0", strlen(str)不会
```
2. 使用列表初始化。```c
char str2[] = {'h', 'e', 'l', 'l', 'o'};
char str3[] = {'h', 'e', 'l', 'l', 'o', '\0'};
```

### 数组不支持直接拷贝和直接赋值
1. 不支持数组的拷贝是为了避免不必要的复制开销，数组复制将会导致连续的内存读和写。
2. 为什么用指针代替数组，不是因为他们太像了，而是避免赋值的开销，因为c里面只有值传递，如果对数组采用pass by value，会有很大的开销。

### 数组的指针和数组的引用
对于数组来说，采用从内向外的方式，即名数组名字开始，然后向左看数组类型，向右看数组大小。```c
int *ptrs[10]; //ptr是一个数组，数组的类型是int*的，大小是10
int (*ptr_array)[10]; //ptr_array是一个指针，指针指向一个大小为10的数组，数组的类型是int
int (&ref_array)[10]; //ref_array是一个引用，绑定到一个大小为10的数组，数组的类型是int
```

## 访问数组元素
使用范围for语句或者下标`[]`运算符，使用数组下标的时候，通常定义为无符号的`size_t`类型。


## 指针和数组
1. 指针和数组的联系很紧密，使用数组的时候编译器一般会把它转换成指针。
2. 使用取地址符获取某个对象的指针，对数组元素使用取地址符就能得到指向该元素的指针。
3. 在很多用到数组名字的时候，编译器都会自动的将它转换成一个指向数组首元素的指针。
4. 使用`auto`分析数组类型时会推断出指针类型，而使用`decltype`会推断出数组类型。


## C风格字符串

## 多维数组



## 参考文献
1.《C++ Primer第五版》
