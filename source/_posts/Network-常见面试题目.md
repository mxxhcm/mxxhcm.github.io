---
title: Network 常见面试题目
date: 2020-02-29 21:44:42
tags:
 - 面试
categories: 面试
---

## 套接字
套接字是一个同一台主机内应用层和网络层之间的接口。由于套接字是在网络上建立网络应用程序的可编程接口，所以也把套接字称为应用程序和网络之间的应用编程接口。

一个UDP套接字是由目的IP地址和目的端口号标识的二元组。两个UDP报文段，只要目的IP地址和目的端口号一样，不论源IP地址和端口号是否一样，都被定向到相同的目的进程。
一个TCP套接字是由源IP地址，源端口号，目的IP地址，目的端口号构成的四元组。所有的这四元组都被用来进行多路分解。


## TCP和UDP的选择
DNS通常采用UDP，因为TCP需要建立连接，会引入建立连接的时延，这样子会慢得多。如果没有收到响应，就会向另一台DNS服务器发送查询，或者通知调用的程序它不能获得响应。
而HTTP使用TCP而不是UDP，因为web网页需要的是可靠性。

## UDP
UDP相对于TCP的优势：
1. 应用层能更好的控制要发送的数据和发送时间。
2. 无需连接建立。
3. 无连接状态。
4. 分组首部开销小。TCP报文段有20字节的首部开销，而UDP只有8字节的开销。

### UDP报文段结构
UDP报文段的首部共8个字节，64位，每个字段8位，共4个字段，：
1. 16位源端口号
2. 16位目的端口号
3. 16位长度字段，长度字段包含了首部在内的UDP报文段的长度（以字节为单位）。
4. 16位检验和


### UDP校验和
1. UDP校验和提供了差错检测功能，但是不能进行差错恢复。为什么UDP校验和work？
2. 为什么要进行差错校验？链路中可能出错，内存中也可能出错。UDP必须在端到端基础上在运输层提供差错校验。
3. 出错后如何处理。一些实现是丢弃受损的报文段，一些是将受损的报文段交给应用程序并告警。

## 可靠数据传输原理
### 停止等待协议
为了解决分组可能出错的情况，引入**自动重传请求**。自动重传请求协议需要另外三种协议：差错检验，接收方反馈和重传。
当一个分组到达时可能出错，接收方进行进行**差错校验**，如果出错，发送一个NAK给发送方。如果没有失败，发送一个ACK给接收方。
直到发送方确定接收方已经收到当前分组之后（收到一个ACK），才会继续发送新数据，这就是**停止等待协议**。如果收到一个NAK，就会重传当前分组。（**接收方反馈**）
但是ACK和NAK也可能出错或者丢失，通过引入**重传**解决这个问题。
到底什么时候重传呢？等待一个RTT太久了，可以使用一个定时器设置一个时间，超过这个时间就重传。
这样子在接收方引入了冗余分组的问题。冗余分组的问题在于不知道接收方发送的ACK或者NAK是否被发送方接收，或者是分组没有丢失，等到了一段时间又到了。接收方不知道接收到的分组到底是哪一个，是重发的分组还是新的分组。可以通过引入分组序号解决这个问题。在停止等待协议中，一个比特的分组序号就够了。**所以也叫比特交替协议**。

### 流水线可靠数据传输协议
停止等待协议的效率太低了。流水线可靠数据传输协议不是一次只发一个分组，而是一次发送多个分组，就好像一条流水线一样。这就产生了几个问题：
1. 必须增加序号范围，原来只要一个比特就够了，现在需要多个。
2. 协议的发送方和接收方也必须能够缓存多个分组。
3. 流水线中如果分组丢失了，有两种方式进行差错恢复，回退N步（GBN）和选择重传（SR）。

### 回退N步
GBN的发送方要处理是三个工作，准备N个分组，处理接收方返回的ACK，以及超时重传。
GBN的接收方要处理的工作，只有接收到的分组的序号和上一次相同，会返回给发送方一个ACK，GBN采用**累计确认**（对序号n的分组的确认表明接收方已经正确接收到n以及n之前的分组了）。所有其他情况，都会丢弃分组。比如失序分组，接收方应该接收序号为n的分组，但是收到了序号为n+1的分组，就会丢弃，而不是缓存。

GBN维护一个大小为N的窗口。对于发送方，维护一个大小为N的窗口，如果这N个分组的ACK都没有收到，就不会发送新的数据，等待接收方返回ACK。发送方还有超时设置，（发送方发送的分组丢了，或者接收方返回的ACK丢了），都会重传。


### 选择重传
GBN有时候会效率太低，因为一个分组丢失，可能导致重传整个N个分组。选择重传可以用来解决这种问题。


## TCP

### 超时
数据处理。TCP从发送缓存重拿数据，加上TCP首部，传递给IP层。然后传递给网络，TCP接收方的接收缓存获取数据。
超时重传触发冗余ACK快速重传（为什么发送方收到三个冗余ACK就立即快重传）。如果超时的话，就倍增超时时间间隔。
ACK处理。如果收到的ACK是窗口的最小未确认序号，那么修改窗口的最小未确认序号。

### TCP累计确认和GBN，选择重传之间的关系
GBN是滑动窗口协议，虽然也提供累计确认，但是它不会缓存失序报文，会把它们全部丢弃。假设序号为n的报文段丢失了，然后需要发送方重传n之后的所有报文。而TCP的发送方至多只会重传一个报文段，如果TCP接收方接收到了
选择重传对失序报文进行缓存，但是没有提供累计确认。

### 三次握手
1. A向B发送一个SYN报文段，并且包含自己的初始序列号。
2. B向A发送一个SYNACK报文段，并且包含自己的初始序列号。同时分配连接缓存，变量等。
3. A向B发送一个ACK报文段，不是SYN报文段。

### 为什么要随机初始化一个报文段序号
减少上次TCP连接中的报文段被当做两台主机之间新的TCP连接中的报文段。

### 为什么是三次握手而不是两次或者四次
其实是四次挥手，只不过第二次和第三次可以合并起来了。三次挥手的目的是确立TCP双方都能获得对方的初始序号。
为什么不是两次？如果A向B发送一个请求，B回应一个请求。而B的回应丢了，A就无法和B进行通信。如果设计成A重传，那么可能会建立很多个连接。如果设计成B重传，为什么要B重传？不是两次握手吗？他怎么知道要重传。这些都是如果设计成两次握手需要考虑的问题。
对于三次握手来说，如果
1. A发给B的丢了，A超时重传。
2. B发给A的丢了，B超时重传。B分配缓存，变量等。
3. A又发给B的丢了，这时候B已经认为建立了连接。
如果双方都没有数据，那么会触发第二步的超时重传。
如果A要发送数据，那么A会直接把数据发给B，就肯定建立连接了。
如果B要发送数据，也会触发第二步的超时重传。


### 四次挥手
1. A发给B FIN报文段。
2. B发给A ACK。B进行WAIT-TIME。等待B终止连接，这个时候B可以给A发送数据，但是A不能给B发送数据。
3. B发给A FIN报文段。
4. A发给B ACK。这个时候A要等待30s或者1分钟，两分钟。因为需要确认B那边收到了ACK，否则的话，B就无法关闭。

## TCP和UDP的区别
1. TCP面向连接，UDP无连接。
2. TCP提供可靠数据传输，UDP提供不可靠数据传输。
3. TCP有流量控制，UDP无流量控制。

## HTTPS和HTTP


## 参考文献
1. 《计算机网络自顶向下》
