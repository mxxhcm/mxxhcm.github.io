---
title: C++ basic data types
date: 2019-11-05 17:11:26
tags:
 - C/C++
 - int
 - float
 - string
categories: C/C++
mathjax: true
---


## 基本内置类型
### 算术类型
算术类型有两类：整形和浮点型。算术类型的大小在不同的机器上实现也可能不同。
整形包括字符，布尔型，整形，长整形。
浮点类型有单精度，双精度和扩展精度浮点数，具体怎么表示可以查看[IEEE 754标准]()。
一般情况下，`char`占用$1$字节，`int`占用$4$字节，`long`占用$8$字节，`long long`占用$8$个字节。`float`占用$4$字节，`double`占用$8$字节。
除了布尔型和扩展的字符型（wchar_t, char16_t, char32_t)之外，其他整形可以划分为无符号和带符号的两种，无符号类型中所有的比特位都用来存储值，而有符号类型需要使用其中的某些位存储符号。`int,long, long long`默认是带符号的。`char`可以分为三种，`char, signed char, unsigned char`，`char`不一定是有符号的，由不同的编译器来决定。

其他注意事项：
1. 算术表达式中不要使用`char`，因为不同的编译器可能处理方式不同，一些是有符号的，一些是无符号的，进行迁移时可能会出现问题。
2. 浮点数运算用`double`，`float`精度不够，而且计算代价和`double`差不多。

#### 强制类型转换
在将有符号数转化为无符号数的时候，如果这个有符号数是负数，那么会做一个模运算，将它转换为正值。
无符号数永远不可能为负。
如果一个运算同时有有符号数和无符号数参与运算，那么会将有符号数转换为无符号数进行运算。如下示例：
```
    int a = -3;
    unsigned int b = 0;
    b--;
    std::cout << b << std::endl;
    //output: 4294967295
    b = a;
    std::cout << b << std::endl;
    //output: 4294967293
```

### 字面值常量
字面值常量包括：整形，浮点型，字符，字符串，转义序列，布尔和指针。可以限制的指定字面值的类型。
通过前缀指定字符串的字面值类型，通过后缀指定整形和浮点型字面值类型。
前缀
- `u`，表示`unicode 16`字符
- `U`，表示`unicode 32`字符
- `L`，表示宽字符
- `u8`，`utf-8`，只用于字符串字面值常量

后缀，这里给出的最小匹配类型，如果不够的话，会自动选择更大的。
- `u,U`，`unsigned`
- `l, L`, `long`
- `ll, LL`, `long long`
- `f, F`, `float`
- `l, L`, `long double`

#### 整形字面值常量
如`12, a, "hello"`等。
十进制的字面值常量是带符号数，比如`12`是`int, long, long long`中能容纳下的占用最小字节的类型；八进制和十六进制的字面值常量是能容纳其数值的`int, long, long long, unsigned int, unsigned long, unsigned long`中的最小类型。

#### 浮点型字面值常量
浮点型的字面值常量是`double`。

#### 字符和字符串字面值常量
`'a'`是字面值字符常量，`"hello world"`是字符串字面值常量。

#### 转义序列
包含不可打印和可打印的字符。`\n,\r,\t,\b,\a`等。

#### 布尔字面值
`true, false`是`bool`变量的字面值。

#### 指针字面值
`nullptr`是指针字面值。


## 变量
1. 什么是对象，具有某种数据类型的内存空间，并不区分是类还是内置类型，也不区分是否命名和是否只读。
2. 初始化，在变量创建时给定一个特定的值，和赋值不一样，赋值是吧对象的当前值擦除，使用一个新值代替。
3. 默认初始化，变量没有指定初值，被赋予默认值。默认值由变量类型和变量位置决定。
对于内置类型的变量，如果没有显式初始化，它的位置由定义的位置决定。函数内部的内置类型不会被初始化，定义于任何函数外部的内置类型被初始化为$0$。未初始化的变量的值是未定义的。
对于自定义的类型来说，每个类决定初始化对象的方式，而且是否允许不经过初始化就定义对象也由自己决定。如果类允许这种行为，由类决定对象的初始值是什么；如果类要求每个对象显示初始化，在创建类对象没有进行明确的初始化操作时，会引发错误。
4. 声明和定义。
声明需要给出变量的类型和名字，但是不需要申请存储空间。只进行声明的话使用`extern`关键字，不要显式的初始化变量。包含了显式初始化的声明就变成了定义。变量只能定义一次，但是可以声明多次。可以方便的在多个文件中使用同一个变量。

## 复合类型
复合类型是指基于其他类型定义的类型，C++中两种常见的复合类型是引用和指针。
一条声明语句由一个基本数据类型和紧随其后的声明符列表组成。每个声明符声明了一个变量并且指定该变量为与基本数据类型有关的某种类型。
简单的声明语句由数据类型和变量名组成，声明符就是变量名。引用的声明语句中将声明符写成`&d`的形式，其中`d`是声明的变量名。指针是另外一种复合类型，通常将声明符写成`*d`的形式，其中`d`是变量名。
```c
int a = 3;
int &b = a;
int *p = &a;
```
在指针操作中，其中操作符`*`称为解引用，操作符`&`称为取地址符。

### 复合类型的声明
变量的定义包含一个基本数据类型和一组声明符。在一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是一条定义语句可能定义处不同类型的变量：
```c
int i = 1024, *p = &i, &r = i;
```
在定义语句中，类型修饰符`*`和`&`仅仅修饰紧随其后的变量。关于引用和指针的声明，一般有两种写法：
1. 将修饰符和变量名写在一起，即：
```c
int *p1, *p2;
```
2. 把修饰符和类型名写在一块，即：
``` c
int* p1;
int* p2;
```

这两种方法都对，C++ primer采用第一种。

#### 指向指针的指针
声明符中修饰符的个数没限制，可以写很多个。
```c
int ival = 1024;
int *pi = &ival; //pi指向一个int数
int **pi = &pi; //pi指向一个int的指针。
```

#### 指针的引用
引用不是对象，所以指针不能指向引用。但是指针是对象，所以有指针的引用。复杂的指针或者引用的声明语句，从右往左读。

```c
int i = 42;
int *p;
int *&r = p;    //从右往左阅读，r是一个引用，是谁的引用，int*的引用。

r = &i; 
*r = 0; // i=0
```

### 引用（左值引用）
引用不是一个对象，没有实际地址，不能定义指向引用的指针。
引用只是一个别名，必须和一个已经存在的对象绑定在一起，无法更改，必须初始化。
定义引用时，标识符必须以`&`开头。
除了两种特殊情况外，所有引用的类型都必须和它绑定的对象严格匹配。
引用只能绑定在对象上，不能绑定在字面值或者某个表达式上。

### 指针
#### 指针和引用的不同点
1. 指针本身就是一个对象，允许赋值和拷贝，在生命周期内可以指向几个不同的对象；而引用本身并非一个对象，一定定义了引用，它就和一个对象终生绑定在了一起。
2. 定义时无须赋值，赋值永远改变的是`=`左侧的对象，可以用来判断到底是改变了指针的值还是改变了指针所指的对象的值。

#### 指针的特点
1. 存放的是对象的地址，要想获取变量的地址，需要使用取地址符`&`，访问指针中地址指向的变量，使用解引用符号`*`，即：
```c
int val = 32;
int *p = & val; //指针p存放的是变量val的地址
int b = *p; //b被初始化为32,p存放的是val的地址，*p获得该地址指向的变量val。
*p = 3; //将val赋值为3
```
2. 除了两种特殊情况外，所有指针的类型都必须和它指向的对象严格匹配。

#### 指针的值，就是地址，有四种可能
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，没有指向任何对象
4. 无效指针，除了以上三种情况的任何值。

使用无效指针和使用未初始化变量是同类错误，编译器都不负责进行检查。

#### 指针的大小
任何类型的指针本身所占的大小都是相等的，取决于计算机的地址大小，如果是`32`位的地址，指针的大小就是`4`个字节，如果是`64`位的地址，指针的大小就是`8`个字节。

#### 空指针
有以下几种方法声明空指针：
``` 
// 1.
int *p1 = nullptr;
// 2.
int *p2 = 0;
// 3.
int *p3 = NULL;//NULL定义在cstdlib中
```
最好使用`nullptr`或者`0`，而避免使用`NULL`。

#### `void*`指针
`void *`指针可以存放任意类型的地址，但是我们并不知道它存放的是什么类型的对象。

## const类型
1. `const`修饰的变量一经初始化，不能改变，而且必须进行初始化。
2. 可以使用任意对象初始化`const`对象。
3. `const`对象默认只在当前文件中有效。如果需要在其他文件中使用，在声明和定义的文件中都需要加上`extern`关键字；而非`const`对象在定义时不需要使用`extern`关键字，只需要在其他文件的声明中加上`extern`即可。
4. 编译器遇到`const`变量时，会将所有该变量出现的地方都换成相应的值。

### const引用
可以把应用绑定到`const`对象上，就像绑定到其他常量上，称为对常量的引用（reference to const)，和普通引用的不同在与，对常量的引用不能用作修改它绑定的对象：
```c
const int ci = 1024;
const int &r1 = ci;

r1 = 42;    //这行代码是错的，因为r1是对常量的引用
int &r2 = ci;   //这行代码也是错的
```
常量引用是对常量的引用的简称。严格来说，并不存在常量引用，因为引用不是一个对象，我们没办法让引用本身恒定不变。但是因为C++中，引用绑定的对象是不能更改的，所以从这层意义上理解，所有的引用又都称得上常量。引用的对象是常量还是非常量决定了引用能进行的操作，但是影响不到引用和对象的绑定关系。

### 初始化和对常量的引用
之前说过引用的类型对象必须和引用对象的类型一样。但是有两个例外，一个例外就是初始化常量引用时可以使用任意表达式作为初值。如：
```
int i = 43;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1*2;
int &r4 = r1*2;
```
根据上面的例子我们也可以看出，对常量的引用可能引用一个非常量对象，我们不能通过`r`改变`i`的值，但是我们可以直接改变`i`的值，因为`r`和`i`是绑定的，所以`r`的值也改变了。

当把一个常量引用绑定到另一种类型上的时候，会发生什么？
```
double dval = 3.14;
const int &ri = dval;
```
上述代码将一个`dobule`类型的变量绑定到一个`const int`型引用上，为了让`ri`绑定一个整数，编译器将上述代码变成了以下形式：
```
const int temp = dval;
const int &ri = temp;
```
将`ri`绑定到了一个临时对象`temp`上，但是我们想要`ri`操作的是`dval`而不是`temp`，所以这种行为被判定为非法。


### 指针和const
指针也可以指向常量。类似于对常量的引用（常量引用），有指向常量的指针（pointer to const)。
- 之前说过指针指向的类型对象必须和指针的类型一样。但是有两个例外，一个例外就是指向常量的指针可以使用非常量对象的地址进行初始化。
- 指向常量的指针不能用于改变其所指对象的值，很容易明白，因为指向的是常量，而常量的值是不能修改的，所以指向常量的指针自然不能修改它指向的对象的值。
- 要想存放指向常量的地址，必须使用指向常量的指针。
- 那么指向常量的指针的指向能否改变？当然可以了，要不然就不会有`const`指针了，即指针本就就是常量对象，指向不能改变的指针对象。

```c
const double pi = 3.14;
double *ptr = &pi;  //报错，必须是指向常量的指针
const double *cptr = &pi;    //
*cptr = 4;  //不能修改常量指针指向的常量的值
```
可以认为指向常量的指针和对常量的引用都是他们自认为指向了常量对象，而常量对象不能被修改，所以就不能修改所指对象的值。

#### `const`指针
指针是对象，而引用不是对象，因此就像其他对象一样，可以把指针本身定义为常量，叫做常量指针，常量指针必须初始化。
`const`指针必须初始化，它指向变量的值能否改变只取决于它指向变量的类型。
``` c
int val = 3;
int *const curErr = &val;   //
const double pi = 3.14;
const double *const pip = &pi;  //
```


### 顶层`const`

### `constexpr`和常量表达式

## 类型操作
### 别名

### `auto`类型

### `decltype`类型

## 自定义数据结构

## 参考文献
1.《C++ Primer第五版》
