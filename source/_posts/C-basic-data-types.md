---
title: C++ data types and type conversions
date: 2019-11-05 17:11:26
tags:
 - C/C++
 - int
 - float
 - string
categories: C/C++
mathjax: true
---

## C++类型
C++中，对象的类型通常有两种：
1. 内置类型，整形和浮点型。整形又包括整数，布尔型，字符串，浮点型又包括单精度浮点型和双精度浮点型。
2. 复合类型，包括数组，指针，引用，类，结构，联合类型。

不同的类型之间是有可能进行相互转换的，并且有不同的规则进行类型转换，主要有以下几种规则：
1. 算术转换，针对于内置类型
2. 其他隐式类型转换
3. 显式类型转换。

## 基本内置类型
### 算术类型
算术类型有两类：整形和浮点型。算术类型的大小在不同的机器上实现也可能不同。
整形包括字符，布尔型，整形，长整形。
浮点类型有单精度，双精度和扩展精度浮点数，具体怎么表示可以查看[IEEE 754标准](https://mxxhcm.github.io/2019/10/24/IEEE-754-Floating-Point-Standard/)。
一般情况下，`char`占用$1$字节，`int`占用$4$字节，`long`占用$8$字节，`long long`占用$8$个字节。`float`占用$4$字节，`double`占用$8$字节。
除了布尔型和扩展的字符型（wchar_t, char16_t, char32_t)之外，其他整形可以划分为无符号和带符号的两种，无符号类型中所有的比特位都用来存储值，而有符号类型需要使用其中的某些位存储符号。`int`,`long`, `long long`默认是带符号的。`char`可以分为三种，`char`, `signed char`, `unsigned char`，`char`不一定是有符号的，由不同的编译器来决定。

其他注意事项：
1. 算术表达式中不要使用`char`，因为不同的编译器对`char`的处理方式可能不同，一些把`char`当做有符号的，一些把`char`当做无符号的，在不同机器之间进行迁移时可能会出现问题。
2. 浮点数运算用`double`，`float`精度不够，而且计算代价和`double`差不多。

#### 强制类型转换
在将有符号数转化为无符号数的时候，如果这个有符号数是负数，那么会做一个模运算，将它转换为正值。
无符号数永远不可能为负。
如果一个运算同时有有符号数和无符号数参与运算，那么会将有符号数转换为无符号数进行运算。如下示例：
``` C++
    int a = -3;
    unsigned int b = 0;
    b--;
    std::cout << b << std::endl;
    //output: 4294967295
    b = a;
    std::cout << b << std::endl;
    //output: 4294967293
```

### 字面值常量
字面值常量是值一看就知道的量，每一个字面值常量都对应一种数据类型，可以是整形，浮点型，字符，字符串，转义序列，布尔和指针等，数据类型由它的形式和值决定。可以通过前缀或者后缀显式的指定字面值的类型，字符和字符串的字面值类型通过前缀指定，整形和浮点型的字面值类型通过后缀指定。
前缀
- `u`，表示`unicode 16`字符
- `U`，表示`unicode 32`字符
- `L`，表示宽字符
- `u8`，`utf-8`，只用于字符串字面值常量

后缀，这里给出的最小匹配类型，如果不够的话，会自动选择更大的。
- `u,U`，`unsigned`
- `l, L`, `long`
- `ll, LL`, `long long`
- `f, F`, `float`
- `l, L`, `long double`

#### 整形字面值常量
如`12`,`1345`等。
十进制的字面值常量是带符号数，比如`12`是`int`, `long`, `long long`中能容纳下的占用最小字节的类型；八进制和十六进制的字面值常量是能容纳其数值的`int`, `long`, `long long`, `unsigned int`, `unsigned long`, `unsigned long`中的最小类型。

#### 浮点型字面值常量
浮点型的字面值常量是`double`。

#### 字符和字符串字面值常量
`'a'`是字面值字符常量，`"hello world"`是字符串字面值常量。

#### 转义序列
包含不可打印和可打印的字符。`\n`,`\r`,`\t`,`\b`,`\a`等。

#### 布尔字面值
`true`, `false`是`bool`变量的字面值。

#### 指针字面值
`nullptr`是指针字面值。


## 变量
1. 什么是对象，具有某种数据类型的内存空间，并不区分是类还是内置类型，也不区分是否命名和是否只读。
2. 初始化，在变量创建时给定一个特定的值，和赋值不一样，赋值是吧对象的当前值擦除，使用一个新值代替。
3. 默认初始化，变量没有指定初值，被赋予默认值。默认值由变量类型和变量位置决定。
对于内置类型的变量，如果没有显式初始化，它的位置由定义的位置决定。函数内部的内置类型不会被初始化，定义于任何函数外部的内置类型被初始化为$0$。未初始化的变量的值是未定义的。
对于自定义的类型来说，每个类决定初始化对象的方式，而且是否允许不经过初始化就定义对象也由自己决定。如果类允许这种行为，由类决定对象的初始值是什么；如果类要求每个对象显示初始化，在创建类对象没有进行明确的初始化操作时，会引发错误。
4. 声明和定义。
声明需要给出变量的类型和名字，但是不需要申请存储空间。只进行声明的话使用`extern`关键字，不要显式的初始化变量。包含了显式初始化的声明就变成了定义。变量只能定义一次，但是可以声明多次。可以方便的在多个文件中使用同一个变量。

## 复合类型
复合类型是指基于其他类型定义的类型，C++中两种常见的复合类型是引用和指针。
一条声明语句由一个基本数据类型和紧随其后的声明符列表组成。每个声明符声明了一个变量并且指定该变量为与基本数据类型有关的某种类型。
简单的声明语句由数据类型和变量名组成，声明符就是变量名。引用的声明语句中将声明符写成`&d`的形式，其中`d`是声明的变量名。指针是另外一种复合类型，通常将声明符写成`*d`的形式，其中`d`是变量名。
```c
int a = 3;
int &b = a;
int *p = &a;
```
在指针操作中，其中操作符`*`称为解引用，操作符`&`称为取地址符。

### 复合类型的声明
变量的定义包含一个基本数据类型和一组声明符。在一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是一条定义语句可能定义处不同类型的变量：```c
int i = 1024, *p = &i, &r = i;
```
在定义语句中，类型修饰符`*`和`&`仅仅修饰紧随其后的变量。关于引用和指针的声明，一般有两种写法：
1. 将修饰符和变量名写在一起，即：```c
int *p1, *p2;
```
2. 把修饰符和类型名写在一块，即：``` c
int* p1;
int* p2;
```

这两种方法都对，C++ primer采用第一种。

#### 指向指针的指针
声明符中修饰符的个数没限制，可以写很多个。
```c
int ival = 1024;
int *pi = &ival; //pi指向一个int数
int **pi = &pi; //pi指向一个int的指针。
```

#### 指针的引用
引用不是对象，所以指针不能指向引用。但是指针是对象，所以有指针的引用。复杂的指针或者引用的声明语句，从右往左读。

```c
int i = 42;
int *p;
int *&r = p;    //从右往左阅读，r是一个引用，是谁的引用，int*的引用。

r = &i; 
*r = 0; // i=0
```

### 引用（左值引用）
1. 引用不是一个对象，没有实际地址，不能定义指向引用的指针。
2. 引用只是一个别名，必须和一个已经存在的对象绑定在一起，无法更改，必须初始化。
3. 定义引用时，标识符必须以`&`开头。
4. 除了两种特殊情况外，所有引用的类型都必须和它绑定的对象严格匹配。
5. 引用只能绑定在对象上，不能绑定在字面值或者某个表达式上。（const引用除外）

### 指针
#### 指针和引用的不同点
1. 指针本身就是一个对象，允许赋值和拷贝，在生命周期内可以指向几个不同的对象；而引用本身并非一个对象，一定定义了引用，它就和一个对象终生绑定在了一起。
2. 指针定义时无须赋值；而引用必须在定义时赋值。

#### 指针的特点
1. 存放的是对象的地址，要想获取变量的地址，需要使用取地址符`&`，访问指针中地址指向的变量，使用解引用符号`*`，即：```c
int val = 32;
int *p = & val; //指针p存放的是变量val的地址
int b = *p; //b被初始化为32,p存放的是val的地址，*p获得该地址指向的变量val。
*p = 3; //将val赋值为3
```
2. 赋值永远改变的是`=`左侧的对象，可以用来判断到底是改变了指针的值还是改变了指针所指的对象的值。
3. 除了两种特殊情况外，所有指针的类型都必须和它指向的对象严格匹配。

#### 指针的值，就是地址，有四种可能取值
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，没有指向任何对象
4. 无效指针，除了以上三种情况的任何值。

使用无效指针和使用未初始化变量是同类错误，编译器都不负责进行检查。

#### 指针的大小
任何类型的指针本身所占的大小都是相等的，取决于计算机的地址大小，如果是`32`位的地址，指针的大小就是`4`个字节，如果是`64`位的地址，指针的大小就是`8`个字节。

#### 空指针
有以下几种方法声明空指针：``` c
// 方法1.
int *p1 = nullptr;
// 方法2.
int *p2 = 0;
// 方法3.
int *p3 = NULL;//NULL定义在cstdlib中
```
最好使用`nullptr`或者`0`，而避免使用`NULL`。

#### `void*`指针
`void *`指针可以存放任意类型的地址，但是我们并不知道它存放的是什么类型的对象。

## `const`类型
1. `const`修饰的变量一经初始化，不能改变其值，而且必须进行初始化。
2. 可以使用任意对象（包含非`const`对象）初始化`const`对象。
3. `const`对象默认只在当前文件中有效。如果需要在其他文件中使用，在声明和定义的文件中都需要加上`extern`关键字；而非`const`对象在定义时不需要使用`extern`关键字，只需要在其他文件的声明中加上`extern`即可。
4. 编译器遇到`const`变量时，会将所有该变量出现的地方都换成相应的值。

### 引用和`const`
可以把应用绑定到`const`对象上，就像绑定到其他常量上，称为对常量的引用（reference to const)，和普通引用的不同在与，对常量的引用不能用作修改它绑定的对象：```c
const int ci = 1024;
const int &r1 = ci;

r1 = 42;    //这行代码是错的，因为r1是对常量的引用
int &r2 = ci;   //这行代码也是错的，因为r2是普通引用
```
常量引用是对常量的引用的简称。严格来说，并不存在常量引用，因为引用不是一个对象，我们没办法让引用本身恒定不变。但是因为C++中，引用绑定的对象是不能更改的，所以从这层意义上理解，所有的引用又都称得上常量。引用的对象是常量还是非常量决定了引用能进行的操作，但是影响不到引用和对象的绑定关系。

#### 初始化和对常量的引用
之前说过引用的类型对象必须和引用对象的类型一样。但是有两个例外，**一个例外就是初始化常量引用时可以使用任意表达式作为初值。**如：```c
int i = 43;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1*2;
int &r4 = r1*2;
```
根据上面的例子我们也可以看出，对常量的引用可能引用一个非常量对象，我们不能通过`r`改变`i`的值，但是我们可以直接改变`i`的值，因为`r`和`i`是绑定的，所以`r`的值也改变了。

当把一个常量引用绑定到另一种类型上的时候，会发生什么？```
double dval = 3.14;
const int &ri = dval;
```
上述代码将一个`dobule`类型的变量绑定到一个`const int`型引用上，为了让`ri`绑定一个整数，编译器将上述代码变成了以下形式：```
const int temp = dval;
const int &ri = temp;
```
将`ri`绑定到了一个临时对象`temp`上，但是我们想要`ri`操作的是`dval`而不是`temp`，所以这种行为被判定为非法。


### 指针和`const`
指针也可以指向常量。类似于对常量的引用（常量引用），有指向常量的指针（pointer to const)。
1. 之前说过指针指向的类型对象必须和指针的类型一样。但是有两个例外，一个例外就是指向常量的指针可以使用非常量对象的地址进行初始化。
2. 要想存放指向常量的地址，必须使用指向常量的指针。
3. 指向常量的指针不能用于改变其所指对象的值，很容易明白，因为指向的是常量，而常量的值是不能修改的，所以指向常量的指针自然不能修改它指向的对象的值。
4. 那么指向常量的指针的指向能否改变？当然可以了，要不然就不会有`const`指针了，即指针本就就是常量对象，指向不能改变的指针对象。

可以认为指向常量的指针和对常量的引用都是他们自认为指向了常量对象，而常量对象不能被修改，所以就不能修改所指对象的值。```c
const double pi = 3.14;
double *ptr = &pi;  //报错，必须是指向常量的指针
const double *cptr = &pi;    //
*cptr = 4;  //不能修改常量指针指向的常量的值
```

#### `const`指针
引用不是对象，而指针是对象，因此就像其他对象一样，可以把指针本身定义为常量，叫做常量指针，常量指针必须初始化。
`const`指针必须初始化，它指向变量的值能否改变只取决于它指向变量的类型。``` c
int val = 3;
int *const curErr = &val;   //
const double pi = 3.14;
const double *const pip = &pi;  //
```

### 顶层`const`
用顶层`const`表示指针本身是一个常量，用底层`const`表示指针指向的对象是一个常量。指针可以既是顶层`const`又是底层`const`。
更一般的，顶层`const`可以表示任何的对象是常量，这一点对任意类型都使用。而底层`const`则和指针，引用等复合类型有关。
可以把一个顶层`const`赋值给非顶层`const`对象；但是不能把底层`const`赋值给非底层`const`对象，这个多加几句，因为底层`const`一定是和复合类型指针和引用相关的，所以要把它赋值给一个非底层的`const`对象，这个待赋值的对象也一定是指针和引用，如果它是非底层`const`对象，那么就可以通过它修改它指向的对象了，而这个对象是`const`的，不能被修改。

对常量的引用（常量引用）可以和常量对量绑定；
对常量的引用（常量引用）可以和非常量对量绑定；
非常量引用不可以和常量对象绑定；
非常量引用可以和非常量对象绑定；

指向常量的指针可以指向常量对象；
指向常量的指针可以指向非常量对象；
常量指针可以指向非常量对象；
常量指针不可以指向常量对象；
普通指针不可以指向常量对象；
普通指针可以指向非常量对象；

常量指针（顶层const）可以用来初始化非常量对象。
对常量的引用和指向常量的指针（底层const）不可以用来初始化非常量对象。

### `constexpr`和常量表达式
常量表达式，值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值和用常量表达式初始化的`const`对象也是常量表达式。比如：```c
int size = 23;  //不是常量表达式，因为他不是`const`对象
const int sz = get_size();  //sz是常量，但不是常量表达式，因为它的值需要等到运行时才能获得。
```
常量表达式一定是常量，但是常量不一定是常量表达式。
声明为`constexpr`的变量由编译器验证它是否是常量表达式。
声明为`constexpr`的变量一定是个常量，而且必须用常量表达式初始化。
如果认定变量一定是个常量表达式，就把它声明成`constexpr`类型，即`constexpr`用于声明常量表达式。

#### 字面值类型
算术类型，引用和指针都属于字面值类型，`string`，IO库和类不属于字面值类型。算术类型包含整形和浮点型，整形中又包含整数，字符和布尔。`constexpr`只能用于字面值类型。
指针和引用能用定义成`constexpr`，但是初值受到严格限制，一个`constexpr`指针的初始值必须是`nullptr`，`0`或者某个固定地址的对象。一般来说，函数内部的变量(除了`static`变量)没有存在固定地址中，而所有函数之外的对象地址固定不变，能用来初始化`constexpr`指针。`constexpr`声明的指针是顶层`const`，即指针本身是个`const`，它指向的对象不能变，它指向的对象的值能变。

## 类型操作
### 别名`typedef`和`using`
``` c
typdef dobuel wages;    //类型别名
using SI = Sales_imte;  //别名声明
```

#### 指针，常量和类型别名
```c
typedef char *pstring;
const pstring cstr = 0; //基本数据类型是char *，即指针类型
const pstring *p;
```
不能简单的把`pstring`用`char *`替换，如果替换了变成下式：
```c
const char *cstr = 0;   //基本数据类型是const char，
```
很容易把`*`看成是声明符的一部分，即`*cstr`的一部分，但是实际上`*`是和`const char`在一起的。`const char *cstr`是**指向`char`常量的指针**，而`const pstring cstr`是指向`char`的**常量指针**。

### `auto`关键字
编译器自动分析表达式的类型，`auto`定义的变量必须有初值。
使用一条`auto`语句可以声明多个变量，多个变量的基本数据类型必须一样。
```
auto i= 0, *p = &i; //正确
auto i = 1, d = 3.14;   //错误
```

#### 复合类型，常量和`auto`
1. 编译器使用`auto`推断出来的值和初始值类型有时候不完全一样。比如使用引用其实使用的是引用对象的值。
2. `auto`会忽略顶层`const`，保留底层`const`。如果希望`auto`推断出的是顶层`const`，需要显式的加一个`const`，即`const auto = ...`。
3. 将引用的类型设为`auto`也可以保留初始值中的顶层`const`属性，
4. 如果给初始值绑定一个引用，并且设为`auto`类型，这个对象就不是顶层`const`了。```c
int i = 0, &r = i;
auto a = r; // a是一个int,而不是int &

const int ci = i, &cr = ci;
auto b = ci;    //b是一个int
auto c = cr;    //c是一个int, cr是ci别名，ci是顶层const
auto d = &i;    //d是int *
auto e = &ci;   //e是一个指向const的指针。

const auto f = ci;  //f是const int
auto &g = ci;   // g是int &

const auto &j = 43;//这个j就不是顶层const了，类型是const int &，它是底层const。
```
### `decltype`类型
`decltype`和`auto`的区别：
1. 它只返回表达式的类型。
2. 它能识别顶层`const`和引用类型``` c
int i = 0, &ri = i, *pi = &i;
decltype(ri);       //是int &
decltype(ri+0);    //是int
const int ci = 0, &cj = ci;
decltype(ci) p = 0; //const int,
decltype(cj) q = 0; //const int &，顶层常量引用可以初始化成字面值
decltype(ci) x; //错误，常量必须初始化
decltype(cj) y; //错误，引用必须初始化
```
引用从来都是作为它所指对象的同义词出现，只有在`decltype`处是例外。

#### `decltype`和引用
1. 如果表达式的内容是解引用操作，使用`decltype`将会得到引用类型。
2. `decltype((variable))`的结果永远是引用，而`decltype(variable)`的结果只有在真的是引用的时候才会返回引用。``` c
int i = 0;
decltype((i)) d;
decltype(i) e;
```

## 自定义数据结构
头文件一旦改变，相关的源文件必须重新编译获取更新过的声明。
预处理器变量无视C++中关于作用域的规则。
加上头文件保护符，防止重复包含。
头文件保护符必须唯一。
```c
#ifndef SALES_DATA_H
#define SALES_DATA_H
#endif
```

## 参考文献
1.《C++ Primer第五版》
2.https://www.cnblogs.com/yc_sunniwell/archive/2010/06/18/1760034.html
