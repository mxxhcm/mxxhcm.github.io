---
title: OS 常见面试题目
date: 2020-02-29 21:43:49
tags:
 - 操作系统
categories: 操作系统
---

## 中断和异常
中断通常被定义为改变处理器执行指令顺序的事件。终端常常被分为同步中断和异步终端：
同步中断是指指令执行时由CPU控制单元产生的。（异常）
异步中断是指其他硬件设备依照CPU时钟信号随机产生的。（中断）
Intel x86把同步和异步中断分别称为异常和中断。

中断提供了一种方式，是处理器转而去做正常控制流之外的代码。


## netstat
netstat监控网络连接，路由表等，网络接口等。
netstat默认打印所有打开的socket连接。
-a, --all展示所有的listening和没有listening的sockets。
-l, --listening，展示所有listening的socket，默认情况下是忽略的。
-p, --program，每一个socket属于哪一个程序和pid。
-n, --numeric，数值展示host，port和用户名。
-t, --tcp
-u, --udp
-r打印路由表。
-i打印网络接口。

## lsof
列出打开的文件。

## ip
ip address，查看ip地址。
ip link，查看网络设备。

## 原子操作
原子操作指的是由多步组成的操作，要么执行完所有步骤，要不一步也不执行。

## 程序和线程
程序是一个存储在硬盘上的可执行文件。
程序的执行实例被称为进程，它是操作系统对一个正在运行的程序的一个抽象。


## fork和vfork区别
1. fork采用copy-on-write，而vfork在调用exec之前和父进程共享数据。
2. fork不对子进程的执行顺序做任何要求，而vfork要求子进程先运行，父进程挂起，知道子进程调用了exec或者exit之后，父进程恢复运行。

## 进程和线程的区别
1. 进程是资源分配和调度的最小单位，而线程是CPU调度的最小单位。
2. 一个进程可以包括多个线程，并且至少包括一个线程，所有的线程共享进程的资源。
3. 线程具有自己的私有属性。比如线程ID，寄存器，线程私有数据。
4. 线程中通常要进行同步操作，当多个线程共享线相同的内存时，需要使用同步操作确保他们看到一致的视图。
5. 进程之间交换信息要使用进程间通信。
6. 一个进程结束后所有线程都将终止。
7. 而一个线程结束通常不会影响其他线程（如果调用了exit就会终止所有线程。）
7. 线程是轻量级的进程，它的创建和销毁的代价要比进程小。

## 进程页表
一个进程的线程地址空间被分成两部分，通常是3G的用户空间和第四个G的内核空间。

## 进程都有哪些资源
寄存器
堆
栈
数据段
代码段
文件描述符
锁
信号

## 进程都有哪些区域
可执行代码
初始化数据
未初始化数据
堆
栈

## 进程创建
怎么创建一个进程。调用fork复制进程的数据空间，代码段，堆和栈的副本。现在的fork利用写时复制，这些区域由父进程和子进程共享，内核将它们的访问权限修改为只读，如果父进程和子进程中的任何一个试图修改这些区域，内核只为修改的那篇区域（通常是一页）制作一个副本，原来的页仍是受到保护的，当其他进程试图写入时，内核会检查写进程是不是这个页的唯一属主，如果是，他把这个页标记为对这个进程是可写的。通过使用一个引用计数记录共享相应页的进程数目。

## fork做了什么

## exec做了什么


## 进程执行
进程，是一个程序的执行实例。
每个进程都由一个进程描述符表示，这个描述符包含有关进程当前状态的信息。当内核暂停一个进程的执行时，它在进程描述符中保存好几个寄存器的内容：
- 程序计数器和栈指针寄存器
- 通过寄存器
- 包含CPU状态信息的处理器控制寄存器
- 内存管理寄存器。

进程描述符用一个结构体task_struct表示。这个结构体中包含tty_struct，fs_struct，files_struct, mm_struct和signal_struct以及其他更多。

## 进程状态
进程描述符中的状态域描述了进程当前可能所处的状态，有五种：
1. 运行状态
2. 中断
3. 不可中断
4. 停止
5. 僵死状态。

## 进程切换
为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行，这种行为被称为进程切换。linux中进程切换的主要内容：
1. 硬件上下文。
2. 硬件支持。
3. Linux代码
4. 保存浮点寄存器。

## 进程结束
使用exit，使用return ，使用Exit，进程的最后一个线程调用pthread_exit。
调用abort，进程接收到某些信号，最后一个线程对cancel做出请求。

## 进程通信
独立进程访问同一个对象的方法。使用共享内存，然后使用信号量，记录锁，或者读写锁进行进行保护。
如何传递一个字符串？使用FIFO？

## 线程都有哪些资源
私有的：程序计数器，栈空间和寄存器。

## 线程创建
pthread_create。

## 线程结束
pthread_exit
cancel
从启动例程返回。


## 线程同步
互斥量
读写锁
条件变量
屏障


## 协程

## select和poll

## 死锁
### 什么是死锁
两个或多个进（线）程在运行过程中相互请求其他进（线）程拥有的资源，造成所有的进程或者线程都无法继续前进。

### 产生死锁的原因
1. 资源竞争。
2. 加锁的顺序不合适。
3. 对同一个互斥量加锁两次。（APUE线程部分）。

### 产生死锁的必要条件
1. 互斥条件：进程要求对所分配的资源进行排他性控制，同一时刻某一个资源只能有一个用户。
2. 请求和保持：进程因请求某个资源而阻塞时，保持已经获得的资源不放。
3. 不剥夺：进程获得的资源没有使用完前，不能被剥夺。
4. 循环等待：A等待B，B等待A。

### 预防死锁的方法
对应死锁产生的后三个必要条件。资源的互斥条件不能改变。
1. 破坏请求和保持条件：资源一次性分配，只要有有一个资源得不到分配，就不给这个进程分资源。
2. 破坏不可剥夺条件：超时放弃已有的锁。
3. 破坏循环等待条件：对所有资源进行排序，以确定的顺序获得锁。

### 避免死锁的方法
1. 一次封锁法。
2. 顺序封锁法。
3. 银行家算法。

## 虚拟内存

## 参考文献
1.《APUE》第三版
2.https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread
3.https://www.geeksforgeeks.org/difference-between-process-and-thread/
