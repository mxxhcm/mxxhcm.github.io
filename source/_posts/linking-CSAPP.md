---
title: C/C++ linking
date: 2019-12-10 19:19:32
tags:
 - C/C++
 - CSAPP
 - 计算机系统
categories: 计算机系统
---


## 链接
**链接**是将各种代码和数据片段收集并组合成一个单一文件的过程，这个文件可以被加载到内存并执行。链接可以在三个时刻进行：
- 编译时(compilation time)，也就是在源代码被翻译成机器代码时。
- 加载时(load time)，在程序被加载器加载到内存并执行时。
- 运行时(run time)，由应用程序负责加载。

早期链接是手动执行的，现代系统中链接是由链接器程序自动执行的，链接器使得分离编译变得可能。

## 编译器驱动程序
执行将源文件翻译成可执行目标文件过程的**程序**，即预处理器，编译器，汇编器和链接器，构成了**编译系统。**
**编译器驱动程序**负责完成整个编译过程，即在需要时分别调用预处理器，编译器，汇编器和连接器，整个编译过程都是由编译器驱动程序负责的。
可以使用GCC对这些步骤进行实践：``` shell
# 1.预处理，生成ASCII码中间文件
cpp main.c main.i
cpp sum.c sum.i
# 2. 编译，将中间文件翻译成ASCII码汇编文件
cc1 main.i -Og -o main.s
cc1 sum.i -Og -o sum.s
# 3. 汇编，将汇编文件翻译成可重定位目标文件
as main.s -o main.o
as sum.s -o sum.o
# 4. 链接，将可重定位目标文件连接成可执行目标文件
ld -o main.o sum.o prog
# 5.执行
./prog
# shell调用操作系统的loader function，将可执行目标文件prog的代码和数据复制到内存中，然后将控制转移到这个程序的开头。
```

## 目标文件
目标文件是字节块的集合，它们按照特定的目标文件格式来组织，代码，数据，还有包含引导链接器和load function的数据结构等。各个系统的目标文件格式都不相同，Linux和UNIX系统下使用的是可执行可连接格式(exceutable and linkable format, ELF)，windows使用的是PE格式，MAC用的是Mach-O格式。
不管哪个平台，目标文件都可以分为三种：
1. 可重定位目标文件。包含二进制代码和数据，在编译时可以和其他目标文件合并起来，创建一个可执行目标文件。编译器和汇编器生成可重定位目标文件。
2. 可执行目标文件。包含二进制代码和数据，可以被直接复制进内存并执行。链接器生成可执行目标文件。
3. 共享目标文件。一种特殊类型的可重定位目标文件，可以在加载或者运行时动态的加载进内存并链接。

C语言中如何读取一个ELF文件的ELF-header。shell中直接使用`readelf`命令。`-h`, `-s`

## 静态链接
LD是静态链接器，它的**输入**是一组ELF可重定位目标文件和命令行参数，**输出**是一个完全链接的，可以加载和运行的ELF可执行目标文件。
输入的ELF可重定位目标文件由不同的section组成，每个section存放代码数据等。

为了构造可执行文件，静态链接器有以下任务：
1. 符号解析。目标文件定义并且引用**符号**，每一个符号对应于一个函数，一个全部变量，或者一个静态变量。符号解析的目的是将每个符号引用和一个符号定义关联起来。
2. 重定位。编译器和汇编器生成的section都是从地址0开始的，链接器通过把每个符号定义和一个内存位置关联起来，对这些section进行重定位，然后修改对这些符号的引用，使得它们指向相应的内存位置。链接器使用汇编器产生的重定位条目执行这样的重定位。

## 可重定位目标文件
一个ELF可重定位目标文件由以下section组成：
![ELF_reloc](ELF_reloc.png)

## 符号和符号表

## 符号解析

## 重定位

## 可执行目标文件

## 加载可执行目标文件

## 动态链接库

## 加载和链接共享库

## 位置无关代码

## 库打桩机制

## 处理目标文件的工具

## 总结

## 参考文献
1.《CSAPP》第七章
2.https://stackoverflow.com/questions/34960383/how-read-elf-header-in-c
