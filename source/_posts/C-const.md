---
title: C/C++ const
date: 2019-11-13 14:15:52
tags:
 - const
 - C/C++
 - 指针
 - 引用
 - 常量引用
 - 指向常量的指针
 - 常量指针
categories: C/C++
---

## `const`类型
1. `const`修饰的变量一经初始化，不能改变其值，而且必须进行初始化。
2. 可以使用任意对象（包含非`const`对象）初始化`const`对象。
3. `const`对象默认只在当前文件中有效。如果需要在其他文件中使用，在声明和定义的文件中都需要加上`extern`关键字；而非`const`对象在定义时不需要使用`extern`关键字，只需要在其他文件的声明中加上`extern`即可。
4. 编译器遇到`const`变量时，会将所有该变量出现的地方都换成相应的值。

## 引用和`const`
可以把应用绑定到`const`对象上，就像绑定到其他常量上，称为对常量的引用（reference to const)，和普通引用的不同在与，对常量的引用不能用作修改它绑定的对象：```c
const int ci = 1024;
const int &r1 = ci;

r1 = 42;    //这行代码是错的，因为r1是对常量的引用
int &r2 = ci;   //这行代码也是错的，因为r2是普通引用
```
常量引用是对常量的引用的简称。严格来说，并不存在常量引用，因为引用不是一个对象，我们没办法让引用本身恒定不变。但是因为C++中，引用绑定的对象是不能更改的，所以从这层意义上理解，所有的引用又都称得上常量。引用的对象是常量还是非常量决定了引用能进行的操作，但是影响不到引用和对象的绑定关系。

### 初始化和对常量的引用
之前说过引用的类型对象必须和引用对象的类型一样。但是有两个例外，**一个例外就是初始化常量引用时可以使用任意表达式作为初值。**如：```c
int i = 43;
const int &r1 = i;
const int &r2 = 42;
const int &r3 = r1*2;
int &r4 = r1*2;
```
根据上面的例子我们也可以看出，对常量的引用可能引用一个非常量对象，我们不能通过`r`改变`i`的值，但是我们可以直接改变`i`的值，因为`r`和`i`是绑定的，所以`r`的值也改变了。

当把一个常量引用绑定到另一种类型上的时候，会发生什么？```
double dval = 3.14;
const int &ri = dval;
```
上述代码将一个`dobule`类型的变量绑定到一个`const int`型引用上，为了让`ri`绑定一个整数，编译器将上述代码变成了以下形式：```
const int temp = dval;
const int &ri = temp;
```
将`ri`绑定到了一个临时对象`temp`上，但是我们想要`ri`操作的是`dval`而不是`temp`，所以这种行为被判定为非法。

### 引用和左值，右值
1. 非常量引用的初始值必须是左值。
2. 常量引用的初始值可以是右值。比如`const int &a =  7`;
3. 常量引用的初始值可以为左值。


## 指针和`const`
指针也可以指向常量。类似于对常量的引用（常量引用），有指向常量的指针（pointer to const)。
1. 之前说过指针指向的类型对象必须和指针的类型一样。但是有两个例外，一个例外就是指向常量的指针可以使用非常量对象的地址进行初始化。
2. 要想存放指向常量的地址，必须使用指向常量的指针。
3. 指向常量的指针不能用于改变其所指对象的值，很容易明白，因为指向的是常量，而常量的值是不能修改的，所以指向常量的指针自然不能修改它指向的对象的值。
4. 那么指向常量的指针的指向能否改变？当然可以了，要不然就不会有`const`指针了，即指针本就就是常量对象，指向不能改变的指针对象。

可以认为指向常量的指针和对常量的引用都是他们自认为指向了常量对象，而常量对象不能被修改，所以就不能修改所指对象的值。```c
const double pi = 3.14;
double *ptr = &pi;  //报错，必须是指向常量的指针
const double *cptr = &pi;    //
*cptr = 4;  //不能修改常量指针指向的常量的值
```

### `const`指针
引用不是对象，而指针是对象，因此就像其他对象一样，可以把指针本身定义为常量，叫做常量指针，常量指针必须初始化。
`const`指针必须初始化，它指向变量的值能否改变只取决于它指向变量的类型。``` c
int val = 3;
int *const curErr = &val;   //
const double pi = 3.14;
const double *const pip = &pi;  //
```

## 顶层`const`
用顶层`const`表示指针本身是一个常量，用底层`const`表示指针指向的对象是一个常量。指针可以既是顶层`const`又是底层`const`。
更一般的，顶层`const`可以表示任何的对象是常量，这一点对任意类型都使用。而底层`const`则和指针，引用等复合类型有关。
可以把一个顶层`const`赋值给非顶层`const`对象；但是不能把底层`const`赋值给非底层`const`对象，这个多加几句，因为底层`const`一定是和复合类型指针和引用相关的，所以要把它赋值给一个非底层的`const`对象，这个待赋值的对象也一定是指针和引用，如果它是非底层`const`对象，那么就可以通过它修改它指向的对象了，而这个对象是`const`的，不能被修改。

对常量的引用（常量引用）可以和常量对量绑定；
对常量的引用（常量引用）可以和非常量对量绑定；
非常量引用不可以和常量对象绑定；
非常量引用可以和非常量对象绑定；

指向常量的指针可以指向常量对象；
指向常量的指针可以指向非常量对象；
常量指针可以指向非常量对象；
常量指针不可以指向常量对象；
普通指针不可以指向常量对象；
普通指针可以指向非常量对象；

常量指针（顶层const）可以用来初始化非常量对象。
对常量的引用和指向常量的指针（底层const）不可以用来初始化非常量对象。

## `constexpr`和常量表达式
常量表达式，值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值和用常量表达式初始化的`const`对象也是常量表达式。比如：```c
int size = 23;  //不是常量表达式，因为他不是`const`对象
const int sz = get_size();  //sz是常量，但不是常量表达式，因为它的值需要等到运行时才能获得。
```
常量表达式一定是常量，但是常量不一定是常量表达式。
声明为`constexpr`的变量由编译器验证它是否是常量表达式。
声明为`constexpr`的变量一定是个常量，而且必须用常量表达式初始化。
如果认定变量一定是个常量表达式，就把它声明成`constexpr`类型，即`constexpr`用于声明常量表达式。

### 字面值类型
算术类型，引用和指针都属于字面值类型，`string`，IO库和类不属于字面值类型。算术类型包含整形和浮点型，整形中又包含整数，字符和布尔。`constexpr`只能用于字面值类型。
指针和引用能用定义成`constexpr`，但是初值受到严格限制，一个`constexpr`指针的初始值必须是`nullptr`，`0`或者某个固定地址的对象。一般来说，函数内部的变量(除了`static`变量)没有存在固定地址中，而所有函数之外的对象地址固定不变，能用来初始化`constexpr`指针。`constexpr`声明的指针是顶层`const`，即指针本身是个`const`，它指向的对象不能变，它指向的对象的值能变。

## 参考文献
1.《C++ Primer》第五版
2.https://www.zhihu.com/question/36052573/answer/65756850
