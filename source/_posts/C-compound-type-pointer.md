---
title: C/C++ compound type pointer
date: 2019-11-13 14:11:26
tags:
 - 指针
 - 复合类型
 - C/C++
categories: C/C++
---

## 指针
1. 变量的值存储在计算机的内存中，每个变量都占据一个特定的位置，每一个内存位置都由地址唯一确定并引用。指针可以看成是地址的另一个名字。
2. 指针变量也是一个变量，其中存放的是另一个变量的地址，因为指针是一个变量，所以指针变量本身也是存放在内存中的一个位置。


## 指针声明和定义
指针也是一个复合类型，需要按照复合类型的声明和定义进行声明。

### 解引用指针（间接访问）操作符和取地址符
在指针中经常用到两个符号`*`和`&`，`*`表示解引用操作或者间接访问操作，`&`是取地址符。
定义一个指针`p`：`int a=3; int *p = &a;`，`p`是一个指向`int`的指针，存放的是变量`a`的地址，`*`是间接访问，`*p`是int类型，`&`表示取变量`a`的地址。

### 指针定义
``` c
int *p; // 定义一个int*的指针p，p进行了默认初始化
int *a, b, *c;  //定义了两个int*类型的指针a,c，一个int类型变量b

char *message = "Hello world!"; //定义一个char*变量，指向数据段的字符串常量区中的字符串"Hello world!"的首字符的地址。
//下面两行代码和上面一行代码的作用是相同的，message是一个`char *`指针，指向字符串常量"Hello world!"的首字符的地址。
char *message = NULL;
message = "Hello world!"; 
```

## 未初始化和非法的指针
看一个错误的代码片段：```c
int *a; //定义一个指针*p
*a = 12;    //把12存储在a指向的内存中，错误
```
这个代码中犯了一个很严重的错误，我们在声明了变量`a`，但是没有对它进行显示初始化，所以编译器会对a进行默认初始化，默认初始化并不会为变量分配内存。如果程序执行这个赋值操作，假如a是一个非法地址，程序会出错，终止程序，在UNIX系统上，这个错误称为"segmentation violation"或者"memory fault"，它告诉我们程序正在访问一个非法的地址。如果a是一个合法的地址，这就会错误的修改a指向的内存中的值，造成一些难以预料到的错误。

## 指针的指针
因为指针也是一个变量，所以它自然也就有地址，也就存在指向指针的指针。``` c
int a, *b, **c;
b = &a;
c = &b;   //紧挨着c左边的那个*表示c是一个指针，然后再往左边的那个`*`是和`int`在一起的，表示指针`c`指向的变量的类型是`int *`类型的。
// a,*b, **c表示同样的东西，都是变量a的值。
// *c和b和&a表示同样的东西，都是变量a的地址。
// a表示int类型的变量
// b是a的地址，*b表示对指针p解引用，*b就是a。
// c是b的地址，*c表示对指针c解引用，*c就是b，也就是a的地址，*(*c)也就是*b，也是a。
```

## 指针的特点
1. 存放的是对象的地址，要想获取变量的地址，需要使用取地址符`&`，访问指针中地址指向的变量，使用解引用符号`*`，即：```c
int val = 32;
int *p = & val; //指针p存放的是变量val的地址
int b = *p; //b被初始化为32,p存放的是val的地址，*p获得该地址指向的变量val。
*p = 3; //将val赋值为3
```
2. 赋值永远改变的是`=`左侧的对象，可以用来判断到底是改变了指针的值还是改变了指针所指的对象的值。
3. 除了两种特殊情况外，所有指针的类型都必须和它指向的对象严格匹配。

## 指针的值，就是地址，有四种可能取值
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，没有指向任何对象
4. 无效指针，除了以上三种情况的任何值。

使用无效指针和使用未初始化变量是同类错误，编译器都不负责进行检查。

## 指针的大小
任何类型的指针本身所占的大小都是相等的，取决于计算机的地址大小，如果是`32`位的地址，指针的大小就是`4`个字节，如果是`64`位的地址，指针的大小就是`8`个字节。

## 空指针
有以下几种方法声明空指针：``` c
// 方法1.
int *p1 = nullptr;
// 方法2.
int *p2 = 0;
// 方法3.
int *p3 = NULL;//NULL定义在cstdlib中
```
最好使用`nullptr`或者`0`，而避免使用`NULL`。

## `void*`指针
`void *`指针可以存放任意类型的地址，但是我们并不知道它存放的是什么类型的对象。

## 指针和引用的不同点
1. 指针本身就是一个对象，允许赋值和拷贝，在生命周期内可以指向几个不同的对象；而引用本身并非一个对象，一定定义了引用，它就和一个对象终生绑定在了一起。
2. 指针定义时无须赋值；而引用必须在定义时赋值。


## 其他骚操作
```c
// 1.
int a;
*&a = 10;

// 2.
*100 = 20; //error
*(int*)100 = 20;
```

## 参考文献
1.《C++ Primer第五版》
2.《C和指针》
