---
title: C/C++ compound type pointer
date: 2019-11-13 14:11:26
tags:
 - 指针
 - 复合类型
 - C/C++
categories: C/C++
---

## 指针
1. 变量的值存储在计算机的内存中，每个变量都占据一个特定的位置，每一个内存位置都由地址唯一确定并引用。指针可以看成是地址的另一个名字[2](3.1.3)。
2. 指针变量也是一个变量，其中存放的是另一个变量的地址，因为指针是一个变量，所以指针变量本身也存放在内存中的某个位置[2](3.1.3)。

## 指针声明和定义
指针也是一个复合类型，需要按照复合类型的声明和定义进行声明。

### 解引用指针（间接访问）操作符和取地址符
在指针中经常用到两个符号`*`和`&`，`*`表示解引用操作或者间接访问操作，解引用操作可以访问一个地址并且获得它的值（或者可以进行赋值），如果只给出一个地址，而不解引用，是不能对地址表示的空间进行操作的。。`&`是取地址符。
定义一个指针`p`：`int a=3; int *p = &a;`，`p`是`int*`类型，存放的是变量`a`的地址，`*`是间接访问，`*p`才是int类型，`&`表示取变量`a`的地址。
**变量和指针中存放的内容（即地址）的区别，变量可以直接进行赋值。变量有它的地址，给变量赋值是往这个变量所在的内存写内容。指针变量也是变量，和普通变量没有区别。
指针存放的是一个地址，但是地址本身就是一个数字，是一个右值。对这个地址上的变量不能直接进行赋值，必须进行解引用访问这个地址表示的内存空间，然后才可以赋值。**

### 指针定义
``` c
int *p; // 定义一个int*的指针p，p进行了默认初始化
int *a, b, *c;  //定义了两个int*类型的指针a,c，一个int类型变量b

char *message = "Hello world!"; //定义一个char*变量，指向数据段的字符串常量区中的字符串"Hello world!"的首字符的地址。
//下面两行代码和上面一行代码的作用是相同的，message是一个`char *`指针，指向字符串常量"Hello world!"的首字符的地址。
char *message = NULL;
message = "Hello world!"; 
```

### 未初始化和非法的指针
看一个错误的代码片段：```c
int *a; //定义一个指针*p
*a = 12;    //把12存储在a指向的内存中，错误
```
这个代码中犯了一个很严重的错误，我们在声明了变量`a`，但是没有对它进行显示初始化，所以编译器会对a进行默认初始化，默认初始化并不会为变量分配内存。如果程序执行这个赋值操作，假如a是一个非法地址，程序会出错，终止程序，在UNIX系统上，这个错误称为"segmentation violation"或者"memory fault"，它告诉我们程序正在访问一个非法的地址。如果a是一个合法的地址，这就会错误的修改a指向的内存中的值，造成一些难以预料到的错误。

### 空指针
有以下几种方法声明空指针：``` c
// 方法1.
int *p1 = nullptr;
// 方法2.
int *p2 = 0;
// 方法3.
int *p3 = NULL;//NULL定义在cstdlib中
```
最好使用`nullptr`或者`0`，而避免使用`NULL`。

### `void*`指针
`void *`指针可以存放任意类型的地址，但是我们并不知道它存放的是什么类型的对象。


## 指针的指针
因为指针也是一个变量，所以它自然也就有地址，也就存在指向指针的指针。``` c
int a, *b, **c;
b = &a;
c = &b;   //紧挨着c左边的那个*表示c是一个指针，然后再往左边的那个`*`是和`int`在一起的，表示指针`c`指向的变量的类型是`int *`类型的。
// a,*b, **c表示同样的东西，都是变量a的值。
// *c和b和&a表示同样的东西，都是变量a的地址。
// a表示int类型的变量
// b是a的地址，*b表示对指针p解引用，*b就是a。
// c是b的地址，*c表示对指针c解引用，*c就是b，也就是a的地址，*(*c)也就是*b，也是a。
```

## 指针的值，就是地址，有四种可能取值
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，没有指向任何对象
4. 无效指针，除了以上三种情况的任何值。

使用无效指针和使用未初始化变量是同类错误，编译器都不负责进行检查。


## 指针的特点
1. 存放的是对象的地址，要想获取变量的地址，需要使用取地址符`&`，访问指针中地址指向的变量，使用解引用符号`*`，即：```c
int val = 32;
int *p = & val; //指针p存放的是变量val的地址
int b = *p; //b被初始化为32,p存放的是val的地址，*p获得该地址指向的变量val。
*p = 3; //将val赋值为3
```
2. 赋值永远改变的是`=`左侧的对象，可以用来判断到底是改变了指针的值还是改变了指针所指的对象的值。
3. 除了两种特殊情况外，所有指针的类型都必须和它指向的对象严格匹配。

## 指针和引用的不同点
1. 指针本身就是一个对象，允许赋值和拷贝，在生命周期内可以指向几个不同的对象；而引用本身并非一个对象，一定定义了引用，它就和一个对象终生绑定在了一起。
2. 指针定义时无须赋值；而引用必须在定义时赋值。


## 指针表达式和左值右值[2]
关于左值和右值的介绍，可以查看[C C++ lvalue and rvalue]()。
给出下列代码
``` c
char ch = 'a';
char *cp = &ch;
//&ch = 4; //这个是错的，&ch是一个地址，但是它本身只是一个数，它的本质和`10=4;`没有区别，使用解引用符号访问这个地址所指向的内存空间；
// 10 = 4; 错误，10既不是指针，也不是变量
//*10 = 4; 错误，10既不是指针，也不是变量
*(int*)10 = 4; //10是一个int，首先把它转化成一个指针，表示一个地址，然后使用解引用进行赋值
```
1. `ch`当右值时，表达式的值是`'a'`，`ch`当左值时，表示的是`ch`在内存中的位置。
2. `&ch`当右值时，表示变量`ch`的地址，但是它不是一个地址，因为它没有指定内存中的一个位置。
3. `cp`
4. `&cp`
5. `*cp`
6. `*cp+`
7. *(cp+1)
8. ++cp
9. cp++
10. *++cp
11. *cp++
12. ++*cp
13. (*cp)++
14. ++*++cp
15. ++*cp++


## 指针运算

### 算术运算
#### 指针加减一个整数
#### 指针减指针

### 关系运算
`>`, `>=`, `<`, `<=`

## 指针的大小
任何类型的指针本身所占的大小都是相等的，取决于计算机的地址大小，如果是`32`位的地址，指针的大小就是`4`个字节，如果是`64`位的地址，指针的大小就是`8`个字节。

## 参考文献
1.《C++ Primer第五版》
2.《C和指针》
