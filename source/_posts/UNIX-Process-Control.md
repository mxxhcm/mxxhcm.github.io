---
title: UNIX Process Control
date: 2019-11-25 10:31:02
tags:
 - UNIX
 - 进程
categories: UNIX
---

## 概述
这一节主要介绍UNIX系统的进程控制，包括进程创建，进程执行和进程控制。以及进程属性的各种的ID-real UID, real GID和effective UID, effective GID和save UID， set UID和set GID，以及它们如何收到进程控制原语的影响。


## 进程标识(pid)
每一个进程都有一个非负整数表示它的唯一进程ID。进程ID标识符总是唯一的，但是可以复用。
系统中有一些专用进程，具体细节跟实现有关。
获得当前进程的各项id：
``` c
// real uid
uid_t ruid = getuid()
// effective uid
uid_t euid = geteuid()

// real gid
uid_t rgid = getgid()
// effective gid
uid_t egid = getegid()

// pid
uid_t pid = getpid()
// parent pid
uid_t ppid = getppid()
```

## `fork`
`fork`创建一个子进程。函数原型：

### `fork`原型
```c
#include <unistd.h>

pid_t fork(void);
```

### `fork`性质
1. **进程ID**。`fork`调用一次，返回两次，分别是0和子进程ID，用以区别父进程和子进程。对于父进程，返回子进程ID，对于子进程，返回0。因为父进程可能有多个子进程，并且没有提供获得一个进程所有子进程ID的函数，而fork只有一个父进程，可以通过`getppid`获得它的父进程的ID。所以这样子进行区分。
2. 子进程和父进程分别继续执行调用`fork`之后的指令。子进程是父进程的副本。子进程获得父本的数据段，堆和栈的完全副本。这是子进程的副本，和父进程不一样，它们并不共享数据的内存空间，但是它们共享text segment。
3. 现代的操作系统实现，使用写时复制代替了父进程数据段，堆和栈的完全副本。这些区域是由父进程和子进程共享的，但是它们的访问权限是只读。如果父进程或者子进程想要对这些区域进行修改的话，内核会为修改区域的那块内存制作一个副本，用于进程修改。
4. 父进程和子进程因为不共享数据，堆和栈，每个进程都有自己的变量，不会相互影响。
5. **执行顺序**。`fork`后父进程和子进程的执行顺序是不确定的，这跟内核的调度算法有关。如果要求父进程和子进程之间进行同步，需要它们之间进行某种形式的进程通信。
6. **文件共享**。对于父进程打开的文件，`fork`相当于将父进程的文件描述符都复制到了子进程中，相当于对父进程的每一个文件描述符，都调用了`dup`函数。父进程和子进程每个相同的打开文件描述符共享同一个文件表项。一般来说，在`fork`之后处理文件描述符有以下两种情况：
    - 父进程等待子进程完成。父进程不需要对它的文件描述符做任何处理。
    - 父进程和子进程分别执行不同的程序段。父进程和子进程各自关闭它们不需要的文件描述符。
7. **`fork`后子进程继承的信息**。
    - real UID, real GID, effective UID, effective GID 
    - set UID和 set GID
    - 附属组ID
    - 进程组ID
    - Session ID
    - 控制终端
    - cwd
    - root dir
    - umask
    - signal mask
    - 文件描述符标志
    - 环境
    - 共享的内存段
    - 内存映像
    - Resource limits
8. **父进程和子进程的区别。**
    - `fork`的返回值不同
    - pid不同
    - 它们有不同的ppid
    - 子进程的很多时间设置为0
    - 父进程设置的文件锁子进程不继承。
    - 子进程的未处理闹钟被清除
    - 子进程的未处理信号被设置为空集。
9. **`fork`的两种用法**。
    - 父进程和子进程分别执行不同的代码。比如网络服务中，父进程负责等待客户端请求，子进程负责处理父进程接收到的请求。
    - 一个进程要执行不同的程序。对shell比较常见，通常执行完`fork`返回后立即调用`exec`。

## `vfork`
创建一个子进程，并且阻塞父进程，函数原型如下：

### `vfork`原型
``` c
#include <sys/types.h>
#include <unistd.h>

pid_t vfork(void);
```

### `vfork`属性
1. `vfork`和`fork`都创建一个新进程，但是`vfork`并不会将父进程的地址空间完全复制到子进程中。因为子进程会立即调用`exec`或者`exit`，就不会引用该地址空间。但是如果在调用`exec`或者`exit`之前，它会在父进程的空间中运行，这种做法会提高效率。但是如果子进程修改除了`vfork`的返回值，或者在没有调用`exit`或者`exec`之前调用其他函数，这种行为是未定义的。
2. `vfork`保证子进程先运行，在子进程没有调用`exec`或者`exit`时，内核会使父进程休眠，在子进程调用`exec`或者`exit`之后父进程才会恢复运行。如果子进程需要父进程进一步操作的时候，就会产生死锁。

## `exit`
总共有八种方式可以让进程终止，包括五种正常和三种异常，前五种是正常终止，后五种是异常终止：
1. 从`main`返回，相当于调用`exit`。
2. 调用`exit`，
3. 调用`_exit`或者`_Exit`
4. 最后一个线程从其启动例程返回
5. 最后一个线程调用`pthread_exit`
6. 调用`abort`
7. 接到一个`signal`
8. 最后一个线程对取消请求做出响应


## `wait`和`waitpid`

## `waitid

## `wait3`和`wait4`

## race condition

## `exec`

## 更改UID和GID

## 解释器文件

## `system`

## 进程会计

## 用户标识

## 进程调度

## 进程时间

## 参考文献
1.《APUE》第三版

