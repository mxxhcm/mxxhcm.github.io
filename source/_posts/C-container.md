---
title: C++ container
date: 2019-11-10 12:34:56
tags:
 - C/C++
 - container
 - 容器
 - 顺序容器
 - 关联容器
categories: C/C++
---

## 什么是容器库
一个容器就是一些特定类型对象的集合。C++标准库中提供了两类容器，一类是顺序容器，一类是关联容器。

顺序容器为程序员提供了控制元素存储和顺序访问的能力。这种顺序不依赖于元素的值，而跟元素加入容器时的位置相对应。
而关联容器则根据关键字的值来存储元素。

## 容器库概述
1. 每一个容器都定义在一个头文件中，文件名和类型相同。
2. 顺序容器几乎可以保存任意类型的元素，但是某些容器对于元素类型有特殊的要求，我们可以为不支持特定操作的类型定义容器，但是使用只用哪些没有特殊要求的容器操作了。
顺序容器构造函数的一个版本接受容器大小参数，它使用元素类型的默认构造函数，但是有些类没有默认构造函数，这时候我们可以定义这种类型的容器，但是需要传入一个元素的初始化器。例如：```c
vector<noDefault> v1(10, init); //正确，
vector<noDefault> v2(10);   //错误，因为没有默认构造函数
```
3. 对于不同类型的容器，它们有各自特有的操作，也有都支持的操作，这一节就简单介绍一下他们都支持的操作：

### 迭代器
所有容器都支持迭代器，迭代器也有公共接口。。所有的迭代器都允许访问容器中的元素，所有的迭代器都通过解引用来实现这个操作。
关于迭代器的具体内容可以查看[C++ string vector and iterator](https://mxxhcm.github.io/2019/11/06/C-string-vector-and-iterator/)。

### 容器类型成员
- `iterator`，容器的迭代器类型
- `const_iterator`，无法修改元素的迭代器类型
- reverse_iterator，反向迭代器
- const_reverse_iterator，不能修改元素的反向迭代器
- `size_type`，无符号整数，足够保存容器的最大大小。
- `difference_type`，有符号整数，足够保存两个迭代器之间的距离
- `value_type`，元素类型
- `reference`，元素的左值类型
- `const_reference`，元素的`const`左值类型。

### 构造函数
- `C c;`，默认构造
- `C c1(c2);`，拷贝构造
- `C c(b, e);`，将迭代器b和e指定范围的元素拷贝到c，不适用于array
- `C c{a, b, c...};`，列表初始化c

### 赋值和`swap`
- `c1 = c2`，将c1的元素用c2的元素替换
- `c1 = {a, b, c, ...}`，将c1中的元素替换为列表中元素，不适用于array
- `a.swap(b)`，交换a和b的元素
- `swap(a,b)`，和`a.swap(b)`相同。

### 大小
- `size()`，容器当前容纳的元素个数，不支持`forward_list`
- `max_size()`，容器所能容纳的最大元素个数
- `empty()`，容器是否为空

具体示例，编译器是gcc-7.4.0
``` c
int main()
{
    vector<int> vi;

    cout << vi.size() << endl;
    // 0
    cout << vi.max_size() << endl;
    // 4611686018427387903
    cout << vi.empty() << endl;
    // 1

    string s;
    
    cout << s.size() << endl;
    // 0
    cout << s.max_size() << endl;
    // 9223372036854775807
    cout << s.empty() << endl;
    // 1
    return 0;
}
```

### 增删元素（不适用于`array`）
注意，在不同的容器中，操作的接口都不同
- c.insert(args)，将args中的元素拷贝进c
- c.emplace(inits)，使用inits构造c中的一个元素
- c.erase(args)，删除args指定的元素
- c.clear()，删除c中所有元素，返回void

### 关系运算符
- `==`和`!=`，所有的容器都支持的运算符
- `<=`,`<`,`>=`, `>`，关系运算符（无序关联容器不支持）

### 获取迭代器
- `c.begin()`和`c.end()`，返回指向c的首元素和尾后元素的迭代器
- `c.cbegin()`和`c.cend()`，返回指向c的首元素和尾后元素的const_iterator
- `c.rbegin()`和`c.rend()`，返回指向c的尾元素和首元素之前的反向迭代器
- `c.crbegin()`和`c.crend()`，返回指向c的尾元素和首元素之前的const_reverse_iterator


## 顺序容器概述
所有C++标准库中的顺序容器包括：
- vector: 可变大小数组，
- list：双向链表，
- forward_list：单向链表，
- deque：双端队列
- array：固定大小数组
- string：与vector类似，但是专门用于字符操作，


### 时间复杂度分析
所有的顺序容器都提供了快速顺序访问元素的能力。但是，这些容器在以下方面都有不同的性能折中：
- 添加或者删除元素的代价
- 随机访问容器中元素的代价

具体如下（都是时间复杂度）：
- vector：支持$O(1)$随机访问。在尾部之外的位置插入或者删除可能很慢$O(n)$。
- list：只支持双向顺序访问$O(n)$，任何位置插入或者删除都是$O(1)$。
- forward_list：单向链表，只支持单向顺序访问$O(n)$，任何位置插入或者删除都是$O(1)$。
- deque：$O(1)$随机访问，头尾插入都是$O(1)$。
- array：$O(1)$随机访问，不支持增删操作。
- string：支持$O(1)$的随机访问，尾部增删是$O(1)$。


### 存储策略
1. `string`和`vector`都存储在连续的的内存空间中。由于元素是连续存储的，根据元素的下标计算元素的地址很快；但是在增删中间的元素时，需要移动增删位置之后所有的元素；此外，添加一个元素时，可能当前的存储空间不够了，还需要分配新的存储空间，这需要将所有的元素都移动到新的存储空间去。
2. `list`和`forward_list`的数据结构都是链表，具有链表的性质。即任何位置增删操作都是$O(1)$的，但是不支持随机存储，在寻找某一个元素时，只能遍历整个链表$O(n)$。此外，和`vector`,`deque`,`array`，他们还需要额外的内存开销，即指针的内存开销，指针用来记录前(后)节点的信息。
3. `deque`支持$O(1)$的随机访问，在中间位置增删都是$O(n)$的开销，但是在`deque`两端增删是$O(1)$的事件开销。
4. `array`和内置数组一样，大小固定，不支持增删，但是更安全。
5. `forward_list`是单向链表，它的设计目标是和手写的单向链表性能相似，因此，`forward_list`没有`size`操作，因为这会增大计算开销。对于其他容器而言，`size`是一个$O(1)$的操作。

### 顺序容器的选择
1. 通常使用`vector`是最好的选择，除非有更好的理由。
2. 程序有很多小的元素，而且空间额外开销很重要，不要用`list`或者`forward_list`。
3. 要求支持随机访问元素，使用`vector`或者`deque`。
4. 在容器中间插入或者删除，使用`list`或者`forward_list`。
5. 程序需要在容器头尾增删，而不会在中间增删，使用`deque`。
6. 如果即需要随机存取，又需要在容器中间增删，这个时候根据存取和增删的操作数量进行选择，哪种操作占据主导地位，就使用相对应的容器。
7. 如果不确定到底应该使用`vector`还是`list`，那么就只使用它们都支持的操作，不使用下标运算，使用迭代器，避免随机访问。

关于顺序容器更详细的内容可以查看[C++ sequential container](https://mxxhcm.github.io/2019/11/10/C-sequential-container/)。

## 关联容器概述
关于关联容器更详细的内容可以查看[C++ associative container](https://mxxhcm.github.io/2019/11/10/C-associative-container/)。


## 参考文献
1.
