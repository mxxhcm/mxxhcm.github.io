---
title: C++ customed type class
date: 2019-11-10 12:31:11
tags:
 - C/C++
 - 类
categories: C/C++
---

## 知识点
1. 成员函数的声明必须在类的内部,成员函数的定义既可以在类的内部也可以在类的外部.**定义在类内部的的函数是隐式的内联函数**.而作为接口部分的非成员函数,如`add`,`print`,`read`等都必须在类的外部.
2. 构造函数不能声明为const类型
3. **友元的声明只是指定了访问权限(可以访问类的私有成员,和第三条不冲突),而并非一个普通的函数声明,如果希望类的用户能够调用某个友元函数,必须在友元声明之外再次对函数进行一次声明.**
4. 封装的好处
    -  确保用户代码不会无意间破坏对象的状态,防止因为引入的原因造成数据被破坏,如果有程序缺陷破坏了对象的数据成员的状态,那么只有实现部分的代码可能产生这样的错误.降低了代码维护和错误修正的难度
    - 被封装的类的具体实现细节可以随时改变,无序调整用于级别的代码.类的作者可以比较自由的修改数据.当实现部分改变时,只要类的接口不变,用户代码就不需要改变.如果数据是`public`的,所有使用了原来数据成员的代码都可能失效,需要先定位并重写这部分代码.**注意当类的实现发生改变时无序更改用户代码,但是使用了该类的源文件必须重新编译.**



## 类
类的基本思想是数据抽象和封装．数据抽象是一种依赖于接口和实现分离的编程技术．类的接口包括用户所能执行的操作，类的实现则包括类的数据成员，负责接口实现的函数以及定义类所需要的各种私有函数．
封装实现了类的接口和实现的分离，封装后的类隐藏了它的实现细节，类的用户只能使用接口而无法访问实现部分．
类想要实现数据抽象和封装，需要首先定义一个抽象数据类型，在抽象数据类型中，类的设计者负责考虑类的实现过程；使用该类的程序员只需要抽象的思考类型做了什么，不需要了解细节．

## 类的定义
`Sales_item`类是一个抽象数据类型,我们通过它的接口使用一个`Sales_item`对象,我们不能访问`Sales_item`对象的数据成员,甚至我们都不知道这个类有哪些数据成员.

`Sales_data`类是一个非抽象数据类型,它允许类的用户直接访问它的数据成员,并且需要用户自己定义相应的操作,即`Sales_data`只有数据成员,没有其他内容.
要把它改成一个和`Sales_item`功能一样的抽象数据类型,我们需要定义一些操作供类的用户使用,然后封装它的数据成员了.

## 类作用域和成员函数
类本身就是一个作用域.类的成员函数的定义在类的作用域之内.编译器在处理类的时候,先编译成员的声明,然后编译成员函数体.
在类的外部定义成员函数时,成员函数的定义必须和它的声明匹配.

### 成员函数
成员函数是定义为类的一部分的函数,有时候也被称为方法,使用.运算符后跟要使用的成员函数,同时使用调用运算符`()`来访问一个函数.
`Sales_data`需要提供的操作:
- 一个isbn成员函数返回对象的isbn号
- 一个combine成员函数,将一个Sales_data对象加到另一个对象上(相当于+=)
- 一个名字为add的非成员函数,执行加法
- 一个read非成员函数,从istream读入数据到Sales_data对象
- 一个print非成员函数,输出Sales_data对象的值到ostream

新的`Sales_data`包含三个数据成员和两个接口成员函数,以及一个实现部分的成员函数,另外还有三个非接口部分成员函数.``` c++
struct Sales_data{

    std::string bookNo;
    unsigned units_sold = 0;
    double revenue = 0.0;

    Sales_data &combine(const Sales_data&);
    std::string& isbn() const {return bookNo};

    //并不是为用户提供的函数.
    double avg_price() const;

};

//非成员接口函数.
Sales_data add(const Sales_data&, const Sales_data&);
std::ostream &print(std::ostream&, const Sales_data&);
std::istream &read(std::istream&, Sales_data&);
```

成员函数的声明必须在类的内部,成员函数的定义既可以在类的内部也可以在类的外部.**定义在类内部的的函数是隐式的内联函数**.而作为接口部分的非成员函数,如`add`,`print`,`read`等都必须在类的外部.


## `this`和`const`成员函数
### `this`指针
当一个对象调用类的成员函数时,到底发生了什么?比如:``` c++
Sales_data book;
book.isbn();
```
上面第二行代码其实相当于:```c++
Sales_data::isbn(&book);
```
成员函数通过一个名字为`this`的额外的隐式参数来访问调用它的那个对象,编译器负责把`book`的地址传递给`isbn`的隐式形参`this`.在函数内部可以直接使用调用该函数的对象的成员,不需要通过成员访问运算符来实现,因为`this`所指的就是这个对象,***任何对类成员的直接访问都被当成`this`的隐式使用.**当`isbn`使用`bookNo`时,隐式的使用`this`指向的成员,就像我们写了`this->bookNo`一样.
虽然`this`形参是隐式定义的,但是定义任何名字为`this`的变量或者函数都是非法的.我们可以在成员函数体内部调用`this`,`this`的目的是总是指向当前这个对象,所以`this`是一个常量指针(顶层const),不允许更改它的指向.

### `const`成员函数
默认情况下,`this`的类型是指向类类型的非常量版本的常量指针(底层const).比如在`Sales_data`的成员函数中,`this`的类型是`Sales_data *const`,尽管`this`是隐式的,它仍然需要遵循初始化规则,即不能把它绑定到常量对象上.也就使得常量对象无法调用普通的成员函数.
如果`isbn`是一个普通函数而且`this`是一个普通的指针参数,应该把`this`生命成`const Sales_data *const`.顶层const是它自己带的,底层const是为了能够使得常量对象也能够调用普通的成员函数.
但是因为`this`是隐式参数,C++选择将const关键字放在函数的参数列表之后,这个const表示`this`是一个指向常量的指针,这样的函数称为常量成员函数.
**常量对象,常量的引用和指针只能调用常量成员函数.并且只能读取它的对象的数据成员,无法修改**

### 返回`this`对象
当我们定义的函数类似于某个内置运算符时,应该尽量让函数的行为和内置运算符类似.比如内置运算符把它的左侧运算对象当做左值返回.如果我们在写一个复合赋值运算的时候,就需要返回一个引用类型,具体的返回值应该是`this`指针指向的整个对象,即`*this`.如下所示:```
Sales_data &combine(const Sales_data &rhs)
{

    units_sold += rhs.units_sold;
    revenut += ths.revenue;

    return *this;
}
```

## 构造函数
构造函数完成类对象的初始化过程.详细介绍可以查看[]().

## 访问控制和封装
### 访问说明符
访问说明符用于加强类的封装性,让用户不能直接访问对象的内部.
- `public`, 定义在public说明符后的成员在整个程序内可以被访问,public定义类的接口,向类的用户提供访问数据成员的功能.
- `private`,定义在private说明符后的成员可以被类的成员函数访问,但是不能被该类的独享访问,它封装了类的实现细节.

C++中的`struct`和`class`很像,只不过`struct`默认访问权限是`public`,而`class`默认访问权限是`private`的.

### 友元
1. 友元提供了其他类或者函数(非类的成员函数)访问类的私有对象的功能.
2. 友元的声明只需要在其他函数或者类前加上`friend`关键字即可.
3. 友元声明只能出现在类定义的内部,并且不会区域访问控制级别的约束.
4. **友元的声明只是指定了访问权限(可以访问类的私有成员,和第三条不冲突),而并非一个普通的函数声明,如果希望类的用户能够调用某个友元函数,必须在友元声明之外再次对函数进行一次声明.**
5. tips,一般来说,最好在类定义开始或者结束前的位置集中声明友元.

### 封装
封装的好处:
1. 确保用户代码不会无意间破坏对象的状态,防止因为引入的原因造成数据被破坏,如果有程序缺陷破坏了对象的数据成员的状态,那么只有实现部分的代码可能产生这样的错误.降低了代码维护和错误修正的难度
2. 被封装的类的具体实现细节可以随时改变,无序调整用于级别的代码.类的作者可以比较自由的修改数据.当实现部分改变时,只要类的接口不变,用户代码就不需要改变.如果数据是`public`的,所有使用了原来数据成员的代码都可能失效,需要先定位并重写这部分代码.**注意当类的实现发生改变时无序更改用户代码,但是使用了该类的源文件必须重新编译.**




## 类的特性

## 类的作用域

## 构造函数

## 类的静态成员

## 其他
头文件一旦改变，相关的源文件必须重新编译获取更新过的声明。
预处理器变量无视C++中关于作用域的规则。加上头文件保护符，防止重复包含。头文件保护符必须唯一。
```c
#ifndef SALES_DATA_H
#define SALES_DATA_H
#endif
```

## 参考文献
1.《C++ Primer第五版》
