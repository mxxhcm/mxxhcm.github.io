---
title: C++ dyncamic memory
date: 2019-11-10 12:39:41
tags:
 - C/C++
categories: C/C++
---

## 概念

## 概述
每一个C程序都把内存划分成静态内存，栈内存，堆内存（自由空间）。静态内存存放局部static对象，类的static数据成员以及定义在任何函数之外的变量。栈存放函数内的非static对象。堆内存是由程序员自己负责管理（申请和释放）的内存。

## 动态内存和智能指针
C++ 中动态内存的管理是通过一对运算符`new`和`delete`实现的。`new`在动态内存中为对象分配空间，并且返回一个指向该对象的指针，可以选择对对象进行初始化；`delete`接收一个动态对象的指针，销毁该对象，释放和它相关的内存。

动态内存很难管理，有时候忘记释放内存，会产生内存泄露；有时候在有指针引用内存的情况下就释放了它，这种情况下产生非法引用的内存。
C++ 提供了两种智能指针，`shared_ptr`和`unique_ptr`管理动态对象。智能指针也是模板。因此，在创建智能指针的时候，需要提供类型信息。
`shared_ptr`允许多个指针指向一个对象，而`unique_ptr`则独占所指向的对象。
下面是`shared_ptr`和`unique_ptr`都支持的一些操作：
![smart_pointer](smart_pointer.png)

## `shared_ptr`
![shared_ptr](shared_pointer.png)

1. `shared_ptr`的声明和创建
2. `make_shared`创建一个指针。
3. `shared_ptr`的拷贝和赋值，引用计数。修改引用计数的几种情况：
    - 拷贝一个`shared_ptr`，比如用一个`shared_ptr`初始化另一个，值传参，返回值等情况，引用计数增加。
    - 给`shared_ptr`赋一个新值，引用计数减少。
    - shared_ptr被销毁时，引用计数减少。
4. 通过析构函数自动销毁它管理的对象。

## `new`
1. 默认初始化。`new`后面加类型，没有小括号，也没有花括号。
默认情况下，new分配的对象，不管是单个分配的还是数组中的，都是默认初始化的。这意味着内置类型或组合类型的对象的值是无定义的，而类类型对象将用默认构造函数进行初始化。
2. 值初始化。类型名字后加()即可，对于内置类型的变量，初始化为0，对于类类型的变量，调用默认构造函数。
3. 直接初始化。使用初始化列表加对象值，或者小括号加对象值。

对于自定义类型而言，只要一调用new，无论后面有没有加()，那么编译器不仅仅给它分配内存，还调用它的默认构造函数初始化。



## `shared_ptr`和`new`

## `unique_ptr`
![unique_ptr](unique_pointer.png)

## 动态数组

### `new`

### allocate类

## 参考文献
