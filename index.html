<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/21/UNIX-file-and-directory/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/21/UNIX-file-and-directory/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">UNIX file and directory</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-21 10:18:13 / 修改时间：23:47:13" itemprop="dateCreated datePublished" datetime="2019-11-21T10:18:13+08:00">2019-11-21</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="概述">概述</h2>
<p>这一节主要介绍文件系统的一些特征和文件的性质。相应的属性都存在<code>stat</code>函数给出的<code>struct stat</code>结构体中，每一个小节都会介绍结构体中的一个字段。</p>
<h2 id="stat-fstat-fstatat-lstat"><code>stat</code>, <code>fstat</code>, <code>fstatat</code>, <code>lstat</code></h2>
<h3 id="函数原型">函数原型</h3>
<p>这一节主要介绍结构体<code>struct stat</code>的字段，以及如何获得某个目录的<code>struct stat</code>结构体。可以通过四个函数获得：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstat</span><span class="params">(<span class="keyword">int</span> fd, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;           /* Definition of AT_* constants */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fstatat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="区别">区别</h3>
<ol>
<li><code>stat</code>将pathname指定的文件的有关信息存在放在<code>statbuf</code>中</li>
<li><code>fstat</code>将文件描述符指定的文件的有关信息存在放在<code>statbuf</code>中</li>
<li><code>lstat</code>和<code>stat</code>类似，但是当文件是一个符号链接时，<code>lstat</code>返回符号链接相关的信息，<code>stat</code>返回的是符号链接链向的文件。</li>
<li><code>fstatat</code>相当于将前三个函数进行了整合：<br>
当<code>dirfd</code>设置为<code>AT_FDCWD</code>时或者pathname是绝对路径时，设置<code>AT_SYSLINK_NOFOLLOW</code> flags时，相当于<code>lstat</code>。<br>
当<code>dirfd</code>设置为<code>AT_FDCWD</code>时或者pathname是绝对路径时，<code>AT_SYSLINK_NOFOLLOW</code> flags不进行设置时，相当于<code>stat</code>。<br>
当<code>dirfd</code>既不是<code>AT_FDCWD</code>而且pathname不是绝对路径时，就是<code>fstatat</code>处理的情况了。</li>
</ol>
<h3 id="struct-stat"><code>struct stat</code></h3>
<p>这个结构体包括：</p>
<ol>
<li>mode_t st_mode; 文件类型和文件操作权限</li>
<li>ino_t st_ino; i-node号</li>
<li>dev_t st_dev; 文件所在文件系统的设备号</li>
<li>dev_t st_rdev; 特殊文件所在文件系统的设备号</li>
<li>nlink_t st_nlink; 链接的数量</li>
<li>uid_t st_uid; 文件所有者的UID</li>
<li>gid_t st_gid; 文件所有者的GID</li>
<li>off_t st_size; 普通文件的字节数</li>
<li>struct timespec st_atime; 最后一次access的时间</li>
<li>struct timespec st_mtime; 最后一个modification的时间</li>
<li>struct timespec st_ctime; 最后一次file status change的时间</li>
<li>blksize_t st_blksize; 最合适的I/O block size</li>
<li>blkcnt_t st_blocks; 分配了多少个disk blocks</li>
</ol>
<h2 id="文件类型">文件类型</h2>
<p>文件类型信息包含在<code>struct stat</code>的<code>st_mode</code>字段中。UNIX系统的文件类型有以下几种：</p>
<ol>
<li>普通文件，可以是二进制文件，也可以是文本文件。除了二进制可执行文件必须遵循标准化格式外，其他的文件对于UNIX内核来说基本上没有区别。使用<code>S_ISREG</code>宏进行判断。</li>
<li>目录文件，包含了其他文件的名字，以及指向这些文件有关信息的指针。对一个目录具有读权限的任意进程都可以读目录的内容，但是只有内核才可以直接写目录文件。使用<code>S_ISDIR</code>宏进行判断。</li>
<li>block special file，提供对设备带缓冲的访问，每次访问以固定的长度进行。使用<code>S_ISBLK</code>宏进行判断。</li>
<li>character special file，提供对设备不带缓冲的访问，每次访问长度可变。系统中的设备要么是block special file要是character special file。使用<code>S_ISCHR</code>宏进行判断。</li>
<li>FIFO，用于进程间通信。使用<code>S_ISFIFO</code>宏进行判断。</li>
<li>socket，用于进程间的网络通信。使用<code>S_ISSOCK</code>宏进行判断。</li>
<li>sysbolic link，指向另一个文件。使用<code>S_ISLNK</code>宏进行判断。</li>
</ol>
<h2 id="和进程相关的uid和gid">和进程相关的UID和GID</h2>
<p>每一个进程有6个或者更多和它相关的ID：</p>
<h3 id="实际uid和gid">实际UID和GID</h3>
<p>real user ID和real group ID，用来表示当前用户。</p>
<h3 id="有效uid和gid">有效UID和GID</h3>
<p>effective user ID和effective group ID，决定我们的文件访问权限。通常情况下，effective user ID以及effective group ID和real user ID以及real group ID一样。</p>
<h3 id="set-user-id和set-group-id">Set-User-ID和Set-Group-ID</h3>
<p>saved set-user-ID和saved set-group-ID，在执行一个程序时，包含了有效user ID和有效group ID的副本。<br>
每一个文件都有一个所有者和组所有者，它们的值在<code>st_uid</code>和<code>st_gid</code>中。<br>
当执行一个程序文件时，进程的effective user ID通常就是real user ID，而effective group ID通常就是real group ID。但是可以在<code>st_mode</code>中设置一个特殊的flag，意思是当执行此文件时，将执行此文件的进程的effective user ID设置为文件所有者的user ID。同样，还有另一个特殊的flag，它将执行此文件的进程的effective group ID设置为文件组所有者的user ID。这两个标志位被记为set-user-ID bit和set-group-ID bit，它们都存放在<code>st_mode</code>中，可以使用<code>S_ISUID</code>和<code>S_ISGID</code>测试。<br>
<strong>运行set UID程序的进程通常会获得额外的权限！！！所以要格外注意。</strong></p>
<h2 id="文件和目录的访问权限">文件和目录的访问权限</h2>
<p><code>st_mode</code>中还包含了文件的访问权限。对于所有文件类型（不单单是文件和目录），都有三种访问权限：</p>
<h3 id="r-读权限">r-读权限</h3>
<p>读权限查询文件名数据</p>
<h3 id="w-写权限">w-写权限</h3>
<ul>
<li>新建文件与目录</li>
<li>删除文件或者目录</li>
<li>重命名以及转移文件或者目录</li>
</ul>
<h3 id="x-可执行权限">x-可执行权限</h3>
<ul>
<li>进入某目录</li>
<li>切换到该目录（cd命令）</li>
</ul>
<p>!!!能不能进入某一目录只与该目录的x权限有关，如果不拥有某目录的x权限，即使拥有r权限，那么也无法执行该目录下的任何命令<br>
但是即使拥有了x权限，但是没有r权限，能进入该目录但是不能打开该目录，因为没有读取的权限。</p>
<h3 id="九个访问权限位">九个访问权限位</h3>
<p>将<code>rwx</code>和user, group以及other进行组合，总共有九个访问权限位：</p>
<ul>
<li>S_ISUID，set user id,</li>
<li>S_ISGID, set group id,</li>
<li>S_ISVTX, stick bit,</li>
<li>S_IRUSR, user read,</li>
<li>S_IWUSR, user write,</li>
<li>S_IXUSR, user exectu,</li>
<li>S_IRGRP, group read,</li>
<li>S_IWGRP, group write,</li>
<li>S_IXGRP, group exectuble,</li>
<li>S_IROTH, other read,</li>
<li>S_IWOTH, other write,</li>
<li>S_TXOTH, other exectuble,</li>
</ul>
<p>可以对最后九项做一个简洁版的表示：<br>
S_IRWXU = S_IRUSR|R_IWUSR|S_IXUSR<br>
S_IRWXG = S_IRGRP|S_IWGRP|S_IXGRP<br>
S_IRWXO = S_IROTH|S_IWOTH|S_IXOTH</p>
<h3 id="文件和目录的操作规则">文件和目录的操作规则</h3>
<ol>
<li>使用名字打开任意类型的文件时，对于文件名字中包含的每一个目录，包括当前工作目录，都应该具有执行权限。</li>
<li>对于一个文件的读权限决定了我们能够打开先有文件进行读操作。这与<code>open</code>函数的<code>O_RDONLY</code>和<code>O_RDWR</code>有关。</li>
<li>对于一个文件的写权限决定了我们能够打开先有文件进行写操作。这与<code>open</code>函数的<code>O_WRONLY</code>和<code>O_RDWR</code>有关。</li>
<li>如果要在<code>open</code>函数中指定<code>O_TRUNC</code>标志，必须对该文件拥有写权限。</li>
<li>为了在一个目录中创建新文件，必须对这个目录具有写权限和执行权限。</li>
<li>为了删除一个现有文件，必须对包含该文件的目录拥有写权限和执行权限，而不必对文件本身拥有读权限和写权限。</li>
<li>如果使用7个<code>exec</code>函数中的任何一个执行某个文件，都必须拥有该文件的写权限。</li>
</ol>
<h3 id="访问权限检测">访问权限检测</h3>
<p>进程每次打开，创建或者删除一个文件时，内核就会进行文件访问权限测试，这种测试可能涉及到文件的所有者ID，文件的组所有者ID，进程的effective user ID和effective group ID。文件的所有者ID和文件的组所有者ID都是文件的属性，而effective user ID和effective group ID是进程的属性。<br>
内核进行访问权限测试的步骤如下：</p>
<ol>
<li>如果进程的effective user ID是0，结束权限判断，允许各项访问。否则跳转第2步进行判断。</li>
<li>如果进程的effectiev user ID等于文件所有者ID，也就是<code>st_uid</code>，结束权限判断，根据访问权限位允许相应操作。否则跳转第3步。</li>
<li>如果进程的effective group ID等于文件的group ID，结束权限判断，根据访问权限的设置允许相应的操作，否则跳转第4步。</li>
<li>如果不满足前三条，就按照若其他用户的访问权限位判定操作是否合法。</li>
</ol>
<p>总结一下，就是依次判断effective user ID是不是等于root，effective user ID是不是等于<code>st_uid</code>，或者effective group ID是不是等于<code>st_gid</code>，如果都不满足，就按照其它权限判定当前进程对文件的操作是否被允许。按照顺序来判断，满足一个就不用判断后面的了。</p>
<h2 id="新文件和新目录的所有权">新文件和新目录的所有权</h2>
<p>新文件的user ID设置为进程的effective user ID。关于新文件的group ID，可以选择以下两种方式中的一个进行设置：</p>
<ol>
<li>新文件的group ID可以是进程的effective group ID</li>
<li>新文件的group ID可以是它所在目录的group ID。</li>
</ol>
<p>不同的UNIX实现有不同的设置，这里拿linux来说，Linux 3.2.0以后，新文件的group ID取决于它所在目录的set-group ID bit是否被设置，如果被设置了，新文件的ID就是它所在目录的GID，否则就是进程的effective GID。</p>
<h2 id="access和faccessat"><code>access</code>和<code>faccessat</code></h2>
<p>使用<code>open</code>函数打开文件时，内核使用进程的effective UID和effective GID检测它对文件的访问权限。<br>
<code>acess</code>使用进程的real UID和real GID进行权限访问测试。访问权限测试步骤和之前介绍的四步一样，只不过使用real UID和real GID代替了effective UID和effective GID。</p>
<h3 id="函数原型-v2">函数原型</h3>
<p><code>access</code>和<code>faccessat</code>的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">access</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">faccessat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="参数和区别">参数和区别</h3>
<ol>
<li><code>mode</code>可选参数有，<code>F_OK</code>，<code>R_OK</code>, <code>W_OK</code>,<code>X_OK</code>，其中<code>F_OK</code>表示测试这个文件是否存在。</li>
<li><code>faccessat</code>和<code>access</code>在两种情况下相同，<code>dirfd</code>设置为<code>AT_FDCWD</code>且<code>pathname</code>四相对路径和<code>pathname</code>是绝对路径。否则的话，<code>faccessat</code>就是测试相对于<code>dirfd</code>指向的打开目录下的<code>pathname</code>的权限。</li>
<li>如果<code>flags</code>设置为<code>AT_EACCESS</code>的话，权限访问检测使用的是effective UID和effective GID而不是real UID和real GID。</li>
</ol>
<h2 id="函数umask">函数<code>umask</code></h2>
<p>前面介绍了和文件相关的9个访问权限位，在此基础上可以使用和每个进程相关的file mode创建mask。<code>umask</code>函数为进程设置mask，原型如下：</p>
<h3 id="函数原型-v3">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">mode_t</span> umask(<span class="keyword">mode_t</span> cmask);</span><br></pre></td></tr></table></figure>
<h3 id="特点">特点</h3>
<ol>
<li>这个函数的作用是去掉<code>cmask</code>中指定的权限，返回之前的mode。</li>
<li><strong>在程序中创建新文件时，如果想要确保指定的访问限权激活，必须在进程运行时修改<code>umask</code>的值。否则，<code>umask</code>可能会覆盖掉我们创建文件时指定的权限位。</strong></li>
<li>shell中有内置的<code>umask</code>命令，SUS要求shell的<code>umask</code>除了支持八进制的拒绝权限外，还要支持符号格式的指定许可的权限。使用<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umask -S</span><br></pre></td></tr></table></figure></li>
</ol>
<p>查看。</p>
<h2 id="函数chmod-fchmod和fchmodat">函数<code>chmod</code>, <code>fchmod</code>和<code>fchmodat</code></h2>
<p>文件的访问权限可以使用<code>chmod</code>, <code>fchmod</code>和<code>fchmodat</code>进行修改，它们的原型如下：</p>
<h4 id="原型">原型</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chmod</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmod</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchmodat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="特点-v2">特点</h3>
<ol>
<li><code>chmod</code>在指定的文件上进行操作</li>
<li><code>fchmod</code>是对已经打开的文件文件描述符进行操作。</li>
<li><code>fchmodat</code>和<code>chmod</code>在两种情况下是相等的，当<code>pathname</code>是绝对路径时，以及<code>dirfd</code>设置为<code>AT_FDCWD</code>且<code>pathname</code>是相对路径的时候。否则，<code>fchmodat</code>操作相对于打开目录的pathname。</li>
<li>当flags设置了<code>AT_SYMLINK_NOFLOLLW</code>时，不会follow符号链接。</li>
<li>在以下两种情况下，<code>chmod</code>函数自动清除两个权限位：</li>
</ol>
<ul>
<li>新创建文件的GID可能不是调用进程的effective GID。新文件的GID可能是父目录的GID。如果新文件的GID不等于进程的effective GID，而且进程没有root权限，set-group-id位会被自动关闭。</li>
<li>stick bit的设置</li>
</ul>
<h2 id="sticky-bit">sticky bit</h2>
<p><code>S_ISVTX</code>较老版本的UNIX叫做表示stick bit，而新版UNIX叫做saved-text bit，这也是<code>S_ISVTX</code>名字的由来。这一位的作用是，当一个可执行文件的这一位被设置了，当该程序第一次被执行，在它终止时，程序正文部分的一个副本，即机器指令，仍然保存在交换区中，这使得下次执行该程序时能较快的载入内存。因为通常的UNIX文件系统中，文件的数据块都是随机存放的，相对来说，交换区被当做一个连续文件来处理。而现在的UNIX系统都使用了虚拟存储系统和快速文件系统，已经不需要这种技术了。<br>
现在系统扩展了stick bit的使用，SUS允许对目录设置目录的stick bit，如果一个目录设置了stick bit，只有对该目录具有写权限的用户并且满足下列条件之一，才能删除或者重命名该目录下的文件：</p>
<ol>
<li>拥有该文件</li>
<li>拥有此目录</li>
<li>是root用户</li>
</ol>
<p>比如/tmp目录，设置了stick bit，任何用户都可以在这个目录下创建文件。任意用户,组和其它对这两个目录的权限都是读写和执行。但是用户不能删除和重命名属于其他人的文件。</p>
<h2 id="函数chown-fchown-chownat和lchown">函数<code>chown</code>, <code>fchown</code>,<code>chownat</code>和<code>lchown</code></h2>
<p>可以使用<code>chown</code>, <code>fchown</code>,<code>chownat</code>和<code>lchown</code>更改文件的UID和GID。它们的原型如下：</p>
<h3 id="函数原型-v4">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchown</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lchown</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fchownat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">uid_t</span> owner, <span class="keyword">gid_t</span> group, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="特点-v3">特点</h3>
<ol>
<li>当文件不是符号链接时，所有的函数操作类似。</li>
<li>当文件是符号链接时，<code>lchown</code>和设置了<code>AT_SYMLINK_NOFOLLOW</code>标志的<code>fchownat</code>都修改的是符号链接本身，而不是它链接的对象。</li>
<li><code>fchown</code>操作的是<code>fd</code>指向的已经打开的文件，因为它在一个已经打开的文件上操作，所以它不能修改符号链接本身。</li>
<li><code>fchownat</code>和<code>fchown</code>或者<code>lchown</code>在下面两种情况下是等价的：当pathname是决定路径或者<code>dirfd</code>设置为<code>AT_FDCWD</code>时且pathname是相对路径时。在这两种情况下，如果<code>flags</code>设置了<code>AT_SYMLINK_NOFOLLOW</code>标志，<code>fchownat</code>和<code>lchown</code>一样，否则<code>fchownat</code>和<code>fchown</code>一样。如果不是这两种情况，<code>fchowat</code>是操作相对于打开目录的pathname。</li>
<li>根据<code>_POSIX_CHOWN_RESTRICTED</code>常量的值，可以查询是否只有超级用户才能更改文件的所有者，如果这个常量对指定的文件有效，那么
<ul>
<li>只有root进程才能更新该文件的UID，普通用户不能修改其他用户文件的UID</li>
<li>如果进程拥有此文件(进程的effective UID等于文件的UID)， 可以更改这些文件的GID，但是只能更改到进程的effective GID或者继承的附属组ID之一。</li>
</ul>
</li>
<li>如果这些函数由非root进程调用，在成功返回时，set UID和set GID位都会被清楚。</li>
</ol>
<h2 id="文件长度">文件长度</h2>
<p><code>struct stat</code>中的<code>st_size</code>以字节为单位表示文件的长度。这个字段只对普通文件，目录文件和符号链接有意义。<br>
对于普通文件，它的长度可以是0，在开始读这种文件时，得到EOF标志。<br>
对于目录，文件长度通常是一个数的整数倍。<br>
对于符号链接，文件长度是链接指向的文件名的实际字节数，不包含null字节。<br>
对于现在的大多数UNIX系统，提供了<code>st_blksize</code>和<code>st_blocks</code>字段。<code>st_blksize</code>表示对文件I/O适合的块长度，第二个是所分配的固定大小的block数量。</p>
<h3 id="文件中的hole">文件中的hole</h3>
<ol>
<li>普通文件可以有hole，hole是当前文件偏移量超过文件尾端，然后进行写入造成的。</li>
<li>对于同样长度的有空洞和没有空洞的文件来说，它们所占用的blocks块数是不同的。这里说的同样长度指的是字节数，使用<code>ls -l</code>列出来的长度，那些空洞不占用磁盘上的存储区。</li>
<li>使用<code>cat</code>进行复制时，会将空洞使用0字节填满。</li>
<li>使用<code>du -s file.txt</code>可以查看文件所占用的blocks数量，这些blocks中还有一些用来存放指向实际数据块的指针。</li>
</ol>
<h2 id="文件截断">文件截断</h2>
<p>函数原型是：</p>
<h3 id="函数原型-v5">函数原型</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="特点-v4">特点</h3>
<ol>
<li>当<code>length</code>长度小于原来文件的长度时，超过<code>length</code>的进行截断。</li>
<li>当<code>length</code>长度大于原来文件的长度时，原来的文件长度到<code>length</code>之间的数据被读作0。</li>
</ol>
<h2 id="文件系统">文件系统</h2>
<h2 id="函数link-linkat-unlink-unlinkat和remove">函数<code>link</code>, <code>linkat</code>, <code>unlink</code>, <code>unlinkat</code>和<code>remove</code></h2>
<h2 id="函数rename和renameat">函数<code>rename</code>和<code>renameat</code></h2>
<h2 id="符号连接">符号连接</h2>
<h2 id="创建和读取符号链接">创建和读取符号链接</h2>
<h2 id="文件的时间">文件的时间</h2>
<h2 id="函数futimens-utimensat和utimes">函数<code>futimens</code>, <code>utimensat</code>和<code>utimes</code></h2>
<h2 id="函数mkdir-mkdirat和rmdir">函数<code>mkdir</code>，<code>mkdirat</code>和<code>rmdir</code></h2>
<h2 id="读目录">读目录</h2>
<h2 id="函数chdir-fchdir和getcwd">函数<code>chdir</code>, <code>fchdir</code>和<code>getcwd</code></h2>
<p>每一个进程都有一个当前工作目录，**当前工作目录是进程的一个属性，**这个目录是搜索所有相对路径名的起点，不以&quot;/&quot;开始的路径名都是相对路径名。可以使用<code>chdir</code>后者<code>fchdir</code>改变当前进程的工作目录。它们的原型如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line"></span><br><span class="line">int chdir(const char *path);</span><br><span class="line">int fchdir(int fd);</span><br><span class="line"></span><br><span class="line">char *getcwd(char *buf, size_t size);</span><br></pre></td></tr></table></figure></p>
<p><code>chdir</code>的参数是<code>path</code>，而<code>fchidir</code>的参数是文件描述符。</p>
<h3 id="chdir只会改变当前进程的work-dir"><code>chdir</code>只会改变当前进程的work dir</h3>
<p>**需要注意的一点是，<code>chdir</code>和<code>fchdir</code>只改变调用这个函数本身的进程，并不影响其他进程。**比如在shell中运行一个程序，在这个程序中更改了进程的当前工作目录，结束这个程序的执行时，shell的当前工作目录并不会改变，因为shell和我们刚才执行的程序属于两个不同的进程。因此，如果要改变shell进程自己的工作目录，应该使用shell直接调用<code>chdir</code>函数，所以<code>cd</code>命令内建在shell中。<br>
<code>getcwd</code>是获得进程当前工作的绝对路径名。内核并不保存目录的完整路径名（linux除外），为了获得进程当前工作的绝对路径名。<code>getcwd</code>需要从当前工作目录开始，找到它的上一级目录，读取目录项，找到和工作目录i节点编号相同的目录项，得到对应的文件名。就这样一层一层的向上找，这就找到了绝对路径名。<code>getcwd</code>会follow符号链接，但是不会知道它是由哪里链接到这里的。</p>
<h3 id="getcwd的使用场景"><code>getcwd</code>的使用场景</h3>
<p>当一个应用程序需要在经过一些列目录操作之后返回它刚开始的工作目录时。可以先使用<code>getcwd</code>获得最开始的工作目录，保存起来，最后再使用<code>chdir</code>进行恢复。<br>
<code>fchdir</code>可以有更简单的操作，在刚开始时，保存目录的文件描述符。最后使用<code>fchdir</code>直接打开这个文件描述符。</p>
<h2 id="设备特殊文件">设备特殊文件</h2>
<p>这一小节主要介绍<code>st_dev</code>和<code>st_rdev</code>字段。</p>
<ol>
<li>每个文件系统所在的存储设备都由其主次设备号表示。设备号所用的数据类型是基本系统数据类型<code>dev_t</code>。主设备号标识设备驱动程序，次设备号标识特定的子设备。一个磁盘驱动器通常可以包含多个文件系统，同一个磁盘上的文件系统通常具有相同的主设备号，但是次设备号却不同。</li>
<li>每个文件名中的<code>st_dev</code>是存放该文件名和其对应i节点的文件系统的设备号。</li>
<li>可以使用两个宏<code>major</code>和<code>minor</code>访问主，次设备号，它们的参数都是<code>st_dev</code>。POSIX.1说明<code>dev_t</code>类型存在，但是没有定义它是什么，具体取值与实现相关。</li>
<li>只有字符特殊文件和块特殊文件才有<code>st_rdev</code>值，同样使用<code>major</code>和<code>minor</code>两个宏访问相应的主次设备号。</li>
<li>块特殊文件是包含随机访问文件系统的设备，比如硬盘驱动器，软盘驱动器和CD-ROM以及磁带等。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://unix.stackexchange.com/questions/21251/execute-vs-read-bit-how-do-directory-permissions-in-linux-work" target="_blank" rel="noopener">https://unix.stackexchange.com/questions/21251/execute-vs-read-bit-how-do-directory-permissions-in-linux-work</a><br>
3.<a href="https://superuser.com/questions/168578/why-must-a-folder-be-executable/168583" target="_blank" rel="noopener">https://superuser.com/questions/168578/why-must-a-folder-be-executable/168583</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/20/data-structure-bineary-search-trees-vs-binary-heaps/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/20/data-structure-bineary-search-trees-vs-binary-heaps/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">data structure bineary search trees vs binary heaps</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-20 09:37:58 / 修改时间：10:05:05" itemprop="dateCreated datePublished" datetime="2019-11-20T09:37:58+08:00">2019-11-20</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/数据结构/" itemprop="url" rel="index"><span itemprop="name">数据结构</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/6147242/heap-vs-binary-search-tree-bst" target="_blank" rel="noopener">https://stackoverflow.com/questions/6147242/heap-vs-binary-search-tree-bst</a><br>
2.<a href="https://cs.stackexchange.com/questions/27860/whats-the-difference-between-a-binary-search-tree-and-a-binary-heap" target="_blank" rel="noopener">https://cs.stackexchange.com/questions/27860/whats-the-difference-between-a-binary-search-tree-and-a-binary-heap</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/18/UNIX-file-I-O/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/18/UNIX-file-I-O/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">UNIX file I/O</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 19:19:20" itemprop="dateCreated datePublished" datetime="2019-11-18T19:19:20+08:00">2019-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-21 10:33:47" itemprop="dateModified" datetime="2019-11-21T10:33:47+08:00">2019-11-21</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="注意事项">注意事项</h2>
<ol>
<li><code>creat</code>以只写方式打开文件，不能进行读操作。</li>
<li>为什么有了<code>open</code>要有<code>creat</code>，早期的<code>open</code>只支持0,1,2三个flag，不能打开不存在的文件，需要有单独的系统调用创建文件。而有了新的<code>open</code>以后就不需要<code>creat</code>了。</li>
<li><code>open</code>和<code>dup</code>返回的文件描述符一定是最小的未使用的文件描述符。</li>
<li>以<code>O_APPEND</code>打开的文件，如果进行<code>write</code>的话，即使使用<code>lseek</code>定位到非文件结尾处，最后也是在文件结尾处进行写。因为使用<code>O_APPEND</code>的<code>write</code>是由两个系统调用函数<code>lseek</code>和“普通的”<code>write</code>构成的一个操作。而<code>read</code>操作可以使用<code>lseek</code>进行定位。</li>
<li>所有的磁盘I/O都要经过内核的block buffers块缓存区，也称为内核的(buffer cache)缓冲区高速缓存。有一个例外就是对原始磁盘设备的I/O，先不考虑这种情况。<code>read</code>和<code>write</code>的数据都要被内核进行缓冲，术语unbuffered I/O指的是在用户的进程中不会对这两个函数进行自动缓冲，每次<code>read</code>和<code>write</code>都会进行一次系统调用。</li>
</ol>
<h2 id="文件i-o">文件I/O</h2>
<p>UNIX系统中的大多数文件I/O只用到了5个函数：<code>open</code>,<code>read</code>,<code>write</code>, <code>lseek</code>和<code>close</code>。不同的缓冲长度对<code>read</code>和<code>write</code>的速度影响。<br>
本章介绍的函数通常被称为不带缓冲的I/O，不带缓冲的I/O指的是每个<code>read</code>和<code>write</code>都调用内核中的一个系统调用，它们不是ISO C的组成部分，但是，它们都是POSIX.1和SUS的组成部分。<br>
只要涉及在多个进程之间共享资源，原子操作的概念就非常重要。本章还进行一步讨论在多个进程之间如何共享文件，以及所涉及的内核有关数据结构。相应的函数有：<code>dup</code>, <code>fcntl</code>,<code>sync</code>, <code>fsync</code>和<code>ioctl</code>等。</p>
<h2 id="文件描述符">文件描述符</h2>
<p>对于内核而言，所有打开的文件都是通过文件描述符引用。文件描述符是一个非负整数。当打开或者创建一个新文件时，内核向进程返回一个文件描述符。当读，写一个文件时，使用<code>open</code>或者<code>creat</code>返回的文件描述符标识该文件，将其作为参数传递给<code>read</code>或者<code>write</code>。<br>
UNIX系统shell把文件描述符0和进程的标准输入关联，文件描述符1和标准输出关联，文件描述符2和标准错误关联。为了提高系统的可读性，通常把它们换成符号常量<code>STDIN_FILENO</code>,<code>STDOUT_FILENO</code>和<code>STDERR_FILENO</code>，它们都在头文件<code>&lt;unistd.h&gt;</code>中定义。<br>
文件描述符的变化范围是0到<code>OPEN_MAX-1</code>，早起的UNIX系统实现采用的上限值是19，现在的很多系统将它增加到63。（对于Linux, FreeBSD等的很多版本，文件描述符的变化范围几乎是无限的，只受到硬件资源的约束）</p>
<h2 id="open-openat和creat-close"><code>open</code>,<code>openat</code>和<code>creat</code>, <code>close</code></h2>
<p>函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">openat</span><span class="params">(<span class="keyword">int</span> dirfd, <span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>参数<code>pathname</code>是路径名，可以是相对路径也可以是绝对路径，<code>flags</code>的选项有很多，它们定义在<code>&lt;fcntl.h&gt;</code>头文件中。flag参数必须在<code>O_RDONLY</code>,<code>O_WRONLY</code>和<code>O_RDWR</code>之中选且只能选一个。然后还有很多其他的可选flag，常见的有：<code>O_APPEND</code>，<code>O_CREAT</code>，<code>O_EXCL</code>, <code>O_DIRECTORY</code>等，使用<code>man 2 open</code>就可以查看。</p>
<h3 id="openat-vs-open"><code>openat</code> vs <code>open</code></h3>
<p><code>open</code>和<code>openat</code>返回的一定是最小的没有使用的文件描述符。可以利用这一点可以在标准输入，标准输出，或者标准错误上打开新的文件。一个应用程序可以先关闭标准输出，然后打开另一个文件，执行打开操作前就能了解到该文件一定会在文件描述符1上打开。<br>
<code>dirfd</code>参数是<code>open</code>和<code>openat</code>的区别，它们之间的关系有以下三种：</p>
<ol>
<li><code>pathname</code>指定的是绝对路径名，<code>dirfd</code>参数被忽略，<code>open</code>和<code>openat</code>一样。</li>
<li><code>pathname</code>指定的是相对路径名，<code>dirfd</code>制定了相对路径名在文件系统中的开始地址，<code>dirfd</code>参数通过打开相对路径名的目录来获取。</li>
<li><code>pathname</code>指定了相对路径名，<code>dirfd</code>的参数是特殊值<code>AT_FDCWD</code>，这种情况下，路径名是在当前工作目录中获取，<code>openat</code>和<code>open</code>在操作上类似。</li>
</ol>
<h3 id="openat作用"><code>openat</code>作用</h3>
<p>为什么增加<code>openat</code>函数，它的目的是解决两个问题：</p>
<ol>
<li>让线程可以使用相对路径名打开目录中的文件，而不再只能打开当前工作目录。同一进程中的所有线程共享相同的当前工作目录。</li>
<li>避免time-of-check-to-time-of-use错误。它的基本思想是，如果有两个基于文件的系统调用，第二个调用的结果依赖于第一个调用的结果，那么程序是脆弱的。因为两个调用并不是原子操作，在两个函数调用之间，文件可能改变了，这就造成了第一个调用的结果不再有效，使得程序的最终结果是错误的。</li>
</ol>
<h3 id="文件名和路径名过长">文件名和路径名过长</h3>
<p>当文件名和路径名过长时，是截断为系统允许的最长量还是返回出错信息？这个是由系统的历史形成的。通常BSD和Linux总是会返回出错，而System V和Solaris等不一定。<br>
具体的可以根据POSIX.1定义的常量<code>_POSIX_NO_TRUC</code>决定是截断还是出错。根据文件系统的类型，这个值可以变换。可以使用<code>fpathconf</code>或者<code>pathconf</code>查询目录具体支持哪种行为。<br>
如果<code>_POSIX_NO_TRUC</code>有效，当路径名超过<code>PATH_MAX</code>或者路径名中的任一文件名超过<code>NAME_MAX</code>时，返回出错，并将<code>errno</code>设置为<code>ENAMETOOLONG</code>。</p>
<h3 id="create和open"><code>create</code>和<code>open</code></h3>
<p><code>create</code>其实相当于指定了<code>open</code>的flags为<code>O_WRONLY|O_CREAT|O_TRUNC</code>。<br>
为什么有了<code>open</code>还要有<code>creat</code>，在早期的UNIX版本中，<code>flags</code>只能为0,1或者2。无法打开一个不存在的文件。因此需要另一个系统调用<code>creat</code>创建新文件。现在的<code>open</code>系统调用提供了<code>O_CREAT</code>和<code>O_TRUNC</code>选项，也就不需要<code>creat</code>了。</p>
<p><code>creat</code>的不足：<code>creat</code>以<strong>只写方式</strong>打开所创建的文件，即创建新文件之后，只能对新文件进行写操作，不能进行读操作。如果要创建一个临时文件，先写文件，然后再读文件。在<code>open</code>的老版本时，即不能打开不存在的文件时，需要先使用<code>creat</code>创建新文件，然后关闭该文件，然后使用<code>open</code>读文件。现在的话，可以使用以下方式实现创建新文件并进行读写：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(path, O_RDWR|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
<h3 id="close"><code>close</code></h3>
<p>调用<code>close</code>关闭一个已经打开的文件。函数原型：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="创建文件">创建文件</h3>
<ol>
<li>
<p>创建一个只写文件（如果文件存在，将文件清零）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">creat(filename, mode);</span><br><span class="line">open(filename, O_WRONLY|O_CREAT|O_TRUNC, mode);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>创建一个读写文件（如果文件存在，将文件清零）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_RDWR|O_CREAT|O_TRUNC);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>检测并创建一个只写文件（ 如果文件存在，错处，返回-1）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_WRONLY|O_CREAT|O_EXCL, mode);</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>检测并创建一个读写文件（ 如果文件存在，错处，返回-1）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open(filename, O_RDWR|O_CREAT|O_EXCL, mode);</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<h2 id="lseek-read-write"><code>lseek</code>, <code>read</code>, <code>write</code></h2>
<p>它们的原型如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence);</span><br><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<h3 id="当前文件偏移量">当前文件偏移量</h3>
<ol>
<li>每一个打开文件都有一个和它相关联的当前文件偏移量(current file offset)。它通常是一个非负整数，用来度量从文件开始处的字节数。</li>
<li>通常情况下，读写操作都是从current file offset开始的，并且使偏移量增加读写的字节数。</li>
<li>除了指定<code>O_APPEND</code>选项外，打开一个文件时，默认的current file offset都是0。</li>
<li><code>whence</code>有三个取值，<code>SEEK_SET</code>, <code>SEEK_CUR</code>, <code>SEEK_END</code>。<code>lseek</code>成功执行，返回的offset等于<code>whence+offset</code>，对于<code>SEEK_CUR</code>和<code>SEEK_END</code>来说，参数<code>offset</code>可正可负，只要保证返回的current file offset非负即可。</li>
<li><code>lseek</code>中的<code>l</code>表示<code>long</code>。</li>
<li>current file offset可以大于文件长度，这种情况会在文件中构成一个空洞。空洞不要求占据磁盘上的存储区。</li>
</ol>
<h3 id="read"><code>read</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p><code>read</code>函数从文件描述符标示的文件中读取至多<code>count</code>个字节到<code>buf</code>指定的位置。如果操作成功的话，返回读到的字节数，如果已经到了文件结尾，返回0。出错的话，返回-1，设置errno。<br>
在以下几种情况下，读到的字节数可能少于<code>count</code>：</p>
<ol>
<li>读普通文件时，在读满<code>count</code>个之前就已经到了文件尾端。</li>
<li>某个信号造成中断时，而已经读取了部分数据时。</li>
<li>从终端设备读时，通常一次最多读一行。</li>
<li>从网络读时，网络中的缓冲机制。</li>
<li>从管道或者FIFO读取时，管道包含的字节数少于<code>count</code>。</li>
<li>从面向记录的设备读时，一次最多返回一个记录。</li>
<li>第二个参数<code>void*</code>表示通用指针。</li>
<li>返回值<code>ssize_t</code>是有符号类型，因为它需要返回正整数字节，0和-1。</li>
<li>第三个参数<code>size_t</code>是一个无符号类型。</li>
</ol>
<h3 id="write"><code>write</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ssize_t</span> write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>
<p>它的返回值通常和<code>count</code>一样，否则就是出错了。出错的常量原因有：</p>
<ol>
<li>磁盘满了，</li>
<li>超过了一个给定进程的文件长度限制。</li>
<li>如果<code>lseek</code>返回的当前文件偏移量不在文件结尾，<code>write</code>会覆盖掉相应位置的数据。</li>
</ol>
<p>对于普通文件，写操作从文件的当前偏移量开始，如果打开文件时指定了<code>O_APPEND</code>选项，那么文件偏移量设置在文件结尾处。在一次写成功之后，文件偏移量增加实际写的字节数。</p>
<h3 id="创建含有空洞的文件">创建含有空洞的文件</h3>
<p>如下所示代码，创建一个含有空洞的文件：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">```</span><br><span class="line"></span><br><span class="line">## I/O的效率</span><br><span class="line">进程终止时，UNIX系统内核会关闭所有打开的文件描述符，但是并不会关闭标准输入和输出。</span><br><span class="line">在选取`read`和`write`的buffer大小时，也有一定技巧。大多数文件系统都使用了预读(read ahead)技术。当进行顺序读取时，系统试图读入比应用所要求的更多数据，并且假设应用很快就会读这些数据。</span><br><span class="line">在使用`ext4`文件系统时，它的磁盘块长度是<span class="number">4096</span>，所以当BUFFER大于等于<span class="number">4096</span>时，读写时间几乎不变。</span><br><span class="line"></span><br><span class="line">## 文件共享</span><br><span class="line"></span><br><span class="line">### I/O数据结构</span><br><span class="line">UNIX支持在不同进程之间共享打开文件。这需要使用到内核用于I/O的数据结构。内核使用三种数据结构表示打开文件：进程表记录项，文件表项和节点表项。</span><br><span class="line"><span class="number">1.</span> 进程表记录项。每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表，每隔描述符占用一项，其中内容有：文件描述符标志和指向文件表项的指针。</span><br><span class="line"><span class="number">2.</span> 文件表项。内核为所有打开文件维持一张文件表。每个表项包含：文件状态标志，当前文件偏移量和指向该文件节点表项的指针</span><br><span class="line"><span class="number">3.</span> 节点表项。每个打开设备都有一个节点结构。包含文件的所有者，文件长度，指向文件实际数据块在磁盘上所在的指针等。</span><br><span class="line"></span><br><span class="line">如果两个进程打开了同一个文件，每个进程都会获得各自相应文件的一个文件表项，这两个文件表项中的节点表项指针指向同一个节点表项。也有可能多个进程的文件描述符指向同一个文件表项。</span><br><span class="line">自己的总结，每一个文件都有一个节点表项，记录文件长度和数据存储地址，而文件表项记录的是在节点表项的哪个位置进行什么操作，进程表记录项记录了每个进程打开了几个文件，每个文件的文件表项在哪里。</span><br><span class="line"></span><br><span class="line">### `write`和`lseek`对当前文件偏移量的影响</span><br><span class="line"><span class="number">1.</span> `write`在写入完成后，在文件表项的当前文件偏移量上加上写入的字节数，如果当前文件偏移量超过了当前文件长度，更新节点表项中的文件长度，相当于文件长度增加了。</span><br><span class="line"><span class="number">2.</span> `lseek`只修改文件表项中的当前文件偏移量，不进行任何I/O操作。</span><br><span class="line"><span class="number">3.</span> `lseel`定位到文件尾端的时候，文件表项中当前文件偏移量被设置为节点表项中的当前文件长度。</span><br><span class="line"><span class="number">4.</span> 使用`O_APPEND`打开文件的时候，文件表项中的文件状态标志也会被修改，对于使用`O_APPEND`操作打开的文件，进行`write`操作相当于先将当前文件偏移量设置为节点表项中的文件长度，然后再`write`，即使先使用`lseek`将当前文件偏移量设置为`SEEK_SET`也不行，也是进行追加。所以在每次append之前不用先进行`lseek`，`lseek`了也白做。但是`read`可以使用`lseek`正常进行。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 原子操作</span><br><span class="line">如果一个操作是原子操作，那么这个操作的所有步骤要么不执行，要不全部执行。</span><br><span class="line"></span><br><span class="line">### 追加文件</span><br><span class="line">指定`open`的`O_APPEND`选项实现追加操作，```c</span><br><span class="line">fileno=open(filename, O_RDWR|O_APPEND);</span><br><span class="line">write(file, buf, BUFSIZE);</span><br></pre></td></tr></table></figure></p>
<p>追加文件是一个原子操作，如果不是原子操作的话，就相当于：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fileno = open(filename, O_RDWR);</span><br><span class="line">lseek(fileno, <span class="number">0</span>, SEEK_END);</span><br><span class="line">write(fileno, buf, BUFSIZE);</span><br></pre></td></tr></table></figure></p>
<p>如果是单进程，上面两段代码是等价的，但是如果是多进程的话，下面代码就可能会出错。进程A lseek，进程B lseek，进程A write，进程B write。进程B的操作会覆盖进程A的操作。<br>
所以这也就解释了使用选项<code>O_APPEND</code>后的操作，因为这个append的<code>write</code>是由两个系统调用组成的原子操作，先<code>lseek</code>，再普通的<code>write</code>。所以在调用<code>write</code>之前不用<code>lseek</code>，就算你<code>lseek</code>了也是白<code>lseek</code>。</p>
<h3 id="读写原子操作">读写原子操作</h3>
<p>读写的原子操作原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> pread(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br><span class="line"><span class="keyword">ssize_t</span> pwrite(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count, <span class="keyword">off_t</span> offset);</span><br></pre></td></tr></table></figure></p>
<p>调用<code>pread</code>相当于调用<code>lseek</code>和<code>read</code>的原子操作，但是<code>pread</code>不改变当前文件偏移量。<br>
调用<code>write</code>相当于调用<code>lseek</code>和<code>write</code>的原子操作，但是<code>pwrite</code>不改变当前文件偏移量。</p>
<h3 id="创建文件原子操作">创建文件原子操作</h3>
<p>检查文件是否存在和创建文件是一个原子操作。如果这个操作不是原子操作，比如说是由<code>open</code>和<code>creat</code>两个函数调用组成的一个操作，它们不是一个原子操作。当前进程确定一个文件不存在，决定创建该文件。在<code>open</code>和<code>creat</code>调用之间，另一个进程创建了这个文件，并写入了数据。当前进程会再次创建这个文件，覆盖掉另一个进程写入的数据。</p>
<h2 id="dup和dup2复制文件描述符"><code>dup</code>和<code>dup2</code>复制文件描述符</h2>
<p>UNIX系统提供了两个原子操作<code>dup</code>和<code>dup2</code>对一个指定的文件描述符进行复制。如果得到的新文件描述符和fd不同，那么这两个文件描述符共享同一个文件表项。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// dup返回的文件描述符一定是当前可用文件描述符中的最小值。和open一个文件类似。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过fd2指定返回的新的文件描述符。</span></span><br><span class="line"><span class="comment">// 如果fd2和fd相等，返回fd2</span></span><br><span class="line"><span class="comment">// 如果fd2和fd不等，关闭fd2，然后返回fd2。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(inf fd, <span class="keyword">int</span> fd2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>非原子操作的文件描述符复制可以通过<code>fcntl</code>实现。</p>
<h2 id="sync-fsync和fdatasync"><code>sync</code>,<code>fsync</code>和<code>fdatasync</code></h2>
<p>UNIX系统在内核中设置了缓冲区高速缓存或者页高速缓存，大多数磁盘的I/O都通过缓冲区进行。当我们向文件写入数据时，内核通常先将数据复制到缓冲区中，然后排入队列，晚些写入磁盘，这方方式叫做<strong>延迟写</strong>。<br>
等到内核需要使用缓冲区存放其他磁盘块数据时，它会把所有延迟写数据写入磁盘。为了保证磁盘上实际文件系统和缓冲区中内容的一致性，UNIX提供了三个函数，它们的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.将所有修改过的块缓冲区排入队列，然后就返回，并不等待实际写磁盘操作结束。</span></span><br><span class="line"><span class="comment">// 通常情况下，update系统守护进程一般每隔30秒调用一次`sync`函数，这就保证了定期将内核块缓冲区的内容写入磁盘。命令sync(1)也会调用`sync`函数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sync</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.只对文件描述符`fd`指定的一个文件起作用，等到写磁盘操作结束才返回。更新文件的数据和属性。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.只对文件描述符`fd`指定的一个文件起作用，等到写磁盘操作结束才返回。只更新文件的数据。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fdatasync</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="fcntl"><code>fcntl</code></h2>
<p>fcntl是文件控制函数，它的原型如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>fcntl有很多种功能，这一节先介绍以下五种：</p>
<ol>
<li>复制一个已有的描述符，设置<code>cmd</code>为<code>F_DUPFD</code>或者<code>F_DUPFD_CLOEXEC</code>。</li>
<li>获取和设置文件描述符标志，设置<code>cmd</code>为<code>F_GETFD</code>或者<code>F_SETFD</code>。当前只有一个文件描述符标志，就是<code>FD_CLOEXEC</code>。</li>
<li>获取和设置文件状态标志，设置<code>cmd</code>为<code>F_GETFL</code>或者<code>F_SETFL</code>。<br>
获取文件状态标志时，介绍<code>open</code>时给出了许多文件状态标志。对于五个互斥的权限，需使用<code>O_ACCMODE</code>取得访问方式位，然后与相应的权限比对。对于其他的权限，将返回值和相应的标志进行与操作，判断是否设置了相应位。<br>
设置文件状态标志位时，可以更改的几个权限有，<code>O_APPEND</code>,<code>O_NONBLOCK</code>,<code>O_SYNC</code>,<code>O_DSYNC</code>,<code>O_RSYNC</code>, <code>O_FSYNC</code>, <code>O_ASYNC</code>。</li>
<li>获取和设置异步I/O所有权，设置<code>cmd</code>为<code>F_GETOWN</code>或者<code>F_SETOWN</code>。</li>
<li>获取和设置记录锁，设置<code>cmd</code>为<code>F_GETLK</code>，或者<code>F_SETLK</code>或者<code>F_SETLKW</code>。</li>
</ol>
<p>在修改文件描述符标志或者文件状态标志时，必须要先获得现在的标志值，然后对它进行修改，获得新的标志值，然后进行设置。不能单单设置一个标志值，否则会关闭以前设置的标志位。</p>
<h2 id="ioctl"><code>ioctl</code></h2>
<p>这个有点看不懂。</p>
<h2 id="dev-fd"><code>/dev/fd</code></h2>
<p>UNIX提供了<code>/dev/fd</code>目录，其中包含了名为0, 1, 2的文件。打开<code>/dev/fd/0</code>,<code>/dev/fd/1</code>, <code>/dev/fd/2</code>相当于复制描述符n。即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/df/0"</span>, mode);</span><br><span class="line">fd = dup(<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p>
<p>上述两行代码是相等的。文件描述符0和fd共享同一个文件表项。在Linux中，文件描述符被映射成指向底层物理文件的符号链接。比如打开<code>/dev/fd/0</code>时，实际上打开的是与标准输入关联的文件。返回的新文件描述符的mode和<code>/dev/fd</code>文件描述符的mode并不相关。所以，即使我们使用<code>O_RDWR</code> mode打开<code>/dev/fd/0</code>，也不能对<code>fd</code>进行写操作。<br>
Linux下提供了<code>/dev/stdin</code>，<code>/dev/stdout</code>, <code>/dev/stderr</code>，它们和<code>/dev/fd/0</code>等都是一样的。在shell中，可以使用dev/fd作为参数，把标准输入和输出当做一个文件，可以像处理其他文件一样进行操作。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/18/how-C-program-works/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/18/how-C-program-works/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">How C program works</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-18 14:27:10" itemprop="dateCreated datePublished" datetime="2019-11-18T14:27:10+08:00">2019-11-18</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-19 22:36:20" itemprop="dateModified" datetime="2019-11-19T22:36:20+08:00">2019-11-19</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="none"></h2>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://mapan1984.github.io/program/2018/03/10/C-%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E4%B8%8E%E5%BA%93%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%9C%E7%94%A8/#c%E8%AF%AD%E8%A8%80%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener">https://mapan1984.github.io/program/2018/03/10/C-编译过程与库文件的作用/#c语言编译过程</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/14/C-CPP-lvalue-and-rvalue/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/14/C-CPP-lvalue-and-rvalue/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C and C++ lvalue and rvalue</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-14 17:22:02" itemprop="dateCreated datePublished" datetime="2019-11-14T17:22:02+08:00">2019-11-14</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-17 20:19:24" itemprop="dateModified" datetime="2019-11-17T20:19:24+08:00">2019-11-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="对象-object-和值-value">对象(object)和值(value)</h2>
<h3 id="c11标准">C11标准</h3>
<p>C11标准的定义如下([14]3.15, 3.19)：</p>
<blockquote>
<p>3.15 object<br>
region of data storage in the execution environment, the contents of which can represent values<br>
NOTE When referenced, an object may be interpreted as having a particular type; see 6.3.2.1.<br>
3.19 value<br>
precise meaning of the contents of an object when interpreted as having a specific type</p>
</blockquote>
<p>object是一块内存空间，它的内容可以表示值。当被使用时，一个对象可以解释为一种特定的类型。value是以具体类型解析object中的内容。</p>
<h3 id="c-11标准">C++11标准</h3>
<p>C++11标准的定义如下([17]1.8)：</p>
<blockquote>
<p>An object is a region of storage. [ Note: A function is not an object, regardless of whether or not it occupies storage in the way that objects do. — end note ]<br>
An object can have a name.<br>
An object has a storage duration which influences its lifetime.<br>
An object has a type.<br>
The term object type refers to the type with which the object is created.</p>
</blockquote>
<p>C++ 中的obejct也是一个内存空间。object可以有名字，可以有类型（内置类型还是复合类型都行），有一个duration。也就是C++ Primer第五版中说的对象是具有某种数据类型的内存空间，可以有名，可以没有名字。</p>
<h2 id="c语言中的lvalue和rvalue">C语言中的lvalue和rvalue</h2>
<h3 id="左值和右值的定义">左值和右值的定义</h3>
<p>首先看一下标准中的定义：<br>
C11中左值的定义：</p>
<blockquote>
<p>An lvalue is an expression (with an object type other than void) that potentially designates an object;64) if an lvalue does not designate an object when it is evaluated, the behavior is undefined. When an object is said to have a particular type, the type is specified by the lvalue used to designate the object. A modifiable lvalue is an lvalue that does not have array type, does not have an incomplete type, does not have a constqualified type, and if it is a structure or union, does not have any member (including, recursively, any member or element of all contained aggregates or unions) with a constqualified type.</p>
</blockquote>
<p>C++11中左值的定义([17]3.10)：</p>
<blockquote>
<p>An lvalue (so called, historically, because lvalues could appear on the left-hand side of an assignment expression) designates a function or an object. [Example: If E is an expression of pointer type, then *E is an lvalue expression referring to the object or function to which E points. As another example, the result of calling a function whose return type is an lvalue reference is an lvalue. — end example ]</p>
</blockquote>
<p>C中早期的定义：<br>
左值是一个表达式，可以出现在赋值操作的左边或者右边，而右值只能出现在左边。<br>
后来C标准和C++ 标准中定义的左值基本一样，可以总结为：<br>
左值指定了一个函数或者对象（变量）。它存放在内存中的某个位置，并且允许使用取值地址符<code>&amp;</code>获取这块内存的地址。如果<code>E</code>是指针类型的表达式，那么<code>*E</code>是<code>E</code>指向的函数或者对象的左值表达式。左值分为可修改左值和不可修改左值，像常量，数组名，等属于不可修改左值，而其它的左值都是可修改左值。如果一个表达式不是左值，那么它就被定义为右值。<br>
怎么样判断左值，满足以下两点中任何一点就是一个左值：</p>
<ol>
<li>是否有名字</li>
<li>是否能够取到它的地址</li>
</ol>
<p>C++ Primer中给出的一个方法：当一个对象被用作右值的时候，用的是对象的值。当一个对象被用作左值的时候，用的是对象在内存中的位置。<br>
示例</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = &amp;ch; <span class="comment">//ch可以当做左值，也可以当做右值</span></span><br><span class="line">&amp;ch = <span class="number">3</span>;  <span class="comment">//错误，因为&amp;ch我们只能取得它的值，并不能获取它在内存中的地址，即它只是一个右值，不能当做左值。</span></span><br></pre></td></tr></table></figure>
<p><strong>对象（变量）和指针变量中存放的内容（即地址）的区别，对象可以直接进行赋值。指针变量中存放的是一个地址，地址本身就是一个数字，是一个右值，不能对其进行赋值，对这个地址进行解引用，得到指针指向对象的左值表达式。</strong></p>
<h3 id="左值和右值的转换">左值和右值的转换</h3>
<h4 id="左值到右值的隐式类型转换-13">左值到右值的隐式类型转换[13]</h4>
<ol>
<li>C语言存在左值到右值的默认类型转换，当运算符需要右值操作对象时，而给出的是左值操作对象时，编译器会默认将左值转换成右值。</li>
<li>数组到指针的转换。在需要右值操作对象的时候，编译器换将数组名转换为其首元素的地址，类型为指向元素的指针。</li>
<li>函数到指针的转换。</li>
</ol>
<p>一般情况下，对象之间的运算，对象是以右值的形式参与的。比如<code>+</code>运算符需要两个右值运算数：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> c = a + b;</span><br></pre></td></tr></table></figure></p>
<p>在上面的例子中,<code>a</code>和<code>b</code>都是左值，在<code>int c = a+b;</code>中，它们经历了隐式的类型转换，将左值转换为了右值。<br>
除了数组，函数，不完整的类型，所有的左值都可以转换为右值，但是右值不能转换为左值。</p>
<h4 id="右值产生左值">右值产生左值</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a[<span class="number">0</span>]; <span class="comment">//a和&amp;a[0]都是数组首元素的值</span></span><br><span class="line">*(p+<span class="number">1</span>) = <span class="number">-1</span>;    <span class="comment">//p+1是右值，但是*(p+1)是左值</span></span><br></pre></td></tr></table></figure>
<h4 id="左值产生右值">左值产生右值</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> var = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;var;  <span class="comment">//var是左值，但是&amp;var是右值。</span></span><br></pre></td></tr></table></figure>
<p>单目运算符<code>&amp;</code>需要一个左值作为它的运算对象，当且仅当<code>n</code>是一个变量时，<code>&amp;n</code>是一个有效的表达式，<code>&amp;12</code>是错误的。</p>
<h3 id="可修改左值和不可修改左值">可修改左值和不可修改左值</h3>
<ol>
<li>
<p>左值指向的位置的内容，如果可以被修改，那么这个左值是一个可修改左值，否则就是不可修改左值。</p>
</li>
<li>
<p>如果一个表达式指向内存中的一个位置，并且它的类型是算术类型，<code>struct</code>，<code>union</code>或者pointer，那么它就是一个可修改左值。</p>
</li>
<li>
<p>可修改左值不能含有数组类型，不完整的类型，<code>const</code>修饰的类型，它们都是不可修改左值。如果<code>struct</code>或者<code>union</code>要是可修改左值，那么它们不能有<code>const</code>成员。</p>
</li>
<li>
<p>为什么可修改左值不能是<code>array</code>，我们不能对数组赋值，但是可以通过下标操作对数组进行赋值，所以数组名字不能是一个可修改的左值。或者说数组名字其实是数组首元素的地址。这里的数组赋值说的是：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[] = &#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line">b = a;  <span class="comment">//想要做的操作是把数组a赋值给数组b，这是错误的。</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>为什么没有说函数不能是可修改左值，函数名指定的是一个函数不是一个对象，所以函数名不能是左值，自然也不能是一个可修改左值。</p>
</li>
<li>
<p>数组和指针都是左值，但是数组是不可修改左值，而指针是可修改左值（非const）。数组作为作为右值表示的是数组首元素的地址，数组作为左值，表示的是数组类型，是不能修改的左值。而指针变量可以作为左值，因为我们可以取得它的地址，指针变量作为右值是指针变量存储的值，即它指向变量的地址。</p>
</li>
</ol>
<h3 id="左值类型">左值类型</h3>
<p>C语言中的左值有以几种：</p>
<ol>
<li>任意类型变量的名字</li>
<li>下标运算符<code>[]</code></li>
<li>指针的成员访问操作<code>-&gt;</code>和<code>.</code></li>
<li>单目运算符解引用<code>*</code>的表达式，不能指向一个数组</li>
<li>指针的解引用操作，不能是一个函数指针</li>
<li>数组，<code>const</code>对象，是一个不可修改左值，比如<code>const int a = 0;</code>，<code>a</code>是一个不可修改左值</li>
<li>字符串字面值常量是一个不可修改左值[12]，因为C中没有字符串类型，字符串常量都是以字符数组类型存储的，而在C中，除了左值以外没有任何方式可以让数组存在于表达式中。</li>
</ol>
<h2 id="c-和c中lvalue的区别">C++和C中lvalue的区别</h2>
<p>《C++ Primer》中说C++和C中的左值和右值不一样，我怎么觉得都一样呢。（好吧，自己还是道行太浅了）。<br>
举例来说：</p>
<ol>
<li>比如说<code>++i</code>和<code>--i</code>操作，在C中，它是一个右值，而在C++ 中，它是左值，而<code>i++</code>和<code>i--</code>在C和C++ 中都是右值[9]。</li>
<li>在C语言中，三目运算符（?:）的结果一定是右值，而在C++中，如果:旁边的两个操作数是左值，那么结果也是左值[10]。</li>
</ol>
<h3 id="c-中的左值运算">C++中的左值运算</h3>
<ol>
<li>赋值运算需要一个非常量左值作为左侧运算对象，得到的结果也仍然是一个左值。</li>
<li>取地址符用作一个左值运算对象，返回一个指向该运算对象的地址，这个值是一个右值。</li>
<li>内置解引用运算符，下标运算符，迭代器解引用运算符，<code>string</code>和<code>vector</code>的求值结果都是左值。</li>
<li>内置类型和迭代器的递增递运算符作用于左值运算对象，其前置版本所得的结果也是左值，即<code>++iter</code>, <code>++i</code>等。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C和指针》<br>
2.《C++ Primer》<br>
3.<a href="https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/lvalue-and-rvalue-in-c-language/</a><br>
4.<a href="https://segmentfault.com/a/1190000003793498" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003793498</a><br>
5.<a href="https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type" target="_blank" rel="noopener">https://stackoverflow.com/questions/45656162/why-cant-a-modifiable-lvalue-have-an-array-type</a><br>
6.<a href="https://www.quora.com/What-is-lvalue-and-rvalue-in-C" target="_blank" rel="noopener">https://www.quora.com/What-is-lvalue-and-rvalue-in-C</a><br>
7.<a href="https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c" target="_blank" rel="noopener">https://www.internalpointers.com/post/understanding-meaning-lvalues-and-rvalues-c</a><br>
8.<a href="https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c" target="_blank" rel="noopener">https://eli.thegreenplace.net/2011/12/15/understanding-lvalues-and-rvalues-in-c-and-c</a><br>
9.<a href="https://www.zhihu.com/question/29936562/answer/46129706" target="_blank" rel="noopener">https://www.zhihu.com/question/29936562/answer/46129706</a><br>
10.<a href="https://www.zhihu.com/question/313519801/answer/642403872" target="_blank" rel="noopener">https://www.zhihu.com/question/313519801/answer/642403872</a><br>
11.<a href="https://www.zhihu.com/question/36052573/answer/65743965" target="_blank" rel="noopener">https://www.zhihu.com/question/36052573/answer/65743965</a><br>
12.<a href="https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value" target="_blank" rel="noopener">https://stackoverflow.com/questions/10004511/why-are-string-literals-l-value-while-all-other-literals-are-r-value</a><br>
13.<a href="https://www.zhihu.com/question/25814721/answer/31648501" target="_blank" rel="noopener">https://www.zhihu.com/question/25814721/answer/31648501</a><br>
14.<a href="https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues" target="_blank" rel="noopener">https://stackoverflow.com/questions/3601602/what-are-rvalues-lvalues-xvalues-glvalues-and-prvalues</a><br>
15.<a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf</a><br>
16.<a href="https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard" target="_blank" rel="noopener">https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard</a><br>
17.<a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2011/n3242.pdf</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-variable-declaration-and-definition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-variable-declaration-and-definition/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C++ variable declaration and definition</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 21:22:49" itemprop="dateCreated datePublished" datetime="2019-11-13T21:22:49+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-16 13:00:16" itemprop="dateModified" datetime="2019-11-16T13:00:16+08:00">2019-11-16</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="c-类型">C++类型</h2>
<p>C++中，对象（变量）的类型通常有两种：</p>
<ol>
<li>基本内置类型，整形和浮点型。整形又包括整数，布尔型，字符串，浮点型又包括单精度浮点型和双精度浮点型，详细介绍可以查看<a href="https://mxxhcm.github.io/2019/11/05/C-fundamental-types-and-variables/">C++算术类型</a>。</li>
<li>复合类型，包括<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">指针</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-array/">数组</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-reference/">引用</a>，<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-class/">类</a>，结构，联合类型。</li>
</ol>
<h2 id="变量和对象">变量和对象</h2>
<h3 id="变量">变量</h3>
<p>变量是一个有名字的，可供程序操作的存储空间。C++ 中的每个变量都有数据类型，数据类型决定着变量所占内存空间的大小和布局方式，该空间能存储的值的范围，以及变量能够参数的运算。对于C++ 程序员来说，变量和对象一般可以互用。</p>
<h3 id="对象">对象</h3>
<p>什么是对象，具有某种数据类型的内存空间，并不区分是复合类型还是内置类型，也不区分是否有名字和是否只读。</p>
<h2 id="变量定义">变量定义</h2>
<p>一条定义语句由一个基本数据类型和紧随其后的一个或者多个声明符组成。每个声明符声明了一个变量并且指定该变量为与基本数据类型有关的某种类型。<br>
基本变量的声明语句由数据类型和变量名组成，声明符就是变量名。而复合类型的声明语句中声明符除了变量名，还会有类型修饰符，如<code>*</code>,<code>&amp;</code>和<code>[]</code>等等。比如引用的声明语句中将声明符写成<code>&amp;d</code>的形式，其中<code>d</code>是声明的变量名,<code>&amp;</code>是类型修饰符。指针是另外一种复合类型，通常将声明符写成<code>*d</code>的形式，其中<code>d</code>是变量名，<code>*</code>是类型修饰符。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p>在指针操作中，其中操作符<code>*</code>称为解引用，操作符<code>&amp;</code>称为取地址符。</p>
<h3 id="复合类型的定义">复合类型的定义</h3>
<p>变量的定义包含一个基本数据类型和一组声明符。在一条定义语句中，虽然基本数据类型只有一个，但是声明符的形式却可以不同，也就是一条定义语句可能定义处不同类型的变量：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1024</span>, *p = &amp;i, &amp;r = i;</span><br></pre></td></tr></table></figure></p>
<p>在定义语句中，类型修饰符<code>*</code>和<code>&amp;</code>仅仅修饰紧随其后的变量。关于引用和指针的声明，一般有两种写法：</p>
<ol>
<li>
<p>将修饰符和变量名写在一起，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1, *p2;</span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>把修饰符和类型名写在一块，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>* p1;</span><br><span class="line"><span class="keyword">int</span>* p2;</span><br></pre></td></tr></table></figure></p>
</li>
</ol>
<p>这两种方法都对，C++ primer采用第一种。</p>
<h4 id="指向指针的指针">指向指针的指针</h4>
<p>声明符中修饰符的个数没限制，可以写很多个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ival = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">int</span> *pi = &amp;ival; <span class="comment">//pi指向一个int数</span></span><br><span class="line"><span class="keyword">int</span> **pi = &amp;pi; <span class="comment">//pi指向一个int的指针。</span></span><br></pre></td></tr></table></figure>
<h4 id="指针的引用">指针的引用</h4>
<p>引用不是对象，所以指针不能指向引用。但是指针是对象，所以有指针的引用。复杂的指针或者引用的声明语句，从右往左读。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">int</span> *p;</span><br><span class="line"><span class="keyword">int</span> *&amp;r = p;    <span class="comment">//从右往左阅读，r是一个引用，是谁的引用，int*的引用。</span></span><br><span class="line"></span><br><span class="line">r = &amp;i; </span><br><span class="line">*r = <span class="number">0</span>; <span class="comment">// i=0</span></span><br></pre></td></tr></table></figure>
<h2 id="变量初始化">变量初始化</h2>
<p>初始化是在变量创建时给一个特定的值，而赋值是把对象的当前值擦除，使用一个新值代替。</p>
<h3 id="默认初始化">默认初始化</h3>
<p>当变量没有指定初值，使用默认初始化的方式进行初始化。默认值由变量类型和变量位置决定。<br>
对于内置类型的变量，如果没有显式初始化，它的位置由定义的位置决定。函数内部的内置类型不会被初始化，定义于任何函数外部的内置类型被初始化为0。未初始化的变量的值是未定义的。<br>
对于自定义的类型来说，每个类决定初始化对象的方式，而且是否允许不经过初始化就定义对象也由自己决定。如果类允许这种行为，由类决定对象的初始值是什么；如果类要求每个对象显示初始化，在创建类对象没有进行明确的初始化操作时，会引发错误。</p>
<h2 id="声明和定义的区别">声明和定义的区别</h2>
<ol>
<li>声明需要给出变量的类型和名字，但是不需要申请存储空间。</li>
<li>只进行声明的话使用<code>extern</code>关键字，不要显式的初始化变量。包含了显式初始化的声明就变成了定义。</li>
<li>变量只能定义一次，但是可以声明多次。可以方便的在多个文件中使用同一个变量。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-type-operation/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-type-operation/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C++ type operation</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:19:46 / 修改时间：14:20:42" itemprop="dateCreated datePublished" datetime="2019-11-13T14:19:46+08:00">2019-11-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="类型操作">类型操作</h2>
<h3 id="别名typedef和using">别名<code>typedef</code>和<code>using</code></h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typdef dobuel wages;    <span class="comment">//类型别名</span></span><br><span class="line"><span class="keyword">using</span> SI = Sales_imte;  <span class="comment">//别名声明</span></span><br></pre></td></tr></table></figure>
<h4 id="指针-常量和类型别名">指针，常量和类型别名</h4>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> pstring cstr = <span class="number">0</span>; <span class="comment">//基本数据类型是char *，即指针类型</span></span><br><span class="line"><span class="keyword">const</span> pstring *p;</span><br></pre></td></tr></table></figure>
<p>不能简单的把<code>pstring</code>用<code>char *</code>替换，如果替换了变成下式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *cstr = <span class="number">0</span>;   <span class="comment">//基本数据类型是const char，</span></span><br></pre></td></tr></table></figure>
<p>很容易把<code>*</code>看成是声明符的一部分，即<code>*cstr</code>的一部分，但是实际上<code>*</code>是和<code>const char</code>在一起的。<code>const char *cstr</code>是<strong>指向<code>char</code>常量的指针</strong>，而<code>const pstring cstr</code>是指向<code>char</code>的<strong>常量指针</strong>。</p>
<h3 id="auto关键字"><code>auto</code>关键字</h3>
<p>编译器自动分析表达式的类型，<code>auto</code>定义的变量必须有初值。<br>
使用一条<code>auto</code>语句可以声明多个变量，多个变量的基本数据类型必须一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto i= 0, *p = &amp;i; //正确</span><br><span class="line">auto i = 1, d = 3.14;   //错误</span><br></pre></td></tr></table></figure>
<h4 id="复合类型-常量和auto">复合类型，常量和<code>auto</code></h4>
<ol>
<li>编译器使用<code>auto</code>推断出来的值和初始值类型有时候不完全一样。比如使用引用其实使用的是引用对象的值。</li>
<li><code>auto</code>会忽略顶层<code>const</code>，保留底层<code>const</code>。如果希望<code>auto</code>推断出的是顶层<code>const</code>，需要显式的加一个<code>const</code>，即<code>const auto = ...</code>。</li>
<li>将引用的类型设为<code>auto</code>也可以保留初始值中的顶层<code>const</code>属性，</li>
<li>如果给初始值绑定一个引用，并且设为<code>auto</code>类型，这个对象就不是顶层<code>const</code>了。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;r = i;</span><br><span class="line"><span class="keyword">auto</span> a = r; <span class="comment">// a是一个int,而不是int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = i, &amp;cr = ci;</span><br><span class="line"><span class="keyword">auto</span> b = ci;    <span class="comment">//b是一个int</span></span><br><span class="line"><span class="keyword">auto</span> c = cr;    <span class="comment">//c是一个int, cr是ci别名，ci是顶层const</span></span><br><span class="line"><span class="keyword">auto</span> d = &amp;i;    <span class="comment">//d是int *</span></span><br><span class="line"><span class="keyword">auto</span> e = &amp;ci;   <span class="comment">//e是一个指向const的指针。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> f = ci;  <span class="comment">//f是const int</span></span><br><span class="line"><span class="keyword">auto</span> &amp;g = ci;   <span class="comment">// g是int &amp;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;j = <span class="number">43</span>;<span class="comment">//这个j就不是顶层const了，类型是const int &amp;，它是底层const。</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="decltype类型"><code>decltype</code>类型</h3>
<p><code>decltype</code>和<code>auto</code>的区别：</p>
<ol>
<li>它只返回表达式的类型。</li>
<li>它能识别顶层<code>const</code>和引用类型<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>, &amp;ri = i, *pi = &amp;i;</span><br><span class="line"><span class="keyword">decltype</span>(ri);       <span class="comment">//是int &amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(ri+<span class="number">0</span>);    <span class="comment">//是int</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">0</span>, &amp;cj = ci;</span><br><span class="line"><span class="keyword">decltype</span>(ci) p = <span class="number">0</span>; <span class="comment">//const int,</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) q = <span class="number">0</span>; <span class="comment">//const int &amp;，顶层常量引用可以初始化成字面值</span></span><br><span class="line"><span class="keyword">decltype</span>(ci) x; <span class="comment">//错误，常量必须初始化</span></span><br><span class="line"><span class="keyword">decltype</span>(cj) y; <span class="comment">//错误，引用必须初始化</span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>引用从来都是作为它所指对象的同义词出现，只有在<code>decltype</code>处是例外。</p>
<h4 id="decltype和引用"><code>decltype</code>和引用</h4>
<ol>
<li>如果表达式的内容是解引用操作，使用<code>decltype</code>将会得到引用类型。</li>
<li><code>decltype((variable))</code>的结果永远是引用，而<code>decltype(variable)</code>的结果只有在真的是引用的时候才会返回引用。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">decltype</span>((i)) d;</span><br><span class="line"><span class="keyword">decltype</span>(i) e;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-const/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-const/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C/C++ const</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:15:52" itemprop="dateCreated datePublished" datetime="2019-11-13T14:15:52+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-15 08:59:01" itemprop="dateModified" datetime="2019-11-15T08:59:01+08:00">2019-11-15</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="const类型"><code>const</code>类型</h2>
<ol>
<li><code>const</code>修饰的变量一经初始化，不能改变其值，而且必须进行初始化。</li>
<li>可以使用任意对象（包含非<code>const</code>对象）初始化<code>const</code>对象。</li>
<li><code>const</code>对象默认只在当前文件中有效。如果需要在其他文件中使用，在声明和定义的文件中都需要加上<code>extern</code>关键字；而非<code>const</code>对象在定义时不需要使用<code>extern</code>关键字，只需要在其他文件的声明中加上<code>extern</code>即可。</li>
<li>编译器遇到<code>const</code>变量时，会将所有该变量出现的地方都换成相应的值。</li>
</ol>
<h2 id="引用和const">引用和<code>const</code></h2>
<p>可以把应用绑定到<code>const</code>对象上，就像绑定到其他常量上，称为对常量的引用（reference to const)，和普通引用的不同在与，对常量的引用不能用作修改它绑定的对象：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = ci;</span><br><span class="line"></span><br><span class="line">r1 = <span class="number">42</span>;    <span class="comment">//这行代码是错的，因为r1是对常量的引用</span></span><br><span class="line"><span class="keyword">int</span> &amp;r2 = ci;   <span class="comment">//这行代码也是错的，因为r2是普通引用</span></span><br></pre></td></tr></table></figure></p>
<p>常量引用是对常量的引用的简称。严格来说，并不存在常量引用，因为引用不是一个对象，我们没办法让引用本身恒定不变。但是因为C++中，引用绑定的对象是不能更改的，所以从这层意义上理解，所有的引用又都称得上常量。引用的对象是常量还是非常量决定了引用能进行的操作，但是影响不到引用和对象的绑定关系。</p>
<h3 id="初始化和对常量的引用">初始化和对常量的引用</h3>
<p>之前说过引用的类型对象必须和引用对象的类型一样。但是有两个例外，**一个例外就是初始化常量引用时可以使用任意表达式作为初值。**如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">43</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1*<span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1*<span class="number">2</span>;</span><br></pre></td></tr></table></figure></p>
<p>根据上面的例子我们也可以看出，对常量的引用可能引用一个非常量对象，我们不能通过<code>r</code>改变<code>i</code>的值，但是我们可以直接改变<code>i</code>的值，因为<code>r</code>和<code>i</code>是绑定的，所以<code>r</code>的值也改变了。</p>
<p>当把一个常量引用绑定到另一种类型上的时候，会发生什么？<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">double dval = 3.14;</span><br><span class="line">const int &amp;ri = dval;</span><br></pre></td></tr></table></figure></p>
<p>上述代码将一个<code>dobule</code>类型的变量绑定到一个<code>const int</code>型引用上，为了让<code>ri</code>绑定一个整数，编译器将上述代码变成了以下形式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const int temp = dval;</span><br><span class="line">const int &amp;ri = temp;</span><br></pre></td></tr></table></figure></p>
<p>将<code>ri</code>绑定到了一个临时对象<code>temp</code>上，但是我们想要<code>ri</code>操作的是<code>dval</code>而不是<code>temp</code>，所以这种行为被判定为非法。</p>
<h3 id="引用和左值-右值">引用和左值，右值</h3>
<ol>
<li>非常量引用的初始值必须是左值。</li>
<li>常量引用的初始值可以是右值。比如<code>const int &amp;a = 7</code>;</li>
<li>常量引用的初始值可以为左值。</li>
</ol>
<h2 id="指针和const">指针和<code>const</code></h2>
<p>指针也可以指向常量。类似于对常量的引用（常量引用），有指向常量的指针（pointer to const)。</p>
<ol>
<li>之前说过指针指向的类型对象必须和指针的类型一样。但是有两个例外，一个例外就是指向常量的指针可以使用非常量对象的地址进行初始化。</li>
<li>要想存放指向常量的地址，必须使用指向常量的指针。</li>
<li>指向常量的指针不能用于改变其所指对象的值，很容易明白，因为指向的是常量，而常量的值是不能修改的，所以指向常量的指针自然不能修改它指向的对象的值。</li>
<li>那么指向常量的指针的指向能否改变？当然可以了，要不然就不会有<code>const</code>指针了，即指针本就就是常量对象，指向不能改变的指针对象。</li>
</ol>
<p>可以认为指向常量的指针和对常量的引用都是他们自认为指向了常量对象，而常量对象不能被修改，所以就不能修改所指对象的值。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">double</span> *ptr = &amp;pi;  <span class="comment">//报错，必须是指向常量的指针</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;pi;    <span class="comment">//</span></span><br><span class="line">*cptr = <span class="number">4</span>;  <span class="comment">//不能修改常量指针指向的常量的值</span></span><br></pre></td></tr></table></figure></p>
<h3 id="const指针"><code>const</code>指针</h3>
<p>引用不是对象，而指针是对象，因此就像其他对象一样，可以把指针本身定义为常量，叫做常量指针，常量指针必须初始化。<br>
<code>const</code>指针必须初始化，它指向变量的值能否改变只取决于它指向变量的类型。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curErr = &amp;val;   <span class="comment">//</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> pi = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *<span class="keyword">const</span> pip = &amp;pi;  <span class="comment">//</span></span><br></pre></td></tr></table></figure></p>
<h2 id="顶层const">顶层<code>const</code></h2>
<p>用顶层<code>const</code>表示指针本身是一个常量，用底层<code>const</code>表示指针指向的对象是一个常量。指针可以既是顶层<code>const</code>又是底层<code>const</code>。<br>
更一般的，顶层<code>const</code>可以表示任何的对象是常量，这一点对任意类型都使用。而底层<code>const</code>则和指针，引用等复合类型有关。<br>
可以把一个顶层<code>const</code>赋值给非顶层<code>const</code>对象；但是不能把底层<code>const</code>赋值给非底层<code>const</code>对象，这个多加几句，因为底层<code>const</code>一定是和复合类型指针和引用相关的，所以要把它赋值给一个非底层的<code>const</code>对象，这个待赋值的对象也一定是指针和引用，如果它是非底层<code>const</code>对象，那么就可以通过它修改它指向的对象了，而这个对象是<code>const</code>的，不能被修改。</p>
<p>对常量的引用（常量引用）可以和常量对量绑定；<br>
对常量的引用（常量引用）可以和非常量对量绑定；<br>
非常量引用不可以和常量对象绑定；<br>
非常量引用可以和非常量对象绑定；</p>
<p>指向常量的指针可以指向常量对象；<br>
指向常量的指针可以指向非常量对象；<br>
常量指针可以指向非常量对象；<br>
常量指针不可以指向常量对象；<br>
普通指针不可以指向常量对象；<br>
普通指针可以指向非常量对象；</p>
<p>常量指针（顶层const）可以用来初始化非常量对象。<br>
对常量的引用和指向常量的指针（底层const）不可以用来初始化非常量对象。</p>
<h2 id="constexpr和常量表达式"><code>constexpr</code>和常量表达式</h2>
<p>常量表达式，值不会改变，并且在编译过程中就能得到计算结果的表达式。字面值和用常量表达式初始化的<code>const</code>对象也是常量表达式。比如：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> size = <span class="number">23</span>;  <span class="comment">//不是常量表达式，因为他不是`const`对象</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> sz = get_size();  <span class="comment">//sz是常量，但不是常量表达式，因为它的值需要等到运行时才能获得。</span></span><br></pre></td></tr></table></figure></p>
<p>常量表达式一定是常量，但是常量不一定是常量表达式。<br>
声明为<code>constexpr</code>的变量由编译器验证它是否是常量表达式。<br>
声明为<code>constexpr</code>的变量一定是个常量，而且必须用常量表达式初始化。<br>
如果认定变量一定是个常量表达式，就把它声明成<code>constexpr</code>类型，即<code>constexpr</code>用于声明常量表达式。</p>
<h3 id="字面值类型">字面值类型</h3>
<p>算术类型，引用和指针都属于字面值类型，<code>string</code>，IO库和类不属于字面值类型。算术类型包含整形和浮点型，整形中又包含整数，字符和布尔。<code>constexpr</code>只能用于字面值类型。<br>
指针和引用能用定义成<code>constexpr</code>，但是初值受到严格限制，一个<code>constexpr</code>指针的初始值必须是<code>nullptr</code>，<code>0</code>或者某个固定地址的对象。一般来说，函数内部的变量(除了<code>static</code>变量)没有存在固定地址中，而所有函数之外的对象地址固定不变，能用来初始化<code>constexpr</code>指针。<code>constexpr</code>声明的指针是顶层<code>const</code>，即指针本身是个<code>const</code>，它指向的对象不能变，它指向的对象的值能变。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer》第五版<br>
2.<a href="https://www.zhihu.com/question/36052573/answer/65756850" target="_blank" rel="noopener">https://www.zhihu.com/question/36052573/answer/65756850</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-compound-type-reference/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-compound-type-reference/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C++ compound type reference</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:14:15 / 修改时间：14:15:33" itemprop="dateCreated datePublished" datetime="2019-11-13T14:14:15+08:00">2019-11-13</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="引用-左值引用">引用（左值引用）</h2>
<ol>
<li>引用不是一个对象，没有实际地址，不能定义指向引用的指针。</li>
<li>引用只是一个别名，必须和一个已经存在的对象绑定在一起，无法更改，必须初始化。</li>
<li>定义引用时，标识符必须以<code>&amp;</code>开头。</li>
<li>除了两种特殊情况外，所有引用的类型都必须和它绑定的对象严格匹配。</li>
<li>引用只能绑定在对象上，不能绑定在字面值或者某个表达式上。（const引用除外）</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<ol>
<li></li>
</ol>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2019/11/13/C-compound-type-pointer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2019/11/13/C-compound-type-pointer/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C/C++ compound type pointer</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-13 14:11:26" itemprop="dateCreated datePublished" datetime="2019-11-13T14:11:26+08:00">2019-11-13</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-11-17 20:59:19" itemprop="dateModified" datetime="2019-11-17T20:59:19+08:00">2019-11-17</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="指针">指针</h2>
<ol>
<li>变量的值存储在计算机的内存中，每个变量都占据一个特定的位置，每一个内存位置都由地址唯一确定并引用。指针可以看成是地址的另一个名字<a href="3.1.3">2</a>。</li>
<li>指针变量也是一个变量，其中存放的是另一个变量的地址，因为指针是一个变量，所以指针变量本身也存放在内存中的某个位置<a href="3.1.3">2</a>。允许对指针赋值和拷贝，在指针的生命周期内可以先后指向几个不同的对象。</li>
<li>指针无须在定义时赋值，和其它内置类型一样，在块作用域内定义的指针如果没有被初始化，也将拥有一个不确定的值。</li>
</ol>
<h2 id="指针声明和定义">指针声明和定义</h2>
<p>指针也是一个复合类型，需要按照复合类型的声明和定义进行声明。</p>
<h3 id="指针定义">指针定义</h3>
<p>定义指针类型的方法将声明符写成<code>*d</code>的形式，其中<code>d</code>是变量名。如果在一条语句中定义了几个指针变量，每个变量前面都必须有符号<code>*</code>。即<code>*</code>是修饰声明符的，而不是修饰<code>int</code>的。如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *p; <span class="comment">// 定义一个int*的指针p，p进行了默认初始化</span></span><br><span class="line"><span class="keyword">int</span> *a, b, *c;  <span class="comment">//定义了两个int*类型的指针a,c，一个int类型变量b</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *message = <span class="string">"Hello world!"</span>; <span class="comment">//定义一个char*变量，指向数据段的字符串常量区中的字符串"Hello world!"的首字符的地址。</span></span><br><span class="line"><span class="comment">//下面两行代码和上面一行代码的作用是相同的，message是一个`char *`指针，指向字符串常量"Hello world!"的首字符的地址。</span></span><br><span class="line"><span class="keyword">char</span> *message = <span class="literal">NULL</span>;</span><br><span class="line">message = <span class="string">"Hello world!"</span>;</span><br></pre></td></tr></table></figure>
<h3 id="取地址符">取地址符</h3>
<p>指针存放某个对象的地址，要想获取改地址，需要使用取地址符<code>&amp;</code>。除了两种特殊情况外，所有指针类型都要和它所指的对象严格匹配。<br>
两种特殊情况：</p>
<ol>
<li>一个指向常量的指针可以指向个非常量对象。</li>
<li>…</li>
</ol>
<h3 id="指针的值-就是地址-有四种可能取值">指针的值，就是地址，有四种可能取值</h3>
<ol>
<li>指向一个对象</li>
<li>指向紧邻对象所占空间的下一个位置</li>
<li>空指针，没有指向任何对象</li>
<li>无效指针，除了以上三种情况的任何值。</li>
</ol>
<p>使用无效指针和使用未初始化变量是同类错误，编译器都不负责进行检查。</p>
<h3 id="解引用指针-间接访问-操作符">解引用指针（间接访问）操作符</h3>
<p>C11中解引用操作符<code>*</code>的定义：</p>
<blockquote>
<p>The unary * operator denotes indirection. If the operand points to a function, the result is a function designator; if it points to an object, the result is an lvalue designating the object. If the operand has type ‘‘pointer to type’’, the result has type ‘‘type’’. If an invalid value has been assigned to the pointer, the behavior of the unary * operator is undefined.102)</p>
</blockquote>
<p>C++11中解引用操作符<code>*</code>的定义：</p>
<blockquote>
<p>The unary * operator performs indirection: the expression to which it is applied shall be a pointer to an object type, or a pointer to a function type and the result is an lvalue referring to the object or function to which the expression points. If the type of the expression is “pointer to T,” the type of the result is “T.” [ Note: a pointer to an incomplete type (other than cv void) can be dereferenced. The lvalue thus obtained can be used in limited ways (to initialize a reference, for example); this lvalue must not be converted to a prvalue, see 4.1. — end note ]</p>
</blockquote>
<p>解引用操作符<code>*</code>应用于指向对象或者指向函数的指针表达式，得到指针指向对象的左值表达式，给解引用的结果赋值其实就是给指针所指的对象赋值([1]2.3.2)。如果不解引用，指针变量中存放的内容就只是地址。<br>
<strong>对象（变量）和指针变量中存放的内容（即地址）的区别，对象可以直接进行赋值。指针变量中存放的是一个地址，地址本身就是一个数字，是一个右值，不能对其进行赋值，对这个地址进行解引用，得到指针指向的对象。</strong><br>
定义一个指针<code>p</code>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">3</span>; </span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br></pre></td></tr></table></figure></p>
<p><code>p</code>是<code>int*</code>类型，存放的是变量<code>a</code>的地址，<code>*</code>是间接访问，<code>*p</code>对指针进行解引用得到指针指向对象的左值表达式，其实就是<code>a</code>，<code>&amp;</code>表示取变量<code>a</code>的地址。</p>
<h3 id="未初始化和非法的指针">未初始化和非法的指针</h3>
<p>看一个错误的代码片段：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *a; <span class="comment">//定义一个指针*p</span></span><br><span class="line">*a = <span class="number">12</span>;    <span class="comment">//把12存储在a指向的内存中，错误</span></span><br></pre></td></tr></table></figure></p>
<p>这个代码中犯了一个很严重的错误，我们在声明了变量<code>a</code>，但是没有对它进行显示初始化，所以编译器会对a进行默认初始化，默认初始化并不会为变量分配内存。如果程序执行这个赋值操作，假如a是一个非法地址，程序会出错，终止程序，在UNIX系统上，这个错误称为&quot;segmentation violation&quot;或者&quot;memory fault&quot;，它告诉我们程序正在访问一个非法的地址。如果a是一个合法的地址，这就会错误的修改a指向的内存中的值，造成一些难以预料到的错误。</p>
<h3 id="空指针">空指针</h3>
<p>有以下几种方法声明空指针：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1.</span></span><br><span class="line"><span class="keyword">int</span> *p1 = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">// 方法2.</span></span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 方法3.</span></span><br><span class="line"><span class="keyword">int</span> *p3 = <span class="literal">NULL</span>;<span class="comment">//NULL定义在cstdlib中</span></span><br></pre></td></tr></table></figure></p>
<p>最好使用<code>nullptr</code>或者<code>0</code>，而避免使用<code>NULL</code>。</p>
<h3 id="void-指针"><code>void*</code>指针</h3>
<p><code>void *</code>指针可以存放任意类型的地址，但是我们并不知道它存放的是什么类型的对象。</p>
<h3 id="指针的指针">指针的指针</h3>
<p>因为指针也是一个变量，所以它自然也就有地址，也就存在指向指针的指针。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a, *b, **c;</span><br><span class="line">b = &amp;a;</span><br><span class="line">c = &amp;b;   <span class="comment">//紧挨着c左边的那个*表示c是一个指针，然后再往左边的那个`*`是和`int`在一起的，表示指针`c`指向的变量的类型是`int *`类型的。</span></span><br><span class="line"><span class="comment">// a,*b, **c表示同样的东西，都是变量a的值。</span></span><br><span class="line"><span class="comment">// *c和b和&amp;a表示同样的东西，都是变量a的地址。</span></span><br><span class="line"><span class="comment">// a表示int类型的变量</span></span><br><span class="line"><span class="comment">// b是a的地址，*b表示对指针p解引用，*b就是a。</span></span><br><span class="line"><span class="comment">// c是b的地址，*c表示对指针c解引用，*c就是b，也就是a的地址，*(*c)也就是*b，也是a。</span></span><br></pre></td></tr></table></figure></p>
<h2 id="指针的特点">指针的特点</h2>
<ol>
<li>
<p>存放的是对象的地址，要想获取变量的地址，需要使用取地址符<code>&amp;</code>，访问指针中地址指向的变量，使用解引用符号<code>*</code>，即：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> val = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp; val; <span class="comment">//指针p存放的是变量val的地址</span></span><br><span class="line"><span class="keyword">int</span> b = *p; <span class="comment">//b被初始化为32,p存放的是val的地址，*p获得该地址指向的变量val。</span></span><br><span class="line">*p = <span class="number">3</span>; <span class="comment">//将val赋值为3</span></span><br></pre></td></tr></table></figure></p>
</li>
<li>
<p>赋值永远改变的是<code>=</code>左侧的对象，可以用来判断到底是改变了指针的值还是改变了指针所指的对象的值。</p>
</li>
<li>
<p>除了两种特殊情况外，所有指针的类型都必须和它指向的对象严格匹配。</p>
</li>
</ol>
<h2 id="指针和引用的不同点">指针和引用的不同点</h2>
<ol>
<li>指针本身就是一个对象，允许赋值和拷贝，在生命周期内可以指向几个不同的对象；而引用本身并非一个对象，一定定义了引用，它就和一个对象终生绑定在了一起。</li>
<li>指针定义时无须赋值；而引用必须在定义时赋值。</li>
</ol>
<h2 id="指针运算">指针运算</h2>
<p>指针加上一个整数的结果是另一个指针。注意，这里假设每种类型都是连续存储的。假设字符型占一个字节，<code>float</code>占四个字节，<code>double</code>占八个字节。<br>
如果将指针加上1：<br>
对于一个字符型，新的指针指向内存中的下一个字符，指针的值实际上增加了1。<br>
对于一个<code>float</code>型，它指向内存中的下一个<code>float</code>，指针的值实际上增加了4。<br>
对于一个<code>double</code>型，它指向内存中的下一个<code>double</code>，指针的值实际上增加了8。<br>
也就是说，对于一个给定类型的指针，将它加一，得到的新指针指向下一个同类型的变量，这也是声明指针类型的作用。</p>
<h3 id="指针的大小">指针的大小</h3>
<p>任何类型的指针本身所占的大小都是相等的，取决于计算机的地址大小，如果是<code>32</code>位的地址，指针的大小就是<code>4</code>个字节，如果是<code>64</code>位的地址，指针的大小就是<code>8</code>个字节。</p>
<h3 id="算术运算">算术运算</h3>
<p>C的算术运算只有两种形式。第一种是指针加减一个整数，第二种是两个指针相减。</p>
<h4 id="指针加减一个整数">指针加减一个整数</h4>
<p>指针加减一个整数的运算形式只能用于指向数组中某个元素的指针，将它加减一个整数得到的表达式也还是一个指针，它仍指向数组中某个元素。如果对指针进行加法或者减法运算之后，指针所指的位置是在数组第一个元素前面或者在最后一个元素后面，它的效果是未定义的。这种操作编译器不会进行检查，需要程序员自己进行检查。<br>
这种形式也适用于<code>malloc</code>函数动态分配的内存。</p>
<h4 id="指针减指针">指针减指针</h4>
<p>两个指针相减的结果类型是<code>ptrdiff_t</code>，是一种有符号整数类型。运算结果是两个指针在内存中的距离，以数组元素的长度为单位，而不是以字节为单位。两个指针必须指向同一个数组，结果可正可负。如果两个指针指向不同的数组，这个距离就没有意思。因为我们不知道两个数组分别存在哪个位置。</p>
<h3 id="关系运算">关系运算</h3>
<p><code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code>, <code>&lt;=</code><br>
关系运算也需要指针指向同一个数组中的元素。为了和C++的迭代器兼容，最好使用<code>==</code>或者<code>!=</code>，因为迭代器不支持关系运算，而指针和迭代器都支持<code>==</code>和<code>!=</code>运算。</p>
<h2 id="c中的指针表达式和左值右值-2">C中的指针表达式和左值右值[2]</h2>
<h3 id="指针自增自减操作">指针自增自减操作</h3>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch = <span class="string">'a'</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = &amp;ch;</span><br></pre></td></tr></table></figure>
<ol>
<li>前置自增操作<code>++cp</code>，将<code>cp</code>的值加一，该操作先将<code>cp</code>的值加一，指向<code>ch</code>后面的一个位置，然后返回<code>cp</code>的一个拷贝。表达式<code>++cp</code>和<code>cp</code>加一后的对象一样。</li>
<li>后置自增操作<code>cp++</code>，将<code>cp</code>的值加一，该操作先返回对象<code>cp</code>的一个拷贝，然后将<code>cp</code>的值加一，指向<code>ch</code>后面的一个位置。表达式<code>cp++</code>和<code>cp</code>加一前的对象一样。</li>
<li>解引用前置自增操作<code>*++cp</code>，这个式子其实是对表达式<code>++cp</code>的解引用操作，也就是对<code>cp</code>加一后的拷贝的解引用操作，而不是对<code>cp</code>的操作。</li>
<li>解引用前置自增操作<code>*cp++</code>，这个式子其实是对表达式<code>cp++</code>的解引用操作，是对<code>cp</code>加一前的拷贝的解引用操作，而不是对<code>cp</code>的操作。</li>
</ol>
<h3 id="指针表达式和左值右值">指针表达式和左值右值</h3>
<p>关于左值和右值的介绍，可以查看<a href="http://localhost:4000/2019/11/14/C-CPP-lvalue-and-rvalue/" target="_blank" rel="noopener">C C++ lvalue and rvalue</a>。<br>
给出下列代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> ch[] = <span class="string">"abc"</span>;</span><br><span class="line"><span class="keyword">char</span> *cp = ch;</span><br><span class="line"></span><br><span class="line"><span class="comment">//&amp;cp = 4; //这个是错的，&amp;cp是一个地址，但是它本身只是一个数，它的本质和`10=4;`没有区别，使用解引用符号访问这个地址上的对象。</span></span><br><span class="line"><span class="comment">// 10 = 4; 错误，10既不是指针，也不是变量</span></span><br><span class="line"><span class="comment">//*10 = 4; 错误，10既不是指针，也不是变量</span></span><br><span class="line">*(<span class="keyword">int</span>*)<span class="number">10</span> = <span class="number">4</span>; <span class="comment">//10是一个int，首先把它转化成一个指针，表示一个地址，然后使用解引用进行赋值</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li><code>ch</code>，作为左值时，表示的是<code>ch</code>在内存中的位置；<code>ch</code>作为右值时，值是<code>'a'</code>，</li>
<li><code>&amp;ch</code>，不能当左值，因为它没有存放在内存中；当右值时，值是变量<code>ch</code>的地址</li>
<li><code>cp</code>，作为左值，是一个指针变量；作为右值，值是变量<code>ch</code>的地址</li>
<li><code>&amp;cp</code>，无法作为左值；作为右值，值是指针变量<code>cp</code>的地址</li>
<li><code>*cp</code>，作为左值，和<code>ch</code>等价；作为右值，值是<code>'a'</code></li>
<li><code>*cp+1</code>，无法作为左值；作为右值，值是<code>'a'+1</code>。</li>
<li><code>*(cp+1)</code>，作为左值，是一个指针，指向<code>ch</code>后面的一个内存单位；作为右值，是<code>ch</code>后面一个内存单位的值。</li>
<li><code>++cp</code>，无法作为左值，右值和<code>*(cp+1)</code>一样。</li>
<li><code>cp++</code>，无法作为左值，右值和<code>*(cp+1)</code>一样。</li>
<li><code>*++cp</code>，作为左值，是一个指针，指向<code>ch</code>后面的一个位置；作为右值，是<code>ch</code>后面那个位置的值。</li>
<li><code>*cp++</code>，作为左值，是一个指针，指向<code>ch</code>；作为右值，<code>'a'</code>。</li>
<li><code>++*cp</code>，无法作为左值；作为右值，是<code>'b'</code>；</li>
<li><code>(*cp)++</code>，无法作为左值；作为右值，是<code>'a'</code>。</li>
<li><code>++*++cp</code>，无法作为左值；作为右值，是<code>'c'</code>。</li>
<li><code>++*cp++</code>，无法作为左值；作为右值，是<code>'c'</code></li>
</ol>
<h2 id="指针和数组">指针和数组</h2>
<ol>
<li>指针和数组的联系很紧密，在很多用到数组名字的时候，编译器都会自动的将它转换成一个指向数组首元素的指针。数组名字是个常量指针。</li>
<li>使用取地址符获取某个对象的指针，对数组元素使用取地址符就能得到指向该元素的指针。</li>
</ol>
<p>关于更多指针和数组之间的内容，点击查看<a href="https://mxxhcm.github.io/2019/11/13/C-compound-type-array/">数组</a>的介绍。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《C++ Primer第五版》<br>
2.《C和指针》<br>
3.<a href="https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard" target="_blank" rel="noopener">https://stackoverflow.com/questions/54621080/lvalues-in-the-iso-c11-standard</a><br>
4.<a href="http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf" target="_blank" rel="noopener">http://www.open-std.org/jtc1/sc22/WG14/www/docs/n1570.pdf</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/28/">28</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">274</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">24</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">379</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
  

  


  
  

  

  

  

  

  

  

</body>
</html>
