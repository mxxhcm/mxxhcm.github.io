<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
































<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=6.6.0" rel="stylesheet" type="text/css">



  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.jpg?v=6.6.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon.jpg?v=6.6.0">










<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '6.6.0',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="记录硕士三年自己的积累">
<meta property="og:type" content="website">
<meta property="og:title" content="mxxhcm&#39;s blog">
<meta property="og:url" content="http://mxxhcm.github.io/index.html">
<meta property="og:site_name" content="mxxhcm&#39;s blog">
<meta property="og:description" content="记录硕士三年自己的积累">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="mxxhcm&#39;s blog">
<meta name="twitter:description" content="记录硕士三年自己的积累">



  <link rel="alternate" href="/atom.xml" title="mxxhcm's blog" type="application/atom+xml">




  <link rel="canonical" href="http://mxxhcm.github.io/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>mxxhcm's blog</title>
  












  <noscript>
  <style>
    .use-motion .motion-element,
    .use-motion .brand,
    .use-motion .menu-item,
    .sidebar-inner,
    .use-motion .post-block,
    .use-motion .pagination,
    .use-motion .comments,
    .use-motion .post-header,
    .use-motion .post-body,
    .use-motion .collection-title { opacity: initial; }

    .use-motion .logo,
    .use-motion .site-title,
    .use-motion .site-subtitle {
      opacity: initial;
      top: initial;
    }

    .use-motion .logo-line-before i { left: initial; }
    .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">mxxhcm's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home menu-item-active">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/03/10/C-STL-hashtable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/10/C-STL-hashtable/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C STL hashtable</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-10 21:22:47 / 修改时间：22:44:17" itemprop="dateCreated datePublished" datetime="2020-03-10T21:22:47+08:00">2020-03-10</time>
            

            
              

              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="hash">hash</h2>
<p>什么是hash，给定不定长的输入，得到定长的输出。<br>
哈希的实现方式：数组，链表等。<br>
hash可以用来干嘛？</p>
<ol>
<li>用时间换空间，实现常数时间的查找。主要是利用哈希表数据结构。</li>
<li>保存密码。</li>
<li>服务器扩容（一致性哈希）。</li>
</ol>
<p>碰撞：给定不同的输入，得到相同的输入。这是一定会发生的，因为输入的范围是无穷大的。</p>
<p>解决碰撞的方法：<br>
线性探测法：<br>
二次散列法：<br>
开链法：SGI STL就采用这种方法。</p>
<h2 id="hashtable">hashtable</h2>
<p>SGI STL中，通过维护一个链表的数组。每个链表叫做一个bucket，通过KEY对buckets取余计算bucket_number。所以不同的KEY可能会被映射到同一个bucket中，这就是冲突。<br>
为了避免冲突太严重，STL中采用了一个方法，当元素的数量大于bucket的数量时，就要进行rehash。插入一个对象时，先判断是否需要rehash。如果需要rehash，需要对元素中的所有元素重新进行hash。<br>
count怎么实现？find怎么实现？比如找某一个val，先找到val对应的key，找到相应bucket中的序号，判断这个bucket中的元素的key是否和要找的key相同。</p>
<p>hashtable的迭代器是ForwardIterator。</p>
<h2 id="一致性hash">一致性hash</h2>
<p>一致性hash经常用在服务器增加或者减少时，服务器失效的问题。为什么要取2的32次方？我的理解是，这样子的话，对于同一个数据key，不管有服务器的个数是多少，得到的数据的hash值都是一样的。所以增加服务器不影响数据的hash值。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《STL源码剖析》<br>
2.<a href="https://zhuanlan.zhihu.com/p/34985026" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/34985026</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/03/10/C-object-model/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/10/C-object-model/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C object model</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-10 20:41:06" itemprop="dateCreated datePublished" datetime="2020-03-10T20:41:06+08:00">2020-03-10</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-11 18:49:26" itemprop="dateModified" datetime="2020-03-11T18:49:26+08:00">2020-03-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="c-对象模型">C++对象模型</h2>
<p><strong>C++ 对象模型：所有的nonstatic data member放在每一个类对象内。所有的static data member, staitc member function和member function都放在所有类对象之外。而对于虚函数，每一个类产生一堆指向虚函数表的指针，放在一个表中，叫做虚表。每一个类对象都会有一个虚指针指向虚表。如果加上继承的话，每一个类对象中还要放着一个虚基类对象的指针。</strong><br>
指向不同类型指针的差异，既不在指针表示不同，也不再其内容（代表一个地址）不同，而是在其所寻址出来的object类型不同。指针类型起到的作用是告诉编译器如果解释某个特定地址中内存内容和其大小。<br>
转型其实只是一种编译器指令，大部分情况下他并不改变一个指针所含的真正地址，它只影响被指向内存的大小和其内容的解释方式。<br>
<strong>一个指针或者引用之所以支持多态，是因为它们并不会引发内存中任何与类型有关的内存委托操作，会受到影响的只是它们所指向内存的“大小和内容解释方式”而已。</strong></p>
<h2 id="构造函数语义学">构造函数语义学</h2>
<p>为什么引入explicit关键字，避免将一个单一参数的构造函数当成一个转换运算符。</p>
<h3 id="默认构造函数">默认构造函数</h3>
<p>默认构造函数会在<strong>编译器需要</strong>的时候被编译器产生出来。注意，这是编译器的需要，不是程序的需要。程序的需要需要程序员进行负责。</p>
<p>如果没有任何用户声明的构造函数，在合适的时候编译器会暗中声明一个non-trivial的构造函数。什么时候会合成non-trivil的构造函数？<br>
四种情况：</p>
<ol>
<li>类中包含具有默认构造函数的成员对象。需要调用成员对象。的默认构造函数。</li>
<li>类继承了含有默认构造函数的基类对象。需要调用派生类的默认构造函数。</li>
<li>含有虚函数的类。初始化类对象的vptr。</li>
<li>含有虚基类的类。初始化虚基类对象。</li>
</ol>
<p>在这四种情况之外的话并且没有声明任何构造函数的类，它们拥有implicit trivial default constructors，实际上并不会被合成出来。</p>
<h3 id="拷贝构造函数">拷贝构造函数</h3>
<p>三种情况，会调用拷贝构造函数：</p>
<ol>
<li>明确的以一个object作为另一个object的初值。</li>
<li>pass by value。</li>
<li>返回一个类对象而不是类对象的引用时。</li>
</ol>
<h4 id="默认的memberwise的初始化">默认的memberwise的初始化</h4>
<p>default memberwise initialization是把每一个内建的或者派生的数据成员（例如指针和数组，就是一个派生的数据成员）的值，从某个object拷贝到另一个object。对于成员类对象，以递归的方式执行memberwise initialization（其实就是深拷贝）。</p>
<p>C++ 标准同样把拷贝构造函数分为trivial和non-trivial的，只有nontrivial的构造函数才会被合成到程序中，决定一个拷贝构造函数是不是nontrivial的，取决于类是否会展现bitwise copy semantics时。bitwise copy其实就是浅拷贝。<br>
什么时候不展现处bitwise copy semantics：</p>
<ol>
<li>类中包含含有拷贝构造函数的成员对象时，无论这个拷贝构造函数是设计者声明的，还是编译器合成的。</li>
<li>类继承了含有拷贝构造函数的基类时，无论这个拷贝构造函数是设计者声明的还是编译器合成的。</li>
<li>类声明了虚函数时。因为类对象中需要虚指针，没有bitwise semantics，编译器需要合成一个拷贝构造函数将vptr合适的初始化。当相同类型的对象相互赋值（基类对象赋值给基类对象，派生类对象赋值给偏生类对象），直接拷贝vptr是安全的，但是把派生类对象赋值给基类对象，vptr直接拷贝就不安全了，合成的拷贝构造函数会负责派生类的vptr的初始化。</li>
<li>类直接或者间接继承了虚基类的时候，也会使得bitwise semantics失效。编译器需要让派生类中的虚基类子对象在执行器就准备妥当，还需要维护位置的完整性。<br>
对于一个继承了虚基类的派生类，编译器会为派生类调用基类的默认构造函数（如果用户没有调用的话），还会将虚指针初始化，最后还会对基类的子对象进行定位（bitwise copy可能会破坏这个位置）（bitwise copy可能会破坏这个位置）（bitwise copy可能会破坏这个位置）（bitwise copy可能会破坏这个位置）（bitwise copy可能会破坏这个位置）（bitwise copy可能会破坏这个位置）（bitwise copy可能会破坏这个位置）（bitwise copy可能会破坏这个位置）（bitwise copy可能会破坏这个位置）。</li>
</ol>
<h3 id="程序转化语义学">程序转化语义学</h3>
<h4 id="函数参数的初始化">函数参数的初始化</h4>
<p>调用拷贝构造函数，构造一个参数传递给函数，并且把函数原型改成接受引用参数。</p>
<h4 id="返回值的初始化">返回值的初始化</h4>
<p>函数返回值怎么获得？一般都是在函数内部声明一个临时对象，然后返回这个临时对象。编译器在处理的时候使用了：<br>
双阶段转换：</p>
<ol>
<li>在函数声明上加了一个额外的引用参数，用来放置返回值。</li>
<li>在return之前调用这个额外参数的拷贝构造函数拷贝函数内部处理的临时对象。</li>
</ol>
<h4 id="使用者层面的优化">使用者层面的优化</h4>
<h4 id="编译器层面的优化-named-return-value">编译器层面的优化（Named Return Value）</h4>
<p>直接使用一个result参数代替函数内部的临时对象，少了一次拷贝构造，这个也叫作name return value(NRV)优化。<br>
为什么没有拷贝构造函数就不能实行NRV优化？（可能是因为NRV优化就是针对拷贝构造函数进行的，你连优化对象都没有了，还优化个毛线。）<br>
我在gcc下进行测试，默认是打开了NRV优化的，但是如果return 指令没有发生在top level就会失效（可看文章最后的代码）。</p>
<h4 id="要不要拷贝构造函数">要不要拷贝构造函数</h4>
<p>如果某个类的拷贝构造函数被视为trivial（即没有带有拷贝构造函数的成员对象，或者基类对象，也没有虚函数和虚基类）。<br>
那么memberwise的初始化会导致bitwisecopy，很快速很安全。<br>
如果单从是否复制的角度来看，不用提供显式的拷贝构造函数。但是！！！如果需要大量的memberwise初始化操作，比如值传递，那么提供拷贝构造函数就可以使用NRV优化。</p>
<h3 id="成员初始化列表">成员初始化列表</h3>
<p>构造函数用来给函数设置初值，除了以下的四种情况，必须使用初始化列表进行初始化，其他情况下既可以在构造函数体内，还可以使用初始化列表。</p>
<ol>
<li>初始化一个引用成员</li>
<li>初始化一个常量成员</li>
<li>调用一个基类的有参数的构造函数时</li>
<li>调用一个成员类的有参数的构造函数时</li>
</ol>
<p>初始化列表中到底发生了什么？<br>
编译器会一一操作初始化列表，用适当的顺序在构造函数内任何用户显式的代码之前安插初始化操作。<br>
还有，就是初始化顺序和初始化列表中的顺序无关，和在类中声明的顺序相关。</p>
<h2 id="data语义学">Data语义学</h2>
<p>空类的大小为1，因为编译器在空类中安插了一个char字节，使得这两个对象在内存中的位置是独一无二的。标准规定空类的大小大于0。虚基类的大小是8字节，因为虚指针。<br>
如果没有虚函数，但是有虚基类，派生类对一个空类进行继承，它的大小受到三个因素的影响（因为没有虚函数，所以没有虚指针）：</p>
<ol>
<li>语言本身的overhead，比如虚基类，在派生类对象中需要有指向虚基类对象的指针。它指向虚基类子对象，或者一个表格。</li>
<li>编译器的优化处理。</li>
<li>对齐。</li>
</ol>
<p>在菱形继承中，X是空的虚基类，A和B派生自X，没有自定义的数据，Y派生自A和B。<br>
在没有优化的时候派生类（A和B）的大小是虚基类指针大小，一个char，一个对齐，也就是8+1+3 = 12字节。A的大小是(虚基类指针大小，一个char，和派生自A和B指向，最后加起来总共是1+8+8+3 = 20。</p>
<p>空虚基类(empty virtual base class)，它提供了一个虚接口，一个空的虚基类被看成派生类的最开始的一部分，也就是说派生类不再是空类了。所以派生自虚基类的空类的大小就是一个指针的大小。在这里，A和B的大小都是一个指向虚基类指针的大小，是8字节。而Y是16字节。</p>
<h3 id="数据成员的绑定">数据成员的绑定</h3>
<p>两个防御性规则</p>
<ol>
<li>把所有的数据成员都放在class声明的开始处。</li>
<li>把所有的inline函数都放在class声明的外部。如果一个inline函数体，在整个类的声明没有完全被看到之前，是不会被评估求值的。但是对于成员函数的参数列表并不是这样的，参数列表中的类型还是会在第一次遇到时被求值。</li>
</ol>
<p>这一节最重要的就是为什么要把类型的typedef放在类的最前面。虽然对于函数的定义来说，可以使用任何类中声明的对象，但是对函数的声明是按照类中的声明顺序进行解析的！所以如果把类型的typedef放在最后，在解析函数声明的时候就可能出错（如果在函数声明出现之前没有找到某个类型，就会查找类外部的作用域）。</p>
<h3 id="数据成员的布局">数据成员的布局</h3>
<ol>
<li>静态数据成员存放在程序的data segment中。和单个的类对象无关。</li>
<li>非静态数据在类对象中的排列顺序和其被声明的顺序一致。<br>
C++标准要求任何在access访问块中，只要满足较晚出现的的members在类对象中有较高的地址即可，它们不一定连续，中间可能会有padding。</li>
<li>还有编译器内部使用的数据成员，用来支持整个对象模型。比如vptr，所有编译器都会把它安插在含有虚函数的类对象之内。一般放在类对象的最前端，有的也放在最后。</li>
</ol>
<h3 id="数据成员的存取">数据成员的存取</h3>
<h4 id="static-data-member的存取">static data member的存取</h4>
<ol>
<li><strong>每一个静态数据成员都只有一个实体，存放在程序的data segment</strong>。C++ 中通过指针和对象存取成员，结果完全相同的唯一情况就是，就是对静态数据成员的存取。实际上，它们的存取都没有经过类对象，因为静态数据成员不在类中。</li>
<li>如果取一个static data member的地址，会得到一个指向其数据类型的指针，而不是一个指向class data member的指针，因为static data member并不含在类对象中。</li>
<li>如果不同的类都声明了同名的静态数据成员，会导致命名冲突，编译器的方法是暗中对每一个static data member进行编码，从而区分它们。</li>
</ol>
<h4 id="nonstatic-data-member">nonstatic data member</h4>
<p>**非静态数据成员直接存放在每一个类对象中，只能通过class object（不管是直接的还是简介的）访问。**比如在member function中，访问nonstatic data member，实际上是经过一个隐式的this指针进行的。<br>
通过指针和.运算访问nontstaic data member，访问的data member是一个struct member，一个clas member，单一继承或者多重继承的情况下效率都相同。<br>
对一个nonstatic data member进行存取操作，编译器需要把类对象的起始地址加上偏移量。每一个nonstatic data member的偏移量在编译时就知道，即使它属于一个基类子对象。因此，存取一个nonstatic data member的效果和存取C结构体或者一个费派生类的成员是一样的。<br>
但如果某个data member是虚基类的成员，指针的存取速度会慢一些。</p>
<h3 id="继承和data-member">继承和data member</h3>
<p>在C++ 继承模型中，一个派生类对象表现出来的，是自己的members加上基类data member的总和。它们的排列顺序没有要求，在大部分编译器中，base class member总是出现在上面。属于虚基类的data member除外。</p>
<h4 id="单继承不含虚函数">单继承不含虚函数</h4>
<h4 id="单继承和虚函数">单继承和虚函数</h4>
<h4 id="多重继承">多重继承</h4>
<h4 id="虚继承">虚继承</h4>
<h2 id="函数语义学">函数语义学</h2>
<p>类的member function有三种：static member function, nonstatic member function和virtual function。<br>
static member funciton的主要特性是没有this指针，它的其他特性统统来自主要特性：</p>
<ol>
<li>不能直接存取非non static data member。</li>
<li>不能声明为非const，volatile, virtual。</li>
<li>不需要经过class object进行访问。</li>
</ol>
<h3 id="member的调用方式">member的调用方式</h3>
<h4 id="nonstatic-member-functions">nonstatic member functions</h4>
<p>nonstatic member function的访问效率必须和一般的nonmember function效率相同。这个是怎么实现的呢？编译器通过将nonstatic member function函数实体转换成对等的nonmember function函数实体：</p>
<ol>
<li>向nonstatic member function添加一个额外的参数（this指针），如果是const nonstatic member function，是通过this指针是一个指向常量对象的指针。this指针本身就是一个常量指针，即它的指向不能改变。</li>
<li>使用this指针对每一个nonstatic data member进行存取。（这就是上一节介绍的东西）。</li>
<li>将member function重新写成一个nonmemeber functon，就是对它起一个新名字。</li>
</ol>
<h4 id="virtual-member-functions">virtual member functions</h4>
<p>对于一个virtual函数来说，比如<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Point3d obj, *ptr = &amp;obj; </span><br><span class="line">ptr-&gt;normalize();   <span class="comment">//normalized虚函数</span></span><br></pre></td></tr></table></figure></p>
<p>会被转化成：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*ptr-&gt;vptr[<span class="number">1</span>])(ptr);</span><br></pre></td></tr></table></figure></p>
<p>其中第一个ptr表示指针ptr，vptr是虚指针，指向一个虚表，1是normalize()虚函数在虚函数表中的位置，ptr表示传递给this指针的实参。<br>
在一个虚函数内调用另一个虚函数，会比较快。<br>
而对于通过成员访问运算符调用的虚函数，因为它不支持多态，所以会把虚函数当做普通函数进行解析。</p>
<h3 id="static-member-function">static member function</h3>
<p>对于static memeber function来说，通过指针或者成员访问运算符调用，编译器会将它们转换成一般的nonmember function调用。</p>
<p>如果取一个static member funciton的地址，获得的是一个地址。因为static member function没有this指针，所以地址类型不是一个指向class member function的地址，而是一个nonmember function指针。</p>
<h3 id="virtual-member-function">virtual member function</h3>
<p>virtual function的一般实现模型：每一个class有一个虚表，包含该class中的virtual function地址，每个对象都有一个vptr，指向virtual table的所在。</p>
<h2 id="代码">代码</h2>
<p>NRV被关闭：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">cout</span>;</span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    X():_val(<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"X()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    X(<span class="keyword">int</span> val): _val(val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"X()"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    X(<span class="keyword">const</span> X&amp; x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"X(const X&amp; x)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">X <span class="title">bar</span><span class="params">(<span class="keyword">int</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a % <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        X x = X(a);</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    X x;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    X t = bar(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码会调用一次构造函数，一次拷贝构造。注意，这个构造函数是临时对象x调用的。t调用的是拷贝构造函数。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《深入探索C++对象模型》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/03/08/C-STL-allocator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/08/C-STL-allocator/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C STL allocator</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-08 22:33:20" itemprop="dateCreated datePublished" datetime="2020-03-08T22:33:20+08:00">2020-03-08</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-10 21:22:26" itemprop="dateModified" datetime="2020-03-10T21:22:26+08:00">2020-03-10</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/C-C/" itemprop="url" rel="index"><span itemprop="name">C/C++</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="allocator">allocator</h2>
<p>一般来说，C++ 对象的分配都是通过new expression来实现的，new expression通过调用operator new函数分配空间，然后调用相应的构造函数。同理释放的时候，通过delete，先调用operator delete，然后调用相应的析构函数。</p>
<p>STL allocator的把这两部分给分开，调用allocate()分配空间，然后调用construct()进行构建，construct()的话一般来说是负责调用构造函数。<br>
而allocate的工作就要多一些，当然也可以少一些，比如直接调用operator new或者malloc分配。这样子的话可能效率要低一下，有内存碎片，overload比较大。<br>
所以就有了下面的分配器。</p>
<h2 id="alloc">alloc</h2>
<p>SGI alloc allocator的实现是一个两级空间配置器，第一级配置器负责分配128字节以上的空间，以及异常处理。第一级配置器使用malloc而不是operator new进行内存分配的原因，可能是C++没有realloc，因为没有使用new，所以就不能使用new_handler，需要自己实现。需要客户端自己设置一个oom_handler。<br>
第二级分配器采用内存池的方式，维护16个链表，每个链表负责分配一个小于128字节的8字节整数倍（8, 16, …, 128个字节）的小区块。初始时是它们都是空指针。（采用嵌入式指针节约空间）<br>
接下来，如果要分配1个64字节大小对象的空间。它会向负责64字节的链表要空间，如果链表上没有足够的空间。它会向内存池要空间，而且要的不止一个，设置为20。如果内存池中有足够的空间，就返回，没有的话，满足一个也行，就返回一个对象。如果一个也没有的话，就向malloc要空间。malloc也没有的话，检测大于64字节的那些链表，是不是有空间。如果还没有的话，就调用第一级空间配置器，调用oom异常处理对象。</p>
<h2 id="其他内存处理工具">其他内存处理工具</h2>
<p>这里使用到了type_traits进行重载。（还有哪里使用了type_traits？）<br>
uninitialized_copy(InputForwardIterator, InputIterator, ForwardIteartor);<br>
uninitialized_fill(ForwardIterator, ForwardIterator, const T&amp; x);<br>
uninitialized_fill_n(ForwardIterator , size_type n, const T&amp; x )<br>
这三个函数，会负责对相应的位置进行初始化，通过type_traits判断是否是POD类型，执行内存，或者是调用构造函数。</p>
<h2 id="参考文z">参考文Z</h2>
<p>1.《STL源码剖析》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/03/08/C-STL/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/08/C-STL/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C STL</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-08 13:47:49" itemprop="dateCreated datePublished" datetime="2020-03-08T13:47:49+08:00">2020-03-08</time>
            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/03/05/UNIX-network-IPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/05/UNIX-network-IPC/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">UNIX network IPC</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-05 15:36:39" itemprop="dateCreated datePublished" datetime="2020-03-05T15:36:39+08:00">2020-03-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-08 09:52:14" itemprop="dateModified" datetime="2020-03-08T09:52:14+08:00">2020-03-08</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="套接字描述符">套接字描述符</h2>
<p>套接字是通信端点的抽象，是软件接口，是传输层和网络层之间的接口。正如使用文件描述符访文件，使用套接字描述符访问套接字。套接字描述符本质上就是一个文件描述符，但是不是所有参数为文件描述符的函数都可以接收套接字描述符（比如说套接字不支持文件偏移量，所以lseek等函数就不支持）。</p>
<h2 id="寻址">寻址</h2>
<h3 id="字节序">字节序</h3>
<p>大端：最大字节出现在最低地址位。<br>
小端：最小字节出现在最低地址位。<br>
TCP/IP协议栈使用大端字节序，Linux x86使用小端。</p>
<p>四个字节序转换函数：<br>
h表示host，n表示network，l表示long(32位整数), s表示short（16位整数）</p>
<ol>
<li>htonl</li>
<li>htons</li>
<li>ntohl</li>
<li>ntohs</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/03/05/UNIX-IPC/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/05/UNIX-IPC/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">UNIX IPC</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-05 15:33:19" itemprop="dateCreated datePublished" datetime="2020-03-05T15:33:19+08:00">2020-03-05</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-12 21:38:39" itemprop="dateModified" datetime="2020-03-12T21:38:39+08:00">2020-03-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="进程间通信">进程间通信</h2>
<p>Linux及城建通信可以分为两类，一类是同一台主机之间的进程间通信，另一类是网络之间的进程通信。<br>
同一台主机之间的进程通信有以下几种：</p>
<ol>
<li>管道</li>
<li>协程</li>
<li>FIFO</li>
<li>消息队列</li>
<li>信号量</li>
<li>共享存储</li>
<li>UNIX域套接字。</li>
</ol>
<p>而网络通信主要就是套接字通信。</p>
<h2 id="管道">管道</h2>
<p>管道的局限性：</p>
<ol>
<li>半双工。（虽然大多数实现都是全双工，为了移植性，假设是半双工）。</li>
<li>管道只能在具有公共祖先的两个进程之间使用。</li>
</ol>
<p>FIFO没有第二种局限性，UNIX域套接字两种局限性都没有。</p>
<h3 id="函数popen和pclose">函数<code>popen</code>和<code>pclose</code></h3>
<p>popen创建一个FILE stream指针。<br>
指定参数’r’从cmd的标准输出读，指定参数’w’向cmd的标准输入写。</p>
<h2 id="协同进程">协同进程</h2>
<p>UNIX过滤程序从标准输入读取数据，向标准输出读取数据。<br>
当一个过滤程序即产生某个过滤程序的输入，又读取该过滤程序的输出时，它就变成了协同进程。<br>
popen只提供连接到另一个进程的标准输入或者标准输出的单向通道，而协同新城有连接到另一个进程的两个单向管道：一个连接到其标准输入，另一个则连接到它的标准输出。<br>
相当于我们把数据写入一个进程的标准输出，经过它的处理后，又从它的标准输出读出。（可以通过创建两个管道来实现，一个管道向该进程的标准输入写，另一个管道从该进程的标准输出读。）<br>
<strong>注意如果使用标准IO函数测试的话，可能要注意缓冲区的设置。</strong></p>
<h2 id="fifo">FIFO</h2>
<p>FIFO也叫命名管道。但是管道只能在两个相关的进程之间使用，而FIFO可以在任意两个进程之间交换数据。<br>
创建一个FIFO之后，需要使用open打开它。<br>
如果不指定O_NONBLOCK，<strong>只读</strong>open会阻塞到别的进程为写打开这个FIFO为止，而<strong>只写</strong>open会阻塞到别的进程为读而打开这个FIFO为止。<br>
如果指定O_NONBLOCK，只读open总是返回成功。而如果没有其他进程为读打开这个FIFO，返回-1，置位errno为ENXIO。<br>
FIFO的用处：</p>
<ol>
<li>shell命令将数据从一条管道传送到另一条时，无需创建中间临时文件。</li>
<li>客户进程-服务器进程应用程序中，FIFO用作汇集点，在服务器和客户端之间传送数据。</li>
</ol>
<h2 id="xsi-ipc">XSI IPC</h2>
<p>XSI IPC包含三种，分别是消息队列，信号量，共享内存。IPC通过IPC描述符进行访问（和文件描述很像）。但是和文件不同的是，IPC都没有名字，所以要创建多个IPC，怎么区分它们，这个就是key（键）的作用，每一个IPC都有一个键（和文件名字很像）。<br>
问题就是怎么让通信的进程知道它们要使用的IPC描述符？</p>
<ol>
<li>使用IPC_PRIVATE创建一个新的IPC（IPC_PRIVATE保证创建一个新的IPC，将返回的IPC描述符存放在一个文件中。或者就是父子进程之间，直接复制IPC描述符。</li>
<li>在一个公用的头文件中指定一个键，这个键被父进程和子进程都认可。这种可能是键已经被用过了，再创建的时候就会出错。</li>
<li>根据一个路径名和项目ID创建一个键。</li>
</ol>
<p>不能使用IPC_PRIVATE作为一个键来引用消息队列，引用消息队列时要绕过get函数。</p>
<h3 id="优点和缺点">优点和缺点</h3>
<ol>
<li>IPC都是在系统范围内起作用的，没有引用计数，所以，如果进程创建了一个IPC，然后退出，那么这些IPC都不会被删除，需要显式的删除。在使用信号量时，如果进程退出时没有释放信号量，信号量不会被释放。</li>
<li>IPC结构在文件系统中没有名字，所以不能使用操作文件的那些函数，需要增加新的系统调用和命令。<br>
此外，没有办法使用多路转接。</li>
<li>如果显式的删除IPC的话，不管当前有多少个进程在使用，都会被删除。下一次再使用的话就会报错。</li>
</ol>
<h2 id="xsi消息队列">XSI消息队列</h2>
<p>消息队列</p>
<h2 id="xsi信号量">XSI信号量</h2>
<p>XSI信号量是一个计数器，用于为多个进程提供对共享数据的访问。但是XSI信号量不是单个信号量，而是一个信号量的集合。<br>
需要使用<code>semget</code>创建一个信号量集合（数量可以等于1）。<br>
然后使用<code>semget</code>获得一个信号量描述符（成功创建时返回的也是信号量描述符）。<br>
接下来使用<code>semctl</code>设置每个信号量的值。<br>
使用<code>semop</code>控制信号量值的增和减。</p>
<p>XSI信号量的缺点：</p>
<ol>
<li>是一个信号集合。</li>
<li>信号量的创建和初始化是分开的。</li>
<li>当进程退出时，可能没有释放分配给他的信号量，使用SEM_UNDO解决。</li>
</ol>
<h2 id="xsi共享内存-2">XSI共享内存[2]</h2>
<p>共享内存允许两个或者多个进程共享一个给定的存储区。因为数据不需要在客户进程和服务器进程之间进行复制，这是最快的一种IPC。<br>
使用共享内存时，需要注意的是，在多个进程之间同步访问一个给定的存储区。通常使用信号量同步共享内存，当然也可以使用互斥量和记录锁，线程锁共享。</p>
<p>共享内存和存储IO映射的区别，用mmap映射的存储段是和文件相关的，而XSI共享内存并没有这种限制。</p>
<h2 id="它们之间的区别">它们之间的区别</h2>
<ol>
<li>信号量和互斥量的区别。都表示对于资源的访问权，但是信号量的资源计数可以超过1，而互斥量的资源计数为1。</li>
<li>消息队列。</li>
</ol>
<h2 id="进程间传递字符串">进程间传递字符串</h2>
<p>若果需要两个进程间的双向数据流，可以使用消息队列和全双工管道。</p>
<ol>
<li>全双工管道。</li>
<li>消息队列。先创建一个消息队列，然后调用fork，它们就可以实现通信了。因为消息队列不能使用IPC_PRIVATE作为一个KEY打开消息队列。</li>
</ol>
<h2 id="进程同步的方法">进程同步的方法</h2>
<p>信号量，记录锁和互斥量的比较。如果在多个进程中共享同一个资源，可以使用这三种方法的任意一种来实现。</p>
<ol>
<li>使用信号量。创建一个包含一个成员的信号量集合，将该信号量的值初始化为1。为了分配资源，以sem_op为-1调用semop，为了释放资源，以sem_op为+1调用semop。对每个操作都指定SEM_UNDO，处理在未释放资源条件下进程终止的情况。</li>
<li>使用记录锁。创建一个空文件，并且使用该文件的第一个字节（无需存在）作为锁字节，为了分配资源，先对该字节获得一个写锁。释放资源时，对该字节解锁。记录锁的性质保证了一个锁的持有者进程终止时，内核会自动释放资源。</li>
<li>使用互斥量。所有的进程将相同的文件映射到它们的地址空间中，使用PTHREAD_PROCESS_SHARED互斥量属性在文件的相同偏移处初始化互斥量。为了分配资源，对互斥量加锁。为了释放资源，解锁互斥量。如果一个进程没有释放互斥量而终止，恢复是非常困难的。</li>
</ol>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://www.cnblogs.com/my_life/articles/4538299.html" target="_blank" rel="noopener">https://www.cnblogs.com/my_life/articles/4538299.html</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/03/03/UNIX-advanced-IO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/03/03/UNIX-advanced-IO/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">UNIX advanced IO</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-03-03 15:21:19" itemprop="dateCreated datePublished" datetime="2020-03-03T15:21:19+08:00">2020-03-03</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-04 18:53:15" itemprop="dateModified" datetime="2020-03-04T18:53:15+08:00">2020-03-04</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/UNIX/" itemprop="url" rel="index"><span itemprop="name">UNIX</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="记录锁">记录锁</h2>
<h2 id="select和poll">select和poll</h2>
<h3 id="select和pselect">select和pselect</h3>
<h3 id="poll">poll</h3>
<h2 id="异步io">异步IO</h2>
<h2 id="readv和writev">readv和writev</h2>
<p>readv从文件描述符指定的文件中读取相应的数据到多个缓冲区。<br>
writev将多个缓冲区中的内容写入文件描述符中。</p>
<h2 id="readn和writen">readn和writen</h2>
<p>适用于已经知道要读取和写入的字节数量的情景。其实就是多次调用非阻塞的read和write进行操作。</p>
<h2 id="存储映射io">存储映射IO</h2>
<p>mmap将一个磁盘文件映射到存储空间的一个缓冲区上。从缓冲区读，就相当于读文件中的相应字节。从缓冲区写，就相当于写文件中的相应字节。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/29/Network-常见面试题目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/29/Network-常见面试题目/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">Network 常见面试题目</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-29 21:44:42" itemprop="dateCreated datePublished" datetime="2020-02-29T21:44:42+08:00">2020-02-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-09 14:47:06" itemprop="dateModified" datetime="2020-03-09T14:47:06+08:00">2020-03-09</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="套接字">套接字</h2>
<p>套接字是一个同一台主机内应用层和网络层之间的接口。由于套接字是在网络上建立网络应用程序的可编程接口，所以也把套接字称为应用程序和网络之间的应用编程接口。</p>
<p>一个UDP套接字是由目的IP地址和目的端口号标识的二元组。两个UDP报文段，只要目的IP地址和目的端口号一样，不论源IP地址和端口号是否一样，都被定向到相同的目的进程。<br>
一个TCP套接字是由源IP地址，源端口号，目的IP地址，目的端口号构成的四元组。所有的这四元组都被用来进行多路分解。</p>
<h2 id="常见应用层协议">常见应用层协议</h2>
<p>DNS<br>
FTP<br>
HTTP<br>
SMTP</p>
<h2 id="http">HTTP</h2>
<h3 id="http请求报文段">HTTP请求报文段</h3>
<p>HTTP包含一行请求行和多行首部行。<br>
请求行有三个字段：方法字段，URL字段，HTTP协议版本字段。<br>
方法字段有GET，POST，HEAD，PUT和DELETE。</p>
<ol>
<li>Host，目标主机。</li>
<li>Connection，浏览器告诉服务器不希望使用持久连接。</li>
<li>User-agent，浏览器。</li>
<li>Accept-language</li>
</ol>
<h3 id="http响应报文段">HTTP响应报文段</h3>
<p>一个状态行和6个首部行，然后是报文实体。<br>
状态行：<br>
协议版本，状态码和相应状态信息。<br>
6个首部行：</p>
<ol>
<li>Connection，不适用持久链接。</li>
<li>Date，服务器产生发送报文的时间。</li>
<li>Server，服务器类型。</li>
<li>Last-Modified，对象创建或者修改的最后日期。</li>
<li>Content-Length，发送内容的长度。</li>
<li>Content Type，发送内容的类型。</li>
</ol>
<h3 id="http状态码-3-4-5">HTTP状态码[3,4, 5]</h3>
<p>1xx信息<br>
2xx成功<br>
200 OK 请求成功<br>
201 Created 当服务器按照客户端的的请求创建了一个新的资源时，发送此响应代码。<br>
204 No Content。服务端拒绝对PUT，POST或者DELETE请求返回任何状态信息。返回空文件替换缓存。而304是使用上次的缓存。<br>
3xx 重定向，客户端需要做一些额外的工作才能得到所需要的资源，他们通过用于GET请求。<br>
301 Moved Permanently 服务器知道客户端请求的资源，但是不喜欢客户端使用当前URL。<br>
302 Found。临时性重定向。不是永久性移动，而是临时性移动。比如说用户把uri保存为书签，出现301时，书签会被更新，出现302时不会。。<br>
303 See Other。请求已经被处理，但是服务器返回的不是文档，是一个URI。和302功能一样，但是303明确表示客户端应该使用GET方法获取资源。<br>
304 Not modified。客户端有数据主题，不需要重复发送。<br>
307 Temporary Redict。临时性重定向，和302有着相同的意思。但是不会将POST修改成GET。<br>
301,302,303响应状态码返回时，几乎所有的浏览器都会把POST改成GET，删除请求体，再次发送请求。尽管301,302是禁止将POST改成GET的，但是大家都会这么做。<br>
4xx表示客户端错误<br>
400 Bad Request，服务器收到了请求，但是不知道什么意思。<br>
401 请求要求用户的身份认证，而客户端认证失败。<br>
403 客户端的请求正确，但是服务端拒绝此请求，暗示了请求的资源确实存在。<br>
404 Not Found，服务器无法把客户端请求的URI转换为一个资源。<br>
405 客户端中请求的方法被禁止<br>
5xx表示服务器错误<br>
500 对于大多数web框架，如果在执行请求处理代码时遇到了异常，就发送此代码。<br>
505 HTTP Version Not Support</p>
<h3 id="get和post区别">GET和POST区别</h3>
<ol>
<li>GET一般是从服务器获取数据，而post一般是向服务器传送数据。</li>
<li>GET会把请求的数据会放在URL后面，而POST把请求的数据放在body中。注意，GET的body也可以存放request body。</li>
<li>GET请求提交的url数据最多是1024字节是浏览器或者服务器限制的。而post则没有限制。</li>
<li>GET和POST都不安全，HTTP本身是明文协议，无论是url,header还是body，都是在网络中明文传播的。只不过url中的数据是可以在浏览器中直接看到的，而header和body中的数据更麻烦一些，需要使用抓包软件查看。</li>
<li>但是GET的效率要比post高。</li>
</ol>
<h3 id="https和http-2">HTTPS和HTTP[2]</h3>
<p>HTTP协议是明文协议，TCP和UDP也没有加密。于是就有了SSL，利用非对称密码体系对发送的数据进行加密。</p>
<h3 id="输入www-baidu-com发生的一切">输入www.baidu.com发生的一切</h3>
<ol>
<li>用户输入网址。</li>
<li>DNS解析。递归查询和迭代查询。<br>
还可以加上其他的，比如IP协议，ARP协议。</li>
<li>TCP连接。三次握手。</li>
<li>发送请求。</li>
<li>接收HTTP相应报文</li>
<li>浏览器渲染。</li>
</ol>
<h3 id="cookie">Cookie</h3>
<p>Cookie用户和服务器的交互。因为HTTP是无状态的，简化了服务器的设计。当想要识别用户的时候，可能限制用户的访问或者想把用户和内容关联起来。HTTP使用了cookie：<br>
cookie有四个部分：</p>
<ol>
<li>HTTP响应报文中有一个cookie首部行。</li>
<li>HTTP请求报文中有一个cookie首部行。</li>
<li>用户端系统有保留一个cookie文件。</li>
<li>Web站点后台有一个cookie数据库。</li>
</ol>
<h3 id="web缓存">Web缓存</h3>
<p>Web缓存器也叫代理服务器，它有自己的磁盘存储空间，并在自己的磁盘存储空间中保存最近请求过的对象拷贝。<br>
然后可以配置浏览器，将用户的所有HTTP请求首先指向Web缓存器，一旦配置了浏览器，每个浏览器对象的请求首先被定向到Web缓存器。</p>
<ol>
<li>浏览器建立一个到Web缓存器的TCP连接，并发送一个HTTP请求。</li>
<li>Web缓存器检查缓存是命中。</li>
<li>命中的话，Web缓存器向发送一个条件GET，查询Last-modified。</li>
<li>没有命中的话，Web缓存器请求该对象，并将其缓存。</li>
<li>Web缓存器向客户机浏览器发送报文。</li>
</ol>
<h3 id="session-cookie和token">Session，Cookie和Token</h3>
<h2 id="tcp和udp的选择">TCP和UDP的选择</h2>
<p>DNS通常采用UDP，因为TCP需要建立连接，会引入建立连接的时延，这样子会慢得多。如果没有收到响应，就会向另一台DNS服务器发送查询，或者通知调用的程序它不能获得响应。<br>
而HTTP使用TCP而不是UDP，因为web网页需要的是可靠性。</p>
<h2 id="udp">UDP</h2>
<p>UDP相对于TCP的优势：</p>
<ol>
<li>应用层能更好的控制要发送的数据和发送时间。</li>
<li>无需连接建立。</li>
<li>无连接状态。</li>
<li>分组首部开销小。TCP报文段有20字节的首部开销，而UDP只有8字节的开销。</li>
</ol>
<h3 id="udp报文段结构">UDP报文段结构</h3>
<p>UDP报文段的首部共8个字节，64位，每个字段8位，共4个字段，：</p>
<ol>
<li>16位源端口号</li>
<li>16位目的端口号</li>
<li>16位长度字段，长度字段包含了首部在内的UDP报文段的长度（以字节为单位）。</li>
<li>16位检验和</li>
</ol>
<h3 id="udp校验和">UDP校验和</h3>
<ol>
<li>UDP校验和提供了差错检测功能，但是不能进行差错恢复。为什么UDP校验和work？</li>
<li>为什么要进行差错校验？链路中可能出错，内存中也可能出错。UDP必须在端到端基础上在运输层提供差错校验。</li>
<li>出错后如何处理。一些实现是丢弃受损的报文段，一些是将受损的报文段交给应用程序并告警。</li>
</ol>
<h2 id="可靠数据传输原理">可靠数据传输原理</h2>
<h3 id="停止等待协议">停止等待协议</h3>
<p>为了解决分组可能出错的情况，引入<strong>自动重传请求</strong>。自动重传请求协议需要另外三种协议：差错检验，接收方反馈和重传。<br>
当一个分组到达时可能出错，接收方进行进行<strong>差错校验</strong>，如果出错，发送一个NAK给发送方。如果没有失败，发送一个ACK给接收方。<br>
直到发送方确定接收方已经收到当前分组之后（收到一个ACK），才会继续发送新数据，这就是<strong>停止等待协议</strong>。如果收到一个NAK，就会重传当前分组。（<strong>接收方反馈</strong>）<br>
但是ACK和NAK也可能出错或者丢失，通过引入<strong>重传</strong>解决这个问题。<br>
到底什么时候重传呢？等待一个RTT太久了，可以使用一个定时器设置一个时间，超过这个时间就重传。<br>
这样子在接收方引入了冗余分组的问题。冗余分组的问题在于不知道接收方发送的ACK或者NAK是否被发送方接收，或者是分组没有丢失，等到了一段时间又到了。接收方不知道接收到的分组到底是哪一个，是重发的分组还是新的分组。可以通过引入分组序号解决这个问题。在停止等待协议中，一个比特的分组序号就够了。<strong>所以也叫比特交替协议</strong>。</p>
<h3 id="流水线可靠数据传输协议">流水线可靠数据传输协议</h3>
<p>停止等待协议的效率太低了。流水线可靠数据传输协议不是一次只发一个分组，而是一次发送多个分组，就好像一条流水线一样。这就产生了几个问题：</p>
<ol>
<li>必须增加序号范围，原来只要一个比特就够了，现在需要多个。</li>
<li>协议的发送方和接收方也必须能够缓存多个分组。</li>
<li>流水线中如果分组丢失了，有两种方式进行差错恢复，回退N步（GBN）和选择重传（SR）。</li>
</ol>
<h3 id="回退n步">回退N步</h3>
<p>GBN的发送方要处理是三个工作，准备N个分组，处理接收方返回的ACK，以及超时重传。<br>
GBN的接收方要处理的工作，只有接收到的分组的序号和上一次相同，会返回给发送方一个ACK，GBN采用<strong>累计确认</strong>（对序号n的分组的确认表明接收方已经正确接收到n以及n之前的分组了）。所有其他情况，都会丢弃分组。比如失序分组，接收方应该接收序号为n的分组，但是收到了序号为n+1的分组，就会丢弃，而不是缓存。</p>
<p>GBN维护一个大小为N的窗口。对于发送方，维护一个大小为N的窗口，如果这N个分组的ACK都没有收到，就不会发送新的数据，等待接收方返回ACK。发送方还有超时设置，（发送方发送的分组丢了，或者接收方返回的ACK丢了），都会重传。</p>
<h3 id="选择重传">选择重传</h3>
<p>GBN有时候会效率太低，因为一个分组丢失，可能导致重传整个N个分组。选择重传可以用来解决这种问题。</p>
<h2 id="tcp">TCP</h2>
<h3 id="tcp累计确认和gbn-选择重传之间的关系">TCP累计确认和GBN，选择重传之间的关系</h3>
<p>GBN是滑动窗口协议，虽然也提供累计确认，但是它不会缓存失序报文，会把它们全部丢弃。假设序号为n的报文段丢失了，然后需要发送方重传n之后的所有报文。而TCP的发送方至多只会重传一个报文段，如果TCP接收方接收到了<br>
选择重传对失序报文进行缓存，但是没有提供累计确认。</p>
<h3 id="可靠数据传输">可靠数据传输</h3>
<p>TCP发送方有三个与发送和重传有关的主要事件：</p>
<ol>
<li>数据处理。TCP从发送缓存重拿数据，加上TCP首部，传递给IP层。然后传递给网络，TCP接收方的接收缓存获取数据。</li>
<li>超时。<br>
通过重传引发超时的报文响应超时时间。如果多次超时的话，就倍增超时时间间隔。<br>
冗余ACK触发<strong>快速重传</strong>（为什么发送方收到三个冗余ACK就立即快重传）。冗余ACK是对按序接收到的最后一个字节数据进行重复确认。</li>
<li>ACK处理。如果收到的ACK是窗口的最小未确认序号，那么修改窗口的最小未确认序号。</li>
</ol>
<h3 id="三次握手">三次握手</h3>
<ol>
<li>A向B发送一个SYN报文段，并且包含自己的初始序列号。</li>
<li>B向A发送一个SYNACK报文段，并且包含自己的初始序列号。同时分配连接缓存，变量等。</li>
<li>A向B发送一个ACK报文段，不是SYN报文段。</li>
</ol>
<h3 id="为什么要随机初始化一个报文段序号">为什么要随机初始化一个报文段序号</h3>
<p>减少上次TCP连接中的报文段被当做两台主机之间新的TCP连接中的报文段。</p>
<h3 id="为什么是三次握手而不是两次或者四次">为什么是三次握手而不是两次或者四次</h3>
<p>其实是四次挥手，只不过第二次和第三次可以合并起来了。三次挥手的目的是确立TCP双方都能获得对方的初始序号。<br>
为什么不是两次？如果A向B发送一个请求，B回应一个请求。而B的回应丢了，A就无法和B进行通信。如果设计成A重传，那么可能会建立很多个连接。如果设计成B重传，为什么要B重传？不是两次握手吗？他怎么知道要重传。这些都是如果设计成两次握手需要考虑的问题。<br>
对于三次握手来说，如果</p>
<ol>
<li>A发给B的丢了，A超时重传。</li>
<li>B发给A的丢了，B超时重传。B分配缓存，变量等。</li>
<li>A又发给B的丢了，这时候B已经认为建立了连接。<br>
如果双方都没有数据，那么会触发第二步的超时重传。<br>
如果A要发送数据，那么A会直接把数据发给B，就肯定建立连接了。<br>
如果B要发送数据，也会触发第二步的超时重传。</li>
</ol>
<h3 id="四次挥手">四次挥手</h3>
<ol>
<li>A发给B FIN报文段。A执行主动关闭。</li>
<li>B发给A ACK。B进行WAIT-TIME。等待B终止连接，这个时候B可以给A发送数据，但是A不能给B发送数据。B执行被动关闭，B处于CLOSE_WAIT状态。</li>
<li>B发给A FIN报文段。A收到报文段之后处于TIME_WAIT状态。</li>
<li>A发给B ACK。这个时候A要等待30s或者1分钟，两分钟。因为需要确认B那边收到了ACK，否则的话，B就无法关闭。</li>
</ol>
<h3 id="流量控制">流量控制</h3>
<p>TCP通过让发送方维护一个16位的接收窗口（是接收方的）的变量来提供流量控制。不正式的说，接收窗口用于告诉发送方，接收方还有多少可用的缓存空间。TCP是全双工的，两端都维护一个接收窗口。<br>
接收方将自己的缓冲区大小填入TCP首部的窗口长度字段。这个字段是多少：缓冲区的大小 - （缓冲区中的最后一个字节编号 - 从缓冲区中读出的最后一个字节）。<br>
如果接收方窗口大小为0怎么办？这时发送方不给接收方发报文，而接收方也不发，只有在有数据或者ACK要发的时候，接收方才会给发送方发报文。随着接收方应用程序从缓冲区取走数据，发送方也不能继续发数据。这个时候怎么办？规定：当接收方的接收窗口大小为0时，发送方会不断发送含有一个数据字节的报文段。</p>
<h3 id="拥塞控制">拥塞控制</h3>
<p>分组重传是网络拥塞的征兆，却不能解决网络拥塞问题。</p>
<p>慢启动。<br>
快重传。<br>
快恢复。</p>
<h3 id="long-fat-network">long fat network</h3>
<p>高带宽和长时延网络情况，被称为长肥网络。带宽和时延的乘积表示网络通道的容量，也就是能够在网络中缓冲的数据量，显然增加带宽和时延都增加在网络中缓冲的数据量。但是随着它们乘积的不断变大，TCP的局限就开始显露出来。常规的窗口大小是16位的，能接收和发送的最大大小为65535，而BDP远大于这个值。TCP就不得不发送一会数据就等待ACK，极端情况下有点像停止等待协议。<br>
缺点</p>
<ol>
<li>窗口小，序号少，无法充分利用带宽。窗口扩展项。</li>
<li>时延长。快重传。</li>
<li>序号用的很快。PAWS算法。</li>
<li>RTT比较难测量。引入时间戳。</li>
</ol>
<h2 id="tcp和udp的区别">TCP和UDP的区别</h2>
<ol>
<li>TCP面向连接，UDP无连接。</li>
<li>TCP提供可靠数据传输，UDP提供不可靠数据传输。</li>
<li>TCP的逻辑通信信道是全双工的可靠信道，而UDP是不可靠信道。</li>
<li>TCP面向字节流，把数据看成一个无结构但是有序的字节流。UDP面向报文段。</li>
<li>TCP有流量控制，拥塞控制，UDP无。</li>
<li>TCP很慢，而UDP很快。</li>
<li>TCP首部20个字节，UDP是8个字节。</li>
</ol>
<h2 id="dos攻击">Dos攻击</h2>
<p>Dos（拒绝服务）攻击是一种宽泛类型的攻击，可以分为三类：</p>
<ul>
<li>弱点攻击</li>
<li>带宽洪泛。攻击者向目的主机发送大量的分组，导致目标的介入链路变得非常拥塞，使得合法的分组无法到达服务器。</li>
<li>连接洪泛。创建大量的全开或者半开TCP连接。</li>
</ul>
<p>DDos攻击，分布式拒绝服务攻击。</p>
<h3 id="syn洪泛攻击">SYN洪泛攻击</h3>
<p>攻击者发送大量的SYN报文段，而不完成TCP握手的第三步，服务器不断地为这些半开连接服务器分配资源，导致服务器资源被迅速消耗。<br>
怎么预防？SYN cookies，当服务器收到一个TCP连接时，不生成一个TCP半开连接，只生成一个初始序列号（精心计算的序列号，被称为cookie），然后发送这种序列号的SYNACK报文段。<br>
如果客户机是合法的，客户机返回一个ACK，服务器收到ACK。然后利用这个ACK计算一个，这个ACK是否对应客户机发送的SYN报文段，如果是，生成一个全开的连接。</p>
<h3 id="dns攻击">DNS攻击</h3>
<p>DDos带宽洪泛攻击。攻击者向多个DNS根服务器发送大量的分组，使得大多数合法的DNS请求得不到回答。比如发送大量的ICMP报文。<br>
怎么预防？分组过滤器，过滤ICMP报文。还有就是本地DNS服务器缓存了顶级域名服务器的地址。使得请求绕过了DNS根服务器。</p>
<h2 id="传输层协议">传输层协议</h2>
<p>TCP协议。<br>
UDP协议。<br>
运输层协议是在端系统而不是网络路由器中实现的。<br>
端口号。<br>
socket？</p>
<h2 id="网络层协议">网络层协议</h2>
<p>IP协议，IP协议为主机之间提供了逻辑通信，它的服务模型是尽力而为交互服务。<br>
ICMP协议。<strong>互联网控制消息协议</strong>。最典型的应用是差错报告。ICMP报文有一个类型字段和一个编码字段，并且包含由该ICMP报文首次生成的IP数据报的首部和前8字节内容，以便于发送方能够确定引发该差错的数据报。<br>
ping程序发送一个ICMP类型为8编码为0的报文到指定主机（表示回显请求），看到该回显请求的目的主机发送一个类型0编码为0的报文回显回答。<br>
traceroute原理。traceroute利用ICMP报文实现，源主机中的该程序向目的主机发送一系列普通的IP数据报，每一个数据报都携带了一个具有不可达UDP端口号的UDP报文段，第i个报文段的TTL(time to live，确保数据报不会永远在网络中循环，每过一个路由器，字段值减一)是i。同时，源主机为每个数据报启动定时器，当第i个数据报到达第i个路由器时，TTL为0。根据IP协议的规则，路由器会向源主机发送一个ICMP告警报文（类型为11，编码为0）。该告警报文含有路由器的名字和IP地址，该ICMP报文到达源主机时，源主机从定时器得到RTT，从ICMP报文得到路由器名字和IP地址。那么什么时候停止发送数据报？当其中一个报文到达目的主机的时候，由于数据报包含了一个不可达的端口，所以目的主机会发送类型为3，编码为3的目的端口不可达的ICMP报文。<br>
IGMP协议。网际组管理协议。用于多播。<br>
ARP协议，地址解析协议。是算在链路层还是网络层？把IPv4地址转换成硬件地址。<br>
RARP协议，反向地址解析协议。把硬件地址映射成IPv4地址。<br>
路由器属于网络层设备，它只检查网络层字段。<br>
IP地址。</p>
<p>MTU（最大传输单元），以太网的MTU是1500字节。IPV4要求最小MTU是68字节（20字节首部长度和40字节选项，以及8字节的偏移）。IPV6要求的最小MTU是1280字节。两个主机路径上的最小MTU称为路径MTU。路径MTU可以不对称。<br>
当IP数据报的大小超过链路MTU时，执行分片。<br>
最小重组缓冲区是IPV4(6)的任何实现都必须保证支持的最小数据报大小，IPV4是576字节，IPV6是1500字节。超过这个大小，就不一定能被接收方识别。所以，使用UDP的网络应用的报文段一般都不超过这个大小。<br>
MSS（最大报文段）是用来通过对方，自己这面能够接收的最大TCP报文段大小，也就是最小重组缓冲区的实际值。MSS的大小通常设置为MTU减去IP和TCP首部的长度。</p>
<p>如果</p>
<h2 id="数据链路层">数据链路层</h2>
<p>成帧，透明传输，差错检测。<br>
MAC地址。<br>
交换机，网桥。<br>
MAC地址。</p>
<h2 id="物理层">物理层</h2>
<p>集线器，中继器。</p>
<h2 id="参考文献">参考文献</h2>
<p>1.《计算机网络自顶向下》<br>
2.<a href="https://segmentfault.com/a/1190000016855991" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016855991</a><br>
3.<a href="https://www.cnblogs.com/xflonga/p/9368993.html" target="_blank" rel="noopener">https://www.cnblogs.com/xflonga/p/9368993.html</a><br>
4.<a href="https://www.cnblogs.com/aliwa/p/8495014.html" target="_blank" rel="noopener">https://www.cnblogs.com/aliwa/p/8495014.html</a><br>
5.<a href="https://blog.csdn.net/qq_39816673/article/details/89611936" target="_blank" rel="noopener">https://blog.csdn.net/qq_39816673/article/details/89611936</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/29/OS-常见面试题目/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/29/OS-常见面试题目/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">OS 常见面试题目</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-29 21:43:49" itemprop="dateCreated datePublished" datetime="2020-02-29T21:43:49+08:00">2020-02-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-12 13:32:03" itemprop="dateModified" datetime="2020-03-12T13:32:03+08:00">2020-03-12</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/操作系统/" itemprop="url" rel="index"><span itemprop="name">操作系统</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="中断和异常">中断和异常</h2>
<p>中断通常被定义为改变处理器执行指令顺序的事件。终端常常被分为同步中断和异步终端：<br>
同步中断是指指令执行时由CPU控制单元产生的。（异常）<br>
异步中断是指其他硬件设备依照CPU时钟信号随机产生的。（中断）<br>
Intel x86把同步和异步中断分别称为异常和中断。</p>
<p>中断提供了一种方式，是处理器转而去做正常控制流之外的代码。</p>
<h2 id="netstat">netstat</h2>
<p>netstat监控网络连接，路由表等，网络接口等。<br>
netstat默认打印所有打开的socket连接。<br>
-a, --all展示所有的listening和没有listening的sockets。<br>
-l, --listening，展示所有listening的socket，默认情况下是忽略的。<br>
-p, --program，每一个socket属于哪一个程序和pid。<br>
-n, --numeric，数值展示host，port和用户名。<br>
-t, --tcp<br>
-u, --udp<br>
-r打印路由表。<br>
-i打印网络接口。</p>
<h2 id="lsof">lsof</h2>
<p>列出打开的文件。</p>
<h2 id="ip">ip</h2>
<p>ip address，查看ip地址。<br>
ip link，查看网络设备。</p>
<h2 id="原子操作">原子操作</h2>
<p>原子操作指的是由多步组成的操作，要么执行完所有步骤，要不一步也不执行。</p>
<h2 id="程序和线程">程序和线程</h2>
<p>程序是一个存储在硬盘上的可执行文件。<br>
程序的执行实例被称为进程，它是操作系统对一个正在运行的程序的一个抽象。</p>
<h2 id="fork和vfork区别">fork和vfork区别</h2>
<ol>
<li>fork采用copy-on-write，而vfork在调用exec之前和父进程共享数据。</li>
<li>fork不对子进程的执行顺序做任何要求，而vfork要求子进程先运行，父进程挂起，知道子进程调用了exec或者exit之后，父进程恢复运行。</li>
</ol>
<h2 id="进程和线程的区别">进程和线程的区别</h2>
<ol>
<li>进程是资源分配和调度的最小单位，而线程是CPU调度的最小单位。</li>
<li>一个进程可以包括多个线程，并且至少包括一个线程，所有的线程共享进程的资源。</li>
<li>线程具有自己的私有属性。比如线程ID，寄存器，线程私有数据。</li>
<li>线程中通常要进行同步操作，当多个线程共享线相同的内存时，需要使用同步操作确保他们看到一致的视图。</li>
<li>进程之间交换信息要使用进程间通信。</li>
<li>一个进程结束后所有线程都将终止。</li>
<li>而一个线程结束通常不会影响其他线程（如果调用了exit就会终止所有线程。）</li>
<li>线程是轻量级的进程，它的创建和销毁的代价要比进程小。</li>
</ol>
<h2 id="进程页表">进程页表</h2>
<p>一个进程的线程地址空间被分成两部分，通常是3G的用户空间和第四个G的内核空间。</p>
<h2 id="进程都有哪些资源">进程都有哪些资源</h2>
<p>寄存器<br>
堆<br>
栈<br>
数据段<br>
代码段<br>
文件描述符<br>
锁<br>
信号</p>
<h2 id="进程都有哪些区域">进程都有哪些区域</h2>
<p>可执行代码<br>
初始化数据<br>
未初始化数据<br>
堆<br>
栈</p>
<h2 id="进程创建">进程创建</h2>
<p>怎么创建一个进程。调用fork复制进程的数据空间，代码段，堆和栈的副本。现在的fork利用写时复制，这些区域由父进程和子进程共享，内核将它们的访问权限修改为只读，如果父进程和子进程中的任何一个试图修改这些区域，内核只为修改的那篇区域（通常是一页）制作一个副本，原来的页仍是受到保护的，当其他进程试图写入时，内核会检查写进程是不是这个页的唯一属主，如果是，他把这个页标记为对这个进程是可写的。通过使用一个引用计数记录共享相应页的进程数目。</p>
<h2 id="fork做了什么">fork做了什么</h2>
<h2 id="exec做了什么">exec做了什么</h2>
<h2 id="进程执行">进程执行</h2>
<p>进程，是一个程序的执行实例。<br>
每个进程都由一个进程描述符表示，这个描述符包含有关进程当前状态的信息。当内核暂停一个进程的执行时，它在进程描述符中保存好几个寄存器的内容：</p>
<ul>
<li>程序计数器和栈指针寄存器</li>
<li>通过寄存器</li>
<li>包含CPU状态信息的处理器控制寄存器</li>
<li>内存管理寄存器。</li>
</ul>
<p>进程描述符用一个结构体task_struct表示。这个结构体中包含tty_struct，fs_struct，files_struct, mm_struct和signal_struct以及其他更多。</p>
<h2 id="进程状态">进程状态</h2>
<p>进程描述符中的状态域描述了进程当前可能所处的状态，有五种：</p>
<ol>
<li>运行状态</li>
<li>中断</li>
<li>不可中断</li>
<li>停止</li>
<li>僵死状态。</li>
</ol>
<h2 id="进程切换">进程切换</h2>
<p>为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行，这种行为被称为进程切换。linux中进程切换的主要内容：</p>
<ol>
<li>硬件上下文。</li>
<li>硬件支持。</li>
<li>Linux代码</li>
<li>保存浮点寄存器。</li>
</ol>
<h2 id="进程结束">进程结束</h2>
<p>使用exit，使用return ，使用Exit，进程的最后一个线程调用pthread_exit。<br>
调用abort，进程接收到某些信号，最后一个线程对cancel做出请求。</p>
<h2 id="进程通信">进程通信</h2>
<p>独立进程访问同一个对象的方法。使用共享内存，然后使用信号量，记录锁，或者读写锁进行进行保护。<br>
如何传递一个字符串？使用FIFO？</p>
<h2 id="线程都有哪些资源">线程都有哪些资源</h2>
<p>私有的：程序计数器，栈空间和寄存器。</p>
<h2 id="线程创建">线程创建</h2>
<p>pthread_create。</p>
<h2 id="线程结束">线程结束</h2>
<p>pthread_exit<br>
cancel<br>
从启动例程返回。</p>
<h2 id="线程同步">线程同步</h2>
<p>互斥量<br>
读写锁<br>
条件变量<br>
屏障</p>
<h2 id="协程">协程</h2>
<h2 id="select和poll">select和poll</h2>
<h2 id="死锁">死锁</h2>
<h3 id="什么是死锁">什么是死锁</h3>
<p>两个或多个进（线）程在运行过程中相互请求其他进（线）程拥有的资源，造成所有的进程或者线程都无法继续前进。</p>
<h3 id="产生死锁的原因">产生死锁的原因</h3>
<ol>
<li>资源竞争。</li>
<li>加锁的顺序不合适。</li>
<li>对同一个互斥量加锁两次。（APUE线程部分）。</li>
</ol>
<h3 id="产生死锁的必要条件">产生死锁的必要条件</h3>
<ol>
<li>互斥条件：进程要求对所分配的资源进行排他性控制，同一时刻某一个资源只能有一个用户。</li>
<li>请求和保持：进程因请求某个资源而阻塞时，保持已经获得的资源不放。</li>
<li>不剥夺：进程获得的资源没有使用完前，不能被剥夺。</li>
<li>循环等待：A等待B，B等待A。</li>
</ol>
<h3 id="预防死锁的方法">预防死锁的方法</h3>
<p>对应死锁产生的后三个必要条件。资源的互斥条件不能改变。</p>
<ol>
<li>破坏请求和保持条件：资源一次性分配，只要有有一个资源得不到分配，就不给这个进程分资源。</li>
<li>破坏不可剥夺条件：超时放弃已有的锁。</li>
<li>破坏循环等待条件：对所有资源进行排序，以确定的顺序获得锁。</li>
</ol>
<h3 id="避免死锁的方法">避免死锁的方法</h3>
<ol>
<li>一次封锁法。</li>
<li>顺序封锁法。</li>
<li>银行家算法。</li>
</ol>
<h2 id="虚拟内存">虚拟内存</h2>
<h2 id="参考文献">参考文献</h2>
<p>1.《APUE》第三版<br>
2.<a href="https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread" target="_blank" rel="noopener">https://stackoverflow.com/questions/200469/what-is-the-difference-between-a-process-and-a-thread</a><br>
3.<a href="https://www.geeksforgeeks.org/difference-between-process-and-thread/" target="_blank" rel="noopener">https://www.geeksforgeeks.org/difference-between-process-and-thread/</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://mxxhcm.github.io/2020/02/29/C-常见面试题/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="马晓鑫爱马荟荟">
      <meta itemprop="description" content="记录硕士三年自己的积累">
      <meta itemprop="image" content="/images/favicon.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mxxhcm's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/2020/02/29/C-常见面试题/" class="post-title-link" itemprop="http://mxxhcm.github.io/index.html">C 常见面试题</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2020-02-29 21:43:10" itemprop="dateCreated datePublished" datetime="2020-02-29T21:43:10+08:00">2020-02-29</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2020-03-11 22:23:42" itemprop="dateModified" datetime="2020-03-11T22:23:42+08:00">2020-03-11</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/面试/" itemprop="url" rel="index"><span itemprop="name">面试</span></a></span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="static关键字-4">static关键字[4]</h2>
<ol>
<li>隐藏全局变量和函数的作用域。这一个已经被标准抛弃了。</li>
<li>修饰局部变量，改变变量的生命周期。</li>
<li>修饰类的数据成员和成员函数。</li>
</ol>
<h2 id="const关键字">const关键字</h2>
<ol>
<li>顶层const和底层const。主要是常量指针和常量引用。</li>
<li>const修饰形参和const修饰返回值。</li>
<li>和类相关。<br>
修饰成员变量，必须使用初始化列表修饰。<br>
const修饰成员函数。<br>
修饰类对象，必须调用const类型的函数。<br>
const可以用来区分重载。</li>
</ol>
<h2 id="const和宏常量的区别">const和宏常量的区别</h2>
<p>const常量有数据类型，而宏常量没有。编译器可以对前者进行安全检查，对后者只能进行字符替换。</p>
<h2 id="inline-10-11">inline[10,11]</h2>
<ol>
<li>为什么引入inline？避免函数调用的开销，比如说参数入栈，出栈。</li>
<li>inline只适合函数体代码简单的函数使用，不能有循环等语句。适用于规模小，流程直接，频繁调用。</li>
<li>用inline声明的函数并不一定会inline，取决于编译器。</li>
<li>建议inline函数的定义放在头文件中。</li>
<li>类内定义的函数是隐式的inline函数。</li>
<li>inline关键字应该和实现放在一块，只在声明中说明没有用。</li>
<li>慎用内联。</li>
</ol>
<h2 id="inline和宏函数的区别">inline和宏函数的区别</h2>
<ol>
<li>宏函数是由预处理器对宏进行替换，而内联函数是通过编译器控制的。</li>
<li>内联函数是函数，会进行参数检查。只不过在调用的时候像宏一样展开，减少函数调用。</li>
<li>宏是不安全的，而内联是安全的。</li>
</ol>
<h2 id="指针函数和函数指针">指针函数和函数指针</h2>
<p>指针函数是一个函数，返回类型是一个指针而已。<br>
函数指针是一个指针，是一个指向函数的指针。</p>
<h2 id="数组和指针">数组和指针</h2>
<ol>
<li>数组是一块连续存放的空间，指针是一个地址，指针变量是一个变量。</li>
<li>初始化。</li>
<li>大小。</li>
<li>指针数组和数组指针。</li>
<li>作为函数参数。</li>
</ol>
<h2 id="指针和引用的区别">指针和引用的区别</h2>
<ol>
<li>可以定义指针的指针，但是不能（直接）定义引用的引用（模板参数推导的时候可以）。</li>
<li>指针可以被重新赋值。而引用一旦被绑定就不能修改。</li>
<li>指针可以为空，引用不能。</li>
<li>指针本身是一个变量，有它自己的内存地址，以及在栈上的大小。而引用的内存地址和它绑定的对象一样，看起来是一样的，但是实际上是不一样的（编译器做了一些操作），可以把引用当做它引用对象的别名。</li>
<li>指针必须被解引用才能使用，而引用不需要。</li>
<li>指针变量可以进行运算，而引用不能。</li>
<li>const引用可以指向字面值常量，而指针不能（除了字符数组）。</li>
<li>指针本身可以是const的，而引用不能。底层const和顶层const。</li>
</ol>
<h2 id="vector扩容">vector扩容</h2>
<h3 id="为什么不是常数">为什么不是常数</h3>
<p>成倍增长可以保持常数时间复杂度的插入操作。<br>
常数增长的插入时间复杂度是O(n)。<br>
为什么？假设要插入n个元素，成倍增长的倍数是p，常数增长的大小是q。<br>
成倍增长总共的复制开销：<br>
$$ \sum_{i=1}^{log_p^n } p^i $$<br>
常数增长总共的复制开销：<br>
$$\sum_{i=1}^{n/q} qi $$</p>
<h3 id="为什么是1-5或者2">为什么是1.5或者2</h3>
<p>为什么是1.5？可以复用之间的空间。<br>
为什么是2？实现简单。</p>
<h2 id="strlen和sizeof的区别">strlen和sizeof的区别</h2>
<ol>
<li>sizeof是运算符。它的值在编译时就已经确定了，所以不能用来获得动态分配的内存空间的大小。</li>
<li>strlen是函数，在运行时计算的。</li>
<li>静态数组传递给strlen就会退化成指针，在传递给sizeof的时候还是数组。strlen是数组中内容的长度，而sizeof是静态数组声明时的大小。</li>
<li>动态数组(malloc)分配的，strlen能获得数组中内容的大小，而sizeof只能获得指针的大小。</li>
<li>strlen不会计算空字符，而sizeof会。</li>
</ol>
<h2 id="override和overload">override和overload</h2>
<p>只有虚函数能被ovrride。<br>
override是用来实现多态的，函数的参数类型和声明和可以父类中完全一样。<br>
而overload中，函数的参数列表必须不同。它的作用我觉得可能是方便记忆，方便理解。实现同一个功能的函数具有同样的名字。</p>
<h2 id="空类的大小为1字节">空类的大小为1字节</h2>
<p>标准规定空类的大小为1，因为两个不同的对象需要不同的地址表示。标准规定完整对象的大小大于0。</p>
<h2 id="虚函数和虚函数表-12">虚函数和虚函数表[12]</h2>
<h2 id="虚析构函数">虚析构函数</h2>
<p>一个基类总是需要虚析构函数。</p>
<h2 id="虚继承">虚继承</h2>
<p>为什么要有虚继承？<br>
派生类可能多次继承同一个类。默认情况下，派生类会含有继承链上每个类对应的子部分，如果某个类在派生过程中出现了多次，派生类中将包含该类的多个子对象。比如iostream之类的类，肯定不行。<br>
声明成虚继承的继承体系中，无论虚基类在继承体系中出现了多少次，派生类中都只含有一个共享的虚基类子对象。</p>
<h2 id="多态">多态</h2>
<p>C++的多态分为两种，一种是静态多态，通过函数重载和模板实现。<br>
一种是动态多态，虚函数实现。</p>
<p>C实现C++的多态[5,6]。</p>
<h2 id="rtti-13">RTTI[13]</h2>
<p>RTTI是运行时类型识别。</p>
<h2 id="cast"><code>cast</code></h2>
<h3 id="static-cast"><code>static_cast</code></h3>
<p>和C中提供的强制类型转换一样。</p>
<h3 id="const-cast"><code>const_cast</code></h3>
<p>只能改变运算对象的底层const，可能去掉也可以添加底层const。</p>
<h3 id="reinterprect-cast"><code>reinterprect_cast</code></h3>
<p>为运算对象的bit mode提供新的解释。比如可以把一个整数解释成字符串。</p>
<h3 id="dynamic-cast"><code>dynamic_cast</code></h3>
<p><code>dynamic_cast</code>实现安全的动态转换。<br>
它可以可以安全实现的执行downcast，但是需要是含有虚函数的类。</p>
<h2 id="智能指针">智能指针</h2>
<h3 id="shared-ptr实现">shared_ptr实现</h3>
<p>引用计数放在指针成员中。<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">shared_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">shared_ptr</span>():pd(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>(T *data): pd(data), <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>)</span><br><span class="line">    &#123; &#125; </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拷贝构造函数</span></span><br><span class="line">    <span class="keyword">explicit</span> <span class="built_in">shared_ptr</span>(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;T&gt; &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        pd = rhs.pd; </span><br><span class="line">        count = rhs.count;</span><br><span class="line"></span><br><span class="line">        ++*rhs.count;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;T&gt;&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;T&gt; &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count &amp;&amp; --*count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> pd;</span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pd = rhs.pd;</span><br><span class="line">        count = rhs.count;</span><br><span class="line">        <span class="keyword">if</span>(rhs.count)</span><br><span class="line">            ++*count;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~<span class="built_in">shared_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(count &amp;&amp; --*count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">delete</span> pd; </span><br><span class="line">            <span class="keyword">delete</span> count;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *p;</span><br><span class="line">    &#125;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> *p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"></span><br><span class="line">    T *pd;</span><br><span class="line">    <span class="keyword">size_t</span> *count;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="unique-ptr实现">unique_ptr实现</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">unique_ptr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">unique_ptr</span>():p(<span class="literal">nullptr</span>)</span><br><span class="line">    &#123; &#125;</span><br><span class="line">    <span class="comment">// 构造函数</span></span><br><span class="line">    explicit unique_ptr(T *data): p(data)</span><br><span class="line">    &#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝构造</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>(<span class="keyword">const</span> <span class="built_in">unique_ptr</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拷贝赋值</span></span><br><span class="line">    <span class="built_in">unique_ptr</span>&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> <span class="built_in">unique_ptr</span> &amp;rhs) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//析构</span></span><br><span class="line">    ~<span class="built_in">unique_ptr</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T *q = p;</span><br><span class="line"></span><br><span class="line">        p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">return</span> q; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T* <span class="title">reset</span><span class="params">(T *data)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            <span class="keyword">delete</span> p;</span><br><span class="line">        p = data;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() &#123;<span class="keyword">return</span> *p;&#125;</span><br><span class="line">    <span class="comment">//指针本身是个常量</span></span><br><span class="line">    <span class="comment">// const 修饰this指针，常量指针，指向不能改变，指针指向的值可以改变。为什么这里返回值不是常量。这个指针可不可以指向常量对象，可以。</span></span><br><span class="line">    T&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123;<span class="keyword">return</span> *p&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T *p;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="shared-ptr和unique-ptr">shared_ptr和unique_ptr</h3>
<ol>
<li>它们管理保存指针的策略，前者可以共享指针，而后者则独占指针。</li>
<li>它们允许用户重载deleter的方式。只要在创建或者reset指针时给shared_ptr提供一个deleter即可。但是，deleter是unique_ptr对象的一部分。<br>
shared_ptr的deleter是运行时绑定，所以需要使用指针，开销大，但是用户重载更方便。它的执行方式可能如下：<code>del?del(p): delete p</code>。<br>
而unique_ptr的deleter是编译时绑定，避免了间接调用deleter的运行时开销。</li>
<li>shared_ptr不能动态管理数组，而unique_ptr可以动态管理数组。</li>
</ol>
<h3 id="智能指针和数组">智能指针和数组</h3>
<ol>
<li>shared_ptr不支持管理动态数组。需要提供自定义的delete（只要是一个可调用对象就行）。</li>
<li>unique_ptr支持动态管理数组，需要在类型后面加上一对方括号。当unique_ptr销毁时，会自动使用delete[]。不能使用成员访问运算符（点和箭头），但是可以使用下标访问运算符。</li>
</ol>
<h3 id="weak-ptr">weak_ptr</h3>
<p><code>weak_ptr</code>可以解决循环引用问题，比如双向链表中的循环引用。[9]</p>
<h2 id="类模板和函数模板的区别">类模板和函数模板的区别</h2>
<p>类模板用来生成类，函数模板的参数是由编译器推导的，而类模板的参数必须指定。</p>
<h2 id="模板特化和偏特化">模板特化和偏特化</h2>
<p>模板特化的本质是模板实例化，定义特化版本时，我们实际上是接替了编译器的工作。<br>
函数模板只能全特化。<br>
类模板可以全特化也可以偏特化。偏特化既有类型的偏特化，也有个数的偏特化。</p>
<h2 id="为什么模板的声明和实现要写在一起而类的实现和声明要分开-7">为什么模板的声明和实现要写在一起而类的实现和声明要分开[7]</h2>
<p>C++ 采用分离式编译。可以不用将所有的代码写在一个文件中，可以将他们分解为更小，更好管理的模块，可以独立的修改和编译这些模板。当我们改变这些模板时，只需要重新的编译它，并重新链接，不必重新编译其他文件。这一功能主要是通过链接器实现的。更多的内容可以查看CSAPP上介绍的。<br>
对于普通对象和函数而言，类的声明写在头文件中，实现写在cpp文件中。cpp文件是可以单独被编译的。<br>
但是模板函数的实现并不能直接编译成二进制代码，因为只有在真正使用模板的时候，才会知道模板参数的值。编译器和链接器的某一个部分，可以去掉模板的多重定义。</p>
<h2 id="模板元编程">模板元编程</h2>
<h2 id="哈希表">哈希表</h2>
<p>哈希表冲突严重的话会退化成单链表。这个时候哈希表的各种操作的时间复杂度都提升了一个量级，会占用大量CPU时间，降低系统响应时间，可以用来做DDos攻击。<br>
解决冲突的方法：</p>
<h2 id="malloc和new">malloc和new</h2>
<h3 id="new">new</h3>
<p>new一个空数组是和合法的，但是不能解引用！！！可以把它当做尾后迭代器来使用。</p>
<h3 id="malloc-calloc和realloc">malloc, calloc和realloc</h3>
<ol>
<li>malloc分配指定字节的数组，初值不定。</li>
<li>calloc分配nobj个size字节的对象，每一位都初始化为0。</li>
<li>realloc在以前分配的区域的基础上扩大为新的容量。如果原来的区域后面有足够大的空间，就在那里，否则复制到一个新的空间中。</li>
</ol>
<h3 id="ptmalloc实现">ptmalloc实现</h3>
<h3 id="placement-new">placement new</h3>
<p>重载operator new函数。placement new可以为分配函数提供额外的信息。<br>
Placement new允许我们将对象构造在已经分配好的内存上，分配好的内存不一定是operator new分配的内存，甚至可以是静态内存。<br>
allocator的内存分配和构造函数的调用是分开进行的，通过两个函数allocate和construct。<br>
对应于new，可以使用operator new进行空间分配，使用placement new调用构造函数。</p>
<h2 id="对齐">对齐</h2>
<p>gcc 默认对齐是4字节对齐。在结构体中要注意。<br>
malloc是16字节对齐。</p>
<h2 id="cmake和makefile">cmake和makefile</h2>
<p>make用来执行makefile，调用makefile中用户指定的命令进行编译和链接。<br>
makefile是文件，包含了怎么样进行编译和链接。<br>
makefile可以手动写，但是它不跨平台（即不同平台的makefile不同），而且工程大很麻烦。<br>
cmake可以根据CMakeList.txt跨平台自动生成makefile。<br>
CMakeLists.txt是我们自己写的。</p>
<h2 id="void">void *</h2>
<p>可以接收任意类型的赋值，无需强制类型转换。<br>
经过类型转换可以赋值给任意类型的变量。</p>
<h2 id="lambda表达式">lambda表达式</h2>
<ol>
<li>总共有四种可调用对象，函数，函数指针，重载了函数运算符的类和lambda表达式。</li>
<li>lambda表达式的声明。<br>
auto f = [local variable](int x){return a;};</li>
<li>对于那种只在一两个地方使用的简单操作，lambda表达式是有用的。当在多个地方使用的话，通过应该使用一个函数，或者需要很多语句的话，也是函数比较好。</li>
<li>capture list中引用和值的作用。</li>
<li>可以和STL中的算法进行交互。</li>
</ol>
<h2 id="面向对象的几大原则">面向对象的几大原则</h2>
<ol>
<li>单一职责原则。解耦，增强内聚，即高内聚低耦合。</li>
<li>开放封闭原则。对扩展开放，对修改关闭。</li>
<li>里氏替换原则。子类可以替换父类。</li>
<li>依赖倒置原则。依赖于抽象而不是依赖细节。</li>
<li>接口分离原则。不需要让客户程序依赖它们不需要的方法。一个接口应该只提供一种对外的功能。</li>
<li>合成复用原则。</li>
<li>迪米特原则。</li>
</ol>
<h2 id="设计模式">设计模式</h2>
<ol>
<li>单例模式</li>
<li>reactor模式</li>
</ol>
<h2 id="move语义">move语义</h2>
<h2 id="分配器">分配器</h2>
<h2 id="虚拟内存">虚拟内存</h2>
<h2 id="数据结构相关">数据结构相关</h2>
<h3 id="堆">堆</h3>
<p><strong>二叉堆是完全二叉树，一般可以用数组实现</strong>。最大堆就是每个根节点的值大于其子节点的值，最小堆就是每个根节点的值小于其子节点的值。</p>
<h4 id="sgi-stl-heap相关的算法">SGI STL heap相关的算法</h4>
<ul>
<li>push_heap，将新的节点插在最后一个位置。</li>
<li>pop_heap，弹出最大堆的堆顶元素。（或者就是heapify）</li>
<li>sort_heap，就是排序。</li>
<li>make_heap，创建一个最大堆。</li>
</ul>
<h4 id="优先队列">优先队列</h4>
<p>底层实现是二叉堆，总是弹出key最大的元素。</p>
<h3 id="哈希和哈希表">哈希和哈希表</h3>
<h4 id="什么是哈希">什么是哈希</h4>
<p>哈希：把任意长度的输入，变成固定长度的输出，这个映射的规则就是对应的哈希算法，原始数据映射后的输出叫做哈希值。哈希值存在的目的是加速key-value的查找速度。<br>
哈希常见的几种实现方式：顺序，链式，散列，索引。哈希表是其中的一种。<br>
注意把哈希和哈希表区分开来。</p>
<h4 id="碰撞-冲突">碰撞（冲突）</h4>
<p>什么是碰撞？输入不同的数据得到相同的输出，哈希一定会发生碰撞。</p>
<h4 id="hash">hash</h4>
<h5 id="好的hash要求">好的hash要求</h5>
<ol>
<li>抗碰撞。不同的输入得到相同输出的概率要小。</li>
<li>抗篡改。输入数据的小的变化会得到完全不同的值，输入相同的数据会得到相同的值。（雪崩效应）。</li>
<li>速度要好。哈希算法的效率要高</li>
<li>根据输出不能反推输入。</li>
</ol>
<h5 id="hash的应用">hash的应用</h5>
<ol>
<li>保存密码，保存用户密码的哈希值。（这也是很多地方只能重置密码的原因，因为它们也不知道你的密码。。。）</li>
<li>数据校验。</li>
<li>负载均衡。在服务器扩容时，使用一致性哈希。</li>
</ol>
<h4 id="hashtable">hashtable</h4>
<p>哈希表是用哈希算法实现的表，提供了对任何有名字项的存取和删除操作，也可以查看是一种字典，提供常数时间的读写操作。<br>
哈希表的扩容(rehash)，元素个数比bucket个数多，再打散，把bucket个数增加两倍（接近两倍的质数）。</p>
<h4 id="hashtable碰撞的解决方法">hashtable碰撞的解决方法</h4>
<p>负载系数：元素个数除以表格大小，除了开链法，都要在0,1之间。<br>
<strong>线性探测</strong>：插入的时候，找到一个不可用的位置（被其他值占了），继续找下下一个位置，直到找到一个空位置。查找的时候，如果找到一个和当前搜索的目标不同的值，就继续往下找。删除的话，采用惰性删除，只删除记号，实际操作等到rehash时再进行。<br>
最坏情况下，哈希表退化成链表。<br>
<strong>二次探测</strong>：发生冲突是，而是使用H+n^2的平方寻找可用的位置。</p>
<ol>
<li>对于二次探测，假设表格大小为质数，负载因子为0.5，保持负载因子在0.5以下，超过0.5就rehash，可以保证插入每一个元素的探测次数不多于2。</li>
<li>二次探测本身所需的计算量其实和一次探测差不多。</li>
<li>rehash的时候，必须重新计算表中的每一个元素。</li>
</ol>
<p><strong>开链(seperate chaining)</strong>：在每一个表格中维护一个链表。表格的负载系数会大于1。</p>
<h4 id="hashtable的桶">hashtable的桶</h4>
<p>SGI使用开链法，表格（桶的集合）使用vector（为了动态扩容），而链表使用自定义的结构体。</p>
<ol start="0">
<li>SGI使用bkt_num()获得每个元素应该存放在哪个bucket中，这个函数负责调用hash function取得一个可以执行取模运算的值。为什么不直接使用hash_function，因为有些元素类型无法直接拿来对hashtable的大小进行模运算，这时候需要做一些转换。<br>
开链法没有要求表格的大小为质数，但是SGI依然这么做了，并且准备了28个质数的表，并且提供一个函数去获取最接近并大于某个数的质数。</li>
<li>在创建一个hashtable对象时，首先要进行实例化，指明hashtable的各个模板参数，然后提供参数给构造函数（没有默认构造函数数）。其中有一个参数大小为n，表明要创建的hashtable的桶的个数（它会自动寻找一个接近n的质数）。</li>
<li>插入元素的时候，每插入一个就会判断是否需要resize。这个是一个很常用的操作，插入操作，首先判断需不要扩容，比如vector等。</li>
<li>扩容的原则：元素数量大于bucket的数量就resize。</li>
<li>复制和删除，删除的时候需要对bucket中每一个链表都删除。而复制的时候需要先把原有的给删除掉，然后保留和复制对象至少一样的空间。</li>
<li>hashtable的示例，在新版本的STL中，不能直接使用hashtable，unordered_set和unordered_map都是对hashtable的封装，调用构造函数时传入一个n是桶的数量，这个n必须指定（STL会自动改成比n大的最小质数）。</li>
</ol>
<h4 id="hash函数">hash函数</h4>
<p>STL定义了很多仿函数，都是模板。hash也是一个仿函数，返回size_t类型。对于char, int,等类型，通常就返回原值，而对字符串和string等设计了相应的转换函数，对于浮点数，怎么办，没有说，STL源码剖析的版本没有实现，但是cppreference上说有，应该是新增加的。</p>
<h4 id="其他">其他</h4>
<p>unordered类容器和非ordered类容器最大的区别就是一个是默认有序，一个是默认无序。</p>
<h3 id="树">树</h3>
<p><strong>二叉搜索树</strong>：任何节点的键值一定大于它的左子树中的所有节点，小于右子树中每一个节点的键值。<br>
关联式容器的内部结构是<strong>平衡二叉树</strong>，平衡二叉树有AVL树，红黑树，AA树等。平衡的大概意思就是没有一个节点过深。</p>
<h4 id="avl树">AVL树</h4>
<p>确保整颗树的深度是logn，任何节点的左右子树高度最多相差1。<br>
AVL利用单旋和双旋，可以将所有不平衡的情况转换为平衡的情况。<br>
对于深度最深的节点X，造成节点X不平衡只有四种情况：<br>
插入点在X的左子节点的左子树。<br>
插入点在X的左子节点的右子树。<br>
插入点在X的右子节点的左子树。<br>
插入点在X的右子节点的右子树。<br>
双旋第一步做完，第二步就是单旋了。</p>
<h4 id="红黑树">红黑树</h4>
<p>红黑树需要满足以下规则：</p>
<ol>
<li>所有节点非红即黑。</li>
<li>根节点为黑色。</li>
<li>如果节点为红，子节点必须为黑。</li>
<li>任一节点到叶子节点的任何路径，所包含的黑色节点必须相同。</li>
</ol>
<h2 id="gcc和gdb-14">gcc和gdb[14]</h2>
<p>gcc 常用选项：<br>
-O编译器优化，Og最低等级的优化，On，数字越大优化等级越高。<br>
-Wall发出所有警告<br>
-g产生调试信息<br>
-o指定输出文件。<br>
-E只进行预处理<br>
-S编译到汇编，就是产生汇编代码<br>
-c之编译汇编，不链接，就是产生目标代码<br>
-static禁止使用动态链接库，只链接静态库，编译后可独立执行，不需要动态库，但是得到的可执行目标文件比较大。<br>
-L dir在库文件的搜索列表添加dir目录<br>
-I dir在头文件的搜索列表添加dir目录<br>
-shared</p>
<p>使用gdb调试时，需要使用使用gcc -g选项添加调试信息。</p>
<ul>
<li>gdb program，</li>
<li>gdb program core，用gdb查看core dump文件</li>
<li>gdb program pid，用gdb查看已经开始运行的进程。</li>
</ul>
<p>使用quit或者q退出。</p>
<p>gdb调试选项<br>
help<br>
run，开始调试程序<br>
break，设置断点。<br>
info break，查看断点信息。<br>
watch，为一个表达式设置一个检视点，可以加上-l选项，当监视的变量改变时，就会自动打印。<br>
catch,<br>
list，打印源码展示出指定的函数或者行。<br>
print，打印出表达式的值。<br>
display，每次程序停止的时候打印出<br>
bt，显示程序的调用栈信息。<br>
framen，简要查看第n帧的信息。<br>
info frame，详细查看当前帧的信息<br>
info registers，查看寄存器<br>
info args，查看当前帧的参数。<br>
info locals，查看当前帧中的局部变量。<br>
continue<br>
step</p>
<h2 id="移动语义和右值引用-16">移动语义和右值引用[16]</h2>
<p>移动语义，是为了避免无用的复制开销。右值引用的出现，让移动语义变得可能。将指针指向的内存直接拿过来使用。<br>
Move semantics is a new way of moving resources around in an optimal way by avoiding unnecessary copies of temporary objects, based on rvalue references. In my opinion, the best way to understand what move semantics is about is to build a wrapper class around a dynamic resource (i.e. a dynamically allocated pointer) and keep track of it as it moves in and out functions. Keep in mind however that move semantics does not apply only to classes!</p>
<h2 id="参考文献">参考文献</h2>
<p>1.<a href="https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in" target="_blank" rel="noopener">https://stackoverflow.com/questions/57483/what-are-the-differences-between-a-pointer-variable-and-a-reference-variable-in</a><br>
2.<a href="https://blog.csdn.net/dengheCSDN/article/details/78985684" target="_blank" rel="noopener">https://blog.csdn.net/dengheCSDN/article/details/78985684</a><br>
3.<a href="https://www.cnblogs.com/carekee/articles/1630789.html" target="_blank" rel="noopener">https://www.cnblogs.com/carekee/articles/1630789.html</a><br>
4.<a href="https://stackoverflow.com/a/943303/8939281" target="_blank" rel="noopener">https://stackoverflow.com/a/943303/8939281</a><br>
5.<a href="https://stackoverflow.com/questions/524033/how-can-i-simulate-oo-style-polymorphism-in-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/524033/how-can-i-simulate-oo-style-polymorphism-in-c</a><br>
6.<a href="https://blog.csdn.net/dumpling5232/article/details/52632060" target="_blank" rel="noopener">https://blog.csdn.net/dumpling5232/article/details/52632060</a><br>
7.<a href="https://blog.csdn.net/uestclr/article/details/51372780" target="_blank" rel="noopener">https://blog.csdn.net/uestclr/article/details/51372780</a><br>
8.<a href="https://stackoverflow.com/questions/10068653/separate-compilation-in-c" target="_blank" rel="noopener">https://stackoverflow.com/questions/10068653/separate-compilation-in-c</a><br>
9.<a href="https://blog.csdn.net/qq_34992845/article/details/69218843" target="_blank" rel="noopener">https://blog.csdn.net/qq_34992845/article/details/69218843</a><br>
10.<a href="https://www.cnblogs.com/fnlingnzb-learner/p/6423917.html" target="_blank" rel="noopener">https://www.cnblogs.com/fnlingnzb-learner/p/6423917.html</a><br>
11.<a href="https://isocpp.org/wiki/faq/inline-functions" target="_blank" rel="noopener">https://isocpp.org/wiki/faq/inline-functions</a><br>
12.<a href="https://isocpp.org/wiki/faq/virtual-functions" target="_blank" rel="noopener">https://isocpp.org/wiki/faq/virtual-functions</a><br>
13.<a href="https://www.cnblogs.com/findumars/p/6358194.html" target="_blank" rel="noopener">https://www.cnblogs.com/findumars/p/6358194.html</a><br>
14.<a href="https://blog.csdn.net/kikajack/article/details/92829582" target="_blank" rel="noopener">https://blog.csdn.net/kikajack/article/details/92829582</a><br>
15.<a href="https://en.cppreference.com/w/cpp/utility/hash" target="_blank" rel="noopener">https://en.cppreference.com/w/cpp/utility/hash</a><br>
16.<a href="https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners" target="_blank" rel="noopener">https://www.internalpointers.com/post/c-rvalue-references-and-move-semantics-beginners</a></p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/34/">34</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/favicon.jpg" alt="马晓鑫爱马荟荟">
            
              <p class="site-author-name" itemprop="name">马晓鑫爱马荟荟</p>
              <p class="site-description motion-element" itemprop="description">记录硕士三年自己的积累</p>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">332</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  <a href="/categories/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">25</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  <a href="/tags/index.html">
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">75</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="https://github.com/mxxhcm" title="GitHub &rarr; https://github.com/mxxhcm" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
                </span>
              
                <span class="links-of-author-item">
                  
                  
                    
                  
                  
                    
                  
                  <a href="mailto:mxxhcm@gmail.com" title="E-Mail &rarr; mailto:mxxhcm@gmail.com" rel="noopener" target="_blank"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                </span>
              
            </div>
          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">马晓鑫爱马荟荟</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> v6.6.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  
    <script src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script src="/js/src/utils.js?v=6.6.0"></script>

  <script src="/js/src/motion.js?v=6.6.0"></script>



  
  


  <script src="/js/src/affix.js?v=6.6.0"></script>

  <script src="/js/src/schemes/pisces.js?v=6.6.0"></script>



  

  


  <script src="/js/src/bootstrap.js?v=6.6.0"></script>



  



  






<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    







  





  

  

  

  

  
  

  
  
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
    
      
        
      
    
  

  
    
      <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
      },
      TeX: {equationNumbers: { autoNumber: "AMS" }}
    });
</script>

<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
      var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>
<script src="//cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<style>
.MathJax_Display {
    overflow: auto hidden;
}
</style>

    
  


  
  

  

  

  

  

  

  

</body>
</html>
